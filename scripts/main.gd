extends Node2D

# Game state
var gold: int = 150
var lives: int = 20
var wave: int = 0
var is_wave_active: bool = false
var placing_tower: bool = false
var ghost_position: Vector2 = Vector2.ZERO

# Tower selection
enum TowerType { ROBIN_HOOD, ALICE, WICKED_WITCH, PETER_PAN, PHANTOM, SCROOGE, SHERLOCK, TARZAN, DRACULA, MERLIN, FRANKENSTEIN, SHADOW_AUTHOR }
var selected_tower: TowerType = TowerType.ROBIN_HOOD

const BOSS_VILLAIN_NAMES: Dictionary = {
	0: "Sheriff of Nottingham",
	1: "Queen of Hearts",
	2: "Dark Witch",
	3: "Captain Hook",
	4: "Dark Phantom",
	5: "Ghost of Christmas",
	6: "Shadow Lord",
	7: "Professor Moriarty",
	8: "Morgan le Fay",
	9: "Clayton",
	10: "Dark Dracula",
	11: "The Creature",
	12: "The Shadow Author"
}

# Purchase tracking — each tower can only be bought once
var purchased_towers: Dictionary = {}
var tower_buttons: Dictionary = {}

var tower_info = {
	TowerType.ROBIN_HOOD: {"name": "Robin Hood", "cost": 75, "range": 200.0, "damage": 18, "fire_rate": 0.55},
	TowerType.ALICE: {"name": "Alice", "cost": 85, "range": 85.0, "damage": 12, "fire_rate": 0.65},
	TowerType.WICKED_WITCH: {"name": "Wicked Witch", "cost": 100, "range": 154.0, "damage": 22, "fire_rate": 0.45},
	TowerType.PETER_PAN: {"name": "Peter Pan", "cost": 90, "range": 85.0, "damage": 10, "fire_rate": 0.80},
	TowerType.PHANTOM: {"name": "The Phantom", "cost": 95, "range": 180.0, "damage": 20, "fire_rate": 0.50},
	TowerType.SCROOGE: {"name": "Scrooge", "cost": 60, "range": 70.0, "damage": 8, "fire_rate": 0.70},
	TowerType.SHERLOCK: {"name": "Sherlock Holmes", "cost": 110, "range": 188.0, "damage": 15, "fire_rate": 0.50},
	TowerType.TARZAN: {"name": "Tarzan", "cost": 100, "range": 120.0, "damage": 25, "fire_rate": 0.40},
	TowerType.DRACULA: {"name": "Count Dracula", "cost": 105, "range": 190.0, "damage": 28, "fire_rate": 0.35},
	TowerType.MERLIN: {"name": "Merlin", "cost": 115, "range": 132.0, "damage": 30, "fire_rate": 0.40},
	TowerType.FRANKENSTEIN: {"name": "The Monster", "cost": 130, "range": 140.0, "damage": 35, "fire_rate": 0.30},
	TowerType.SHADOW_AUTHOR: {"name": "Shadow Author", "cost": 250, "range": 170.0, "damage": 40, "fire_rate": 0.35},
}

# Constants
var total_waves: int = 20
const MIN_PATH_DIST: float = 40.0
const MIN_TOWER_DIST: float = 48.0
const MAX_SURVIVOR_LEVEL: int = 20
# BTD6-inspired sub-exponential XP curve (19 entries, index = current_level - 1)
const HERO_XP_TABLE: Array = [180, 460, 1000, 1860, 3280, 5180, 8320, 9380, 13620, 16380, 18200, 20100, 22100, 24200, 26400, 28800, 31400, 34200, 37200]

# Preloads
var tower_scenes = {
	TowerType.ROBIN_HOOD: preload("res://scenes/robin_hood.tscn"),
	TowerType.ALICE: preload("res://scenes/alice.tscn"),
	TowerType.WICKED_WITCH: preload("res://scenes/wicked_witch.tscn"),
	TowerType.PETER_PAN: preload("res://scenes/peter_pan.tscn"),
	TowerType.PHANTOM: preload("res://scenes/phantom.tscn"),
	TowerType.SCROOGE: preload("res://scenes/scrooge.tscn"),
}
var new_tower_scenes: Dictionary = {}  # Loaded at runtime after unlock

var enemy_scene = preload("res://scenes/enemy.tscn")

@onready var enemy_path: Path2D = $EnemyPath
@onready var towers_node: Node2D = $Towers

# UI references
var wave_label: Label
var gold_label: Label
var lives_label: Label
var start_button: Button
var game_over_label: Label
var info_label: Label
var top_bar: ColorRect
var bottom_panel: ColorRect
var cancel_button: Button

# Ability choice UI
var ability_panel: ColorRect
var ability_title: Label
var ability_buttons: Array = []
var _ability_tower: Node2D = null

# Tower upgrade selection
var selected_tower_node: Node2D = null
const TOWER_SELECT_RADIUS: float = 48.0
var upgrade_panel: ColorRect
var upgrade_name_label: Label
var upgrade_buttons: Array = []  # 4 upgrade tier buttons
var upgrade_cost_labels: Array = []  # 4 cost labels
var upgrade_desc_labels: Array = []  # 4 description labels
var upgrade_status_rects: Array = []  # 4 background rects for status coloring
var sell_button: Button
var sell_value_label: Label
var targeting_button: Button

# Game state & levels
enum GameState { MENU, PLAYING, GAME_OVER_STATE }
var game_state: int = GameState.MENU
var game_font: Font
var current_level: int = -1

# Menu UI
var menu_overlay: ColorRect
var menu_title: Label
var menu_subtitle: Label
var level_cards: Array = []
var return_button: Button
var retry_button: Button
var menu_exit_button: Button
var completed_levels: Array = []
var level_stars: Dictionary = {}
var level_difficulty_medals: Dictionary = {}  # { level_idx: [bool, bool, bool] } Easy/Med/Hard beaten
var level_difficulty_stars: Dictionary = {}   # { level_idx: [int, int, int] } stars per difficulty (0-3)
var level_best_wave: Dictionary = {}          # { level_idx: int } best wave reached per level

# Storybook menu - character page showcase
var menu_character_index: int = 0
var menu_level_name_label: Label
var menu_level_desc_label: Label
var menu_level_stats_label: Label
var menu_level_stars_label: Label

var menu_left_arrow: Button
var menu_right_arrow: Button
var menu_showcase_panel: ColorRect
# Chapter card UI elements
var chapter_buttons: Array = []  # 3 PLAY buttons for chapters
var chapter_title_labels: Array = []  # 3 chapter title labels
var chapter_desc_labels: Array = []  # 3 chapter description labels
var chapter_star_labels: Array = []  # 3 star display labels
var chapter_stat_labels: Array = []  # 3 stat labels (waves/gold/lives)
var chapter_lock_labels: Array = []  # 3 lock/difficulty labels

# Gothic menu - bottom nav
var menu_nav_buttons: Array = []
var menu_nav_labels: Array = []
var menu_current_view: String = "chapters"
var menu_transition_alpha: float = 1.0  # For fade transitions between views
var menu_star_total_label: Label

# Survivors tab
var survivor_types = [
	TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH,
	TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE,
	TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA,
	TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR
]
var survivor_descriptions = {
	TowerType.ROBIN_HOOD: "The legendary outlaw of Sherwood Forest.\nLong-range archer with piercing arrows and gold bonus.",
	TowerType.ALICE: "The curious girl from Wonderland.\nThrows cake that slows and shrinks all nearby enemies.",
	TowerType.WICKED_WITCH: "The Wicked Witch of the West.\nSwoops to strike enemies, summons wolves and monkeys.",
	TowerType.PETER_PAN: "The boy who never grew up.\nFast dagger attacks with shadow and fairy dust.",
	TowerType.PHANTOM: "The masked genius beneath the Opera.\nHeavy music note attacks with stun and AoE.",
	TowerType.SCROOGE: "The miserly old man visited by ghosts.\nRings his bell to blast enemies backwards and earn gold.",
	TowerType.SHERLOCK: "The world's greatest detective.\nMagnifying glass beam burns enemies. Marks targets for team damage.",
	TowerType.TARZAN: "The lord of the jungle.\nDevastating melee attacks, vine swings, and animal allies.",
	TowerType.DRACULA: "The immortal count from Transylvania.\nDrains life from enemies, summons bats, turns foes to minions.",
	TowerType.MERLIN: "The legendary wizard of Camelot.\nBuffs allies, curses enemies, summons Excalibur strikes.",
	TowerType.FRANKENSTEIN: "The tragic creature brought to life.\nLightning-charged fist smash with devastating area damage.",
	TowerType.SHADOW_AUTHOR: "The dark narrator who writes the story.\nMaster of ink and shadow, bends reality to his will.",
}
# Survivor grid UI
var survivor_grid_cards: Array = []  # Array of Button nodes for each character
var survivor_grid_container: Control = null  # Container for the grid
var survivor_grid_previews: Array = []  # Tower preview nodes for each card
var survivor_selected_index: int = -1  # Currently selected survivor (-1 = none)
var survivor_preview_node: Node2D = null  # Preview of selected survivor

# Character detail page
var survivor_detail_open: bool = false
var survivor_detail_index: int = -1
var survivor_detail_container: Control = null
var survivor_detail_back_btn: Button = null
var survivor_detail_preview: Node2D = null
var survivor_detail_abilities: Array = []  # [{name, desc, cost}] from tower TIER_NAMES/ABILITY_DESCRIPTIONS/TIER_COSTS
var detail_hover_type: String = ""  # "ability", "sidekick", "relic", "weapon", "levelup", ""
var detail_hover_index: int = -1
var detail_levelup_hover: bool = false
var detail_info_overlay_open: bool = false
var detail_info_close_hover: bool = false

# Character progression — levels, gear, sidekicks, relics
var survivor_progress: Dictionary = {}  # TowerType -> {level, xp, gear, sidekicks, relics}
var session_damage: Dictionary = {}  # TowerType -> float, damage dealt this game session

# Mobile support
var _is_mobile: bool = false
var _touch_scroll_start_y: float = -1.0
var _touch_scroll_velocity: float = 0.0
var _touch_last_y: float = 0.0
var _input_cooldown: float = 0.0
var _portrait_hem_offsets: Array = []
var _portrait_hair_offsets: Array = []
var _sfx_pool: Array = []
var _sfx_pool_index: int = 0
const SFX_POOL_SIZE: int = 8
var _unique_synergies_ever: Array = []  # Cumulative unique synergies for achievement
var _cached_enemies: Array = []  # Updated once per frame for performance

# Gear definitions per character
var survivor_gear = {
	TowerType.ROBIN_HOOD: {"name": "Longbow", "type": "Bow", "desc": "Yew longbow of Sherwood. +15% range, +1 pierce.", "range": 0.15, "pierce": 1},
	TowerType.ALICE: {"name": "Looking Glass", "type": "Wand", "desc": "See the world differently. +20% AoE radius, +10% slow.", "aoe": 0.20, "slow": 0.10},
	TowerType.WICKED_WITCH: {"name": "Broomstick", "type": "Wand", "desc": "Fly and strike from above. +15% speed, +10% range.", "attack_speed": 0.15, "range": 0.10},
	TowerType.PETER_PAN: {"name": "Shadow Blade", "type": "Sword", "desc": "Forged from a lost shadow. +20% damage, +10% crit.", "damage": 0.20, "crit": 0.10},
	TowerType.PHANTOM: {"name": "Pipe Organ", "type": "Instrument", "desc": "Haunting melodies stun all who hear. +15% stun, buffs nearby towers +8% speed.", "stun": 0.15, "aura_speed": 0.08},
	TowerType.SCROOGE: {"name": "Counting Ledger", "type": "Instrument", "desc": "Every coin counts twice. +25% gold gen, nearby towers earn +10% gold.", "gold": 0.25, "aura_gold": 0.10},
	TowerType.SHERLOCK: {"name": "Magnifying Glass", "type": "Gun", "desc": "Focused deduction beam. +20% damage, +15% range, reveals hidden.", "damage": 0.20, "range": 0.15, "reveal": true},
	TowerType.TARZAN: {"name": "Jungle Vine", "type": "Sword", "desc": "Swing and strike with primal force. +15% speed, +20% damage.", "attack_speed": 0.15, "damage": 0.20},
	TowerType.DRACULA: {"name": "Blood Chalice", "type": "Wand", "desc": "Drink deep and heal. +15% damage, +8% lifesteal.", "damage": 0.15, "lifesteal": 0.08},
	TowerType.MERLIN: {"name": "Crystal Staff", "type": "Wand", "desc": "Channel arcane power. +20% AoE, +15% range.", "aoe": 0.20, "range": 0.15},
	TowerType.FRANKENSTEIN: {"name": "Lightning Rod", "type": "Bomb", "desc": "Channels storms. +20% chain targets, +15% damage.", "chain": 0.20, "damage": 0.15},
	TowerType.SHADOW_AUTHOR: {"name": "Quill of Darkness", "type": "Wand", "desc": "Writes reality into shadow. +25% damage, +10% all stats.", "damage": 0.25, "all": 0.10},
}

# Sidekick definitions (3 per character)
var survivor_sidekicks = {
	TowerType.ROBIN_HOOD: [{"name": "Little John", "desc": "Slows nearby enemies"}, {"name": "Friar Tuck", "desc": "Heals nearby towers"}, {"name": "Maid Marian", "desc": "Bonus gold on kill"}],
	TowerType.ALICE: [{"name": "Cheshire Cat", "desc": "Reveals hidden enemies"}, {"name": "White Rabbit", "desc": "Speeds up attack rate"}, {"name": "Mad Hatter", "desc": "Random debuffs on hit"}],
	TowerType.WICKED_WITCH: [{"name": "Winged Monkey", "desc": "Flies to attack distant foes"}, {"name": "Toto", "desc": "Detects hidden enemies"}, {"name": "Tin Woodman", "desc": "Blocks enemies briefly"}],
	TowerType.PETER_PAN: [{"name": "Tinker Bell", "desc": "AoE fairy dust heal"}, {"name": "Lost Boys", "desc": "Extra dagger throws"}, {"name": "Tiger Lily", "desc": "Poisons enemies on hit"}],
	TowerType.PHANTOM: [{"name": "Christine", "desc": "Sings to slow enemies"}, {"name": "Madame Giry", "desc": "Reveals enemy paths"}, {"name": "Raoul", "desc": "Blocks strongest enemy"}],
	TowerType.SCROOGE: [{"name": "Bob Cratchit", "desc": "Collects extra gold"}, {"name": "Tiny Tim", "desc": "Inspires nearby towers"}, {"name": "Ghost of Marley", "desc": "Chains slow enemies"}],
	TowerType.SHERLOCK: [{"name": "Dr. Watson", "desc": "Backup shots at marked targets"}, {"name": "Mrs. Hudson", "desc": "Gradually restores nearby tower health"}, {"name": "Inspector Lestrade", "desc": "Slows fastest enemy"}],
	TowerType.TARZAN: [{"name": "Cheeta", "desc": "Throws fruit to slow enemies"}, {"name": "Tantor", "desc": "Stomps to stun nearby enemies"}, {"name": "Jane", "desc": "Boosts Tarzan's attack speed"}],
	TowerType.DRACULA: [{"name": "Renfield", "desc": "Collects blood from kills for power"}, {"name": "Bat Swarm", "desc": "Attacks enemies in a cloud"}, {"name": "Bride of Dracula", "desc": "Charms enemies to fight each other"}],
	TowerType.MERLIN: [{"name": "Archimedes", "desc": "Owl spots hidden enemies"}, {"name": "Lady of the Lake", "desc": "Heals and buffs nearest tower"}, {"name": "Young Arthur", "desc": "Extra sword strikes on enemies"}],
	TowerType.FRANKENSTEIN: [{"name": "Igor", "desc": "Repairs and buffs the Monster"}, {"name": "Lightning Coil", "desc": "Passive chain lightning"}, {"name": "Victor's Notes", "desc": "Kill stacks build faster"}],
	TowerType.SHADOW_AUTHOR: [{"name": "Ink Familiar", "desc": "Shadow creature attacks nearby enemies"}, {"name": "Torn Pages", "desc": "Scattered pages slow enemies"}, {"name": "Dark Muse", "desc": "Boosts all nearby towers' damage"}],
}

# Character-specific relic definitions (6 per character, 36 total)
var survivor_relics = {
	TowerType.ROBIN_HOOD: [
		{"name": "Lincoln Green Cloak", "desc": "Blend with Sherwood — enemies sometimes miss", "effect": "dodge", "value": 0.12, "cost": 0, "icon": "green_cloak"},
		{"name": "Silver Arrow", "desc": "Legendary arrow that pierces the toughest armor", "effect": "pierce_damage", "value": 0.20, "cost": 100, "icon": "silver_arrow"},
		{"name": "Sherwood Longbow", "desc": "Yew bow carved from the oldest oak in Sherwood", "effect": "range", "value": 0.15, "cost": 0, "icon": "longbow"},
		{"name": "Friar Tuck's Flask", "desc": "A sip of mead restores the weariest fighter", "effect": "heal_nearby", "value": 2.0, "cost": 250, "icon": "flask"},
		{"name": "Merry Men's Horn", "desc": "The call to arms rallies all who hear it", "effect": "atk_speed_aura", "value": 0.10, "cost": 0, "icon": "horn"},
		{"name": "Prince John's Crown", "desc": "Stolen from the tyrant — riches for the poor", "effect": "bonus_gold", "value": 0.25, "cost": 500, "icon": "gold_crown"},
	],
	TowerType.ALICE: [
		{"name": "Drink Me Potion", "desc": "One sip and everything changes size", "effect": "slow", "value": 0.15, "cost": 0, "icon": "drink_me"},
		{"name": "Eat Me Cake", "desc": "Grow larger than life itself", "effect": "aoe_radius", "value": 0.20, "cost": 100, "icon": "eat_me_cake"},
		{"name": "Vorpal Sword", "desc": "One, two! One, two! And through and through!", "effect": "crit_chance", "value": 0.10, "cost": 0, "icon": "vorpal_sword"},
		{"name": "Queen's Scepter", "desc": "Off with their heads!", "effect": "instant_kill", "value": 0.08, "cost": 250, "icon": "heart_scepter"},
		{"name": "White Rabbit's Watch", "desc": "I'm late! I'm late! No time to waste!", "effect": "cooldown", "value": 0.15, "cost": 0, "icon": "pocket_watch"},
		{"name": "Cheshire Grin", "desc": "We're all mad here", "effect": "confuse", "value": 0.12, "cost": 500, "icon": "cheshire_grin"},
	],
	TowerType.WICKED_WITCH: [
		{"name": "Ruby Slippers", "desc": "There's no place like home", "effect": "reposition", "value": 1.0, "cost": 0, "icon": "ruby_slippers"},
		{"name": "Crystal Ball", "desc": "I see everything, my pretty", "effect": "reveal_camo", "value": 1.0, "cost": 100, "icon": "crystal_ball"},
		{"name": "Winged Monkey Fez", "desc": "Fly! Fly! Bring them to me!", "effect": "extra_projectile", "value": 1.0, "cost": 0, "icon": "monkey_fez"},
		{"name": "Poppy Dust", "desc": "Poppies will put them to sleep", "effect": "aoe_sleep", "value": 0.10, "cost": 250, "icon": "poppy_dust"},
		{"name": "Golden Cap", "desc": "The enchanted cap commands dark magic", "effect": "spell_damage", "value": 0.18, "cost": 0, "icon": "golden_cap"},
		{"name": "Hourglass of Doom", "desc": "Your time is running out, my dear", "effect": "hp_drain", "value": 0.03, "cost": 500, "icon": "hourglass"},
	],
	TowerType.PETER_PAN: [
		{"name": "Fairy Dust Vial", "desc": "Think happy thoughts and you can fly", "effect": "atk_speed_aura", "value": 0.12, "cost": 0, "icon": "fairy_vial"},
		{"name": "Captain Hook's Hook", "desc": "The hook gleams with cruel promise", "effect": "bleed", "value": 0.02, "cost": 100, "icon": "iron_hook"},
		{"name": "Neverland Star Map", "desc": "Second star to the right, straight on til morning", "effect": "range", "value": 0.15, "cost": 0, "icon": "star_map"},
		{"name": "Crocodile's Tooth", "desc": "Tick-tock, tick-tock — the croc comes calling", "effect": "fear", "value": 0.08, "cost": 250, "icon": "croc_tooth"},
		{"name": "Wendy's Thimble", "desc": "A thimble kiss to mend your wounds", "effect": "heal_self", "value": 3.0, "cost": 0, "icon": "thimble"},
		{"name": "Shadow Thread", "desc": "His shadow has a mind of its own", "effect": "clone_attack", "value": 5.0, "cost": 500, "icon": "shadow_thread"},
	],
	TowerType.PHANTOM: [
		{"name": "Red Rose", "desc": "A token of dark devotion", "effect": "charm", "value": 0.10, "cost": 0, "icon": "red_rose"},
		{"name": "Punjab Lasso", "desc": "The noose tightens from the shadows", "effect": "snare", "value": 2.0, "cost": 100, "icon": "punjab_lasso"},
		{"name": "Opera Score", "desc": "The music of the night is devastating", "effect": "aoe_damage", "value": 0.15, "cost": 0, "icon": "opera_score"},
		{"name": "Chandelier Chain", "desc": "When the chandelier falls, all tremble", "effect": "stun", "value": 0.12, "cost": 250, "icon": "chandelier_chain"},
		{"name": "Lake Gondola Key", "desc": "The key to the lair beneath the opera", "effect": "boss_damage", "value": 0.30, "cost": 0, "icon": "gondola_key"},
		{"name": "Christine's Mirror", "desc": "The mirror reveals what lies behind the mask", "effect": "reflect", "value": 0.08, "cost": 500, "icon": "hand_mirror"},
	],
	TowerType.SCROOGE: [
		{"name": "Marley's Chains", "desc": "Forged in life, link by link, yard by yard", "effect": "slow_aura", "value": 0.20, "cost": 0, "icon": "heavy_chains"},
		{"name": "Ghost Lantern", "desc": "The spirits illuminate all hidden truths", "effect": "reveal_weaken", "value": 0.10, "cost": 100, "icon": "ghost_lantern"},
		{"name": "Counting House Key", "desc": "Every penny pinched is a penny earned", "effect": "gold_gen", "value": 0.15, "cost": 0, "icon": "brass_key"},
		{"name": "Christmas Pudding", "desc": "God bless us, every one!", "effect": "heal_nearby", "value": 2.0, "cost": 250, "icon": "xmas_pudding"},
		{"name": "Fezziwig's Fiddle", "desc": "The old fiddle sets every foot to dancing", "effect": "atk_speed_aura", "value": 0.10, "cost": 0, "icon": "fiddle"},
		{"name": "Redemption Bell", "desc": "The bell tolls for a changed heart", "effect": "wave_start_buff", "value": 0.08, "cost": 500, "icon": "church_bell"},
	],
	TowerType.SHERLOCK: [
		{"name": "Deerstalker Cap", "desc": "The iconic hat sharpens the mind", "effect": "crit_chance", "value": 0.12, "cost": 0, "icon": "deerstalker"},
		{"name": "Watson's Revolver", "desc": "The good doctor always packs heat", "effect": "extra_projectile", "value": 1.0, "cost": 100, "icon": "revolver"},
		{"name": "Violin of Thought", "desc": "Music aids the deductive process", "effect": "cooldown", "value": 0.15, "cost": 0, "icon": "violin"},
		{"name": "Cocaine Solution", "desc": "Seven percent solution heightens senses", "effect": "atk_speed_aura", "value": 0.12, "cost": 250, "icon": "vial"},
		{"name": "Reichenbach Stone", "desc": "A stone from the falls where he cheated death", "effect": "dodge", "value": 0.10, "cost": 0, "icon": "dark_stone"},
		{"name": "Moriarty's Cipher", "desc": "Know thy enemy as thyself", "effect": "boss_damage", "value": 0.25, "cost": 500, "icon": "cipher"},
	],
	TowerType.TARZAN: [
		{"name": "Mangani Fang", "desc": "A great ape's tooth, symbol of strength", "effect": "pierce_damage", "value": 0.20, "cost": 0, "icon": "ape_tooth"},
		{"name": "Jungle Crown", "desc": "Vines woven into the mark of the king", "effect": "aoe_radius", "value": 0.18, "cost": 100, "icon": "vine_crown"},
		{"name": "Father's Knife", "desc": "The blade that saved his life as a babe", "effect": "bleed", "value": 0.03, "cost": 0, "icon": "hunting_knife"},
		{"name": "Elephant Tusk", "desc": "Tantor's gift — unstoppable force", "effect": "stun", "value": 0.10, "cost": 250, "icon": "ivory_tusk"},
		{"name": "Jane's Locket", "desc": "Love tames the wildest heart", "effect": "heal_self", "value": 3.0, "cost": 0, "icon": "gold_locket"},
		{"name": "Kerchak's Roar", "desc": "The alpha's challenge echoes through the jungle", "effect": "fear", "value": 0.10, "cost": 500, "icon": "ape_mask"},
	],
	TowerType.DRACULA: [
		{"name": "Transylvanian Earth", "desc": "Soil from his homeland sustains him", "effect": "heal_self", "value": 4.0, "cost": 0, "icon": "dark_soil"},
		{"name": "Crucifix Shard", "desc": "Turned against its purpose — burns foes", "effect": "spell_damage", "value": 0.18, "cost": 100, "icon": "broken_cross"},
		{"name": "Wolf Pelt Cape", "desc": "The wolves answer to the count", "effect": "slow_aura", "value": 0.15, "cost": 0, "icon": "wolf_pelt"},
		{"name": "Mirror of Absence", "desc": "No reflection, no weakness", "effect": "dodge", "value": 0.12, "cost": 250, "icon": "dark_mirror"},
		{"name": "Renfield's Offering", "desc": "The faithful servant's gift of life force", "effect": "hp_drain", "value": 0.04, "cost": 0, "icon": "blood_vial"},
		{"name": "Brides' Chalice", "desc": "Three brides, three powers, one vessel", "effect": "charm", "value": 0.15, "cost": 500, "icon": "ornate_chalice"},
	],
	TowerType.MERLIN: [
		{"name": "Crystal Ball", "desc": "Foresee the enemy's every move", "effect": "reveal_camo", "value": 1.0, "cost": 0, "icon": "crystal_orb"},
		{"name": "Excalibur Shard", "desc": "A fragment of the legendary blade", "effect": "pierce_damage", "value": 0.22, "cost": 100, "icon": "sword_shard"},
		{"name": "Druidic Circlet", "desc": "Ancient power flows through the stones", "effect": "aoe_damage", "value": 0.15, "cost": 0, "icon": "stone_circlet"},
		{"name": "Holy Grail Replica", "desc": "A reflection of the cup that heals all wounds", "effect": "heal_nearby", "value": 3.0, "cost": 250, "icon": "golden_cup"},
		{"name": "Nimue's Tear", "desc": "The Lady of the Lake's sorrow made manifest", "effect": "slow", "value": 0.20, "cost": 0, "icon": "blue_tear"},
		{"name": "Stonehenge Fragment", "desc": "Cosmic power channeled through ancient rock", "effect": "wave_start_buff", "value": 0.12, "cost": 500, "icon": "stone_frag"},
	],
	TowerType.FRANKENSTEIN: [
		{"name": "Galvanic Cell", "desc": "Raw electrical power courses through", "effect": "aoe_damage", "value": 0.20, "cost": 0, "icon": "battery"},
		{"name": "Stitched Heart", "desc": "Beating despite all odds", "effect": "heal_self", "value": 5.0, "cost": 100, "icon": "sewn_heart"},
		{"name": "Victor's Journal", "desc": "The secrets of reanimation", "effect": "atk_speed_aura", "value": 0.10, "cost": 0, "icon": "old_journal"},
		{"name": "Arctic Ice Shard", "desc": "From the frozen wastes where the tale ended", "effect": "slow", "value": 0.18, "cost": 250, "icon": "ice_crystal"},
		{"name": "Blind Man's Fiddle", "desc": "The only kindness ever shown to the creature", "effect": "charm", "value": 0.10, "cost": 0, "icon": "old_fiddle"},
		{"name": "Promethean Spark", "desc": "The fire of creation itself", "effect": "boss_damage", "value": 0.30, "cost": 500, "icon": "lightning_spark"},
	],
	TowerType.SHADOW_AUTHOR: [
		{"name": "Inkwell of Void", "desc": "Ink attacks leave pools of shadow", "effect": "aoe_damage", "value": 0.15, "cost": 0, "icon": "inkwell"},
		{"name": "Quill of Fate", "desc": "Rewrites enemy destiny with each strike", "effect": "pierce_damage", "value": 0.20, "cost": 100, "icon": "dark_quill"},
		{"name": "Tome of Endings", "desc": "Every story the Author finishes empowers the next", "effect": "spell_damage", "value": 0.18, "cost": 0, "icon": "dark_tome"},
		{"name": "Shadow Bookmark", "desc": "Marks a page to return to in times of need", "effect": "cooldown", "value": 0.15, "cost": 250, "icon": "bookmark"},
		{"name": "Midnight Candle", "desc": "Burns with stories untold, lighting the way", "effect": "range", "value": 0.15, "cost": 0, "icon": "dark_candle"},
		{"name": "The Final Period", "desc": "The punctuation that ends all tales forever", "effect": "boss_damage", "value": 0.30, "cost": 500, "icon": "period_mark"},
	],
}
# Track which relic slot is hovered/selected for tooltip
var relic_hover_index: int = -1
var relic_tooltip_visible: bool = false

# Emporium (in-game store)
var emporium_categories = [
	{"name": "Gold Exchange", "desc": "Spend gold from chests on other currencies", "icon": "emp_gold", "badge": ""},
	{"name": "Enchanted Quills", "desc": "Trade Quills for rare treasures", "icon": "emp_quills", "badge": ""},
	{"name": "Relic Shards", "desc": "Collect Shards to forge powerful Relics", "icon": "emp_shards", "badge": ""},
	{"name": "Relic Chests", "desc": "Chests contain powerful Relics!", "icon": "emp_chests", "badge": "AVAILABLE!"},
	{"name": "Survivor Packs", "desc": "Bundles of literary might", "icon": "emp_packs", "badge": "SALE!"},
	{"name": "Storybook Stars", "desc": "Empower and level up your Survivors", "icon": "emp_stars", "badge": ""},
	{"name": "Trophy Store", "desc": "Spend Trophies on cosmetic upgrades", "icon": "emp_trophy", "badge": "NEW!"},
	{"name": "Battle Powers", "desc": "Stock up on consumable battle abilities", "icon": "emp_powers", "badge": ""},
	{"name": "Tome Bindings", "desc": "Relics to empower your towers", "icon": "emp_bindings", "badge": "NEW!"},
	{"name": "Salvage Workshop", "desc": "Dismantle items into Relic Shards", "icon": "emp_salvage", "badge": ""},
	{"name": "Chest Forge", "desc": "Craft Golden Treasure Chests", "icon": "emp_forge", "badge": "NEW!"},
	{"name": "Instruments", "desc": "Literary aura items for battle", "icon": "emp_instruments", "badge": "NEW!"},
]
var emporium_hover_index: int = -1

# Menu color palette — deep navy-purple + gold (matches defenseplanet.org)
var menu_bg_dark = Color(0.04, 0.04, 0.10)        # #0a0a1a deep navy
var menu_bg_section = Color(0.055, 0.055, 0.14)    # #0e0e24
var menu_bg_card = Color(0.08, 0.08, 0.20)         # #141432
var menu_bg_card_hover = Color(0.10, 0.10, 0.25)   # #1a1a40
var menu_gold = Color(0.79, 0.66, 0.30)            # #c9a84c (unchanged)
var menu_gold_light = Color(0.91, 0.83, 0.55)      # #e8d48b (unchanged)
var menu_gold_dim = Color(0.54, 0.45, 0.20)        # #8a7433 (unchanged)
var menu_parchment = Color(0.94, 0.90, 0.83)       # #f0e6d3 warm white
var menu_text = Color(0.77, 0.73, 0.66)            # #c4baa8
var menu_text_muted = Color(0.54, 0.51, 0.47)      # #8a8278
var menu_accent_purple = Color(0.16, 0.04, 0.23)   # #2a0a3a deep purple accent
var menu_accent_glow = Color(0.30, 0.10, 0.50, 0.3) # soft purple glow

# Storybook menu - animation (particles, lanterns, decorations)
var _dust_positions: Array = []
var _book_candle_positions: Array = []
var _floating_pages: Array = []
var _menu_ink_splatters: Array = []
var _menu_splatter_rng: RandomNumberGenerator = RandomNumberGenerator.new()
var _quill_positions: Array = []
var _bookshelf_heights: Array = []

# World map data
var world_map_hover_index: int = -1
var world_map_zone_centers: Array = [
	Vector2(200, 310), Vector2(500, 260), Vector2(1060, 300),
	Vector2(200, 490), Vector2(640, 460), Vector2(1060, 490)
]
var _world_map_stars: Array = []
var _world_map_clouds: Array = []
var _world_map_smoke: Array = []

var character_names: Array = ["Robin Hood", "Alice", "Wicked Witch", "Peter Pan", "The Phantom", "Scrooge", "Sherlock Holmes", "Tarzan", "Count Dracula", "Merlin", "Frankenstein's Monster", "The Shadow Author"]
var character_novels: Array = ["The Merry Adventures of Robin Hood", "Alice's Adventures in Wonderland", "The Wonderful Wizard of Oz", "Peter and Wendy", "The Phantom of the Opera", "A Christmas Carol", "The Adventures of Sherlock Holmes", "Tarzan of the Apes", "Dracula", "Le Morte d'Arthur", "Frankenstein", "The Tome of Shadows"]
var character_quotes: Array = [
	"Steal from the rich, defend the path!",
	"Curiouser and curiouser!",
	"I'll get you, my pretties!",
	"To live will be an awfully big adventure!",
	"The Music of the Night!",
	"Bah! Humbug!",
	"The game is afoot!",
	"The jungle provides!",
	"I never drink... wine.",
	"Knowledge is the greatest power!",
	"I am not what you think I am!",
	"Every story needs an author...",
]

# =====================================================================================
# === FEATURE SYSTEMS (10 BATTD-inspired) ===============================================
# =====================================================================================

# --- Feature 1: Enemy Modifiers (Shadow-Infested, Regrown, Fortified, Shielded, Cursed, Phantom) ---
# Extended modifiers handled in _apply_enemy_modifiers and enemy.gd

# --- Feature 2: MOAB Villain Super-Enemies ---
# Maps enemy_theme to the MOAB villain name (the big boss of that world)
const MOAB_VILLAIN_NAMES: Dictionary = {
	0: "Sheriff's Wrath", 1: "Queen's Fury", 2: "Witch's Tempest",
	3: "Hook's Armada", 4: "Phantom's Crescendo", 5: "Marley's Chains",
	6: "Shadow Colossus", 7: "Moriarty's Machine", 8: "Fay's Corruption",
	9: "Clayton's Juggernaut", 10: "Dracula's Dominion", 11: "Creature's Rage",
	12: "Author's Apocalypse"
}
const MOAB_TIER_NAMES: Array = ["Overlord", "Tyrant", "Sovereign"]
const MOAB_TIER_SCALES: Array = [3.0, 4.5, 6.0]
const MOAB_TIER_HP_MULT: Array = [8.0, 20.0, 50.0]
const MOAB_TIER_CHILDREN: Array = [4, 4, 3]  # Children spawned on death

# --- Feature 3: Item Dismantling / Sharding ---
var salvage_rates: Dictionary = {"tattered": 5, "bound": 15, "gilded": 40, "mythic": 120, "forbidden": 400}
# Salvage currency is player_relic_shards (already exists)

# --- Feature 4: Golden Treasure Chest Crafting ---
var golden_chest_craft_costs: Array = [
	{"name": "Bronze Treasure Chest", "shard_cost": 30, "tier": 0},
	{"name": "Silver Treasure Chest", "shard_cost": 75, "tier": 1},
	{"name": "Golden Treasure Chest", "shard_cost": 150, "tier": 2},
]

# --- Feature 5: Rotating Daily Deals Shop ---
var daily_deals: Array = []  # 3 items, regenerated each day
var daily_deals_date: String = ""  # Date string of last generation
var daily_deals_purchased: Array = [false, false, false]

# --- Feature 6: Shadow Arena (Competitive Leaderboard Mode) ---
var shadow_arena_active: bool = false
var shadow_arena_wave: int = 0
var shadow_arena_modifiers: Array = []  # e.g. ["no_powers", "regrow_only", "shadow_infested"]
var shadow_arena_high_score: int = 0
var shadow_arena_weekly_seed: int = 0
var arena_crystals: int = 0  # Exclusive currency from Shadow Arena
var arena_leaderboard: Array = []  # [{name, score}] - simulated leaderboard

# --- Feature 7: Branching Upgrade Paths ---
# Each tower now has 2 upgrade branches (A and B), each with 2 tiers
# Branch selection stored per tower instance; data defined in tower scripts
var tower_branch_choice: Dictionary = {}  # tower_instance_id -> "A" or "B"
var _branch_hover: String = ""  # "A" or "B" when hovering branch choice
var _branch_tier_hover: int = -1  # Tier index when hovering branch upgrade
var _gs_upgrade_btn_rect: Rect2 = Rect2()  # Stored golden shield upgrade button position
var _placing_instrument: String = ""  # Instrument ID being placed (empty = not placing)
var _instrument_picker_open: bool = false
var _instrument_picker_hover: int = -1

# --- Feature 8: Golden Shields (Expandable Gear Slots) ---
# Golden Shields = star-level system that expands gear/sidekick/binding slots
const MAX_GOLDEN_SHIELD: int = 10
const GOLDEN_SHIELD_COSTS: Array = [100, 200, 350, 550, 800, 1100, 1500, 2000, 2800, 4000]  # XP cost per shield level
# Slot unlocks per golden shield level: [base=1 gear, 1 sidekick, 2 bindings]
# Each shield level: +1 binding slot (up to 12), +1 sidekick at shield 3/6/9, +1 gear at shield 5/10
func _get_golden_shield_level(tower_type) -> int:
	return survivor_progress.get(tower_type, {}).get("golden_shields", 0)

func _get_binding_slot_count(tower_type) -> int:
	var shields = _get_golden_shield_level(tower_type)
	return 2 + shields  # Base 2, up to 12 at shield 10

func _get_sidekick_slot_count(tower_type) -> int:
	var shields = _get_golden_shield_level(tower_type)
	var slots = 1  # Base 1
	if shields >= 3: slots += 1
	if shields >= 6: slots += 1
	if shields >= 9: slots += 1
	return slots  # Max 4

func _get_gear_slot_count(tower_type) -> int:
	var shields = _get_golden_shield_level(tower_type)
	var slots = 1  # Base 1
	if shields >= 5: slots += 1
	if shields >= 10: slots += 1
	return slots  # Max 3

# --- Feature 9: Quest / Mission System ---
var active_quests: Array = []  # [{id, desc, type, target, progress, reward_type, reward_amount, expires}]
var quest_last_refresh: String = ""
var total_quests_completed: int = 0
const QUEST_TEMPLATES: Array = [
	{"desc": "Kill %d enemies", "type": "kill", "targets": [50, 100, 200], "reward_type": "shards", "amounts": [10, 20, 35]},
	{"desc": "Kill %d shadow-infested enemies", "type": "kill_shadow", "targets": [5, 10, 20], "reward_type": "quills", "amounts": [3, 5, 10]},
	{"desc": "Complete %d level(s)", "type": "complete_levels", "targets": [1, 2, 3], "reward_type": "shards", "amounts": [15, 25, 40]},
	{"desc": "Earn %d gold in a single game", "type": "earn_gold", "targets": [200, 500, 1000], "reward_type": "quills", "amounts": [2, 5, 8]},
	{"desc": "Place %d towers", "type": "place_towers", "targets": [10, 20, 30], "reward_type": "shards", "amounts": [8, 15, 25]},
	{"desc": "Earn %d stars", "type": "earn_stars", "targets": [3, 6, 9], "reward_type": "stars", "amounts": [1, 1, 2]},
	{"desc": "Use %d battle power(s)", "type": "use_powers", "targets": [1, 3, 5], "reward_type": "shards", "amounts": [10, 20, 30]},
	{"desc": "Upgrade %d tower(s) to max tier", "type": "max_upgrades", "targets": [1, 2, 3], "reward_type": "quills", "amounts": [5, 8, 12]},
]

# --- Feature 10: Literary Instruments (Aura Support Gear) ---
# Instruments are special gear items that buff all towers in radius instead of attacking
var literary_instruments: Array = [
	{"id": "harpsichord_of_harmony", "name": "Harpsichord of Harmony", "desc": "All towers in range attack 15% faster", "effect": "attack_speed", "value": 0.15, "radius": 150.0, "cost": 120},
	{"id": "drums_of_war", "name": "Drums of War", "desc": "All towers in range deal 20% more damage", "effect": "damage", "value": 0.20, "radius": 130.0, "cost": 150},
	{"id": "lyre_of_legends", "name": "Lyre of Legends", "desc": "All towers in range gain 25% more range", "effect": "range", "value": 0.25, "radius": 140.0, "cost": 135},
	{"id": "flute_of_frost", "name": "Flute of Frost", "desc": "Enemies in range are slowed by 20%", "effect": "enemy_slow", "value": 0.20, "radius": 120.0, "cost": 100},
	{"id": "organ_of_shadows", "name": "Organ of Shadows", "desc": "All towers in range gain 10% crit chance", "effect": "crit", "value": 0.10, "radius": 160.0, "cost": 175},
	{"id": "violin_of_valor", "name": "Violin of Valor", "desc": "Towers in range earn 30% more gold on kill", "effect": "gold_bonus", "value": 0.30, "radius": 135.0, "cost": 110},
]
var owned_instruments: Dictionary = {}  # instrument_id -> count
var placed_instruments: Array = []  # [{id, position, radius, effect, value}] — active in-game

var levels = [
	# === PROLOGUE — Into the Pages (Level 0) ===
	{
		"name": "Into the Pages", "subtitle": "Prologue",
		"description": "The Tome of Shadows opens and pulls our heroes into a world of ink and forgotten stories. Survive the first wave of shadow entities!",
		"character": -1, "chapter": 0, "enemy_theme": 6,
		"waves": 10, "gold": 120, "lives": 30, "difficulty": 0.8,
		"sky_color": Color(0.04, 0.02, 0.08),
		"ground_color": Color(0.03, 0.03, 0.05),
	},
	# === SHERLOCK HOLMES — Baker Street Investigation (Levels 1-3) ===
	{
		"name": "Baker Street Investigation", "subtitle": "Sherlock Holmes — Chapter 1",
		"description": "The fog-choked streets of Victorian London hide criminals in every alley. Sherlock awaits rescue at 221B Baker Street.",
		"character": -1, "chapter": 0, "enemy_theme": 7,
		"waves": 15, "gold": 110, "lives": 25, "difficulty": 1.0,
		"sky_color": Color(0.06, 0.06, 0.08),
		"ground_color": Color(0.12, 0.10, 0.08),
	},
	{
		"name": "The Whitechapel Pursuit", "subtitle": "Sherlock Holmes — Chapter 2",
		"description": "Through the dangerous back alleys of Whitechapel, Moriarty's agents close in. The game is afoot!",
		"character": -1, "chapter": 1, "enemy_theme": 7,
		"waves": 20, "gold": 110, "lives": 22, "difficulty": 1.15,
		"sky_color": Color(0.05, 0.05, 0.07),
		"ground_color": Color(0.10, 0.08, 0.06),
	},
	{
		"name": "Reichenbach Falls", "subtitle": "Sherlock Holmes — Chapter 3",
		"description": "The final confrontation at the thundering falls. Moriarty's full criminal network descends. Free Sherlock Holmes!",
		"character": -1, "chapter": 2, "enemy_theme": 7,
		"waves": 25, "gold": 110, "lives": 20, "difficulty": 1.3,
		"sky_color": Color(0.04, 0.04, 0.06),
		"ground_color": Color(0.08, 0.08, 0.10),
	},
	# === MERLIN — The Round Table (Levels 4-6) ===
	{
		"name": "The Round Table", "subtitle": "Merlin — Chapter 1",
		"description": "Camelot lies in shadow. Dark sorcery has corrupted the knights. Merlin is trapped within a crystal cave.",
		"character": -1, "chapter": 0, "enemy_theme": 8,
		"waves": 15, "gold": 110, "lives": 25, "difficulty": 1.05,
		"sky_color": Color(0.02, 0.08, 0.04),
		"ground_color": Color(0.10, 0.08, 0.04),
	},
	{
		"name": "The Enchanted Forest", "subtitle": "Merlin — Chapter 2",
		"description": "Ancient standing stones pulse with dark magic. Cursed knights patrol the enchanted woodland paths.",
		"character": -1, "chapter": 1, "enemy_theme": 8,
		"waves": 20, "gold": 110, "lives": 22, "difficulty": 1.2,
		"sky_color": Color(0.02, 0.06, 0.03),
		"ground_color": Color(0.08, 0.06, 0.03),
	},
	{
		"name": "The Crystal Cave", "subtitle": "Merlin — Chapter 3",
		"description": "Deep within the crystal cave, Morgan le Fay guards Merlin's prison. Shatter the enchantment and free the wizard!",
		"character": -1, "chapter": 2, "enemy_theme": 8,
		"waves": 25, "gold": 110, "lives": 20, "difficulty": 1.35,
		"sky_color": Color(0.03, 0.04, 0.06),
		"ground_color": Color(0.06, 0.06, 0.08),
	},
	# === TARZAN — The Jungle Canopy (Levels 7-9) ===
	{
		"name": "The Jungle Canopy", "subtitle": "Tarzan — Chapter 1",
		"description": "Poachers invade the shadow jungle. Tarzan, king of the apes, fights alone against the intruders.",
		"character": -1, "chapter": 0, "enemy_theme": 9,
		"waves": 15, "gold": 110, "lives": 25, "difficulty": 1.1,
		"sky_color": Color(0.04, 0.10, 0.14),
		"ground_color": Color(0.04, 0.14, 0.02),
	},
	{
		"name": "The Elephant Graveyard", "subtitle": "Tarzan — Chapter 2",
		"description": "Big game hunters track through the elephant graveyard, seeking Tarzan's ape family. The bones rattle with warning.",
		"character": -1, "chapter": 1, "enemy_theme": 9,
		"waves": 20, "gold": 110, "lives": 22, "difficulty": 1.25,
		"sky_color": Color(0.06, 0.08, 0.10),
		"ground_color": Color(0.06, 0.10, 0.02),
	},
	{
		"name": "Clayton's Fortress", "subtitle": "Tarzan — Chapter 3",
		"description": "Clayton's mercenary fortress blocks the jungle path. Storm the compound and free Tarzan from his cage!",
		"character": -1, "chapter": 2, "enemy_theme": 9,
		"waves": 25, "gold": 110, "lives": 20, "difficulty": 1.4,
		"sky_color": Color(0.05, 0.07, 0.08),
		"ground_color": Color(0.05, 0.08, 0.03),
	},
	# === DRACULA — The Transylvanian Village (Levels 10-12) ===
	{
		"name": "The Transylvanian Village", "subtitle": "Dracula — Chapter 1",
		"description": "A cursed village at the foot of the Carpathian Mountains. The undead walk the streets at night.",
		"character": -1, "chapter": 0, "enemy_theme": 10,
		"waves": 18, "gold": 110, "lives": 24, "difficulty": 1.15,
		"sky_color": Color(0.06, 0.02, 0.04),
		"ground_color": Color(0.06, 0.04, 0.04),
	},
	{
		"name": "Castle Dracula", "subtitle": "Dracula — Chapter 2",
		"description": "The castle looms above, its corridors filled with vampire brides and dire wolves. The Count watches from his tower.",
		"character": -1, "chapter": 1, "enemy_theme": 10,
		"waves": 22, "gold": 110, "lives": 20, "difficulty": 1.3,
		"sky_color": Color(0.04, 0.02, 0.03),
		"ground_color": Color(0.05, 0.03, 0.04),
	},
	{
		"name": "The Crypt of Blood", "subtitle": "Dracula — Chapter 3",
		"description": "In the deepest crypt, Dracula lies chained by shadow ink. Defeat his captors and the Count joins your cause!",
		"character": -1, "chapter": 2, "enemy_theme": 10,
		"waves": 28, "gold": 110, "lives": 18, "difficulty": 1.5,
		"sky_color": Color(0.03, 0.01, 0.02),
		"ground_color": Color(0.04, 0.02, 0.03),
	},
	# === FRANKENSTEIN — The Laboratory (Levels 13-15) ===
	{
		"name": "The Laboratory", "subtitle": "Frankenstein — Chapter 1",
		"description": "Victor Frankenstein's abandoned laboratory crackles with dark energy. Failed experiments roam the halls.",
		"character": -1, "chapter": 0, "enemy_theme": 11,
		"waves": 18, "gold": 110, "lives": 24, "difficulty": 1.2,
		"sky_color": Color(0.04, 0.04, 0.06),
		"ground_color": Color(0.08, 0.08, 0.08),
	},
	{
		"name": "The Angry Village", "subtitle": "Frankenstein — Chapter 2",
		"description": "Villagers with torches and pitchforks march against the Monster. But here, the villagers are the real monsters.",
		"character": -1, "chapter": 1, "enemy_theme": 11,
		"waves": 22, "gold": 110, "lives": 20, "difficulty": 1.35,
		"sky_color": Color(0.05, 0.04, 0.05),
		"ground_color": Color(0.07, 0.06, 0.06),
	},
	{
		"name": "The Arctic Wastes", "subtitle": "Frankenstein — Chapter 3",
		"description": "The frozen north, where the tale ends. Igor guards the Monster's prison of ice. Shatter his chains!",
		"character": -1, "chapter": 2, "enemy_theme": 11,
		"waves": 28, "gold": 110, "lives": 18, "difficulty": 1.55,
		"sky_color": Color(0.06, 0.06, 0.08),
		"ground_color": Color(0.10, 0.10, 0.12),
	},
	# === ROBIN HOOD — The Merry Adventures of Robin Hood (Levels 16-18) ===
	{
		"name": "The Outlaw's Call", "subtitle": "Sherwood Forest — Chapter 1",
		"description": "Robin becomes an outlaw and builds his camp in Sherwood Forest. Defend the hideout from the Sheriff's tax collectors!",
		"character": 0, "chapter": 0, "enemy_theme": 0,
		"waves": 12, "gold": 100, "lives": 25, "difficulty": 1.0,
		"sky_color": Color(0.02, 0.06, 0.10),
		"ground_color": Color(0.06, 0.16, 0.04),
	},
	{
		"name": "The Sheriff's Pursuit", "subtitle": "Sherwood Forest — Chapter 2",
		"description": "The Sheriff of Nottingham sends his soldiers to hunt Robin. Defend Little John's Bridge and the river crossing!",
		"character": 0, "chapter": 1, "enemy_theme": 0,
		"waves": 15, "gold": 100, "lives": 22, "difficulty": 1.15,
		"sky_color": Color(0.02, 0.04, 0.08),
		"ground_color": Color(0.05, 0.14, 0.03),
	},
	{
		"name": "Siege of Nottingham", "subtitle": "Sherwood Forest — Chapter 3",
		"description": "Robin leads the attack on Nottingham Castle to free his captured men. Defeat the Sheriff at the castle gates!",
		"character": 0, "chapter": 2, "enemy_theme": 0,
		"waves": 18, "gold": 100, "lives": 20, "difficulty": 1.3,
		"sky_color": Color(0.06, 0.04, 0.02),
		"ground_color": Color(0.08, 0.08, 0.06),
	},
	# === ALICE — Alice's Adventures in Wonderland (Levels 19-21) ===
	{
		"name": "Down the Rabbit Hole", "subtitle": "Wonderland — Chapter 1",
		"description": "Alice follows the White Rabbit into a curious garden of giant mushrooms, talking flowers, and nonsense.",
		"character": 1, "chapter": 0, "enemy_theme": 1,
		"waves": 14, "gold": 100, "lives": 25, "difficulty": 1.0,
		"sky_color": Color(0.12, 0.04, 0.16),
		"ground_color": Color(0.08, 0.18, 0.06),
	},
	{
		"name": "The Mad Tea Party", "subtitle": "Wonderland — Chapter 2",
		"description": "Deeper into Wonderland — the Mad Hatter's tea party and the Queen of Hearts' card army advances, painting the roses red.",
		"character": 1, "chapter": 1, "enemy_theme": 1,
		"waves": 17, "gold": 100, "lives": 22, "difficulty": 1.2,
		"sky_color": Color(0.10, 0.03, 0.14),
		"ground_color": Color(0.06, 0.14, 0.05),
	},
	{
		"name": "The Queen's Court", "subtitle": "Wonderland — Chapter 3",
		"description": "Alice reaches the Queen's palace. The rose garden runs red. Off with their heads!",
		"character": 1, "chapter": 2, "enemy_theme": 1,
		"waves": 20, "gold": 100, "lives": 18, "difficulty": 1.4,
		"sky_color": Color(0.14, 0.02, 0.08),
		"ground_color": Color(0.10, 0.06, 0.06),
	},
	# === WICKED WITCH — The Wonderful Wizard of Oz (Levels 22-24) ===
	{
		"name": "The Yellow Brick Road", "subtitle": "Land of Oz — Chapter 1",
		"description": "Dorothy and companions follow the golden road through poppy fields toward the Emerald City.",
		"character": 2, "chapter": 0, "enemy_theme": 2,
		"waves": 14, "gold": 100, "lives": 25, "difficulty": 1.05,
		"sky_color": Color(0.02, 0.10, 0.06),
		"ground_color": Color(0.14, 0.12, 0.02),
	},
	{
		"name": "The Witch's Domain", "subtitle": "Land of Oz — Chapter 2",
		"description": "The Wicked Witch of the West sends her flying monkeys. Dark western territory and dead forests loom ahead.",
		"character": 2, "chapter": 1, "enemy_theme": 2,
		"waves": 17, "gold": 100, "lives": 22, "difficulty": 1.3,
		"sky_color": Color(0.04, 0.06, 0.02),
		"ground_color": Color(0.10, 0.08, 0.04),
	},
	{
		"name": "The Emerald Throne", "subtitle": "Land of Oz — Chapter 3",
		"description": "Inside the Emerald City, the Nome King rises to seize power. Green crystal walls crack as rock soldiers march.",
		"character": 2, "chapter": 2, "enemy_theme": 2,
		"waves": 20, "gold": 100, "lives": 18, "difficulty": 1.5,
		"sky_color": Color(0.02, 0.08, 0.04),
		"ground_color": Color(0.06, 0.12, 0.06),
	},
	# === PETER PAN — Peter and Wendy (Levels 25-27) ===
	{
		"name": "Flight to Neverland", "subtitle": "Neverland — Chapter 1",
		"description": "Second star to the right and straight on till morning. Mermaid lagoon sparkles and pirate scouts appear.",
		"character": 3, "chapter": 0, "enemy_theme": 3,
		"waves": 16, "gold": 100, "lives": 25, "difficulty": 1.1,
		"sky_color": Color(0.04, 0.06, 0.14),
		"ground_color": Color(0.08, 0.18, 0.06),
	},
	{
		"name": "The Lost Boys' Stand", "subtitle": "Neverland — Chapter 2",
		"description": "Captain Hook's pirate officers lead raiding parties through the dense jungle to attack the Lost Boys' hideout.",
		"character": 3, "chapter": 1, "enemy_theme": 3,
		"waves": 19, "gold": 100, "lives": 20, "difficulty": 1.4,
		"sky_color": Color(0.03, 0.05, 0.10),
		"ground_color": Color(0.06, 0.15, 0.04),
	},
	{
		"name": "The Jolly Roger", "subtitle": "Neverland — Chapter 3",
		"description": "The final battle aboard Captain Hook's ship. Sword fights on deck, walking the plank over the ticking crocodile!",
		"character": 3, "chapter": 2, "enemy_theme": 3,
		"waves": 22, "gold": 100, "lives": 18, "difficulty": 1.6,
		"sky_color": Color(0.08, 0.04, 0.02),
		"ground_color": Color(0.12, 0.08, 0.06),
	},
	# === PHANTOM — The Phantom of the Opera (Levels 28-30) ===
	{
		"name": "The Grand Stage", "subtitle": "Paris Opera — Chapter 1",
		"description": "The Paris Opera House, elegant and grand. Strange things happen during performances — a ghost in the wings.",
		"character": 4, "chapter": 0, "enemy_theme": 4,
		"waves": 18, "gold": 100, "lives": 22, "difficulty": 1.2,
		"sky_color": Color(0.04, 0.02, 0.08),
		"ground_color": Color(0.10, 0.08, 0.10),
	},
	{
		"name": "The Labyrinth", "subtitle": "Paris Opera — Chapter 2",
		"description": "Descending beneath the opera into mirrors, candlelit tunnels, and traps. The Phantom reveals himself.",
		"character": 4, "chapter": 1, "enemy_theme": 4,
		"waves": 21, "gold": 100, "lives": 20, "difficulty": 1.5,
		"sky_color": Color(0.03, 0.02, 0.06),
		"ground_color": Color(0.08, 0.06, 0.08),
	},
	{
		"name": "The Phantom's Lair", "subtitle": "Paris Opera — Chapter 3",
		"description": "The underground lake, the great organ, roses on black water. Defeat the Dark Phantom in his domain!",
		"character": 4, "chapter": 2, "enemy_theme": 4,
		"waves": 24, "gold": 100, "lives": 16, "difficulty": 1.7,
		"sky_color": Color(0.02, 0.01, 0.04),
		"ground_color": Color(0.06, 0.04, 0.06),
	},
	# === SCROOGE — A Christmas Carol (Levels 31-33) ===
	{
		"name": "Christmas Eve", "subtitle": "Victorian London — Chapter 1",
		"description": "Victorian London on a cold Christmas Eve. Scrooge at his counting house, ignoring the carolers. Marley's ghost appears.",
		"character": 5, "chapter": 0, "enemy_theme": 5,
		"waves": 20, "gold": 100, "lives": 22, "difficulty": 1.3,
		"sky_color": Color(0.08, 0.08, 0.12),
		"ground_color": Color(0.10, 0.10, 0.12),
	},
	{
		"name": "The Three Spirits", "subtitle": "Victorian London — Chapter 2",
		"description": "The Ghosts of Christmas Past, Present, and Future visit Scrooge. Spectral London, gravestones, chains rattling.",
		"character": 5, "chapter": 1, "enemy_theme": 5,
		"waves": 23, "gold": 100, "lives": 18, "difficulty": 1.6,
		"sky_color": Color(0.06, 0.06, 0.10),
		"ground_color": Color(0.08, 0.08, 0.10),
	},
	{
		"name": "Redemption's Dawn", "subtitle": "Victorian London — Chapter 3",
		"description": "Christmas morning. The Ghost of Christmas Yet to Come leads an army of despair. Warm light fights to break through.",
		"character": 5, "chapter": 2, "enemy_theme": 5,
		"waves": 25, "gold": 100, "lives": 15, "difficulty": 1.8,
		"sky_color": Color(0.10, 0.08, 0.06),
		"ground_color": Color(0.12, 0.10, 0.10),
	},
	# === SHADOW AUTHOR — The Final Chapter (Levels 34-36) ===
	{
		"name": "The Ink Realm", "subtitle": "Shadow Author — Chapter 1",
		"description": "The Shadow Author's domain unfolds — a realm of pure ink and unwritten nightmares. All heroes unite for the final battle.",
		"character": -1, "chapter": 0, "enemy_theme": 12,
		"waves": 30, "gold": 120, "lives": 25, "difficulty": 1.8,
		"sky_color": Color(0.02, 0.01, 0.03),
		"ground_color": Color(0.02, 0.02, 0.04),
	},
	{
		"name": "The Unwritten Pages", "subtitle": "Shadow Author — Chapter 2",
		"description": "Blank pages stretch to infinity. The Author rewrites reality itself, sending corrupted versions of literary heroes against you.",
		"character": -1, "chapter": 1, "enemy_theme": 12,
		"waves": 35, "gold": 120, "lives": 22, "difficulty": 1.9,
		"sky_color": Color(0.01, 0.01, 0.02),
		"ground_color": Color(0.02, 0.01, 0.03),
	},
	{
		"name": "The Final Chapter", "subtitle": "Shadow Author — Chapter 3",
		"description": "The last page. The Shadow Author rises from the ink, quill in hand, to write THE END for every story ever told. Stop him!",
		"character": -1, "chapter": 2, "enemy_theme": 12,
		"waves": 40, "gold": 130, "lives": 20, "difficulty": 2.0,
		"sky_color": Color(0.01, 0.00, 0.01),
		"ground_color": Color(0.01, 0.01, 0.02),
	},
]

# Difficulty selection (0=Easy, 1=Medium, 2=Hard)
var selected_difficulty: int = 0
var difficulty_waves: Array = [20, 30, 40, 40]
var difficulty_gold_bonus: Array = [8, 0, -10, -20]
var difficulty_lives_bonus: Array = [5, 0, -5, -5]  # Legacy — overridden by fixed lives below
var difficulty_fixed_lives: Array = [100, 50, 20, 1]  # Easy=100, Medium=50, Hard=20, Pure=1
const PURE_MODE: int = 3
var chapter_diff_buttons: Array = []  # Array of 3 arrays, each with 3 buttons

# Player inventory (persistent across sessions)
var player_quills: int = 0
var player_relic_shards: int = 0
var player_storybook_stars: int = 0
var player_gold: int = 0

# Treasure chest state
var chest_loot: Array = []  # Array of {"type": String, "amount": int, "name": String}
var chest_open: bool = false
var chest_timer: float = 0.0

# Relics tab hover state
var relics_tab_hover_tier: int = -1
var relics_tab_hover_row: int = -1
var relics_tab_hover_col: int = -1

# Wave management
var enemies_to_spawn: int = 0
var enemies_alive: int = 0
var spawn_timer: float = 0.0
var spawn_interval: float = 0.75

# Fast-forward
var fast_forward: bool = false
var _game_speed_level: float = 1.0
var speed_button: Button
var wave_auto_timer: float = -1.0
var auto_wave_enabled: bool = true
var auto_wave_delay: float = 2.0  # seconds before auto-starting next wave
var auto_wave_delay_options: Array = [1.0, 2.0, 3.0, 5.0]
var auto_wave_delay_index: int = 1  # default 2s

# Pause & restart
var game_paused: bool = false
var restart_button: Button
var auto_wave_btn: Button
var wave_start_gold: int = 0
var wave_start_lives: int = 0

# Audio mute toggles
var sfx_muted: bool = false
var voices_muted: bool = false
var sfx_mute_button: Button
var voice_mute_button: Button

# Free placement tracking
var placed_tower_positions: Array = []
var path_points: PackedVector2Array = PackedVector2Array()
var _path_thumbnail_cache: Dictionary = {}

# Level decoration data (regenerated per level)
var _decorations: Array = []
var _time: float = 0.0

# Shadow Author taunt system (one random taunt per map on every level)
var _sa_taunt_triggered: bool = false
var _sa_taunt_timer: float = -1.0  # -1 = not active, 0+ = animation time
var _sa_taunt_x: float = 0.0
var _sa_taunt_y: float = 0.0
var _sa_taunt_trigger_time: float = 15.0  # randomized per level
# Shadow figures fly on all maps
var _sa_shadow_figures: Array = []

# Musical beat clock — towers read this to select harmonious notes
var music_beat_index: int = 0
var _music_beat_accum: float = 0.0
const MUSIC_BPM: float = 140.0
const MUSIC_BEAT_INTERVAL: float = 60.0 / MUSIC_BPM  # ~0.4286s

# Audio — procedural hip hop beat
var music_player: AudioStreamPlayer
var music_tracks: Array = []
var music_index: int = 0
var music_playing: bool = false

# Audio — character voice clips
var voice_player: AudioStreamPlayer
var voice_clips: Dictionary = {}
var tower_quotes: Dictionary = {}

# Voice-over catchphrase system (MP3 files from edge-tts)
var catchphrase_player: AudioStreamPlayer
var placement_voice_clips: Dictionary = {}  # TowerType → Array[AudioStreamMP3]
var fighting_voice_clips: Dictionary = {}   # TowerType → Array[AudioStreamMP3]
var placement_quotes: Dictionary = {}       # TowerType → Array[String]
var fighting_quotes: Dictionary = {}        # TowerType → Array[String]
var _fighting_quote_timer: float = 25.0

# UI / Gameplay SFX (procedurally generated)
var _sfx_ui_click: AudioStreamWAV
var _sfx_wave_start: AudioStreamWAV
var _sfx_wave_complete: AudioStreamWAV
var _sfx_enemy_death: AudioStreamWAV
var _sfx_victory: AudioStreamWAV
var _sfx_defeat: AudioStreamWAV
var _sfx_life_lost: AudioStreamWAV
var _sfx_player: AudioStreamPlayer

# === META FEATURES: Save/Load, Emporium, Chests, Relics, Knowledge, Daily ===
var _save_path: String = "user://shadow_defense_save.json"

# Emporium sub-panel state
var emporium_sub_open: bool = false
var emporium_sub_category: int = -1
var emporium_sub_hover: int = -1
var emporium_sub_message: String = ""
var emporium_sub_message_timer: float = 0.0
var _emporium_confirm_index: int = -1
var _emporium_confirm_timer: float = 0.0
var _emporium_purchase_flash: float = 0.0  # Purchase confirmation flash overlay
var _menu_transition_alpha: float = 0.0  # View transition dark overlay fade
var _deal_confirm_index: int = -1
var _deal_confirm_timer: float = 0.0
var _arena_confirm_index: int = -1
var _arena_confirm_timer: float = 0.0
var emporium_items: Dictionary = {}

# Treasure chest opening overlay
var chest_opening_active: bool = false
var chest_opening_tier: int = 0  # 0=Bronze, 1=Silver, 2=Gold
var chest_opening_phase: int = 0  # 0=idle(click to open), 1=shake, 2=burst, 3=cards_slide, 4=cards_flip, 5=pick, 6=done
var chest_opening_timer: float = 0.0
var chest_opening_cards: Array = []
var chest_opening_picked: int = -1
var chest_opening_flip_index: int = 0
var treasure_chests_owned: Dictionary = {"bronze": 0, "silver": 0, "gold": 0}

# Victory chest overlay (post-level reward)
var victory_chest_active: bool = false
var victory_chest_stars: int = 0
var victory_trinket_pending: Dictionary = {}  # The trinket card picked, awaiting character equip
var victory_equip_active: bool = false  # Character selection overlay for trinket equip
var victory_equip_hover: int = -1

# Relic equipment
var equipped_relics: Dictionary = {}  # TowerType -> Array of equipped relic indices

# Knowledge tree (Chronicles tab)
var knowledge_ink: int = 0
var knowledge_tree: Dictionary = {}
var knowledge_branches: Array = []
var chronicles_hover_node: int = -1
var chronicles_hover_branch: int = -1

# Daily rewards
var daily_streak: int = 0
var daily_last_claim: String = ""
var daily_reward_open: bool = false
var daily_reward_hover_day: int = -1
var daily_reward_claimed_today: bool = false
var daily_rewards_schedule: Array = [
	{"name": "Relic Shards", "type": "shards", "amount": 10},
	{"name": "Enchanted Quills", "type": "quills", "amount": 5},
	{"name": "Gold Sovereigns", "type": "gold", "amount": 50},
	{"name": "Relic Shards", "type": "shards", "amount": 20},
	{"name": "Storybook Star", "type": "stars", "amount": 1},
	{"name": "Enchanted Quills", "type": "quills", "amount": 10},
	{"name": "Gold Treasure Chest", "type": "gold_chest", "amount": 1},
]

# === TOWER SYNERGIES ===
var synergy_definitions: Array = []
var active_synergies: Array = []
var synergies_ever_activated: Array = []
var synergy_banner_text: String = ""
var synergy_banner_timer: float = 0.0

# === ACHIEVEMENTS ===
var achievement_definitions: Array = []
var achievement_progress: Dictionary = {}
var achievements_unlocked: Dictionary = {}
var achievement_popup_text: String = ""
var achievement_popup_timer: float = 0.0
var achievement_popup_reward: String = ""
var total_towers_placed: int = 0
var total_enemies_killed: int = 0
var total_gold_spent: int = 0
var total_gold_earned: int = 0
var total_emporium_purchases: int = 0
var total_chests_opened: int = 0
var total_knowledge_nodes: int = 0
var total_daily_claims: int = 0
var current_game_lives_lost: int = 0
var current_game_fast_forward_only: bool = true

# === BATTLE POWERS ===
var battle_power_definitions: Array = []
var owned_powers: Dictionary = {}
var selected_powers: Array = []
var power_selection_open: bool = false
var active_power_effects: Dictionary = {}
var battle_power_buttons: Array = []
var storybook_shield_charges: int = 0
var power_enchanted_timer: float = 0.0

# === ODYSSEY MODE ===
var odyssey_maps: Array = []
var odyssey_active: bool = false
var odyssey_current_map: int = 0
var odyssey_carry_lives: int = 0
var odyssey_carry_gold: int = 0
var odyssey_completed_this_week: bool = false
var trophy_currency: int = 0
var odyssey_transition_timer: float = 0.0
var odyssey_transition_active: bool = false
var odyssey_lives_at_start: int = 0

# === TROPHY STORE ===
var trophy_store_items: Dictionary = {}
var owned_cosmetics: Array = []
var equipped_cosmetics: Dictionary = {}

# === BOSS RESCUE ANIMATION ===
var boss_rescue_active: bool = false
var boss_rescue_timer: float = 0.0
var boss_rescue_pos: Vector2 = Vector2.ZERO
var boss_rescue_boss_ref: Node2D = null
var boss_rescue_phase: int = 0  # 0=smoke, 1=author_appears, 2=grab, 3=flash, 4=fade
var _rescue_smoke_particles: Array = []

# === COMBO KILL SYSTEM ===
var combo_count: int = 0
var combo_timer: float = 0.0
var combo_last_pos: Vector2 = Vector2.ZERO
var combo_best: int = 0
const COMBO_WINDOW: float = 1.5
const COMBO_MIN: int = 3

# === UNDO TOWER PLACEMENT ===
var undo_tower_data: Dictionary = {}  # {node, type, position, cost, timer}
var undo_button: Button
const UNDO_DURATION: float = 3.0

# === WAVE PREVIEW ===
var wave_preview_active: bool = false
var wave_preview_timer: float = 0.0
var wave_preview_data: Array = []

# === TOWER STATS OVERLAY ===
# (drawn procedurally when tower selected)

# === PRESTIGE SYSTEM ===
var prestige_level: int = 0

# === MILESTONE REWARDS ===
var milestone_claimed: Dictionary = {}
var total_damage: int = 0

# === CHARACTER MASTERY ===
var mastery_challenges: Dictionary = {}

# === DAILY CHALLENGE ===
var daily_challenge_last_date: String = ""
var daily_challenge_completed_today: bool = false
var daily_challenge_streak: int = 0
var daily_challenge_active: bool = false
var daily_challenge_modifier: String = ""
var daily_challenge_level: int = -1

# === BOSS RUSH MODE ===
var boss_rush_mode: bool = false
var boss_rush_wave: int = 0
var boss_rush_completed: bool = false
var boss_rush_best_wave: int = 0

# === ENHANCED ENDLESS MODE ===
var endless_mutation: String = ""
var endless_top_runs: Array = []
const ENDLESS_MUTATIONS: Array = [
	"Speed Surge", "Camo Wave", "Boss Rush", "Shield Wall",
	"Regen Wave", "Swarm", "Shadow Infested", "Gold Drought"
]

# === FLOATING TEXTS & DEATH EFFECTS ===
var _floating_texts: Array = []
var _screen_shake_timer: float = 0.0
var _insufficient_gold_flash: float = 0.0
var _boss_alert_timer: float = 0.0
var _boss_alert_text: String = ""
var _wave_clear_timer: float = 0.0
var _wave_clear_num: int = 0
var _screen_shake_intensity: float = 0.0
var _screen_shake_offset: Vector2 = Vector2.ZERO
var _ink_splatters: Array = []
var _death_flash_timer: float = 0.0

# === VISUAL POLISH EFFECTS ===
var _aoe_impacts: Array = []
var _crit_flashes: Array = []
var _build_effects: Array = []
var _victory_burst_timer: float = 0.0
var _victory_particles: Array = []
var _defeat_timer: float = 0.0
var _defeat_cracks: Array = []
var _spawn_portal_intensity: float = 0.0
var _env_particles: Array = []
var _wave_banner_timer: float = 0.0
var _wave_banner_num: int = 0
var _wave_banner_name: String = ""
var _wave_banner_is_boss: bool = false
var _gold_pickups: Array = []
var _gold_pickup_flash: float = 0.0

# === BATTD FEATURE: GEAR FUSION FORGE ===
var fusion_selected_ids: Array = []  # Binding IDs selected for fusion

# === BATTD FEATURE: BOSS HEALTH BAR ===
var _active_boss_node: Node2D = null
var _boss_hp_bar_timer: float = 0.0

# === BATTD FEATURE: POST-VICTORY STATS ===
var _session_stats: Dictionary = {}
var _show_stats_screen: bool = false

# === BATTD FEATURE: EARLY WAVE SEND BONUS ===
var _early_send_bonus: int = 0

# === BATTD FEATURE: LUCKY LOOT DROPS ===
const LUCKY_DROP_CHANCE: float = 0.05  # 5% per kill
var _lucky_drops_this_game: int = 0

# === BATTD FEATURE: XP SHARING ===
var xp_sharing_enabled: bool = true
const XP_SHARE_RATIO: float = 0.25  # 25% of avg XP to unused chars

# === BATTD FEATURE: INCOME BREAKDOWN ===
var _income_breakdown: Dictionary = {"kills": 0, "wave_bonus": 0, "combo": 0, "early_send": 0, "lucky": 0}
var _income_display_timer: float = 0.0

# === BATTD FEATURE: REVENGE RETRY ===
var _revenge_available: bool = false
var _revenge_bonus_pct: float = 0.20  # 20% extra starting gold

# === BATTD FEATURE: ENEMY KILL COUNTER ===
var _wave_enemies_total: int = 0
var _wave_enemies_killed: int = 0

# === BATTD FEATURE: CRIT STREAK ===
var _crit_streak: int = 0
var _crit_streak_best: int = 0
var _crit_streak_timer: float = 0.0

# === BATTD FEATURE: MAP COLLECTIBLES ===
var _map_collectibles: Array = []
var _collectibles_found_this_game: int = 0
const MAX_MAP_COLLECTIBLES: int = 3

# === BATTD FEATURE: GEAR WISH LIST ===
var gear_wish_list: Array = []  # Up to 3 effect type strings

# === BATTD FEATURE: CHARACTER HOME BONUS ===
const HOME_CHAPTER_BONUS: float = 0.10  # +10% all stats

# === BATTD FEATURE: DOUBLE CASH MODE ===
var double_cash_unlocked: bool = false
var double_cash_enabled: bool = false

# === BATTD FEATURE: TOWER BUFF ICONS ===
# (procedural drawing, no extra vars)

# === BATTD FEATURE: WAVE RUSH TIMER ===
var _wave_start_time: float = 0.0
var _wave_rush_bonus: int = 0
const WAVE_RUSH_THRESHOLD: float = 15.0  # Clear under 15s for bonus

# === BATTD FEATURE: GEAR AUTO-EQUIP ===
# (function only)

# === BATTD FEATURE: BOUNTY BOARD ===
var _active_bounties: Array = []  # [{desc, kill_type, target, progress, reward_type, reward_amount}]
var _bounties_completed_total: int = 0

# === BATTD FEATURE: PLACEMENT STREAK ===
var _placement_streak_count: int = 0
var _placement_streak_timer: float = 0.0
const PLACEMENT_STREAK_WINDOW: float = 5.0
const PLACEMENT_STREAK_DISCOUNT: float = 0.05  # 5% per streak level

# === BATTD2 FEATURE: INSTA-TOWERS ===
var insta_towers: Array = []  # [{type: TowerType, tier: int}] - pre-built towers
var _placing_insta: bool = false
var _insta_index: int = -1

# === BATTD2 FEATURE: GEAR ENCHANTING ===
const ENCHANT_COST_QUILLS: int = 5
const ENCHANT_EFFECTS: Array = ["damage", "attack_speed", "range", "crit", "gold_bonus"]

# === BATTD2 FEATURE: CHARACTER BONDS ===
var _active_bonds: Array = []  # [{pair: [TowerType, TowerType], bonus: float}]
const BOND_PAIRS: Array = [
	[0, 3],   # Robin Hood + Peter Pan (adventurers)
	[1, 2],   # Alice + Wicked Witch (Oz/Wonderland)
	[4, 9],   # Phantom + Merlin (magic users)
	[5, 10],  # Scrooge + Frankenstein (Victorian era)
	[6, 7],   # Sherlock + Tarzan (adventure novels)
	[8, 9],   # Dracula + Merlin (supernatural)
]
const BOND_RADIUS: float = 200.0
const BOND_BONUS: float = 0.08

# === BATTD2 FEATURE: MULTI-WAVE RUSH ===
var _multi_wave_active: bool = false
var _multi_wave_count: int = 0

# === BATTD2 FEATURE: PATH TRAPS ===
var _path_traps: Array = []  # [{pos, type, uses_left, damage/slow}]
const TRAP_TYPES: Array = [
	{"name": "Spike Strip", "cost": 30, "damage": 50.0, "uses": 10, "icon": "spike"},
	{"name": "Tar Pit", "cost": 25, "slow": 0.5, "duration": 3.0, "uses": 8, "icon": "tar"},
	{"name": "Fire Mine", "cost": 50, "damage": 150.0, "uses": 3, "icon": "mine"},
]
var _placing_trap: int = -1  # Index into TRAP_TYPES, -1 = not placing

# === BATTD2 FEATURE: TOWER SACRIFICE ===
var _sacrifice_mode: bool = false
var _sacrifice_source: Node2D = null

# === BATTD2 FEATURE: PITY TIMER ===
var _drops_since_mythic: int = 0
var _drops_since_forbidden: int = 0
const PITY_MYTHIC: int = 30
const PITY_FORBIDDEN: int = 100

# === BATTD2 FEATURE: ENEMY INTEL ===
var _intel_target: Node2D = null
var _intel_timer: float = 0.0

# === BATTD2 FEATURE: CHALLENGE HANDICAPS ===
var _handicaps_active: Array = []
var _handicap_bonus_mult: float = 1.0
const HANDICAP_OPTIONS: Array = [
	{"name": "Broke Start", "desc": "-40% starting gold", "gold_mult": 0.6, "reward_mult": 1.3},
	{"name": "Fragile", "desc": "-5 lives", "lives_reduce": 5, "reward_mult": 1.25},
	{"name": "Swarm", "desc": "+50% enemies", "enemy_mult": 1.5, "reward_mult": 1.4},
	{"name": "Speedy", "desc": "Enemies 25% faster", "speed_mult": 1.25, "reward_mult": 1.2},
	{"name": "Unarmed", "desc": "No battle powers", "no_powers": true, "reward_mult": 1.15},
	{"name": "Inflation", "desc": "Towers cost 25% more", "cost_mult": 1.25, "reward_mult": 1.2},
]

# === BATTD2 FEATURE: GEAR SET DISPLAY ===
# (drawing function only, no extra state)

# === BATTD2 FEATURE: STORYBOOK PAGES ===
var storybook_pages_found: Dictionary = {}  # level_index -> bool
var _level_page_pos: Vector2 = Vector2.ZERO
var _level_page_collected: bool = false
const PAGE_SHARD_REWARD: int = 5

# === BATTD2 FEATURE: GOLD INTEREST ===
var gold_interest_enabled: bool = true
const GOLD_INTEREST_RATE: float = 0.05  # 5% interest on gold between waves
const GOLD_INTEREST_CAP: int = 50  # Max interest per wave

# === BATTD2 FEATURE: WAVE BLESSING ===
var _blessing_active: bool = false
var _blessing_timer: float = 0.0
var _blessing_type: String = ""
const BLESSING_COST: int = 40
const BLESSING_DURATION: float = 15.0
const BLESSING_OPTIONS: Array = [
	{"name": "Fury", "type": "damage", "value": 0.25, "desc": "+25% damage"},
	{"name": "Haste", "type": "attack_speed", "value": 0.30, "desc": "+30% attack speed"},
	{"name": "Farsight", "type": "range", "value": 0.20, "desc": "+20% range"},
]

# === BATTD2 FEATURE: EMERGENCY RECALL ===
# (function only — sell all towers at 50% and restart wave)

# === BATTD2 FEATURE: TOWER XP BAR ===
# (drawing only, uses existing tower.damage_dealt for XP proxy)

# === BATTD2 FEATURE: OVERCHARGE ===
var _overcharged_tower: Node2D = null
var _overcharge_timer: float = 0.0
const OVERCHARGE_COST: int = 35
const OVERCHARGE_DURATION: float = 10.0

# === BATTD2 FEATURE: PATH EVENTS ===
var _path_events: Array = []  # [{pos, type, timer, damage}]
var _path_event_cooldown: float = 0.0
const PATH_EVENT_INTERVAL: float = 20.0  # seconds between events

# === BATTD2 FEATURE: AUTO-COLLECT ===
var auto_collect_enabled: bool = false

# === BATTD2 FEATURE: GEAR REROLL ===
const REROLL_SHARD_COST: int = 15

# === BATTD2 FEATURE: VICTORY STREAK ===
var victory_streak: int = 0
var victory_streak_best: int = 0
const STREAK_GOLD_BONUS: float = 0.05  # +5% gold per streak level
const STREAK_XP_BONUS: float = 0.05   # +5% XP per streak level


# === BATTD3 FEATURE: CHARACTER AFFINITY ===
# Characters earn affinity on their home chapters, unlocking exclusive bonuses
var character_affinity: Dictionary = {}  # TowerType -> float (0.0 to 100.0)
const AFFINITY_PER_WAVE: float = 0.5  # +0.5 affinity per wave survived on home map
const AFFINITY_MILESTONES: Array = [10.0, 25.0, 50.0, 75.0, 100.0]
const AFFINITY_BONUSES: Array = [
	{"name": "Homefield", "desc": "+5% damage on home map", "effect": "damage", "value": 0.05},
	{"name": "Familiar Ground", "desc": "+8% range on home map", "effect": "range", "value": 0.08},
	{"name": "Deep Roots", "desc": "+10% attack speed on home map", "effect": "attack_speed", "value": 0.10},
	{"name": "Territorial", "desc": "+15% all stats on home map", "effect": "all", "value": 0.15},
	{"name": "Master of Domain", "desc": "+5% crit chance on home map", "effect": "crit", "value": 0.05},
]
const CHARACTER_HOME_LEVELS: Dictionary = {
	0: [0, 1, 2], 1: [3, 4, 5], 2: [6, 7, 8],
	3: [9, 10, 11], 4: [12, 13, 14], 5: [15, 16, 17],
}
# === LAYERED MUSIC SYSTEM ===
# Each character plays an instrument — placing towers builds the song
var _music_layers: Array = []  # 7 AudioStreamPlayers [drums, robin, alice, witch, peter, phantom, scrooge]
var _music_layer_targets: Array = [0.35, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Target volumes (linear)
var _music_layer_current: Array = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Current volumes (for tweening)
var _music_song_index: int = 0  # Which of 5 songs is playing
var _music_layers_active: bool = false
var _music_tempo_mult: float = 1.0  # Speeds up with upgrades
var _music_max_tier_cache: int = 0  # Cached max upgrade tier (updated on place/sell/upgrade)
var _music_intensity: float = 0.0  # 0.0-1.0, rises during boss waves / late game
const MUSIC_FADE_IN_SPEED: float = 0.8  # Volume units/sec for fading IN (snappy entry)
const MUSIC_FADE_OUT_SPEED: float = 0.35  # Volume units/sec for fading OUT (gradual exit)
const MUSIC_PULSE_DECAY_SPEED: float = 1.2  # Volume units/sec for pulse decay (fast snap-back)
const MUSIC_LOOP_BARS: int = 4  # 4-bar loops
const MUSIC_GEN_RATE: int = 44100

# Song definitions: key, tempo, chord progression, mood

# === BATTD3 FEATURE: MILESTONE TITLES ===
const MILESTONE_TITLES: Array = [
	{"threshold": 0, "title": "Novice", "color_r": 0.6, "color_g": 0.6, "color_b": 0.65},
	{"threshold": 10000, "title": "Apprentice", "color_r": 0.4, "color_g": 0.7, "color_b": 0.4},
	{"threshold": 100000, "title": "Veteran", "color_r": 0.3, "color_g": 0.5, "color_b": 0.9},
	{"threshold": 500000, "title": "Champion", "color_r": 0.7, "color_g": 0.3, "color_b": 0.9},
	{"threshold": 2000000, "title": "Legend", "color_r": 0.9, "color_g": 0.6, "color_b": 0.1},
	{"threshold": 10000000, "title": "Myth", "color_r": 1.0, "color_g": 0.3, "color_b": 0.2},
	{"threshold": 50000000, "title": "Eternal", "color_r": 1.0, "color_g": 0.85, "color_b": 0.3},
]

# === BATTD3 FEATURE: AWAKENING SYSTEM ===
var awakened_characters: Dictionary = {}  # TowerType -> bool
const AWAKENING_SHARD_COST: int = 500
const AWAKENING_QUILL_COST: int = 50
const AWAKENING_PASSIVES: Dictionary = {
	0: {"name": "Rain of Arrows", "desc": "Every 10th shot fires 3 arrows", "effect": "multi_shot"},
	1: {"name": "Wonderland Chaos", "desc": "Random chance to polymorph enemies", "effect": "polymorph"},
	2: {"name": "Hex Storm", "desc": "Attacks have 15% chance to curse nearby enemies", "effect": "chain_curse"},
	3: {"name": "Never Grow Up", "desc": "Gains +1% all stats per wave survived", "effect": "scaling"},
	4: {"name": "Requiem", "desc": "Defeated enemies explode for 20% of their max HP", "effect": "death_explosion"},
	5: {"name": "Golden Touch", "desc": "Every kill has 10% chance to drop bonus gold", "effect": "gold_on_kill"},
}

# === BATTD3 FEATURE: COSMIC INK ===
var cosmic_ink: int = 0  # Universal currency convertible to any character's XP
const COSMIC_INK_TO_XP: float = 100.0  # 1 Cosmic Ink = 100 XP
const COSMIC_INK_CONVERSION_COST: int = 1  # 1 ink per conversion

# === BATTD3 FEATURE: STAT RESPEC ===
var respec_count: int = 0  # Times respecced (costs increase)
const RESPEC_BASE_COST: int = 50  # Shards
const RESPEC_COST_MULT: float = 1.5  # Each respec costs 50% more

# === BATTD3 FEATURE: GEAR LOADOUT PRESETS ===
var gear_loadouts: Dictionary = {}  # TowerType -> [{bindings: [], relics: []}] x 3
var gear_loadout_active: Dictionary = {}  # TowerType -> int (0-2)
const MAX_LOADOUTS: int = 3

# === BATTD3 FEATURE: TRINKET LOCKING ===
var locked_bindings: Dictionary = {}  # binding_id -> bool

# === BATTD3 FEATURE: GEAR COMPARISON ===
var _gear_compare_binding: String = ""  # Currently compared binding ID
var _gear_compare_visible: bool = false

# === BATTD3 FEATURE: RELIC MASTERY ===
var relic_usage_tracker: Dictionary = {}  # "tower_type_relic_idx" -> int (waves equipped)
const RELIC_MASTERY_THRESHOLDS: Array = [10, 25, 50, 100]  # Waves to reach each mastery level
const RELIC_MASTERY_BONUS: float = 0.05  # +5% effect per mastery level

# === BATTD3 FEATURE: GEAR COLLECTION CODEX ===
var discovered_bindings: Dictionary = {}  # binding_id -> bool (ever seen, even if sharded)
var codex_open: bool = false
var codex_scroll: float = 0.0
var codex_filter_rarity: String = ""  # "" = all, or rarity name
var codex_hover_index: int = -1

# === BATTD3 FEATURE: STATS SUMMARY PANEL ===
var detail_stats_expanded: bool = false  # Toggle for expanded stats on detail page

# === BATTD3 FEATURE: RECENT ITEMS FEED ===
var recent_items: Array = []  # [{name, rarity, timestamp}] — last 5 items acquired
const MAX_RECENT_ITEMS: int = 5

# === BATTD3 FEATURE: FAVORITE CHARACTERS ===
var favorite_characters: Array = []  # Up to 3 TowerType values pinned to top of grid

# === BATTD3 FEATURE: QUICK-EQUIP FROM CHEST ===
var quick_equip_pending: Dictionary = {}  # {binding_id, rarity} — pending quick-equip item
var quick_equip_active: bool = false

# === BATTD3 FEATURE: PARTY POWER RATING ===
var _cached_power_ratings: Dictionary = {}  # TowerType -> int
var _power_rating_dirty: bool = true

# === BATTD3 FEATURE: LEVEL-UP FANFARE ===
var levelup_fanfare_active: bool = false
var levelup_fanfare_timer: float = 0.0
var levelup_fanfare_tower_type: int = -1
var levelup_fanfare_new_level: int = 0
var levelup_fanfare_particles: Array = []  # [{pos, vel, color, life}]
const LEVELUP_FANFARE_DURATION: float = 2.5

# === BATTD3 FEATURE: SESSION STATS RECAP ===
var session_stats: Dictionary = {}  # Populated post-victory: {towers_placed, gold_earned, gold_spent, dps_per_tower, waves_sent_early, crits, ...}
var session_recap_open: bool = false
var session_recap_scroll: float = 0.0

# === BATTD3 FEATURE: CAREER STATS ===
var career_stats: Dictionary = {
	"total_games_played": 0,
	"total_games_won": 0,
	"total_games_lost": 0,
	"total_waves_survived": 0,
	"total_gold_earned_lifetime": 0,
	"total_gold_spent_lifetime": 0,
	"total_towers_placed_lifetime": 0,
	"total_enemies_killed_lifetime": 0,
	"total_bosses_killed": 0,
	"total_damage_dealt_lifetime": 0.0,
	"highest_single_hit": 0.0,
	"most_towers_in_game": 0,
	"fastest_victory_waves": 0,
	"longest_victory_streak": 0,
	"total_play_time_seconds": 0.0,
	"favorite_tower": -1,
}
var career_stats_open: bool = false

# === BATTD3 FEATURE: NEXT GOAL TRACKER ===
var _next_goals: Array = []  # [{type, desc, progress, target, reward}] — nearest 3 goals
var _goals_dirty: bool = true

# === BATTD3 FEATURE: CHARACTER RANK BADGES ===
const RANK_BADGE_TIERS: Array = [
	{"name": "Bronze", "min_score": 0, "color_r": 0.72, "color_g": 0.45, "color_b": 0.20},
	{"name": "Silver", "min_score": 50, "color_r": 0.75, "color_g": 0.75, "color_b": 0.80},
	{"name": "Gold", "min_score": 150, "color_r": 0.85, "color_g": 0.65, "color_b": 0.10},
	{"name": "Platinum", "min_score": 350, "color_r": 0.40, "color_g": 0.75, "color_b": 0.85},
	{"name": "Diamond", "min_score": 600, "color_r": 0.55, "color_g": 0.30, "color_b": 0.90},
	{"name": "Mythic", "min_score": 1000, "color_r": 1.0, "color_g": 0.30, "color_b": 0.15},
]
# Each song maps to a group of levels
const MAP_SONGS: Array = [
	{
		"name": "Shadows of London", "bpm": 120, "key": "Dm",
		"root": 146.83, # D3
		"scale": [0, 2, 3, 5, 7, 8, 10],  # Natural minor
		"chord_roots": [0, 5, 3, 7],  # i - iv - III - v
		"levels": [0, 1, 2, 3, 10, 11, 12],  # Prologue + Sherlock + Dracula
	},
	{
		"name": "The Enchanted Grove", "bpm": 130, "key": "Gm",
		"root": 196.0, # G3
		"scale": [0, 2, 3, 5, 7, 8, 10],
		"chord_roots": [0, 3, 5, 7],  # i - III - iv - v
		"levels": [4, 5, 6, 16, 17, 18],  # Merlin + Robin Hood
	},
	{
		"name": "Wonderland Waltz", "bpm": 140, "key": "C",
		"root": 130.81, # C3
		"scale": [0, 2, 4, 5, 7, 9, 11],  # Major
		"chord_roots": [0, 5, 7, 4],  # I - IV - V - iii
		"levels": [19, 20, 21, 25, 26, 27],  # Alice + Peter Pan
	},
	{
		"name": "The Dark Laboratory", "bpm": 110, "key": "Em",
		"root": 164.81, # E3
		"scale": [0, 2, 3, 5, 7, 8, 10],
		"chord_roots": [0, 3, 5, 8],  # i - III - iv - VI
		"levels": [7, 8, 9, 13, 14, 15],  # Tarzan + Frankenstein
	},
	{
		"name": "The Final Verse", "bpm": 135, "key": "Am",
		"root": 110.0, # A2
		"scale": [0, 2, 3, 5, 7, 8, 10],
		"chord_roots": [0, 7, 5, 3],  # i - v - iv - III
		"levels": [22, 23, 24, 28, 29, 30, 31, 32, 33, 34, 35, 36],  # Witch+Phantom+Scrooge+Shadow Author
	},
]

# Character → layer index mapping
const TOWER_LAYER_MAP: Dictionary = {
	0: 1,   # ROBIN_HOOD → layer 1 (strings)
	1: 2,   # ALICE → layer 2 (music box)
	2: 3,   # WICKED_WITCH → layer 3 (organ)
	3: 4,   # PETER_PAN → layer 4 (flute)
	4: 5,   # PHANTOM → layer 5 (piano)
	5: 6,   # SCROOGE → layer 6 (brass)
}




# === ENDLESS MODE ===
var endless_mode: bool = false
var endless_high_wave: int = 0
var endless_background_level: int = 0

# === TOME BINDINGS (Gear) ===
const TOME_BINDINGS: Array = [
	# ===== COMMON / BLUE (50 relics) =====
	# -- Robin Hood --
	{"id": "lincoln_band", "name": "Lincoln Green Band", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "robin_hood"},
	{"id": "nottingham_arrow", "name": "Nottingham Arrow", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "robin_hood"},
	{"id": "sherwood_acorn", "name": "Sherwood Acorn", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "robin_hood"},
	{"id": "merry_men_purse", "name": "Merry Men Purse", "desc": "+12% gold bonus", "rarity": "tattered", "effect": "gold_bonus", "value": 0.12, "character": "robin_hood"},
	# -- Alice --
	{"id": "cheshire_grin", "name": "Cheshire Grin", "desc": "+8% dodge", "rarity": "tattered", "effect": "dodge", "value": 0.08, "character": "alice"},
	{"id": "croquet_mallet", "name": "Croquet Mallet", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "alice"},
	{"id": "caterpillar_hookah", "name": "Caterpillar Hookah", "desc": "+10% slow", "rarity": "tattered", "effect": "slow", "value": 0.10, "character": "alice"},
	{"id": "mad_hatter_thimble", "name": "Mad Hatter's Thimble", "desc": "+8% crit", "rarity": "tattered", "effect": "crit", "value": 0.08, "character": "alice"},
	# -- Wicked Witch --
	{"id": "winkie_helm", "name": "Winkie Guard Helm", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "wicked_witch"},
	{"id": "poppy_petal", "name": "Poppy Petal", "desc": "+12% slow", "rarity": "tattered", "effect": "slow", "value": 0.12, "character": "wicked_witch"},
	{"id": "silver_whistle", "name": "Silver Whistle", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "wicked_witch"},
	{"id": "emerald_shard", "name": "Emerald Shard", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "wicked_witch"},
	# -- Peter Pan --
	{"id": "lost_boy_dagger", "name": "Lost Boy Dagger", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "peter_pan"},
	{"id": "pixie_dust_pinch", "name": "Pixie Dust Pinch", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "peter_pan"},
	{"id": "neverland_shell", "name": "Neverland Shell", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "peter_pan"},
	{"id": "tick_tock_tooth", "name": "Tick-Tock Tooth", "desc": "+8% crit", "rarity": "tattered", "effect": "crit", "value": 0.08, "character": "peter_pan"},
	# -- Phantom --
	{"id": "opera_mask_fragment", "name": "Opera Mask Fragment", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "phantom"},
	{"id": "chandelier_crystal", "name": "Chandelier Crystal", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "phantom"},
	{"id": "music_box_key", "name": "Music Box Key", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "phantom"},
	{"id": "catacomb_stone", "name": "Catacomb Stone", "desc": "+8% dodge", "rarity": "tattered", "effect": "dodge", "value": 0.08, "character": "phantom"},
	# -- Scrooge --
	{"id": "counting_house_coin", "name": "Counting House Coin", "desc": "+15% gold bonus", "rarity": "tattered", "effect": "gold_bonus", "value": 0.15, "character": "scrooge"},
	{"id": "ghost_chain_link", "name": "Ghost Chain Link", "desc": "+10% slow", "rarity": "tattered", "effect": "slow", "value": 0.10, "character": "scrooge"},
	{"id": "fezziwig_fiddle", "name": "Fezziwig Fiddle", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "scrooge"},
	{"id": "tiny_tim_crutch", "name": "Tiny Tim's Crutch", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "scrooge"},
	# -- Sherlock --
	{"id": "magnifying_lens", "name": "Magnifying Lens", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "sherlock"},
	{"id": "baker_street_pipe", "name": "Baker Street Pipe", "desc": "+8% crit", "rarity": "tattered", "effect": "crit", "value": 0.08, "character": "sherlock"},
	{"id": "watson_revolver", "name": "Watson's Revolver", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "sherlock"},
	{"id": "deerstalker_pin", "name": "Deerstalker Pin", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "sherlock"},
	# -- Tarzan --
	{"id": "jungle_vine", "name": "Jungle Vine", "desc": "+10% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.10, "character": "tarzan"},
	{"id": "mangani_claw", "name": "Mangani Claw", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "tarzan"},
	{"id": "treehouse_bark", "name": "Treehouse Bark", "desc": "+8% dodge", "rarity": "tattered", "effect": "dodge", "value": 0.08, "character": "tarzan"},
	{"id": "elephant_tusk", "name": "Elephant Tusk", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "tarzan"},
	# -- Dracula --
	{"id": "bat_wing_fragment", "name": "Bat Wing Fragment", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "dracula"},
	{"id": "coffin_nail", "name": "Coffin Nail", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "dracula"},
	{"id": "transylvania_soil", "name": "Transylvania Soil", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "dracula"},
	{"id": "garlic_braid", "name": "Garlic Braid", "desc": "+12% slow", "rarity": "tattered", "effect": "slow", "value": 0.12, "character": "dracula"},
	# -- Merlin --
	{"id": "crystal_ball_chip", "name": "Crystal Ball Chip", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "merlin"},
	{"id": "dragon_scale", "name": "Dragon Scale", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "merlin"},
	{"id": "camelot_banner", "name": "Camelot Banner", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "merlin"},
	{"id": "excalibur_polish", "name": "Excalibur Polish", "desc": "+8% crit", "rarity": "tattered", "effect": "crit", "value": 0.08, "character": "merlin"},
	# -- Frankenstein --
	{"id": "copper_wire", "name": "Copper Wire", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08, "character": "frankenstein"},
	{"id": "lightning_rod_tip", "name": "Lightning Rod Tip", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10, "character": "frankenstein"},
	{"id": "lab_journal_page", "name": "Lab Journal Page", "desc": "+10% range", "rarity": "tattered", "effect": "range", "value": 0.10, "character": "frankenstein"},
	{"id": "galvanic_bolt", "name": "Galvanic Bolt", "desc": "+10% splash radius", "rarity": "tattered", "effect": "splash_radius", "value": 0.10, "character": "frankenstein"},
	# -- Universal --
	{"id": "quill_swiftness", "name": "Quill of Swiftness", "desc": "+8% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.08},
	{"id": "inkwell_power", "name": "Inkwell of Power", "desc": "+10% damage", "rarity": "tattered", "effect": "damage", "value": 0.10},
	{"id": "bookmark_reach", "name": "Bookmark of Reach", "desc": "+12% range", "rarity": "tattered", "effect": "range", "value": 0.12},
	{"id": "leather_journal", "name": "Leather-Bound Journal", "desc": "+15% gold bonus", "rarity": "tattered", "effect": "gold_bonus", "value": 0.15},
	{"id": "fairy_dust", "name": "Fairy Dust Vial", "desc": "+12% attack speed", "rarity": "tattered", "effect": "attack_speed", "value": 0.12},
	{"id": "marleys_chains", "name": "Marley's Chains", "desc": "+20% slow", "rarity": "tattered", "effect": "slow", "value": 0.20},
	# ===== UNCOMMON / PURPLE (50 relics) =====
	# -- Robin Hood --
	{"id": "longbow_riser", "name": "Longbow Riser", "desc": "+12% damage, +5% range", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "range", "value": 0.05}], "character": "robin_hood"},
	{"id": "friar_tuck_flask", "name": "Friar Tuck's Flask", "desc": "+15% heal, +5% all stats", "rarity": "bound", "effects": [{"effect": "heal_nearby", "value": 1.5}, {"effect": "all", "value": 0.05}], "character": "robin_hood"},
	{"id": "maid_marian_ribbon", "name": "Maid Marian's Ribbon", "desc": "+10% atk spd, +8% dodge", "rarity": "bound", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "dodge", "value": 0.08}], "character": "robin_hood"},
	{"id": "sheriff_badge", "name": "Sheriff's Badge", "desc": "+15% gold, +8% crit", "rarity": "bound", "effects": [{"effect": "gold_bonus", "value": 0.15}, {"effect": "crit", "value": 0.08}], "character": "robin_hood"},
	# -- Alice --
	{"id": "vorpal_blade", "name": "Vorpal Blade", "desc": "+10% crit, +12% crit damage", "rarity": "bound", "effects": [{"effect": "crit", "value": 0.10}, {"effect": "crit_damage", "value": 0.12}], "character": "alice"},
	{"id": "queen_scepter", "name": "Queen's Scepter", "desc": "+12% damage, +8% splash", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "splash_radius", "value": 0.08}], "character": "alice"},
	{"id": "looking_glass", "name": "Looking Glass", "desc": "+15% range, +5% dodge", "rarity": "bound", "effects": [{"effect": "range", "value": 0.15}, {"effect": "dodge", "value": 0.05}], "character": "alice"},
	{"id": "drink_me_elixir", "name": "Drink Me Elixir", "desc": "+12% slow, +8% debuff amp", "rarity": "bound", "effects": [{"effect": "slow", "value": 0.12}, {"effect": "debuff_amp", "value": 0.08}], "character": "alice"},
	# -- Wicked Witch --
	{"id": "broomstick_splinter", "name": "Broomstick Splinter", "desc": "+10% atk spd, +8% range", "rarity": "bound", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "range", "value": 0.08}], "character": "wicked_witch"},
	{"id": "monkey_wing_medal", "name": "Monkey Wing Medal", "desc": "+12% damage, +5% crit", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "crit", "value": 0.05}], "character": "wicked_witch"},
	{"id": "crystal_ball_oz", "name": "Crystal Ball of Oz", "desc": "+15% range, +5% slow", "rarity": "bound", "effects": [{"effect": "range", "value": 0.15}, {"effect": "slow", "value": 0.05}], "character": "wicked_witch"},
	{"id": "ruby_heel", "name": "Ruby Heel", "desc": "+10% atk spd, +10% dodge", "rarity": "bound", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "dodge", "value": 0.10}], "character": "wicked_witch"},
	# -- Peter Pan --
	{"id": "shadow_thread", "name": "Shadow Thread", "desc": "+10% dodge, +10% crit", "rarity": "bound", "effects": [{"effect": "dodge", "value": 0.10}, {"effect": "crit", "value": 0.10}], "character": "peter_pan"},
	{"id": "hook_compass", "name": "Hook's Compass", "desc": "+15% range, +5% damage", "rarity": "bound", "effects": [{"effect": "range", "value": 0.15}, {"effect": "damage", "value": 0.05}], "character": "peter_pan"},
	{"id": "mermaid_scale", "name": "Mermaid Scale", "desc": "+8% all stats", "rarity": "bound", "effect": "all", "value": 0.08, "character": "peter_pan"},
	{"id": "wendy_thimble_kiss", "name": "Wendy's Thimble Kiss", "desc": "+10% atk spd, +8% heal", "rarity": "bound", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "heal_nearby", "value": 0.8}], "character": "peter_pan"},
	# -- Phantom --
	{"id": "punjab_lasso", "name": "Punjab Lasso Fiber", "desc": "+12% slow, +10% debuff amp", "rarity": "bound", "effects": [{"effect": "slow", "value": 0.12}, {"effect": "debuff_amp", "value": 0.10}], "character": "phantom"},
	{"id": "christine_rose", "name": "Christine's Rose", "desc": "+15% aura range, +5% atk spd", "rarity": "bound", "effects": [{"effect": "aura_range", "value": 0.15}, {"effect": "attack_speed", "value": 0.05}], "character": "phantom"},
	{"id": "organ_pipe_reed", "name": "Organ Pipe Reed", "desc": "+12% damage, +8% splash", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "splash_radius", "value": 0.08}], "character": "phantom"},
	{"id": "underground_lake_gem", "name": "Underground Lake Gem", "desc": "+10% range, +8% dodge", "rarity": "bound", "effects": [{"effect": "range", "value": 0.10}, {"effect": "dodge", "value": 0.08}], "character": "phantom"},
	# -- Scrooge --
	{"id": "ghost_past_candle", "name": "Ghost of Past's Candle", "desc": "+10% crit, +10% first blood", "rarity": "bound", "effects": [{"effect": "crit", "value": 0.10}, {"effect": "first_blood", "value": 0.10}], "character": "scrooge"},
	{"id": "cratchit_ledger", "name": "Cratchit's Ledger", "desc": "+12% gold, +10% wave gold", "rarity": "bound", "effects": [{"effect": "gold_bonus", "value": 0.12}, {"effect": "wave_gold", "value": 0.10}], "character": "scrooge"},
	{"id": "belle_locket", "name": "Belle's Locket", "desc": "+8% all stats", "rarity": "bound", "effect": "all", "value": 0.08, "character": "scrooge"},
	{"id": "spirit_future_scythe", "name": "Spirit of Future's Scythe", "desc": "+15% execute, +5% damage", "rarity": "bound", "effects": [{"effect": "execute", "value": 0.15}, {"effect": "damage", "value": 0.05}], "character": "scrooge"},
	# -- Sherlock --
	{"id": "violin_string", "name": "Violin String", "desc": "+12% atk spd, +8% crit", "rarity": "bound", "effects": [{"effect": "attack_speed", "value": 0.12}, {"effect": "crit", "value": 0.08}], "character": "sherlock"},
	{"id": "moriarty_cipher", "name": "Moriarty's Cipher", "desc": "+15% damage, -5% atk spd", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.15}, {"effect": "attack_speed", "value": -0.05}], "character": "sherlock"},
	{"id": "irene_brooch", "name": "Irene Adler's Brooch", "desc": "+10% dodge, +10% range", "rarity": "bound", "effects": [{"effect": "dodge", "value": 0.10}, {"effect": "range", "value": 0.10}], "character": "sherlock"},
	{"id": "baskerville_tooth", "name": "Baskerville Hound Tooth", "desc": "+12% dmg, +8% armor pierce", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "armor_pierce", "value": 0.08}], "character": "sherlock"},
	# -- Tarzan --
	{"id": "ape_king_crown", "name": "Ape King's Crown", "desc": "+12% dmg, +8% aura range", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "aura_range", "value": 0.08}], "character": "tarzan"},
	{"id": "jane_sketch_pad", "name": "Jane's Sketch Pad", "desc": "+10% range, +10% crit", "rarity": "bound", "effects": [{"effect": "range", "value": 0.10}, {"effect": "crit", "value": 0.10}], "character": "tarzan"},
	{"id": "sabor_fang", "name": "Sabor's Fang", "desc": "+15% armor pierce, +5% atk spd", "rarity": "bound", "effects": [{"effect": "armor_pierce", "value": 0.15}, {"effect": "attack_speed", "value": 0.05}], "character": "tarzan"},
	{"id": "kerchak_knuckle", "name": "Kerchak's Knuckle", "desc": "+12% dmg, +8% splash", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "splash_radius", "value": 0.08}], "character": "tarzan"},
	# -- Dracula --
	{"id": "mina_crucifix", "name": "Mina's Crucifix", "desc": "+12% damage, +8% burn", "rarity": "bound", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "burn", "value": 0.08}], "character": "dracula"},
	{"id": "harker_journal", "name": "Harker's Journal", "desc": "+15% range, +5% crit", "rarity": "bound", "effects": [{"effect": "range", "value": 0.15}, {"effect": "crit", "value": 0.05}], "character": "dracula"},
	{"id": "van_helsing_stake", "name": "Van Helsing's Stake", "desc": "+15% boss dmg, +5% dmg", "rarity": "bound", "effects": [{"effect": "boss_damage", "value": 0.15}, {"effect": "damage", "value": 0.05}], "character": "dracula"},
	{"id": "blood_chalice", "name": "Blood Chalice", "desc": "+8% lifesteal, +5% atk spd", "rarity": "bound", "effects": [{"effect": "lifesteal", "value": 0.08}, {"effect": "attack_speed", "value": 0.05}], "character": "dracula"},
	# -- Merlin --
	{"id": "round_table_shard", "name": "Round Table Shard", "desc": "+8% all stats", "rarity": "bound", "effect": "all", "value": 0.08, "character": "merlin"},
	{"id": "morgan_mirror", "name": "Morgan le Fay's Mirror", "desc": "+12% range, +8% chain", "rarity": "bound", "effects": [{"effect": "range", "value": 0.12}, {"effect": "chain", "value": 0.08}], "character": "merlin"},
	{"id": "nimue_pearl", "name": "Nimue's Pearl", "desc": "+10% cooldown red., +5% range", "rarity": "bound", "effects": [{"effect": "cooldown_reduction", "value": 0.10}, {"effect": "range", "value": 0.05}], "character": "merlin"},
	{"id": "grail_knight_shield", "name": "Grail Knight's Shield", "desc": "+10% dodge, +8% absorb", "rarity": "bound", "effects": [{"effect": "dodge", "value": 0.10}, {"effect": "absorb_hit", "value": 0.8}], "character": "merlin"},
	# -- Frankenstein --
	{"id": "prometheus_flame", "name": "Prometheus Flame", "desc": "+12% burn, +8% damage", "rarity": "bound", "effects": [{"effect": "burn", "value": 0.12}, {"effect": "damage", "value": 0.08}], "character": "frankenstein"},
	{"id": "arctic_ice_shard", "name": "Arctic Ice Shard", "desc": "+15% slow, +8% debuff amp", "rarity": "bound", "effects": [{"effect": "slow", "value": 0.15}, {"effect": "debuff_amp", "value": 0.08}], "character": "frankenstein"},
	{"id": "creature_heart", "name": "Creature's Heart", "desc": "+8% lifesteal, +8% damage", "rarity": "bound", "effects": [{"effect": "lifesteal", "value": 0.08}, {"effect": "damage", "value": 0.08}], "character": "frankenstein"},
	{"id": "elizabeth_ring", "name": "Elizabeth's Ring", "desc": "+10% aura range, +8% atk spd", "rarity": "bound", "effects": [{"effect": "aura_range", "value": 0.10}, {"effect": "attack_speed", "value": 0.08}], "character": "frankenstein"},
	# -- Universal --
	{"id": "silver_monocle", "name": "Silver Monocle", "desc": "+8% crit chance", "rarity": "bound", "effect": "crit", "value": 0.08},
	{"id": "iron_clasp", "name": "Iron Clasp", "desc": "+5% all stats", "rarity": "bound", "effect": "all", "value": 0.05},
	{"id": "dusty_tome", "name": "Dusty Tome", "desc": "+15% XP gain", "rarity": "bound", "effect": "xp_gain", "value": 0.15},
	{"id": "gothic_candelabra", "name": "Gothic Candelabra", "desc": "+8% range, +5% damage", "rarity": "bound", "effects": [{"effect": "range", "value": 0.08}, {"effect": "damage", "value": 0.05}]},
	{"id": "raven_feather", "name": "Raven Feather", "desc": "+10% atk spd, -5% damage", "rarity": "bound", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "damage", "value": -0.05}]},
	{"id": "wolf_pelt", "name": "Wolf Pelt Cape", "desc": "+15% slow, +5% range", "rarity": "bound", "effects": [{"effect": "slow", "value": 0.15}, {"effect": "range", "value": 0.05}]},
	# ===== RARE / GOLD (50 relics) =====
	# -- Robin Hood --
	{"id": "bow_greenwood", "name": "Bow of the Greenwood", "desc": "+20% dmg, +10% crit, +15% chain", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "crit", "value": 0.10}, {"effect": "chain", "value": 0.15}], "character": "robin_hood"},
	{"id": "sherwood_heart", "name": "Sherwood's Heart", "desc": "+15% all stats", "rarity": "gilded", "effect": "all", "value": 0.15, "character": "robin_hood"},
	{"id": "hood_final_arrow", "name": "Hood's Final Arrow", "desc": "+25% first blood, +10% armor pierce", "rarity": "gilded", "effects": [{"effect": "first_blood", "value": 0.25}, {"effect": "armor_pierce", "value": 0.10}], "character": "robin_hood"},
	{"id": "little_john_staff", "name": "Little John's Staff", "desc": "+20% splash, +15% slow", "rarity": "gilded", "effects": [{"effect": "splash_radius", "value": 0.20}, {"effect": "slow", "value": 0.15}], "character": "robin_hood"},
	# -- Alice --
	{"id": "jabberwock_scale", "name": "Jabberwock Scale", "desc": "+25% boss dmg, +10% crit dmg", "rarity": "gilded", "effects": [{"effect": "boss_damage", "value": 0.25}, {"effect": "crit_damage", "value": 0.10}], "character": "alice"},
	{"id": "queen_hearts_crown", "name": "Queen of Hearts' Crown", "desc": "+20% dmg, +15% execute", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "execute", "value": 0.15}], "character": "alice"},
	{"id": "wonderland_key", "name": "Wonderland Key", "desc": "+12% all stats, +10% CD red.", "rarity": "gilded", "effects": [{"effect": "all", "value": 0.12}, {"effect": "cooldown_reduction", "value": 0.10}], "character": "alice"},
	{"id": "cheshire_essence", "name": "Cheshire Essence", "desc": "+20% dodge, +15% crit", "rarity": "gilded", "effects": [{"effect": "dodge", "value": 0.20}, {"effect": "crit", "value": 0.15}], "character": "alice"},
	# -- Wicked Witch --
	{"id": "witch_hourglass", "name": "Witch's Hourglass", "desc": "+20% slow, +15% debuff amp, +5% dmg", "rarity": "gilded", "effects": [{"effect": "slow", "value": 0.20}, {"effect": "debuff_amp", "value": 0.15}, {"effect": "damage", "value": 0.05}], "character": "wicked_witch"},
	{"id": "wizard_curtain", "name": "Wizard's Curtain", "desc": "+15% dodge, +15% range", "rarity": "gilded", "effects": [{"effect": "dodge", "value": 0.15}, {"effect": "range", "value": 0.15}], "character": "wicked_witch"},
	{"id": "glinda_wand", "name": "Glinda's Wand", "desc": "+20% aura range, +10% atk spd", "rarity": "gilded", "effects": [{"effect": "aura_range", "value": 0.20}, {"effect": "attack_speed", "value": 0.10}], "character": "wicked_witch"},
	{"id": "enchanted_silver_shoes", "name": "Enchanted Silver Shoes", "desc": "+15% all stats", "rarity": "gilded", "effect": "all", "value": 0.15, "character": "wicked_witch"},
	# -- Peter Pan --
	{"id": "second_star_compass", "name": "Second Star Compass", "desc": "+12% all stats, +10% range", "rarity": "gilded", "effects": [{"effect": "all", "value": 0.12}, {"effect": "range", "value": 0.10}], "character": "peter_pan"},
	{"id": "captain_hook_claw", "name": "Captain Hook's Claw", "desc": "+25% dmg, +10% armor pierce", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.25}, {"effect": "armor_pierce", "value": 0.10}], "character": "peter_pan"},
	{"id": "fairy_queen_wing", "name": "Fairy Queen's Wing", "desc": "+20% atk spd, +15% CD red.", "rarity": "gilded", "effects": [{"effect": "attack_speed", "value": 0.20}, {"effect": "cooldown_reduction", "value": 0.15}], "character": "peter_pan"},
	{"id": "neverland_hourglass", "name": "Neverland Hourglass", "desc": "+20% slow, +5% all stats", "rarity": "gilded", "effects": [{"effect": "slow", "value": 0.20}, {"effect": "all", "value": 0.05}], "character": "peter_pan"},
	# -- Phantom --
	{"id": "phantom_full_mask", "name": "Phantom's Full Mask", "desc": "+20% dmg, +15% crit, +8% lifesteal", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "crit", "value": 0.15}, {"effect": "lifesteal", "value": 0.08}], "character": "phantom"},
	{"id": "christine_voice", "name": "Christine's Voice", "desc": "+20% aura range, +15% debuff amp", "rarity": "gilded", "effects": [{"effect": "aura_range", "value": 0.20}, {"effect": "debuff_amp", "value": 0.15}], "character": "phantom"},
	{"id": "opera_ghost_cape", "name": "Opera Ghost's Cape", "desc": "+20% dodge, +10% damage", "rarity": "gilded", "effects": [{"effect": "dodge", "value": 0.20}, {"effect": "damage", "value": 0.10}], "character": "phantom"},
	{"id": "beneath_opera", "name": "Beneath the Opera", "desc": "+25% boss dmg, +15% execute", "rarity": "gilded", "effects": [{"effect": "boss_damage", "value": 0.25}, {"effect": "execute", "value": 0.15}], "character": "phantom"},
	# -- Scrooge --
	{"id": "christmas_miracle", "name": "Christmas Miracle", "desc": "+3 HP heal/wave, +15% all stats", "rarity": "gilded", "effects": [{"effect": "heal_nearby", "value": 3.0}, {"effect": "all", "value": 0.15}], "character": "scrooge"},
	{"id": "scrooge_redemption", "name": "Scrooge's Redemption", "desc": "+25% gold, +15% wave gold", "rarity": "gilded", "effects": [{"effect": "gold_bonus", "value": 0.25}, {"effect": "wave_gold", "value": 0.15}], "character": "scrooge"},
	{"id": "ghost_present_torch", "name": "Ghost of Present's Torch", "desc": "+20% dmg, +15% aura range", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "aura_range", "value": 0.15}], "character": "scrooge"},
	{"id": "marley_lockbox", "name": "Marley's Lockbox", "desc": "Absorb 2 hits, +10% dodge", "rarity": "gilded", "effects": [{"effect": "absorb_hit", "value": 2.0}, {"effect": "dodge", "value": 0.10}], "character": "scrooge"},
	# -- Sherlock --
	{"id": "mind_palace_key", "name": "Mind Palace Key", "desc": "+15% all stats, +10% crit", "rarity": "gilded", "effects": [{"effect": "all", "value": 0.15}, {"effect": "crit", "value": 0.10}], "character": "sherlock"},
	{"id": "reichenbach_memento", "name": "Reichenbach Memento", "desc": "+25% dmg, +15% boss dmg", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.25}, {"effect": "boss_damage", "value": 0.15}], "character": "sherlock"},
	{"id": "hound_collar", "name": "The Hound's Collar", "desc": "+20% dmg, +12% chain", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "chain", "value": 0.12}], "character": "sherlock"},
	{"id": "elementary_lens", "name": "Elementary Lens", "desc": "+20% range, +15% crit, +10% armor pierce", "rarity": "gilded", "effects": [{"effect": "range", "value": 0.20}, {"effect": "crit", "value": 0.15}, {"effect": "armor_pierce", "value": 0.10}], "character": "sherlock"},
	# -- Tarzan --
	{"id": "king_jungle_crown", "name": "King of the Jungle Crown", "desc": "+20% dmg, +15% atk spd, +10% aura", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}, {"effect": "aura_range", "value": 0.10}], "character": "tarzan"},
	{"id": "greystoke_signet", "name": "Greystoke Signet", "desc": "+12% all stats, +10% gold", "rarity": "gilded", "effects": [{"effect": "all", "value": 0.12}, {"effect": "gold_bonus", "value": 0.10}], "character": "tarzan"},
	{"id": "darnot_compass", "name": "D'Arnot's Compass", "desc": "+20% range, +15% chain", "rarity": "gilded", "effects": [{"effect": "range", "value": 0.20}, {"effect": "chain", "value": 0.15}], "character": "tarzan"},
	{"id": "tarzan_war_cry", "name": "Tarzan's War Cry", "desc": "+25% splash, +15% debuff amp", "rarity": "gilded", "effects": [{"effect": "splash_radius", "value": 0.25}, {"effect": "debuff_amp", "value": 0.15}], "character": "tarzan"},
	# -- Dracula --
	{"id": "dracula_signet_ring", "name": "Dracula's Signet Ring", "desc": "+20% dmg, +8% lifesteal, +10% crit", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "lifesteal", "value": 0.08}, {"effect": "crit", "value": 0.10}], "character": "dracula"},
	{"id": "carfax_abbey_tome", "name": "Carfax Abbey Tome", "desc": "+25% boss dmg, +15% burn", "rarity": "gilded", "effects": [{"effect": "boss_damage", "value": 0.25}, {"effect": "burn", "value": 0.15}], "character": "dracula"},
	{"id": "brides_veil", "name": "Brides' Veil", "desc": "+20% slow, +15% debuff amp, +5% dodge", "rarity": "gilded", "effects": [{"effect": "slow", "value": 0.20}, {"effect": "debuff_amp", "value": 0.15}, {"effect": "dodge", "value": 0.05}], "character": "dracula"},
	{"id": "nosferatu_shadow", "name": "Nosferatu's Shadow", "desc": "+20% dodge, +15% execute, +5% atk spd", "rarity": "gilded", "effects": [{"effect": "dodge", "value": 0.20}, {"effect": "execute", "value": 0.15}, {"effect": "attack_speed", "value": 0.05}], "character": "dracula"},
	# -- Merlin --
	{"id": "excalibur_reforged", "name": "Excalibur Reforged", "desc": "+25% dmg, +15% crit, +10% armor pierce", "rarity": "gilded", "effects": [{"effect": "damage", "value": 0.25}, {"effect": "crit", "value": 0.15}, {"effect": "armor_pierce", "value": 0.10}], "character": "merlin"},
	{"id": "holy_grail_merlin", "name": "Holy Grail", "desc": "+3 HP heal/wave, +12% all stats", "rarity": "gilded", "effects": [{"effect": "heal_nearby", "value": 3.0}, {"effect": "all", "value": 0.12}], "character": "merlin"},
	{"id": "merlin_starfire_staff", "name": "Merlin's Starfire Staff", "desc": "+20% splash, +15% burn", "rarity": "gilded", "effects": [{"effect": "splash_radius", "value": 0.20}, {"effect": "burn", "value": 0.15}], "character": "merlin"},
	{"id": "avalon_mist", "name": "Avalon Mist", "desc": "+15% dodge, +15% CD red., +10% range", "rarity": "gilded", "effects": [{"effect": "dodge", "value": 0.15}, {"effect": "cooldown_reduction", "value": 0.15}, {"effect": "range", "value": 0.10}], "character": "merlin"},
	# -- Frankenstein --
	{"id": "spark_of_life", "name": "Spark of Life", "desc": "+25% chain, +15% dmg, +8% burn", "rarity": "gilded", "effects": [{"effect": "chain", "value": 0.25}, {"effect": "damage", "value": 0.15}, {"effect": "burn", "value": 0.08}], "character": "frankenstein"},
	{"id": "shelley_manuscript", "name": "Shelley's Manuscript", "desc": "+12% all stats, +15% XP gain", "rarity": "gilded", "effects": [{"effect": "all", "value": 0.12}, {"effect": "xp_gain", "value": 0.15}], "character": "frankenstein"},
	{"id": "arctic_titan_fist", "name": "Arctic Titan's Fist", "desc": "+25% boss dmg, +20% armor pierce", "rarity": "gilded", "effects": [{"effect": "boss_damage", "value": 0.25}, {"effect": "armor_pierce", "value": 0.20}], "character": "frankenstein"},
	{"id": "bride_heart", "name": "Bride's Heart", "desc": "+20% aura, +15% atk spd, +8% lifesteal", "rarity": "gilded", "effects": [{"effect": "aura_range", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}, {"effect": "lifesteal", "value": 0.08}], "character": "frankenstein"},
	# -- Universal --
	{"id": "torn_manuscript", "name": "Torn Manuscript", "desc": "+25% boss damage", "rarity": "gilded", "effect": "boss_damage", "value": 0.25},
	{"id": "wax_seal", "name": "Wax Seal", "desc": "Absorb 1 hit", "rarity": "gilded", "effect": "absorb_hit", "value": 1.0},
	{"id": "phantoms_quill", "name": "Phantom's Quill", "desc": "+3% lifesteal", "rarity": "gilded", "effect": "lifesteal", "value": 0.03},
	{"id": "bloodstained_page", "name": "Bloodstained Page", "desc": "+25% dmg when low lives", "rarity": "gilded", "effect": "bloodstained", "value": 0.25},
	{"id": "authors_signet", "name": "Author's Signet", "desc": "+2 gold per kill", "rarity": "gilded", "effect": "kill_gold", "value": 2.0},
	{"id": "holy_grail", "name": "Holy Grail Replica", "desc": "+3 HP heal/wave", "rarity": "gilded", "effect": "heal_nearby", "value": 3.0},
	# ===== MYTHIC GEAR =====
	# -- Character-Specific Mythic Gear --
	{"id": "m_greenwood_wreath", "name": "Greenwood Wreath", "desc": "Arrows fork into 3 upon impact. +20% range, +15% pierce, +10% damage.", "rarity": "mythic", "effects": [{"effect": "range", "value": 0.20}, {"effect": "pierce", "value": 0.15}, {"effect": "damage", "value": 0.10}], "special": "split_arrow_3", "character": "robin_hood", "per_level": 0.02},
	{"id": "m_looking_glass_tiara", "name": "Looking-Glass Tiara", "desc": "Attacks bewitch enemies, slowing 30%. +20% damage, +15% attack speed.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}], "special": "bewitch_slow_30pct", "character": "alice", "per_level": 0.02},
	{"id": "m_hemlock_cauldron", "name": "Hemlock Cauldron", "desc": "Brews lingering poison on hit. +25% splash, +15% burn.", "rarity": "mythic", "effects": [{"effect": "splash_radius", "value": 0.25}, {"effect": "burn", "value": 0.15}], "special": "poison_dot", "character": "wicked_witch", "per_level": 0.02},
	{"id": "m_second_star_compass", "name": "Second Star Compass", "desc": "Grants flight over all terrain. +20% range, +15% speed, +10% dodge.", "rarity": "mythic", "effects": [{"effect": "range", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}, {"effect": "dodge", "value": 0.10}], "special": "ignore_terrain", "character": "peter_pan", "per_level": 0.02},
	{"id": "m_chandelier_chain", "name": "Chandelier Chain", "desc": "Stun duration doubled on all attacks. +20% stun, +15% damage, +10% range.", "rarity": "mythic", "effects": [{"effect": "stun", "value": 0.20}, {"effect": "damage", "value": 0.15}, {"effect": "range", "value": 0.10}], "special": "double_stun_duration", "character": "phantom", "per_level": 0.02},
	{"id": "m_counting_house_key", "name": "Counting House Key", "desc": "Doubles gold earned from defeated foes. +25% gold bonus, +10% all stats.", "rarity": "mythic", "effects": [{"effect": "gold_bonus", "value": 0.25}, {"effect": "all", "value": 0.10}], "special": "double_kill_gold", "character": "scrooge", "per_level": 0.02},
	{"id": "m_spellbound_quill", "name": "Spellbound Quill", "desc": "Every 5th strike deals 3x damage. +20% damage, +15% pierce.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "pierce", "value": 0.15}], "special": "crit_every_5th_3x", "character": "merlin", "per_level": 0.02},
	{"id": "m_galvanic_coil", "name": "Galvanic Coil", "desc": "Lightning arcs between 3 enemies. +20% damage, +15% range.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "range", "value": 0.15}], "special": "chain_lightning_3", "character": "frankenstein", "per_level": 0.02},
	{"id": "m_nocturne_chalice", "name": "Nocturne Chalice", "desc": "Drains 5% of damage dealt as life. +20% damage, +15% attack speed.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}], "special": "life_steal_5pct", "character": "dracula", "per_level": 0.02},
	{"id": "m_duality_elixir", "name": "Duality Elixir", "desc": "Transform: +50% stats 10s, then -20% 5s. +20% damage, +15% speed.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}], "special": "duality_transform", "character": "jekyll_hyde", "per_level": 0.02},
	{"id": "m_tale_spinners_thread", "name": "Tale-Spinner's Thread", "desc": "Weave 3 story wishes per game (free upgrade). +20% all stats.", "rarity": "mythic", "effects": [{"effect": "all", "value": 0.20}], "special": "three_wishes", "character": "scheherazade", "per_level": 0.02},
	# -- Universal Mythic Gear --
	{"id": "m_resurrection_page", "name": "Resurrection Page", "desc": "Revive once per game at 50% HP. +15% all stats.", "rarity": "mythic", "effects": [{"effect": "all", "value": 0.15}], "special": "revive_once_50pct", "per_level": 0.015},
	{"id": "m_hourglass_of_ages", "name": "Hourglass of Ages", "desc": "Slow all enemies 15% within range. +20% range, +10% speed.", "rarity": "mythic", "effects": [{"effect": "range", "value": 0.20}, {"effect": "attack_speed", "value": 0.10}], "special": "aura_slow_15pct", "per_level": 0.015},
	{"id": "m_penumbra_cloak", "name": "Penumbra Cloak", "desc": "25% chance to evade incoming damage. +15% dodge, +10% damage.", "rarity": "mythic", "effects": [{"effect": "dodge", "value": 0.15}, {"effect": "damage", "value": 0.10}], "special": "dodge_25pct", "per_level": 0.015},
	{"id": "m_crimson_inkwell", "name": "Crimson Inkwell", "desc": "+1% damage per enemy felled (caps 50%). +15% damage.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.15}], "special": "ramping_damage_1pct", "per_level": 0.015},
	{"id": "m_tempest_seal", "name": "Tempest Seal", "desc": "Lightning strikes a random foe every 8s. +15% damage, +15% range.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.15}, {"effect": "range", "value": 0.15}], "special": "lightning_strike_8s", "per_level": 0.015},
	{"id": "m_winters_grasp", "name": "Winter's Grasp", "desc": "Freeze enemies 1s every 10 hits. +20% slow, +10% damage.", "rarity": "mythic", "effects": [{"effect": "slow", "value": 0.20}, {"effect": "damage", "value": 0.10}], "special": "freeze_every_10", "per_level": 0.015},
	{"id": "m_reflection_ward", "name": "Reflection Ward", "desc": "Reflect 20% damage back to attackers. +15% defense, +10% range.", "rarity": "mythic", "effects": [{"effect": "defense", "value": 0.15}, {"effect": "range", "value": 0.10}], "special": "reflect_20pct", "per_level": 0.015},
	{"id": "m_oblivion_sphere", "name": "Oblivion Sphere", "desc": "10% chance to banish non-boss enemies. +15% damage.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.15}], "special": "instant_banish_10pct", "per_level": 0.015},
	{"id": "m_chronicle_clasp", "name": "Chronicle Clasp", "desc": "Cooldowns reduced 25%. +20% cooldown reduction, +10% speed.", "rarity": "mythic", "effects": [{"effect": "cooldown_reduction", "value": 0.20}, {"effect": "attack_speed", "value": 0.10}], "special": "cd_reduce_25pct", "per_level": 0.015},
	{"id": "m_cinder_diadem", "name": "Cinder Diadem", "desc": "Burn aura scorches nearby foes. +15% burn, +15% splash.", "rarity": "mythic", "effects": [{"effect": "burn", "value": 0.15}, {"effect": "splash_radius", "value": 0.15}], "special": "burn_aura", "per_level": 0.015},
	{"id": "m_lodestone_heart", "name": "Lodestone Heart", "desc": "Pull enemies toward your tower. +15% range, +10% slow.", "rarity": "mythic", "effects": [{"effect": "range", "value": 0.15}, {"effect": "slow", "value": 0.10}], "special": "gravity_pull", "per_level": 0.015},
	{"id": "m_lamplight_soul", "name": "Lamplight Soul", "desc": "+2% damage per wave survived. +10% all stats.", "rarity": "mythic", "effects": [{"effect": "all", "value": 0.10}], "special": "wave_scaling_2pct", "per_level": 0.015},
	{"id": "m_berserker_binding", "name": "Berserker Binding", "desc": "+30% attack speed when below 50% HP. +15% speed, +10% damage.", "rarity": "mythic", "effects": [{"effect": "attack_speed", "value": 0.15}, {"effect": "damage", "value": 0.10}], "special": "berserk_low_hp", "per_level": 0.015},
	{"id": "m_prismatic_bookmark", "name": "Prismatic Bookmark", "desc": "Attacks cycle fire/ice/lightning. +15% damage, +10% all.", "rarity": "mythic", "effects": [{"effect": "damage", "value": 0.15}, {"effect": "all", "value": 0.10}], "special": "element_cycle", "per_level": 0.015},
	# ===== FORBIDDEN GEAR =====
	{"id": "f_authors_omniscience", "name": "Author's Omniscience", "desc": "All stats +30%. Activate: double damage 10s (60s CD).", "rarity": "forbidden", "effects": [{"effect": "all", "value": 0.30}], "special": "activated_double_damage_10s", "per_level": 0.025},
	{"id": "f_yggdrasil_sapling", "name": "Yggdrasil Sapling", "desc": "Restore 1 life per wave. +25% all stats.", "rarity": "forbidden", "effects": [{"effect": "all", "value": 0.25}], "special": "regen_1_life_per_wave", "per_level": 0.025},
	{"id": "f_midas_manuscript", "name": "Midas Manuscript", "desc": "Double all gold earned. +20% gold bonus, +20% damage.", "rarity": "forbidden", "effects": [{"effect": "gold_bonus", "value": 0.20}, {"effect": "damage", "value": 0.20}], "special": "double_all_gold", "per_level": 0.025},
	{"id": "f_narrators_crown", "name": "Narrator's Crown", "desc": "Buff all towers +10% stats. +25% range, +20% damage.", "rarity": "forbidden", "effects": [{"effect": "range", "value": 0.25}, {"effect": "damage", "value": 0.20}], "special": "global_buff_10pct", "per_level": 0.025},
	{"id": "f_reapers_quill", "name": "Reaper's Quill", "desc": "25% chance to deal 5x damage. +25% damage, +15% speed.", "rarity": "forbidden", "effects": [{"effect": "damage", "value": 0.25}, {"effect": "attack_speed", "value": 0.15}], "special": "crit_25pct_5x", "per_level": 0.025},
	{"id": "f_inferno_tome", "name": "Inferno Tome", "desc": "Scorch all enemies in range. +25% burn, +20% splash, +15% damage.", "rarity": "forbidden", "effects": [{"effect": "burn", "value": 0.25}, {"effect": "splash_radius", "value": 0.20}, {"effect": "damage", "value": 0.15}], "special": "aura_burn_all", "per_level": 0.025},
	{"id": "f_wyrm_scale_codex", "name": "Wyrm-Scale Codex", "desc": "Immune to damage 3s after placing. +30% damage, +20% range.", "rarity": "forbidden", "effects": [{"effect": "damage", "value": 0.30}, {"effect": "range", "value": 0.20}], "special": "invuln_3s_on_place", "per_level": 0.025},
	{"id": "f_piercing_verse", "name": "Piercing Verse", "desc": "Attacks pierce through all enemies in line. +25% pierce, +20% range.", "rarity": "forbidden", "effects": [{"effect": "pierce", "value": 0.25}, {"effect": "range", "value": 0.20}], "special": "infinite_pierce", "per_level": 0.025},
	{"id": "f_fates_manuscript", "name": "Fate's Manuscript", "desc": "Random powerful boon each wave. +20% all stats.", "rarity": "forbidden", "effects": [{"effect": "all", "value": 0.20}], "special": "random_buff_per_wave", "per_level": 0.025},
	{"id": "f_frozen_chronicle", "name": "Frozen Chronicle", "desc": "Activate: freeze all enemies 5s (90s CD). +20% slow, +15% speed.", "rarity": "forbidden", "effects": [{"effect": "slow", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}], "special": "activated_time_stop_5s", "per_level": 0.025},
	{"id": "f_deathknell_bell", "name": "Deathknell Bell", "desc": "Defeated enemies explode for 50% AoE. +25% damage, +20% splash.", "rarity": "forbidden", "effects": [{"effect": "damage", "value": 0.25}, {"effect": "splash_radius", "value": 0.20}], "special": "death_explosion_50pct", "per_level": 0.025},
	{"id": "f_plot_armor", "name": "Plot Armor", "desc": "Block 1 lethal hit per game. +25% defense, +20% all stats.", "rarity": "forbidden", "effects": [{"effect": "defense", "value": 0.25}, {"effect": "all", "value": 0.20}], "special": "life_save_once", "per_level": 0.025},
	{"id": "f_twinned_binding", "name": "Twinned Binding", "desc": "Link 2 towers: share 25% stats. +20% all stats.", "rarity": "forbidden", "effects": [{"effect": "all", "value": 0.20}], "special": "tower_link_25pct", "per_level": 0.025},
	{"id": "f_pandemonium_scroll", "name": "Pandemonium Scroll", "desc": "+50% all stats but enemies +20% speed. Risk and reward.", "rarity": "forbidden", "effects": [{"effect": "all", "value": 0.50}], "special": "enemy_speed_20pct_penalty", "per_level": 0.025},
	{"id": "f_spectral_echo", "name": "Spectral Echo", "desc": "Tower fires from two positions. +25% range, +20% damage.", "rarity": "forbidden", "effects": [{"effect": "range", "value": 0.25}, {"effect": "damage", "value": 0.20}], "special": "double_projectile", "per_level": 0.025},
]
var RARITY_COLORS = {"tattered": Color(0.6, 0.6, 0.65), "bound": Color(0.3, 0.75, 0.3), "gilded": Color(0.3, 0.5, 0.9), "mythic": Color(0.7, 0.35, 0.9), "forbidden": Color(1.0, 0.6, 0.1)}
var RARITY_SHARD_VALUES = {"tattered": 10, "bound": 25, "gilded": 100, "mythic": 300, "forbidden": 1000}
var RARITY_ORDER = ["tattered", "bound", "gilded", "mythic", "forbidden"]
var owned_bindings: Dictionary = {}  # binding_id -> count
var equipped_bindings: Dictionary = {}  # tower_type -> [binding_id, binding_id]
var _binding_lookup: Dictionary = {}  # binding_id -> binding dict (cache)
var relic_scroll_offset: float = 0.0
var binding_shop_scroll: float = 0.0
var detail_binding_scroll: float = 0.0

# === STORY DIALOG SYSTEM ===
var story_dialogs: Dictionary = {}  # "pre_level_N" -> [{speaker, text, voice_type}]
var story_state: Dictionary = {
	"current_dialog": "", "line_index": 0, "char_index": 0,
	"typewriter_timer": 0.0, "active": false, "auto_advance_timer": 0.0,
	"queued_dialog": ""
}
var story_seen: Array = []  # dialog keys already seen (persisted)
var story_voice_clips: Dictionary = {}  # "narrator", "male_hero", "female_hero", "monster"
var shadow_author_story_clips: Dictionary = {}  # "prologue_0" -> AudioStreamMP3
var shadow_author_fight_clips: Array = []  # fight_0..fight_6 AudioStreamMP3
var character_story_clips: Dictionary = {}  # "pre_level_1_sherlock_0" -> AudioStreamMP3
var shadow_author_taunt_timer: float = 0.0
var shadow_author_taunt_cooldown: float = 25.0  # seconds between taunts

# === UNLOCKABLE CHARACTERS ===
# 5 new characters freed from the shadow realm
# Sherlock=beat Robin levels (0-2), Tarzan=beat Alice levels (3-5),
# Dracula=beat Witch levels (6-8), Merlin=beat Peter levels (9-11),
# Frankenstein=beat Phantom levels (12-14)
var unlocked_characters: Array = []  # Array of string IDs: "sherlock", "tarzan", "dracula", "merlin", "frankenstein"
var character_unlock_map: Dictionary = {
	"sherlock": [1, 2, 3],
	"merlin": [4, 5, 6],
	"tarzan": [7, 8, 9],
	"dracula": [10, 11, 12],
	"frankenstein": [13, 14, 15],
	"shadow_author": [34, 35, 36],
}

# Arc data for menu navigation (37 levels across 13 arcs)
var arc_data = [
	{"name": "Prologue", "levels": [0], "icon": "book"},
	{"name": "Sherlock Holmes", "levels": [1, 2, 3], "unlock_char": "sherlock"},
	{"name": "Merlin", "levels": [4, 5, 6], "unlock_char": "merlin"},
	{"name": "Tarzan", "levels": [7, 8, 9], "unlock_char": "tarzan"},
	{"name": "Dracula", "levels": [10, 11, 12], "unlock_char": "dracula"},
	{"name": "Frankenstein", "levels": [13, 14, 15], "unlock_char": "frankenstein"},
	{"name": "Robin Hood", "levels": [16, 17, 18]},
	{"name": "Alice", "levels": [19, 20, 21]},
	{"name": "Wicked Witch", "levels": [22, 23, 24]},
	{"name": "Peter Pan", "levels": [25, 26, 27]},
	{"name": "Phantom", "levels": [28, 29, 30]},
	{"name": "Scrooge", "levels": [31, 32, 33]},
	{"name": "Shadow Author", "levels": [34, 35, 36], "icon": "skull"},
]

# Save version for migration
const SAVE_VERSION = 3
const OLD_TO_NEW_LEVEL_MAP = {0:16, 1:17, 2:18, 3:19, 4:20, 5:21, 6:22, 7:23, 8:24, 9:25, 10:26, 11:27, 12:28, 13:29, 14:30, 15:31, 16:32, 17:33}

func _ready() -> void:
	add_to_group("main")
	_is_mobile = OS.has_feature("mobile") or OS.has_feature("android") or OS.has_feature("ios")
	# Pre-generate random offsets for portrait drawing (fixes flickering in _draw)
	var rng_port = RandomNumberGenerator.new()
	rng_port.seed = 42
	for _i in range(8):
		_portrait_hem_offsets.append(rng_port.randf_range(-5, 5))
	for _i in range(12):
		_portrait_hair_offsets.append(rng_port.randf_range(5, 15))
	# Load Cinzel display font for all game text
	game_font = load("res://fonts/Cinzel.ttf")
	_init_survivor_progress()
	_init_emporium_items()
	_init_knowledge_tree()
	_init_equipped_relics()
	_init_synergy_definitions()
	_init_achievement_definitions()
	_init_battle_power_definitions()
	_init_trophy_store_items()
	_init_odyssey_maps()
	_init_story_dialogs()
	_build_binding_lookup()
	_init_quests()
	_init_shadow_arena()
	_load_game()
	_generate_daily_deals()
	_refresh_quests_if_needed()
	_cache_path_points()
	_cache_path_thumbnails()
	_generate_decorations_for_level(0)
	_create_ui()
	_apply_font_to_controls(self)
	_setup_audio()
	_show_menu()

# Ability unlock popup state
var _ability_popup_timer: float = 0.0
var _ability_popup_tower_type: int = -1
var _ability_popup_index: int = -1
var _ability_popup_name: String = ""
var _ability_popup_desc: String = ""
var _ability_popup_freeze: float = 0.0

# Ability thresholds (same for all characters)
const PROGRESSIVE_ABILITY_THRESHOLDS = [5000, 25000, 100000, 350000, 1000000, 3000000, 10000000, 35000000, 100000000]

# Spawn debuff flags (set by Crystal Ball / Beneath the Opera)
var spawn_hp_reduction: float = 0.0   # Crystal Ball: 0.15 = 15% less HP
var spawn_permanent_slow: float = 1.0 # Beneath the Opera: 0.7 = 30% slower

func _init_survivor_progress() -> void:
	# Init all tower types including unlockable ones
	var all_types = [TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH,
		TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE,
		TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA,
		TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR]
	for t in all_types:
		survivor_progress[t] = {
			"level": 1,
			"xp": 0.0,
			"xp_next": float(HERO_XP_TABLE[0]),
			"gear_unlocked": false,
			"sidekicks_unlocked": [false, false, false],
			"relics_unlocked": [false, false, false, false, false, false],
			"total_damage": 0.0,
			"abilities_unlocked": [false, false, false, false, false, false, false, false, false],
			"golden_shields": 0,
			"upgrade_branch": "",  # "" = not chosen, "A" or "B"
		}
		session_damage[t] = 0.0

func _get_xp_for_level(level: int) -> float:
	# Returns XP needed to go from 'level' to 'level+1'
	if level <= 0:
		return float(HERO_XP_TABLE[0])
	if level >= MAX_SURVIVOR_LEVEL:
		return float(HERO_XP_TABLE[HERO_XP_TABLE.size() - 1])  # Still accumulates but won't level up
	var idx = level - 1
	if idx < HERO_XP_TABLE.size():
		return float(HERO_XP_TABLE[idx])
	return float(HERO_XP_TABLE[HERO_XP_TABLE.size() - 1])

func _get_level_bonuses(tower_type) -> Dictionary:
	var level = survivor_progress.get(tower_type, {}).get("level", 1)
	var bonuses = {"damage": 0.0, "range": 0.0, "attack_speed": 0.0, "gold_bonus": 0.0, "crit": 0.0}
	var lvls = level - 1  # Bonuses start at level 2
	if lvls <= 0:
		return bonuses
	# Universal bonuses: +2% damage, +1.5% range, +1% attack speed per level
	bonuses["damage"] += lvls * 0.02
	bonuses["range"] += lvls * 0.015
	bonuses["attack_speed"] += lvls * 0.01
	# Role-specific extras per level
	match tower_type:
		TowerType.ROBIN_HOOD:
			bonuses["range"] += lvls * 0.015
		TowerType.ALICE:
			bonuses["range"] += lvls * 0.01  # AoE radius mapped to range
		TowerType.WICKED_WITCH:
			bonuses["damage"] += lvls * 0.015
		TowerType.PETER_PAN:
			bonuses["attack_speed"] += lvls * 0.015
		TowerType.PHANTOM:
			bonuses["damage"] += lvls * 0.01
			bonuses["range"] += lvls * 0.005
		TowerType.SCROOGE:
			bonuses["gold_bonus"] += lvls * 0.015
		TowerType.SHERLOCK:
			bonuses["damage"] += lvls * 0.01
			bonuses["crit"] += lvls * 0.005
		TowerType.TARZAN:
			bonuses["damage"] += lvls * 0.02
		TowerType.DRACULA:
			bonuses["damage"] += lvls * 0.01
		TowerType.MERLIN:
			bonuses["range"] += lvls * 0.015
		TowerType.FRANKENSTEIN:
			bonuses["damage"] += lvls * 0.02
		TowerType.SHADOW_AUTHOR:
			bonuses["damage"] += lvls * 0.015
			bonuses["range"] += lvls * 0.01
	# Milestone bonuses
	if level >= 5:
		bonuses["damage"] += 0.05
	if level >= 15:
		bonuses["damage"] += 0.10
		bonuses["range"] += 0.10
		bonuses["attack_speed"] += 0.10
	return bonuses

func _get_relic_bonuses(tower_type) -> Dictionary:
	var bonuses: Dictionary = {}
	var effects = get_equipped_relic_effects(tower_type)
	for relic in effects:
		var eff = relic.get("effect", "")
		var val = relic.get("value", 0.0)
		match eff:
			"pierce_damage", "spell_damage":
				bonuses["damage"] = bonuses.get("damage", 0.0) + val
			"range":
				bonuses["range"] = bonuses.get("range", 0.0) + val
			"atk_speed_aura":
				bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
			"bonus_gold":
				bonuses["gold_bonus"] = bonuses.get("gold_bonus", 0.0) + val
			"crit_chance":
				bonuses["crit"] = bonuses.get("crit", 0.0) + val
			"cooldown":
				bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
			_:
				bonuses[eff] = bonuses.get(eff, 0.0) + val
	return bonuses

func _get_gear_bonuses(tower_type) -> Dictionary:
	var bonuses: Dictionary = {}
	if not survivor_progress.has(tower_type):
		return bonuses
	if not survivor_progress[tower_type].get("gear_unlocked", false):
		return bonuses
	# Each tower's gear provides a thematic stat boost
	match tower_type:
		TowerType.ROBIN_HOOD:
			bonuses["range"] = 0.15
			bonuses["damage"] = 0.05
		TowerType.ALICE:
			bonuses["range"] = 0.10
			bonuses["damage"] = 0.10
		TowerType.WICKED_WITCH:
			bonuses["attack_speed"] = 0.12
			bonuses["damage"] = 0.05
		TowerType.PETER_PAN:
			bonuses["damage"] = 0.15
			bonuses["attack_speed"] = 0.05
		TowerType.PHANTOM:
			bonuses["range"] = 0.10
			bonuses["attack_speed"] = 0.08
		TowerType.SCROOGE:
			bonuses["gold_bonus"] = 0.20
		TowerType.SHERLOCK:
			bonuses["damage"] = 0.12
			bonuses["range"] = 0.08
		TowerType.TARZAN:
			bonuses["range"] = 0.15
			bonuses["attack_speed"] = 0.08
		TowerType.DRACULA:
			bonuses["damage"] = 0.10
			bonuses["range"] = 0.10
		TowerType.MERLIN:
			bonuses["range"] = 0.12
			bonuses["damage"] = 0.08
		TowerType.FRANKENSTEIN:
			bonuses["damage"] = 0.12
			bonuses["attack_speed"] = 0.08
		TowerType.SHADOW_AUTHOR:
			bonuses["damage"] = 0.15
			bonuses["range"] = 0.10
	return bonuses

func _get_sidekick_bonuses(tower_type) -> Dictionary:
	var bonuses: Dictionary = {}
	if not survivor_progress.has(tower_type):
		return bonuses
	var sk_unlocked = survivor_progress[tower_type].get("sidekicks_unlocked", [false, false, false])
	# Each unlocked sidekick gives a small passive bonus
	if sk_unlocked.size() > 0 and sk_unlocked[0]:
		bonuses["damage"] = bonuses.get("damage", 0.0) + 0.05
	if sk_unlocked.size() > 1 and sk_unlocked[1]:
		bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + 0.05
	if sk_unlocked.size() > 2 and sk_unlocked[2]:
		bonuses["gold_bonus"] = bonuses.get("gold_bonus", 0.0) + 0.10
	return bonuses

func _apply_meta_buffs(tower_node, tower_type) -> void:
	var buffs: Dictionary = {}
	# 0) Prestige bonus: +5% global damage per prestige level
	if prestige_level > 0:
		buffs["damage"] = buffs.get("damage", 0.0) + prestige_level * 0.05
	# 0b) BATTD: Character Home Bonus (+10% all stats when on own chapter)
	if current_level >= 0 and current_level < levels.size():
		var lvl_char = levels[current_level].get("character", -1)
		if lvl_char == tower_type:
			for hk in ["damage", "range", "attack_speed", "crit"]:
				buffs[hk] = buffs.get(hk, 0.0) + HOME_CHAPTER_BONUS
	# 0c) BATTD2: Character Bond bonus (+8% when paired character nearby)
	for bond in _active_bonds:
		if tower_type in bond["pair"]:
			for bk in ["damage", "attack_speed"]:
				buffs[bk] = buffs.get(bk, 0.0) + bond["bonus"]
	# 0d) BATTD2: Blessing bonus (temporary team buff)
	if _blessing_active and _blessing_type != "":
		buffs[_blessing_type] = buffs.get(_blessing_type, 0.0) + 0.25
	# 0e) BATTD2: Victory Streak XP/damage bonus
	if victory_streak >= 2:
		buffs["damage"] = buffs.get("damage", 0.0) + float(victory_streak) * STREAK_GOLD_BONUS
	# 1) Level bonuses
	var lvl_b = _get_level_bonuses(tower_type)
	for k in lvl_b:
		buffs[k] = buffs.get(k, 0.0) + lvl_b[k]
	# 2) Knowledge bonuses (global, all towers benefit) — disabled in Pure Mode
	if selected_difficulty != PURE_MODE:
		for stat_key in ["damage", "range", "attack_speed", "crit"]:
			var kb = _get_knowledge_bonus(stat_key)
			if kb > 0.0:
				buffs[stat_key] = buffs.get(stat_key, 0.0) + kb
	# 3) Relic bonuses (per-character)
	var rel_b = _get_relic_bonuses(tower_type)
	for k in rel_b:
		buffs[k] = buffs.get(k, 0.0) + rel_b[k]
	# 4) Tome Binding bonuses
	var bind_b = _get_binding_bonuses(tower_type)
	for k in bind_b:
		buffs[k] = buffs.get(k, 0.0) + bind_b[k]
	# 4b) Survivor level stat boosts
	var level_b = _get_level_stat_boosts(tower_type)
	for k in level_b:
		if level_b[k] != 0.0:
			buffs[k] = buffs.get(k, 0.0) + level_b[k]
	# 4c) Per-level gear scaling (mythic/forbidden gear scale with survivor level)
	var slvl = survivor_progress.get(tower_type, {}).get("level", 1)
	if slvl > 1:
		var eq_binds = equipped_bindings.get(tower_type, [])
		for bid in eq_binds:
			var bdata = _find_binding(bid)
			if bdata.has("per_level"):
				var pl_bonus = bdata["per_level"] * float(slvl - 1)
				if bdata.has("effects"):
					for fx in bdata["effects"]:
						var eff = fx.get("effect", "")
						if eff == "all":
							for ak in ["damage", "range", "attack_speed", "crit"]:
								buffs[ak] = buffs.get(ak, 0.0) + pl_bonus
						elif eff != "":
							buffs[eff] = buffs.get(eff, 0.0) + pl_bonus
	# 5) Literary Instrument aura bonuses
	if tower_node and is_instance_valid(tower_node):
		var inst_b = _get_instrument_buffs_at(tower_node.global_position)
		for k in inst_b:
			buffs[k] = buffs.get(k, 0.0) + inst_b[k]
	# 6) Branch upgrade bonuses (read from tower metadata)
	if tower_node and is_instance_valid(tower_node) and tower_node.has_meta("branch_upgrades"):
		var branch_ups = tower_node.get_meta("branch_upgrades")
		for bu in branch_ups:
			var eff = bu.get("effect", "")
			var val = bu.get("value", 0.0)
			# Map branch effects to stat keys the tower scripts read
			match eff:
				"damage", "crit", "crit_damage", "slow", "gold_bonus", "range", "attack_speed":
					buffs[eff] = buffs.get(eff, 0.0) + val
				"pierce_damage", "shrink_damage", "mark_damage", "ramp_damage":
					buffs["damage"] = buffs.get("damage", 0.0) + val
				"early_damage":
					buffs["damage"] = buffs.get("damage", 0.0) + val * 0.5
				"multi_shot":
					buffs["damage"] = buffs.get("damage", 0.0) + (val - 1.0) * 0.5
				"aoe_radius":
					buffs["range"] = buffs.get("range", 0.0) + val * 0.5
				"gold_on_hit", "passive_gold", "global_gold":
					buffs["gold_bonus"] = buffs.get("gold_bonus", 0.0) + val
				"attack_speed_aura":
					buffs["attack_speed"] = buffs.get("attack_speed", 0.0) + val
				"global_range":
					buffs["range"] = buffs.get("range", 0.0) + val
				"chain_count":
					buffs["damage"] = buffs.get("damage", 0.0) + val * 0.08
				"execute":
					buffs["damage"] = buffs.get("damage", 0.0) + 0.15
				_:
					# Complex effects (tornado, stampede, etc.) stored for future use
					buffs[eff] = buffs.get(eff, 0.0) + val
	# 7) Gear bonuses (if gear unlocked for this character)
	var gear_b = _get_gear_bonuses(tower_type)
	for k in gear_b:
		buffs[k] = buffs.get(k, 0.0) + gear_b[k]
	# 8) Sidekick bonuses (for each unlocked sidekick)
	var side_b = _get_sidekick_bonuses(tower_type)
	for k in side_b:
		buffs[k] = buffs.get(k, 0.0) + side_b[k]
	# Apply to tower
	if tower_node.has_method("set_meta_buffs"):
		tower_node.set_meta_buffs(buffs)

# Map character string ID to TowerType
var character_id_to_tower_type: Dictionary = {
	"sherlock": TowerType.SHERLOCK,
	"tarzan": TowerType.TARZAN,
	"dracula": TowerType.DRACULA,
	"merlin": TowerType.MERLIN,
	"frankenstein": TowerType.FRANKENSTEIN,
	"shadow_author": TowerType.SHADOW_AUTHOR,
}

# Map TowerType to scene path for new characters (loaded at runtime)
var new_tower_scene_paths: Dictionary = {
	TowerType.SHERLOCK: "res://scenes/sherlock.tscn",
	TowerType.TARZAN: "res://scenes/tarzan.tscn",
	TowerType.DRACULA: "res://scenes/dracula.tscn",
	TowerType.MERLIN: "res://scenes/merlin.tscn",
	TowerType.FRANKENSTEIN: "res://scenes/frankenstein.tscn",
	TowerType.SHADOW_AUTHOR: "res://scenes/shadow_author.tscn",
}

func _refresh_unlocked_survivors() -> void:
	# Ensure unlocked characters have their scenes loaded
	for char_id in unlocked_characters:
		if not character_id_to_tower_type.has(char_id):
			continue
		var tt = character_id_to_tower_type[char_id]
		# Load scene if not already in tower_scenes
		if not tower_scenes.has(tt) and new_tower_scene_paths.has(tt):
			var path = new_tower_scene_paths[tt]
			if ResourceLoader.exists(path):
				tower_scenes[tt] = load(path)

func _is_character_unlocked(tower_type) -> bool:
	if tower_type in [TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH,
					  TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE]:
		return true
	var id_map = {
		TowerType.SHERLOCK: "sherlock", TowerType.MERLIN: "merlin",
		TowerType.TARZAN: "tarzan", TowerType.DRACULA: "dracula",
		TowerType.FRANKENSTEIN: "frankenstein", TowerType.SHADOW_AUTHOR: "shadow_author"
	}
	return id_map.get(tower_type, "") in unlocked_characters

func _init_emporium_items() -> void:
	emporium_items = {
		0: [  # Gold Exchange (gold → other currencies)
			{"name": "Quill Pouch", "desc": "Trade gold for writing tools", "cost": 50, "currency": "gold", "reward": "quills", "amount": 3},
			{"name": "Quill Bundle", "desc": "A scholar's supply of quills", "cost": 150, "currency": "gold", "reward": "quills", "amount": 10},
			{"name": "Shard Fragments", "desc": "Convert gold to crystal shards", "cost": 100, "currency": "gold", "reward": "shards", "amount": 15},
			{"name": "Storybook Star", "desc": "A star forged from golden ink", "cost": 200, "currency": "gold", "reward": "stars", "amount": 1},
		],
		1: [  # Enchanted Quills (shards → quills)
			{"name": "Ink & Quill", "desc": "A basic writing set", "cost": 15, "currency": "shards", "reward": "quills", "amount": 3},
			{"name": "Scribe's Bundle", "desc": "A scholar's collection", "cost": 40, "currency": "shards", "reward": "quills", "amount": 10},
			{"name": "Arcane Library", "desc": "Ancient enchanted tomes", "cost": 80, "currency": "shards", "reward": "quills", "amount": 25},
		],
		2: [  # Relic Shards (stars → shards)
			{"name": "Shard Fragment", "desc": "Glowing crystal piece", "cost": 1, "currency": "stars", "reward": "shards", "amount": 20},
			{"name": "Shard Cluster", "desc": "A cluster of raw shards", "cost": 2, "currency": "stars", "reward": "shards", "amount": 50},
			{"name": "Prismatic Core", "desc": "Pure crystallized energy", "cost": 4, "currency": "stars", "reward": "shards", "amount": 120},
		],
		3: [  # Relic Chests
			{"name": "Bronze Chest", "desc": "Common treasures within", "cost": 10, "currency": "shards", "reward": "chest_bronze", "amount": 1},
			{"name": "Silver Chest", "desc": "Uncommon relics await", "cost": 30, "currency": "shards", "reward": "chest_silver", "amount": 1},
			{"name": "Gold Chest", "desc": "Legendary artifacts inside", "cost": 80, "currency": "shards", "reward": "chest_gold", "amount": 1},
		],
		4: [  # Survivor Packs (stars → XP)
			{"name": "Training Scroll", "desc": "Basic combat lessons", "cost": 1, "currency": "stars", "reward": "xp", "amount": 500},
			{"name": "Battle Manual", "desc": "Advanced techniques", "cost": 2, "currency": "stars", "reward": "xp", "amount": 1500},
			{"name": "War Chronicle", "desc": "Legendary battle wisdom", "cost": 4, "currency": "stars", "reward": "xp", "amount": 4000},
		],
		5: [  # Storybook Stars (quills → stars)
			{"name": "Fallen Star", "desc": "A faint glimmer of magic", "cost": 15, "currency": "quills", "reward": "stars", "amount": 1},
			{"name": "Star Cluster", "desc": "A constellation captured", "cost": 35, "currency": "quills", "reward": "stars", "amount": 3},
			{"name": "Celestial Nova", "desc": "Pure starlight essence", "cost": 60, "currency": "quills", "reward": "stars", "amount": 6},
		],
		7: [  # Battle Powers (shards → powers)
			{"name": "Quill Strike", "desc": "500 damage to all on-screen enemies", "cost": 15, "currency": "shards", "reward": "power", "power_id": "quill_strike", "amount": 1},
			{"name": "Golden Bounty", "desc": "+200 gold instantly", "cost": 10, "currency": "shards", "reward": "power", "power_id": "golden_bounty", "amount": 1},
			{"name": "Storybook Shield", "desc": "Blocks next 10 life losses", "cost": 20, "currency": "shards", "reward": "power", "power_id": "storybook_shield", "amount": 1},
			{"name": "Ink Freeze", "desc": "Freeze all enemies 5 seconds", "cost": 18, "currency": "shards", "reward": "power", "power_id": "ink_freeze", "amount": 1},
			{"name": "Chapter Skip", "desc": "Instantly completes current wave", "cost": 25, "currency": "shards", "reward": "power", "power_id": "chapter_skip", "amount": 1},
			{"name": "Enchanted Towers", "desc": "All towers +50% damage for 15s", "cost": 22, "currency": "shards", "reward": "power", "power_id": "enchanted_towers", "amount": 1},
		],
	}

func _init_knowledge_tree() -> void:
	knowledge_branches = [
		{
			"name": "Heroic Tales",
			"desc": "Offense",
			"color": Color(0.85, 0.3, 0.2),
			"nodes": [
				{"name": "Sharp Blades", "desc": "+5% tower damage", "effect": "damage", "value": 0.05, "cost": 1},
				{"name": "Eagle Eye", "desc": "+8% tower range", "effect": "range", "value": 0.08, "cost": 1},
				{"name": "Swift Strikes", "desc": "+10% attack speed", "effect": "attack_speed", "value": 0.10, "cost": 2},
				{"name": "Critical Lore", "desc": "+5% crit chance", "effect": "crit", "value": 0.05, "cost": 2},
				{"name": "Legendary Might", "desc": "+15% tower damage", "effect": "damage", "value": 0.15, "cost": 3},
				{"name": "Piercing Words", "desc": "+8% pierce damage", "effect": "damage", "value": 0.08, "cost": 3},
				{"name": "Battle Fury", "desc": "+5% attack speed", "effect": "attack_speed", "value": 0.05, "cost": 4},
				{"name": "Ruthless Prose", "desc": "+8% crit damage", "effect": "crit", "value": 0.08, "cost": 4},
				{"name": "Author's Wrath", "desc": "+10% boss damage", "effect": "damage", "value": 0.10, "cost": 5},
			],
		},
		{
			"name": "Enchanted Pages",
			"desc": "Defense",
			"color": Color(0.3, 0.6, 0.85),
			"nodes": [
				{"name": "Thick Covers", "desc": "+2 starting lives", "effect": "lives", "value": 2, "cost": 1},
				{"name": "Golden Bookmark", "desc": "+25 starting gold", "effect": "start_gold", "value": 25, "cost": 1},
				{"name": "Bargain Ink", "desc": "-5% tower cost", "effect": "tower_discount", "value": 0.05, "cost": 2},
				{"name": "Bound in Iron", "desc": "+3 starting lives", "effect": "lives", "value": 3, "cost": 2},
				{"name": "Master Binding", "desc": "-10% tower cost", "effect": "tower_discount", "value": 0.10, "cost": 3},
				{"name": "Iron Spine", "desc": "+5 starting lives", "effect": "lives", "value": 5, "cost": 3},
				{"name": "Gilded Pages", "desc": "+50 starting gold", "effect": "start_gold", "value": 50, "cost": 4},
				{"name": "Bulk Bargain", "desc": "-5% upgrade cost", "effect": "upgrade_discount", "value": 0.05, "cost": 4},
				{"name": "Impenetrable Tome", "desc": "+1 life regen/wave", "effect": "life_regen", "value": 1, "cost": 5},
			],
		},
		{
			"name": "Lost Chapters",
			"desc": "Meta",
			"color": Color(0.6, 0.45, 0.8),
			"nodes": [
				{"name": "Quick Study", "desc": "+10% XP gain", "effect": "xp_gain", "value": 0.10, "cost": 1},
				{"name": "Lucky Find", "desc": "+15% chest loot", "effect": "chest_loot", "value": 0.15, "cost": 1},
				{"name": "Merchant's Eye", "desc": "+10% currency earn", "effect": "currency_earn", "value": 0.10, "cost": 2},
				{"name": "Deep Reading", "desc": "+20% XP gain", "effect": "xp_gain", "value": 0.20, "cost": 2},
				{"name": "Treasure Hunter", "desc": "+25% chest loot", "effect": "chest_loot", "value": 0.25, "cost": 3},
				{"name": "Speed Reading", "desc": "+15% XP gain", "effect": "xp_gain", "value": 0.15, "cost": 3},
				{"name": "Collector's Eye", "desc": "+15% currency earn", "effect": "currency_earn", "value": 0.15, "cost": 4},
				{"name": "Double Down", "desc": "+20% chest loot", "effect": "chest_loot", "value": 0.20, "cost": 4},
				{"name": "Inkwell Overflow", "desc": "+1 bonus Ink/5 lvls", "effect": "bonus_ink", "value": 1, "cost": 5},
			],
		},
		{
			"name": "Character Bonds",
			"desc": "Synergies",
			"color": Color(0.85, 0.65, 0.2),
			"nodes": [
				{"name": "Fellowship", "desc": "+5% synergy damage", "effect": "synergy_damage", "value": 0.05, "cost": 1},
				{"name": "Common Ground", "desc": "+3% synergy range", "effect": "synergy_range", "value": 0.03, "cost": 1},
				{"name": "Shared Stories", "desc": "Synergies +15%", "effect": "synergy_power", "value": 0.15, "cost": 2},
				{"name": "Bound by Ink", "desc": "+1 relic slot", "effect": "bonus_relic_slot", "value": 1, "cost": 2},
				{"name": "Literary Alliance", "desc": "Synergies +25%", "effect": "synergy_power", "value": 0.25, "cost": 3},
				{"name": "Heroic Assembly", "desc": "+10% dmg w/ 3+ towers", "effect": "army_damage", "value": 0.10, "cost": 3},
				{"name": "Sidekick Synergy", "desc": "Sidekicks +15%", "effect": "sidekick_power", "value": 0.15, "cost": 4},
				{"name": "Epic Crossover", "desc": "Cross-char relic equip", "effect": "cross_equip", "value": 1, "cost": 4},
				{"name": "Legend of the Tome", "desc": "+20% all w/ full team", "effect": "full_team_bonus", "value": 0.20, "cost": 5},
			],
		},
		{
			"name": "Dark Passages",
			"desc": "Enemy Debuffs",
			"color": Color(0.3, 0.55, 0.35),
			"nodes": [
				{"name": "Weakened Binding", "desc": "Enemies -3% HP", "effect": "enemy_hp_reduce", "value": 0.03, "cost": 1},
				{"name": "Slow Ink", "desc": "Enemies 3% slower", "effect": "enemy_slow", "value": 0.03, "cost": 1},
				{"name": "Paper Cuts", "desc": "1 dmg/sec bleed", "effect": "enemy_bleed", "value": 1.0, "cost": 2},
				{"name": "Fading Pages", "desc": "Enemies -5% armor", "effect": "enemy_armor_reduce", "value": 0.05, "cost": 2},
				{"name": "Rewrite the Script", "desc": "Bosses -5% HP", "effect": "boss_hp_reduce", "value": 0.05, "cost": 3},
				{"name": "Smudged Letters", "desc": "Enemies -5% HP", "effect": "enemy_hp_reduce", "value": 0.05, "cost": 3},
				{"name": "Torn Pages", "desc": "Enemies 5% slower", "effect": "enemy_slow", "value": 0.05, "cost": 4},
				{"name": "Erased Villains", "desc": "5% half HP spawn", "effect": "enemy_half_hp", "value": 0.05, "cost": 4},
				{"name": "Author's Edit", "desc": "Bosses -10% HP", "effect": "boss_hp_reduce", "value": 0.10, "cost": 5},
			],
		},
	]
	# Initialize knowledge_tree dict — ensure all branch/node keys exist
	for bi in range(knowledge_branches.size()):
		for ni in range(knowledge_branches[bi]["nodes"].size()):
			var key = "%d_%d" % [bi, ni]
			if not knowledge_tree.has(key):
				knowledge_tree[key] = false

func _init_equipped_relics() -> void:
	for t in survivor_types:
		if not equipped_relics.has(t):
			equipped_relics[t] = []

func _init_synergy_definitions() -> void:
	synergy_definitions = [
		{"name": "Merry Mischief", "tower_a": TowerType.ROBIN_HOOD, "tower_b": TowerType.PETER_PAN,
		 "buffs": {"damage": 0.15}, "desc": "Forest outlaws — +15% damage"},
		{"name": "Dark Enchantment", "tower_a": TowerType.WICKED_WITCH, "tower_b": TowerType.PHANTOM,
		 "buffs": {"range": 0.20}, "desc": "Dark magic amplifies — +20% range"},
		{"name": "Holiday Spirit", "tower_a": TowerType.SCROOGE, "tower_b": TowerType.ALICE,
		 "buffs": {"attack_speed": 0.15}, "desc": "Generosity meets wonder — +15% attack speed"},
		{"name": "Shadow Pact", "tower_a": TowerType.PHANTOM, "tower_b": TowerType.PETER_PAN,
		 "buffs": {"damage": 0.10, "range": 0.10}, "desc": "Shadow & the boy who won't grow up — +10% damage, +10% range"},
		{"name": "Cunning & Chaos", "tower_a": TowerType.ROBIN_HOOD, "tower_b": TowerType.WICKED_WITCH,
		 "buffs": {"gold_bonus": 0.25}, "desc": "Stealing meets hexing — +25% gold bonus"},
		{"name": "Storybook Alliance", "tower_a": TowerType.ALICE, "tower_b": TowerType.SCROOGE,
		 "buffs": {"attack_speed": 0.20}, "desc": "Imagination meets ambition — +20% attack speed"},
		# New character synergies
		{"name": "The Great Game", "tower_a": TowerType.SHERLOCK, "tower_b": TowerType.ROBIN_HOOD,
		 "buffs": {"damage": 0.20}, "desc": "Detective precision meets outlaw aim — +20% damage"},
		{"name": "Lords of the Wild", "tower_a": TowerType.TARZAN, "tower_b": TowerType.PETER_PAN,
		 "buffs": {"attack_speed": 0.20}, "desc": "Jungle king meets the boy who never grew up — +20% speed"},
		{"name": "Children of Darkness", "tower_a": TowerType.DRACULA, "tower_b": TowerType.PHANTOM,
		 "buffs": {"damage": 0.15, "range": 0.15}, "desc": "Two creatures of the night — +15% damage & range"},
		{"name": "Arcane Alliance", "tower_a": TowerType.MERLIN, "tower_b": TowerType.WICKED_WITCH,
		 "buffs": {"range": 0.25}, "desc": "Old magic amplifies green magic — +25% range"},
		{"name": "Tragic Souls", "tower_a": TowerType.FRANKENSTEIN, "tower_b": TowerType.SCROOGE,
		 "buffs": {"gold_bonus": 0.30}, "desc": "Redemption meets creation — +30% gold bonus"},
		{"name": "Deductive Darkness", "tower_a": TowerType.SHERLOCK, "tower_b": TowerType.DRACULA,
		 "buffs": {"damage": 0.15, "attack_speed": 0.10}, "desc": "Brilliant minds, dark methods — +15% damage, +10% speed"},
	]

func _init_achievement_definitions() -> void:
	achievement_definitions = [
		# Combat (8)
		{"id": "first_blood", "name": "First Blood", "desc": "Kill your first enemy", "category": "Combat", "target": 1, "reward_type": "shards", "reward_amount": 5},
		{"id": "centurion", "name": "Centurion", "desc": "Kill 100 enemies", "category": "Combat", "target": 100, "reward_type": "shards", "reward_amount": 20},
		{"id": "thousand_slayer", "name": "Thousand Slayer", "desc": "Kill 1000 enemies", "category": "Combat", "target": 1000, "reward_type": "quills", "reward_amount": 10, "trophy_bonus": 5},
		{"id": "untouchable", "name": "Untouchable", "desc": "Complete a level with 0 lives lost", "category": "Combat", "target": 1, "reward_type": "quills", "reward_amount": 5},
		{"id": "speed_demon", "name": "Speed Demon", "desc": "Complete a level entirely on fast-forward", "category": "Combat", "target": 1, "reward_type": "shards", "reward_amount": 15},
		{"id": "wave_master", "name": "Wave Master", "desc": "Complete 50 total waves", "category": "Combat", "target": 50, "reward_type": "shards", "reward_amount": 25},
		{"id": "flawless", "name": "Flawless Victory", "desc": "Earn 3 stars on any level", "category": "Combat", "target": 1, "reward_type": "quills", "reward_amount": 5},
		{"id": "perfect_campaign", "name": "Perfect Campaign", "desc": "Earn 3 stars on all 37 levels", "category": "Combat", "target": 37, "reward_type": "stars", "reward_amount": 5, "trophy_bonus": 15},
		# Tower (6)
		{"id": "novice_builder", "name": "Novice Builder", "desc": "Place 10 towers total", "category": "Tower", "target": 10, "reward_type": "shards", "reward_amount": 10},
		{"id": "master_builder", "name": "Master Builder", "desc": "Place 100 towers total", "category": "Tower", "target": 100, "reward_type": "quills", "reward_amount": 8},
		{"id": "max_power", "name": "Max Power", "desc": "Fully upgrade a tower (tier 4)", "category": "Tower", "target": 1, "reward_type": "shards", "reward_amount": 20},
		{"id": "full_roster", "name": "Full Roster", "desc": "Place all 6 tower types in one game", "category": "Tower", "target": 6, "reward_type": "quills", "reward_amount": 5},
		{"id": "synergy_seeker", "name": "Synergy Seeker", "desc": "Activate 1 tower synergy", "category": "Tower", "target": 1, "reward_type": "shards", "reward_amount": 15},
		{"id": "synergy_master", "name": "Synergy Master", "desc": "Activate all 6 synergies (across games)", "category": "Tower", "target": 6, "reward_type": "stars", "reward_amount": 3, "trophy_bonus": 10},
		# Economy (5)
		{"id": "penny_pincher", "name": "Penny Pincher", "desc": "Earn 500 gold total", "category": "Economy", "target": 500, "reward_type": "shards", "reward_amount": 10},
		{"id": "big_spender", "name": "Big Spender", "desc": "Spend 2000 gold total", "category": "Economy", "target": 2000, "reward_type": "quills", "reward_amount": 5},
		{"id": "emporium_regular", "name": "Emporium Regular", "desc": "Make 10 Emporium purchases", "category": "Economy", "target": 10, "reward_type": "shards", "reward_amount": 20},
		{"id": "chest_collector", "name": "Chest Collector", "desc": "Open 20 treasure chests", "category": "Economy", "target": 20, "reward_type": "quills", "reward_amount": 8},
		{"id": "knowledge_scholar", "name": "Knowledge Scholar", "desc": "Unlock 10 knowledge nodes", "category": "Economy", "target": 10, "reward_type": "stars", "reward_amount": 2},
		# Progression (6)
		{"id": "first_steps", "name": "First Steps", "desc": "Complete your first level", "category": "Progression", "target": 1, "reward_type": "shards", "reward_amount": 10},
		{"id": "halfway_there", "name": "Halfway There", "desc": "Complete 18 levels", "category": "Progression", "target": 18, "reward_type": "quills", "reward_amount": 10},
		{"id": "campaign_complete", "name": "Campaign Complete", "desc": "Complete all 37 levels", "category": "Progression", "target": 37, "reward_type": "stars", "reward_amount": 5, "trophy_bonus": 10},
		{"id": "veteran_survivor", "name": "Veteran Survivor", "desc": "Get any character to level 5", "category": "Progression", "target": 5, "reward_type": "shards", "reward_amount": 30},
		{"id": "master_survivor", "name": "Master Survivor", "desc": "Get any character to level 10", "category": "Progression", "target": 10, "reward_type": "quills", "reward_amount": 15, "trophy_bonus": 5},
		{"id": "daily_devotee", "name": "Daily Devotee", "desc": "Claim 7 daily rewards", "category": "Progression", "target": 7, "reward_type": "stars", "reward_amount": 2},
	]
	for ach in achievement_definitions:
		if not achievement_progress.has(ach["id"]):
			achievement_progress[ach["id"]] = 0
		if not achievements_unlocked.has(ach["id"]):
			achievements_unlocked[ach["id"]] = false

func _init_battle_power_definitions() -> void:
	battle_power_definitions = [
		{"id": "quill_strike", "name": "Quill Strike", "desc": "500 damage to all on-screen enemies", "icon": "quill", "cost_shards": 15},
		{"id": "golden_bounty", "name": "Golden Bounty", "desc": "+200 gold instantly", "icon": "gold", "cost_shards": 10},
		{"id": "storybook_shield", "name": "Storybook Shield", "desc": "Blocks next 10 life losses", "icon": "shield", "cost_shards": 25},
		{"id": "ink_freeze", "name": "Ink Freeze", "desc": "Freeze all enemies for 5 seconds", "icon": "ink", "cost_shards": 20},
		{"id": "chapter_skip", "name": "Chapter Skip", "desc": "Instantly completes current wave", "icon": "skip", "cost_shards": 30},
		{"id": "enchanted_towers", "name": "Enchanted Towers", "desc": "All towers +50% damage for 15s", "icon": "enchant", "cost_shards": 20},
	]
	for bp in battle_power_definitions:
		if not owned_powers.has(bp["id"]):
			owned_powers[bp["id"]] = 0

func _init_trophy_store_items() -> void:
	trophy_store_items = {
		"auras": [
			{"id": "aura_emerald", "name": "Emerald Aura", "desc": "Green glow ring around tower", "cost": 5, "color": Color(0.2, 0.9, 0.3, 0.3)},
			{"id": "aura_crimson", "name": "Crimson Aura", "desc": "Red glow ring around tower", "cost": 8, "color": Color(0.9, 0.2, 0.2, 0.3)},
			{"id": "aura_sapphire", "name": "Sapphire Aura", "desc": "Blue glow ring around tower", "cost": 8, "color": Color(0.2, 0.4, 0.95, 0.3)},
			{"id": "aura_golden", "name": "Golden Aura", "desc": "Gold glow ring around tower", "cost": 10, "color": Color(0.95, 0.8, 0.2, 0.3)},
			{"id": "aura_shadow", "name": "Shadow Aura", "desc": "Dark purple glow ring around tower", "cost": 12, "color": Color(0.5, 0.1, 0.8, 0.3)},
			{"id": "aura_prismatic", "name": "Prismatic Aura", "desc": "Rainbow shifting glow ring", "cost": 15, "color": Color(1, 1, 1, 0.3)},
		],
		"trails": [
			{"id": "trail_ink", "name": "Ink Splash", "desc": "Dark ink trail on projectiles", "cost": 10, "color": Color(0.1, 0.1, 0.2)},
			{"id": "trail_stardust", "name": "Stardust", "desc": "Sparkling star trail", "cost": 12, "color": Color(1.0, 0.9, 0.5)},
			{"id": "trail_fire", "name": "Fire Trail", "desc": "Fiery orange trail", "cost": 15, "color": Color(1.0, 0.4, 0.1)},
			{"id": "trail_frost", "name": "Frost Wake", "desc": "Icy blue trail", "cost": 20, "color": Color(0.5, 0.8, 1.0)},
		],
		"fanfares": [
			{"id": "fanfare_confetti", "name": "Confetti Burst", "desc": "Confetti on victory screen", "cost": 15},
			{"id": "fanfare_fireworks", "name": "Fireworks", "desc": "Fireworks on victory screen", "cost": 20},
			{"id": "fanfare_ovation", "name": "Standing Ovation", "desc": "Crowd applause on victory", "cost": 25},
		],
		"themes": [
			{"id": "theme_midnight", "name": "Midnight Library", "desc": "Deep blue menu theme", "cost": 20, "bg": Color(0.02, 0.02, 0.08), "accent": Color(0.4, 0.5, 0.9)},
			{"id": "theme_garden", "name": "Enchanted Garden", "desc": "Green & gold menu theme", "cost": 25, "bg": Color(0.03, 0.06, 0.03), "accent": Color(0.4, 0.8, 0.3)},
			{"id": "theme_crimson", "name": "Crimson Study", "desc": "Red & gold menu theme", "cost": 30, "bg": Color(0.08, 0.02, 0.02), "accent": Color(0.9, 0.3, 0.2)},
		],
	}

func _init_odyssey_maps() -> void:
	# Generate 3 maps based on current week number
	var week_seed = int(Time.get_unix_time_from_system() / 604800)
	var rng = RandomNumberGenerator.new()
	rng.seed = week_seed
	odyssey_maps.clear()
	var available = range(levels.size())
	for i in range(3):
		var idx = rng.randi_range(0, available.size() - 1)
		odyssey_maps.append(available[idx])
		available.remove_at(idx)

# === TOWER SYNERGY SYSTEM ===
func _check_synergies() -> void:
	var placed_types: Dictionary = {}
	var tower_nodes: Dictionary = {}
	var script_to_type = {
		"robin_hood.gd": TowerType.ROBIN_HOOD,
		"alice.gd": TowerType.ALICE,
		"wicked_witch.gd": TowerType.WICKED_WITCH,
		"peter_pan.gd": TowerType.PETER_PAN,
		"phantom.gd": TowerType.PHANTOM,
		"scrooge.gd": TowerType.SCROOGE,
		"sherlock.gd": TowerType.SHERLOCK,
		"tarzan.gd": TowerType.TARZAN,
		"dracula.gd": TowerType.DRACULA,
		"merlin.gd": TowerType.MERLIN,
		"frankenstein.gd": TowerType.FRANKENSTEIN,
		"shadow_author.gd": TowerType.SHADOW_AUTHOR,
	}
	for tower in get_tree().get_nodes_in_group("towers"):
		var fname = tower.get_script().resource_path.get_file() if tower.get_script() else ""
		if script_to_type.has(fname):
			var tt = script_to_type[fname]
			placed_types[tt] = true
			tower_nodes[tt] = tower
	# Clear existing synergy buffs from all towers
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.has_method("clear_synergy_buff"):
			tower.clear_synergy_buff()
	var old_synergies = active_synergies.duplicate()
	active_synergies.clear()
	for syn in synergy_definitions:
		if placed_types.has(syn["tower_a"]) and placed_types.has(syn["tower_b"]):
			active_synergies.append(syn["name"])
			# Apply buffs to both towers
			if tower_nodes.has(syn["tower_a"]) and tower_nodes[syn["tower_a"]].has_method("set_synergy_buff"):
				tower_nodes[syn["tower_a"]].set_synergy_buff(syn["buffs"])
			if tower_nodes.has(syn["tower_b"]) and tower_nodes[syn["tower_b"]].has_method("set_synergy_buff"):
				tower_nodes[syn["tower_b"]].set_synergy_buff(syn["buffs"])
			# Show banner for newly activated synergies
			if not syn["name"] in old_synergies:
				synergy_banner_text = "SYNERGY: %s — %s" % [syn["name"], syn["desc"]]
				synergy_banner_timer = 3.0
				_check_achievement("synergy_seeker", 1)
	# Track cumulative unique synergies for synergy_master achievement
	for syn_name in active_synergies:
		if not syn_name in synergies_ever_activated:
			synergies_ever_activated.append(syn_name)
	_check_achievement("synergy_master", synergies_ever_activated.size())

# === ACHIEVEMENT SYSTEM ===
func _check_achievement(id: String, value = 1) -> void:
	if achievements_unlocked.get(id, false):
		return
	# Find the definition
	var def_data = null
	for ach in achievement_definitions:
		if ach["id"] == id:
			def_data = ach
			break
	if not def_data:
		return
	# Set or increment progress based on achievement type
	if id in ["synergy_master", "perfect_campaign", "full_roster"]:
		achievement_progress[id] = value
	else:
		achievement_progress[id] = achievement_progress.get(id, 0) + value
	# Check if target reached
	if achievement_progress[id] >= def_data["target"]:
		achievements_unlocked[id] = true
		# Grant reward
		match def_data["reward_type"]:
			"shards": player_relic_shards += def_data["reward_amount"]
			"quills": player_quills += def_data["reward_amount"]
			"stars": player_storybook_stars += def_data["reward_amount"]
		var trophy_bonus = def_data.get("trophy_bonus", 0)
		if trophy_bonus > 0:
			trophy_currency += trophy_bonus
		achievement_popup_text = "ACHIEVEMENT: %s" % def_data["name"]
		var reward_str = "+%d %s" % [def_data["reward_amount"], def_data["reward_type"].capitalize()]
		if trophy_bonus > 0:
			reward_str += " + %d Trophies" % trophy_bonus
		achievement_popup_reward = reward_str
		achievement_popup_timer = 3.0
		_save_game()

# === BATTLE POWER SYSTEM ===
func _activate_power(power_id: String) -> void:
	if selected_difficulty == PURE_MODE:
		info_label.text = "Powers disabled in Pure Mode!"
		return
	if shadow_arena_active and "no_powers" in shadow_arena_modifiers:
		info_label.text = "Powers disabled in Shadow Arena!"
		return
	if owned_powers.get(power_id, 0) <= 0:
		return
	owned_powers[power_id] -= 1
	_update_quest_progress("use_powers", 1)
	match power_id:
		"quill_strike":
			for enemy in get_tree().get_nodes_in_group("enemies"):
				if is_instance_valid(enemy) and enemy.has_method("take_damage"):
					enemy.take_damage(500.0, "true")
		"golden_bounty":
			gold += 200
			update_hud()
		"storybook_shield":
			storybook_shield_charges += 10
		"ink_freeze":
			for enemy in get_tree().get_nodes_in_group("enemies"):
				if is_instance_valid(enemy):
					enemy.set("speed_multiplier", 0.0)
			active_power_effects["ink_freeze"] = 5.0
		"chapter_skip":
			# Kill all current enemies, stop spawning
			enemies_to_spawn = 0
			var skip_count = 0
			for enemy in get_tree().get_nodes_in_group("enemies"):
				if is_instance_valid(enemy):
					enemy.remove_from_group("enemies")
					enemy.queue_free()
					skip_count += 1
			enemies_alive = maxi(enemies_alive - skip_count, 0)
			_check_wave_complete()
		"enchanted_towers":
			power_enchanted_timer = 15.0
			active_power_effects["enchanted_towers"] = 15.0
			for tower in get_tree().get_nodes_in_group("towers"):
				if "power_damage_mult" in tower:
					tower.power_damage_mult = 1.5
	# Remove from selected if depleted
	_update_power_buttons()
	_save_game()

func _update_power_buttons() -> void:
	for i in range(battle_power_buttons.size()):
		if i < selected_powers.size():
			var pid = selected_powers[i]
			var count = owned_powers.get(pid, 0)
			var pname = ""
			for bp in battle_power_definitions:
				if bp["id"] == pid:
					pname = bp["name"]
					break
			battle_power_buttons[i].text = "%s (%d)" % [pname, count]
			battle_power_buttons[i].visible = true
			battle_power_buttons[i].disabled = count <= 0
		else:
			battle_power_buttons[i].visible = false

# === ODYSSEY MODE ===
func _start_odyssey() -> void:
	if odyssey_completed_this_week:
		return
	odyssey_active = true
	odyssey_current_map = 0
	odyssey_carry_lives = 25
	odyssey_carry_gold = 100
	odyssey_lives_at_start = 25
	# Start first map
	_start_odyssey_map(0)

func _start_odyssey_map(map_index: int) -> void:
	odyssey_current_map = map_index
	if map_index >= odyssey_maps.size():
		_odyssey_complete()
		return
	var level_idx = odyssey_maps[map_index]
	selected_difficulty = 1  # Medium difficulty for odyssey
	_remove_survivor_preview()
	current_level = level_idx
	_reset_game()
	var level = levels[level_idx]
	gold = odyssey_carry_gold
	lives = odyssey_carry_lives
	total_waves = 15  # Shorter waves for odyssey
	_setup_path_for_level(level_idx)
	_generate_decorations_for_level(level_idx)
	_stop_music()
	menu_overlay.visible = false
	top_bar.visible = true
	bottom_panel.visible = true
	game_over_label.visible = false
	return_button.visible = false
	game_state = GameState.PLAYING
	start_button.text = "  START WAVE  "
	# Base 6 towers always available
	var base_types = [TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH,
					  TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE]
	for tt in base_types:
		var tname = tower_info[tt]["name"]
		var short = tname.split(" ")[0] if tname.length() > 8 else tname
		tower_buttons[tt].text = "%s [%dG]" % [short, _get_discounted_cost(tt)]
		tower_buttons[tt].disabled = false
	# Unlockable characters — row 2, stretched horizontally
	var unlock_order = [TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA, TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR]
	var ody_visible := 0
	for tt in unlock_order:
		if tower_buttons.has(tt):
			if tt in survivor_types and _is_character_unlocked(tt):
				var bx = 8 + ody_visible * 158
				tower_buttons[tt].position = Vector2(bx, 42)
				var tname = tower_info[tt]["name"]
				var short = tname.split(" ")[0] if tname.length() > 8 else tname
				tower_buttons[tt].text = "%s [%dG]" % [short, _get_discounted_cost(tt)]
				tower_buttons[tt].visible = true
				tower_buttons[tt].disabled = false
				ody_visible += 1
			else:
				tower_buttons[tt].visible = false
	# Panel height: 2 rows if unlocked chars, 1 row if not
	if ody_visible > 0:
		bottom_panel.size.y = 80
		bottom_panel.position.y = 720 - 80
	else:
		bottom_panel.size.y = 42
		bottom_panel.position.y = 720 - 42
	start_button.visible = true
	start_button.disabled = false
	speed_button.visible = true
	update_hud()
	info_label.text = "ODYSSEY %d/3 — %s" % [map_index + 1, level["name"]]
	wave_auto_timer = -1.0

func _odyssey_map_victory() -> void:
	# Save carry-over state
	odyssey_carry_lives = lives
	odyssey_carry_gold = gold
	odyssey_current_map += 1
	if odyssey_current_map >= 3:
		_odyssey_complete()
	else:
		odyssey_transition_active = true
		odyssey_transition_timer = 3.0

func _odyssey_complete() -> void:
	odyssey_active = false
	odyssey_completed_this_week = true
	# Award trophies based on remaining lives
	var trophy_reward = 10 + odyssey_carry_lives
	trophy_reward = clampi(trophy_reward, 10, 30)
	trophy_currency += trophy_reward
	game_over_label.text = "ODYSSEY COMPLETE! +%d Trophies" % trophy_reward
	game_over_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	game_over_label.visible = true
	return_button.visible = true
	_save_game()

func _odyssey_defeat() -> void:
	odyssey_active = false
	# Partial trophy reward
	var partial = 3 + odyssey_current_map * 3
	trophy_currency += partial
	game_over_label.text = "ODYSSEY FAILED — Map %d/3. +%d Trophies" % [odyssey_current_map + 1, partial]
	_save_game()

func _get_relic_slots(level: int) -> int:
	if level >= 10:
		return 5
	elif level >= 7:
		return 4
	elif level >= 4:
		return 3
	return 2

func get_equipped_relic_effects(tower_type) -> Array:
	var effects: Array = []
	if not equipped_relics.has(tower_type):
		return effects
	var char_relics_data = survivor_relics.get(tower_type, [])
	for ri in equipped_relics[tower_type]:
		if ri < char_relics_data.size():
			effects.append(char_relics_data[ri])
	return effects

func _get_knowledge_bonus(effect_type: String) -> float:
	var total: float = 0.0
	for bi in range(knowledge_branches.size()):
		var branch = knowledge_branches[bi]
		for ni in range(branch["nodes"].size()):
			var node = branch["nodes"][ni]
			if knowledge_tree.get("%d_%d" % [bi, ni], false) and node["effect"] == effect_type:
				total += node["value"]
	return total

func _save_game() -> void:
	var save_data: Dictionary = {}
	# Currencies
	save_data["player_quills"] = player_quills
	save_data["player_relic_shards"] = player_relic_shards
	save_data["player_storybook_stars"] = player_storybook_stars
	save_data["player_gold"] = player_gold
	save_data["gold"] = gold
	# Progress
	save_data["completed_levels"] = completed_levels
	var stars_save: Dictionary = {}
	for key in level_stars:
		stars_save[str(key)] = level_stars[key]
	save_data["level_stars"] = stars_save
	# Per-difficulty medals and stars
	var medals_save: Dictionary = {}
	for key in level_difficulty_medals:
		medals_save[str(key)] = level_difficulty_medals[key]
	save_data["level_difficulty_medals"] = medals_save
	var diff_stars_save: Dictionary = {}
	for key in level_difficulty_stars:
		diff_stars_save[str(key)] = level_difficulty_stars[key]
	save_data["level_difficulty_stars"] = diff_stars_save
	# Survivor progress (use tower name strings for reorder safety)
	var sp_save: Dictionary = {}
	for t in survivor_progress:
		var key_name = tower_info[t]["name"] if tower_info.has(t) else str(t)
		sp_save[key_name] = survivor_progress[t]
	save_data["survivor_progress"] = sp_save
	# Equipped relics (use tower name strings)
	var eq_save: Dictionary = {}
	for t in equipped_relics:
		var key_name = tower_info[t]["name"] if tower_info.has(t) else str(t)
		eq_save[key_name] = equipped_relics[t]
	save_data["equipped_relics"] = eq_save
	# Knowledge tree
	save_data["knowledge_tree"] = knowledge_tree
	save_data["knowledge_ink"] = knowledge_ink
	# Treasure chests owned
	save_data["treasure_chests_owned"] = treasure_chests_owned
	# Daily rewards
	save_data["daily_streak"] = daily_streak
	save_data["daily_last_claim"] = daily_last_claim
	# Achievements
	save_data["achievement_progress"] = achievement_progress
	save_data["achievements_unlocked"] = achievements_unlocked
	save_data["total_towers_placed"] = total_towers_placed
	save_data["total_enemies_killed"] = total_enemies_killed
	save_data["total_gold_spent"] = total_gold_spent
	save_data["total_gold_earned"] = total_gold_earned
	save_data["total_emporium_purchases"] = total_emporium_purchases
	save_data["total_chests_opened"] = total_chests_opened
	save_data["total_knowledge_nodes"] = total_knowledge_nodes
	save_data["total_daily_claims"] = total_daily_claims
	# Battle powers
	save_data["owned_powers"] = owned_powers
	# Odyssey
	save_data["odyssey_completed_this_week"] = odyssey_completed_this_week
	save_data["trophy_currency"] = trophy_currency
	# Trophy store
	save_data["owned_cosmetics"] = owned_cosmetics
	save_data["equipped_cosmetics"] = equipped_cosmetics
	# Story progress
	save_data["story_seen"] = story_seen
	save_data["unlocked_characters"] = unlocked_characters
	# Endless mode
	save_data["endless_high_wave"] = endless_high_wave
	# Tome Bindings
	save_data["owned_bindings"] = owned_bindings
	var eq_bindings_save: Dictionary = {}
	for t in equipped_bindings:
		eq_bindings_save[str(t)] = equipped_bindings[t]
	save_data["equipped_bindings"] = eq_bindings_save
	# Synergy tracking for achievements
	var synergy_names_seen: Array = synergies_ever_activated.duplicate()
	for s in active_synergies:
		if not s in synergy_names_seen:
			synergy_names_seen.append(s)
	save_data["synergies_ever_activated"] = synergy_names_seen
	# === NEW FEATURE SAVES ===
	# Daily Deals
	save_data["daily_deals_date"] = daily_deals_date
	save_data["daily_deals_purchased"] = daily_deals_purchased
	# Shadow Arena
	save_data["shadow_arena_high_score"] = shadow_arena_high_score
	save_data["arena_crystals"] = arena_crystals
	# Quests
	save_data["active_quests"] = active_quests
	save_data["quest_last_refresh"] = quest_last_refresh
	save_data["total_quests_completed"] = total_quests_completed
	# Literary Instruments
	save_data["owned_instruments"] = owned_instruments
	# Settings
	save_data["auto_wave_enabled"] = auto_wave_enabled
	save_data["auto_wave_delay"] = auto_wave_delay
	save_data["auto_wave_delay_index"] = auto_wave_delay_index
	# === NEW v3 SAVE FIELDS ===
	save_data["prestige_level"] = prestige_level
	save_data["combo_best"] = combo_best
	save_data["milestone_claimed"] = milestone_claimed
	save_data["total_damage"] = total_damage
	save_data["mastery_challenges"] = mastery_challenges
	save_data["daily_challenge_last_date"] = daily_challenge_last_date
	save_data["daily_challenge_streak"] = daily_challenge_streak
	save_data["daily_challenge_completed_today"] = daily_challenge_completed_today
	save_data["boss_rush_completed"] = boss_rush_completed
	save_data["boss_rush_best_wave"] = boss_rush_best_wave
	save_data["endless_top_runs"] = endless_top_runs
	# === BATTD v4 SAVE FIELDS ===
	save_data["gear_wish_list"] = gear_wish_list
	save_data["double_cash_unlocked"] = double_cash_unlocked
	save_data["double_cash_enabled"] = double_cash_enabled
	save_data["_bounties_completed_total"] = _bounties_completed_total
	save_data["xp_sharing_enabled"] = xp_sharing_enabled
	save_data["_crit_streak_best"] = _crit_streak_best
	# === BATTD2 v5 SAVE FIELDS ===
	save_data["insta_towers"] = insta_towers
	save_data["storybook_pages_found"] = storybook_pages_found
	save_data["_drops_since_mythic"] = _drops_since_mythic
	save_data["_drops_since_forbidden"] = _drops_since_forbidden
	save_data["victory_streak"] = victory_streak
	save_data["victory_streak_best"] = victory_streak_best
	save_data["gold_interest_enabled"] = gold_interest_enabled
	save_data["auto_collect_enabled"] = auto_collect_enabled
	# === BATTD3 v6 SAVE FIELDS ===
	save_data["character_affinity"] = character_affinity
	save_data["awakened_characters"] = awakened_characters
	save_data["cosmic_ink"] = cosmic_ink
	save_data["respec_count"] = respec_count
	save_data["gear_loadouts"] = gear_loadouts
	save_data["gear_loadout_active"] = gear_loadout_active
	save_data["locked_bindings"] = locked_bindings
	save_data["relic_usage_tracker"] = relic_usage_tracker
	save_data["discovered_bindings"] = discovered_bindings
	save_data["favorite_characters"] = favorite_characters
	save_data["career_stats"] = career_stats
	save_data["recent_items"] = recent_items
	# Save version
	save_data["save_version"] = SAVE_VERSION
	# Atomic write with backup rotation
	var save_json = JSON.stringify(save_data, "\t")
	var tmp_path = _save_path + ".tmp"
	var file = FileAccess.open(tmp_path, FileAccess.WRITE)
	if file:
		file.store_string(save_json)
		file.close()
		# Rotate backups: .bak2 <- .bak1 <- .bak <- current
		if FileAccess.file_exists(_save_path + ".bak1"):
			DirAccess.rename_absolute(_save_path + ".bak1", _save_path + ".bak2")
		if FileAccess.file_exists(_save_path + ".bak"):
			DirAccess.rename_absolute(_save_path + ".bak", _save_path + ".bak1")
		if FileAccess.file_exists(_save_path):
			DirAccess.rename_absolute(_save_path, _save_path + ".bak")
		# Move temp to final
		DirAccess.rename_absolute(tmp_path, _save_path)
	else:
		push_warning("Failed to save game: could not open %s for writing" % tmp_path)

func _load_game() -> void:
	# Try main save, then backups in order
	var paths_to_try = [_save_path, _save_path + ".bak", _save_path + ".bak1", _save_path + ".bak2"]
	var data: Dictionary = {}
	var loaded = false
	for try_path in paths_to_try:
		if not FileAccess.file_exists(try_path):
			continue
		var file = FileAccess.open(try_path, FileAccess.READ)
		if not file:
			continue
		var text = file.get_as_text()
		file.close()
		if text.is_empty():
			continue
		var json = JSON.new()
		if json.parse(text) != OK:
			push_warning("Save file corrupted: %s, trying backup..." % try_path)
			continue
		if not json.data is Dictionary:
			continue
		data = json.data
		loaded = true
		if try_path != _save_path:
			push_warning("Loaded from backup: %s" % try_path)
		break
	if not loaded:
		return
	# Save migration: v1 (old 18 levels at 0-17) -> v2 (shifted to 16-33)
	var save_ver = int(data.get("save_version", 1))
	if save_ver < 2:
		var old_cl = data.get("completed_levels", [])
		var new_cl: Array = []
		for v in old_cl:
			var old_idx = int(v)
			if OLD_TO_NEW_LEVEL_MAP.has(old_idx):
				new_cl.append(OLD_TO_NEW_LEVEL_MAP[old_idx])
			else:
				new_cl.append(old_idx)
		data["completed_levels"] = new_cl
		var old_ls = data.get("level_stars", {})
		var new_ls: Dictionary = {}
		for key in old_ls:
			var old_idx = int(key)
			if OLD_TO_NEW_LEVEL_MAP.has(old_idx):
				new_ls[str(OLD_TO_NEW_LEVEL_MAP[old_idx])] = old_ls[key]
			else:
				new_ls[key] = old_ls[key]
		data["level_stars"] = new_ls
		# Remap story_seen dialog keys
		var old_ss = data.get("story_seen", [])
		var new_ss: Array = []
		for v in old_ss:
			var s = str(v)
			if s.begins_with("pre_level_") or s.begins_with("post_level_"):
				var parts = s.split("_")
				var old_idx = int(parts[parts.size() - 1])
				if OLD_TO_NEW_LEVEL_MAP.has(old_idx):
					var prefix = s.substr(0, s.rfind("_") + 1)
					new_ss.append(prefix + str(OLD_TO_NEW_LEVEL_MAP[old_idx]))
				else:
					new_ss.append(s)
			else:
				new_ss.append(s)
		data["story_seen"] = new_ss
		data["save_version"] = 2
	# v2 → v3 migration: initialize new fields with defaults
	if save_ver < 3:
		data["prestige_level"] = data.get("prestige_level", 0)
		data["combo_best"] = data.get("combo_best", 0)
		data["milestone_claimed"] = data.get("milestone_claimed", {})
		data["total_damage"] = data.get("total_damage", 0)
		data["mastery_challenges"] = data.get("mastery_challenges", {})
		data["daily_challenge_last_date"] = data.get("daily_challenge_last_date", "")
		data["daily_challenge_streak"] = data.get("daily_challenge_streak", 0)
		data["daily_challenge_completed_today"] = data.get("daily_challenge_completed_today", false)
		data["boss_rush_completed"] = data.get("boss_rush_completed", false)
		data["boss_rush_best_wave"] = data.get("boss_rush_best_wave", 0)
		data["endless_top_runs"] = data.get("endless_top_runs", [])
		data["auto_wave_delay_index"] = data.get("auto_wave_delay_index", 1)
		data["save_version"] = SAVE_VERSION
	# Currencies
	player_quills = int(data.get("player_quills", 0))
	player_relic_shards = int(data.get("player_relic_shards", 0))
	player_storybook_stars = int(data.get("player_storybook_stars", 0))
	player_gold = int(data.get("player_gold", 0))
	# Migrate old gold savings: if player_gold is 0 but old save had gold, transfer it
	if player_gold == 0 and data.has("gold") and int(data.get("gold", 0)) > 0:
		player_gold = int(data["gold"])
	gold = int(data.get("gold", gold))
	# Completed levels
	var cl = data.get("completed_levels", [])
	completed_levels.clear()
	for v in cl:
		completed_levels.append(int(v))
	# Level stars
	var ls = data.get("level_stars", {})
	level_stars.clear()
	for key in ls:
		level_stars[int(key)] = int(ls[key])
	# Per-difficulty medals and stars
	var ldm = data.get("level_difficulty_medals", {})
	level_difficulty_medals.clear()
	for key in ldm:
		var arr = ldm[key]
		var medals_arr = [false, false, false]
		for di in range(mini(arr.size(), 3)):
			medals_arr[di] = bool(arr[di])
		level_difficulty_medals[int(key)] = medals_arr
	var lds = data.get("level_difficulty_stars", {})
	level_difficulty_stars.clear()
	for key in lds:
		var arr = lds[key]
		var stars_arr = [0, 0, 0]
		for di in range(mini(arr.size(), 3)):
			stars_arr[di] = int(arr[di])
		level_difficulty_stars[int(key)] = stars_arr
	# Migration: old saves without per-difficulty data — mark Easy as beaten for completed levels
	if ldm.is_empty() and not completed_levels.is_empty():
		for lvl_idx in completed_levels:
			level_difficulty_medals[lvl_idx] = [true, false, false]
			var s = level_stars.get(lvl_idx, 0)
			level_difficulty_stars[lvl_idx] = [s, 0, 0]
	# Survivor progress
	var sp = data.get("survivor_progress", {})
	# Build name→TowerType reverse lookup for name-based save keys
	var _name_to_type: Dictionary = {}
	for tt in tower_info:
		_name_to_type[tower_info[tt]["name"]] = tt
	for key in sp:
		# Support both old int keys (str(0)) and new name keys ("Robin Hood")
		var t: int = -1
		if key.is_valid_int():
			t = int(key)
		elif _name_to_type.has(key):
			t = _name_to_type[key]
		if t < 0 or not survivor_progress.has(t):
			continue
		var saved = sp[key]
		var loaded_level = int(saved.get("level", 1))
		# Migration: cap level at MAX_SURVIVOR_LEVEL
		if loaded_level > MAX_SURVIVOR_LEVEL:
			loaded_level = MAX_SURVIVOR_LEVEL
		survivor_progress[t]["level"] = loaded_level
		survivor_progress[t]["xp"] = float(saved.get("xp", 0.0))
		# Migration: recalculate xp_next from new HERO_XP_TABLE instead of old 500*level
		survivor_progress[t]["xp_next"] = _get_xp_for_level(loaded_level)
		survivor_progress[t]["gear_unlocked"] = bool(saved.get("gear_unlocked", false))
		survivor_progress[t]["total_damage"] = float(saved.get("total_damage", 0.0))
		var sk = saved.get("sidekicks_unlocked", [false, false, false])
		for i in range(mini(sk.size(), 3)):
			survivor_progress[t]["sidekicks_unlocked"][i] = bool(sk[i])
		var rl = saved.get("relics_unlocked", [false, false, false, false, false, false])
		for i in range(mini(rl.size(), 6)):
			survivor_progress[t]["relics_unlocked"][i] = bool(rl[i])
		var ab = saved.get("abilities_unlocked", [])
		for i in range(mini(ab.size(), 9)):
			survivor_progress[t]["abilities_unlocked"][i] = bool(ab[i])
	# Equipped relics (supports both int and name keys)
	var eq = data.get("equipped_relics", {})
	for key in eq:
		var t: int = -1
		if key.is_valid_int():
			t = int(key)
		elif _name_to_type.has(key):
			t = _name_to_type[key]
		if t < 0:
			continue
		equipped_relics[t] = []
		for v in eq[key]:
			equipped_relics[t].append(int(v))
	# Knowledge tree
	var kt = data.get("knowledge_tree", {})
	for key in kt:
		knowledge_tree[key] = bool(kt[key])
	knowledge_ink = int(data.get("knowledge_ink", 0))
	# Treasure chests
	var tc = data.get("treasure_chests_owned", {"bronze": 0, "silver": 0, "gold": 0})
	treasure_chests_owned["bronze"] = int(tc.get("bronze", 0))
	treasure_chests_owned["silver"] = int(tc.get("silver", 0))
	treasure_chests_owned["gold"] = int(tc.get("gold", 0))
	# Daily rewards
	daily_streak = int(data.get("daily_streak", 0))
	daily_last_claim = str(data.get("daily_last_claim", ""))
	# Achievements
	var ap = data.get("achievement_progress", {})
	for key in ap:
		achievement_progress[key] = int(ap[key])
	var au = data.get("achievements_unlocked", {})
	for key in au:
		achievements_unlocked[key] = bool(au[key])
	total_towers_placed = int(data.get("total_towers_placed", 0))
	total_enemies_killed = int(data.get("total_enemies_killed", 0))
	total_gold_spent = int(data.get("total_gold_spent", 0))
	total_gold_earned = int(data.get("total_gold_earned", 0))
	total_emporium_purchases = int(data.get("total_emporium_purchases", 0))
	total_chests_opened = int(data.get("total_chests_opened", 0))
	total_knowledge_nodes = int(data.get("total_knowledge_nodes", 0))
	total_daily_claims = int(data.get("total_daily_claims", 0))
	# Battle powers
	var op = data.get("owned_powers", {})
	for key in op:
		owned_powers[key] = int(op[key])
	# Odyssey
	odyssey_completed_this_week = bool(data.get("odyssey_completed_this_week", false))
	trophy_currency = int(data.get("trophy_currency", 0))
	# Trophy store
	var oc = data.get("owned_cosmetics", [])
	owned_cosmetics.clear()
	for v in oc:
		owned_cosmetics.append(str(v))
	var ec = data.get("equipped_cosmetics", {})
	equipped_cosmetics.clear()
	for key in ec:
		equipped_cosmetics[key] = str(ec[key])
	# Story progress
	var ss = data.get("story_seen", [])
	story_seen.clear()
	for v in ss:
		story_seen.append(str(v))
	var uc = data.get("unlocked_characters", [])
	unlocked_characters.clear()
	for v in uc:
		unlocked_characters.append(str(v))
	# Endless mode
	endless_high_wave = int(data.get("endless_high_wave", 0))
	# Tome Bindings
	var ob = data.get("owned_bindings", {})
	owned_bindings.clear()
	for key in ob:
		owned_bindings[key] = int(ob[key])
	var eb = data.get("equipped_bindings", {})
	equipped_bindings.clear()
	for key in eb:
		var t = int(key)
		equipped_bindings[t] = []
		for v in eb[key]:
			equipped_bindings[t].append(str(v))
	# === LOAD NEW FEATURE DATA ===
	# Daily Deals
	daily_deals_date = str(data.get("daily_deals_date", ""))
	var ddp = data.get("daily_deals_purchased", [false, false, false])
	daily_deals_purchased = []
	for v in ddp:
		daily_deals_purchased.append(bool(v))
	while daily_deals_purchased.size() < 3:
		daily_deals_purchased.append(false)
	# Shadow Arena
	shadow_arena_high_score = int(data.get("shadow_arena_high_score", 0))
	arena_crystals = int(data.get("arena_crystals", 0))
	# Quests
	var aq = data.get("active_quests", [])
	active_quests.clear()
	for q in aq:
		active_quests.append(q)
	quest_last_refresh = str(data.get("quest_last_refresh", ""))
	total_quests_completed = int(data.get("total_quests_completed", 0))
	# Synergy tracking
	var sea = data.get("synergies_ever_activated", [])
	synergies_ever_activated.clear()
	for v in sea:
		synergies_ever_activated.append(str(v))
	# Literary Instruments
	var oi = data.get("owned_instruments", {})
	owned_instruments.clear()
	for key in oi:
		owned_instruments[key] = int(oi[key])
	# Settings
	auto_wave_enabled = data.get("auto_wave_enabled", true)
	auto_wave_delay = data.get("auto_wave_delay", 2.0)
	auto_wave_delay_index = int(data.get("auto_wave_delay_index", 1))
	# === LOAD v3 FIELDS ===
	prestige_level = int(data.get("prestige_level", 0))
	combo_best = int(data.get("combo_best", 0))
	var mc = data.get("milestone_claimed", {})
	milestone_claimed.clear()
	for key in mc:
		milestone_claimed[key] = bool(mc[key])
	total_damage = int(data.get("total_damage", 0))
	var mch = data.get("mastery_challenges", {})
	mastery_challenges.clear()
	for key in mch:
		mastery_challenges[key] = mch[key]
	daily_challenge_last_date = str(data.get("daily_challenge_last_date", ""))
	daily_challenge_streak = int(data.get("daily_challenge_streak", 0))
	daily_challenge_completed_today = bool(data.get("daily_challenge_completed_today", false))
	# Reset daily_challenge_completed_today if date changed
	var today = Time.get_date_string_from_system()
	if daily_challenge_last_date != today:
		daily_challenge_completed_today = false
	boss_rush_completed = bool(data.get("boss_rush_completed", false))
	boss_rush_best_wave = int(data.get("boss_rush_best_wave", 0))
	var etr = data.get("endless_top_runs", [])
	endless_top_runs.clear()
	for r in etr:
		endless_top_runs.append(r)
	# === LOAD BATTD v4 FIELDS ===
	var gwl = data.get("gear_wish_list", [])
	gear_wish_list.clear()
	for v in gwl:
		gear_wish_list.append(str(v))
	double_cash_unlocked = bool(data.get("double_cash_unlocked", false))
	double_cash_enabled = bool(data.get("double_cash_enabled", false))
	_bounties_completed_total = int(data.get("_bounties_completed_total", 0))
	xp_sharing_enabled = bool(data.get("xp_sharing_enabled", true))
	_crit_streak_best = int(data.get("_crit_streak_best", 0))
	# === LOAD BATTD2 v5 FIELDS ===
	var it = data.get("insta_towers", [])
	insta_towers.clear()
	for v in it:
		insta_towers.append(v)
	var spf = data.get("storybook_pages_found", {})
	storybook_pages_found.clear()
	for key in spf:
		storybook_pages_found[key] = bool(spf[key])
	_drops_since_mythic = int(data.get("_drops_since_mythic", 0))
	_drops_since_forbidden = int(data.get("_drops_since_forbidden", 0))
	victory_streak = int(data.get("victory_streak", 0))
	victory_streak_best = int(data.get("victory_streak_best", 0))
	gold_interest_enabled = bool(data.get("gold_interest_enabled", true))
	auto_collect_enabled = bool(data.get("auto_collect_enabled", false))
	# === LOAD BATTD3 v6 FIELDS ===
	var ca_data = data.get("character_affinity", {})
	for key in ca_data:
		character_affinity[int(key)] = float(ca_data[key])
	var aw_data = data.get("awakened_characters", {})
	for key in aw_data:
		awakened_characters[int(key)] = bool(aw_data[key])
	cosmic_ink = int(data.get("cosmic_ink", 0))
	respec_count = int(data.get("respec_count", 0))
	var gl_data = data.get("gear_loadouts", {})
	for key in gl_data:
		gear_loadouts[int(key)] = gl_data[key]
	var gla_data = data.get("gear_loadout_active", {})
	for key in gla_data:
		gear_loadout_active[int(key)] = int(gla_data[key])
	var lb_data = data.get("locked_bindings", {})
	locked_bindings.clear()
	for key in lb_data:
		locked_bindings[str(key)] = bool(lb_data[key])
	var rut_data = data.get("relic_usage_tracker", {})
	relic_usage_tracker.clear()
	for key in rut_data:
		relic_usage_tracker[str(key)] = int(rut_data[key])
	var db_data = data.get("discovered_bindings", {})
	discovered_bindings.clear()
	for key in db_data:
		discovered_bindings[str(key)] = bool(db_data[key])
	var fc_data = data.get("favorite_characters", [])
	favorite_characters.clear()
	for v in fc_data:
		favorite_characters.append(int(v))
	var cs_data = data.get("career_stats", {})
	for key in cs_data:
		career_stats[key] = cs_data[key]
	var ri_data = data.get("recent_items", [])
	recent_items.clear()
	for v in ri_data:
		recent_items.append(v)
	# Golden Shields migration — ensure existing progress has the field
	for t in survivor_progress:
		if not survivor_progress[t].has("golden_shields"):
			survivor_progress[t]["golden_shields"] = 0
		if not survivor_progress[t].has("upgrade_branch"):
			survivor_progress[t]["upgrade_branch"] = ""
	# Refresh unlocked survivors into the active roster
	_refresh_unlocked_survivors()
	# Check if prologue should be triggered on first load
	if story_seen.size() == 0 and story_dialogs.has("prologue"):
		call_deferred("_start_story_dialog", "prologue")

func _cache_path_points() -> void:
	var curve = enemy_path.curve
	if not curve:
		return
	var length = curve.get_baked_length()
	for i in range(0, int(length), 6):
		path_points.append(curve.sample_baked(float(i)))

func _cache_path_thumbnails() -> void:
	_path_thumbnail_cache.clear()
	var curve = enemy_path.curve
	if not curve:
		return
	for idx in range(levels.size()):
		curve.clear_points()
		_setup_path_for_level(idx)
		var length = curve.get_baked_length()
		var pts: PackedVector2Array = PackedVector2Array()
		var step = maxi(int(length / 40.0), 10)
		for i in range(0, int(length), step):
			pts.append(curve.sample_baked(float(i)))
		if length > 0:
			pts.append(curve.sample_baked(length))
		_path_thumbnail_cache[idx] = pts
	# Restore current level path
	_setup_path_for_level(current_level)

func _generate_decorations_for_level(index: int) -> void:
	_decorations.clear()
	var rng = RandomNumberGenerator.new()
	rng.seed = 42 + index

	match index:
		0: # Prologue — Into the Pages
			for i in range(20):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "torn_page", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0, TAU)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 610))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "ink_puddle", "size": rng.randf_range(10, 20), "extra": rng.randf_range(0, 1)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(100, 560))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "quill", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "shadow_wisp", "size": rng.randf_range(4, 10), "extra": rng.randf_range(0, TAU)})
		1: # Sherlock Ch1 — Baker Street
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "gaslight", "size": rng.randf_range(16, 28), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "magnifying_glass", "size": rng.randf_range(6, 12), "extra": 0.0})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "footprint", "size": rng.randf_range(3, 6), "extra": rng.randf_range(0, TAU)})
			for i in range(5):
				var pos = Vector2(rng.randf_range(100, 1180), rng.randf_range(120, 550))
				if _dist_to_path(pos) > 65.0:
					_decorations.append({"pos": pos, "type": "pipe", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, 1)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "fog_patch", "size": rng.randf_range(20, 40), "extra": rng.randf_range(0, 1)})
		2: # Sherlock Ch2 — Whitechapel
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.25:
						_decorations.append({"pos": pos, "type": "gaslight", "size": rng.randf_range(18, 30), "extra": rng.randf_range(0, TAU)})
					elif r < 0.45:
						_decorations.append({"pos": pos, "type": "magnifying_glass", "size": rng.randf_range(7, 13), "extra": 0.0})
					elif r < 0.65:
						_decorations.append({"pos": pos, "type": "footprint", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, TAU)})
					elif r < 0.82:
						_decorations.append({"pos": pos, "type": "pipe", "size": rng.randf_range(5, 11), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "fog_patch", "size": rng.randf_range(22, 44), "extra": rng.randf_range(0, 1)})
		3: # Sherlock Ch3 — Reichenbach
			for i in range(40):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.25:
						_decorations.append({"pos": pos, "type": "gaslight", "size": rng.randf_range(18, 32), "extra": rng.randf_range(0, TAU)})
					elif r < 0.45:
						_decorations.append({"pos": pos, "type": "magnifying_glass", "size": rng.randf_range(7, 14), "extra": 0.0})
					elif r < 0.65:
						_decorations.append({"pos": pos, "type": "footprint", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
					elif r < 0.82:
						_decorations.append({"pos": pos, "type": "pipe", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "fog_patch", "size": rng.randf_range(24, 48), "extra": rng.randf_range(0, 1)})
		4: # Merlin Ch1 — Round Table
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "standing_stone", "size": rng.randf_range(14, 28), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "crystal_orb", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "ancient_rune", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 560))
				if _dist_to_path(pos) > 65.0:
					_decorations.append({"pos": pos, "type": "celtic_tree", "size": rng.randf_range(16, 30), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 610))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, 1)})
		5: # Merlin Ch2 — Enchanted Forest
			for i in range(38):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "standing_stone", "size": rng.randf_range(15, 30), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.4:
						_decorations.append({"pos": pos, "type": "crystal_orb", "size": rng.randf_range(7, 14), "extra": rng.randf_range(0, TAU)})
					elif r < 0.6:
						_decorations.append({"pos": pos, "type": "ancient_rune", "size": rng.randf_range(5, 9), "extra": rng.randf_range(0, TAU)})
					elif r < 0.8:
						_decorations.append({"pos": pos, "type": "celtic_tree", "size": rng.randf_range(18, 34), "extra": rng.randf_range(-0.04, 0.04)})
					else:
						_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, 1)})
		6: # Merlin Ch3 — Crystal Cave
			for i in range(44):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "standing_stone", "size": rng.randf_range(16, 32), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.45:
						_decorations.append({"pos": pos, "type": "crystal_orb", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0, TAU)})
					elif r < 0.65:
						_decorations.append({"pos": pos, "type": "ancient_rune", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
					elif r < 0.82:
						_decorations.append({"pos": pos, "type": "celtic_tree", "size": rng.randf_range(18, 36), "extra": rng.randf_range(-0.04, 0.04)})
					else:
						_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0, 1)})
		7: # Tarzan Ch1 — Jungle Canopy
			for i in range(20):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(16, 32), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(15):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 610))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "vine", "size": rng.randf_range(10, 24), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "exotic_flower", "size": rng.randf_range(4, 10), "extra": rng.randf_range(0, 1)})
			for i in range(4):
				var pos = Vector2(rng.randf_range(100, 1180), rng.randf_range(120, 550))
				if _dist_to_path(pos) > 65.0:
					_decorations.append({"pos": pos, "type": "parrot", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
		8: # Tarzan Ch2 — Elephant Graveyard
			for i in range(36):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.25:
						_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(18, 34), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.45:
						_decorations.append({"pos": pos, "type": "vine", "size": rng.randf_range(12, 26), "extra": rng.randf_range(0, TAU)})
					elif r < 0.65:
						_decorations.append({"pos": pos, "type": "exotic_flower", "size": rng.randf_range(5, 11), "extra": rng.randf_range(0, 1)})
					elif r < 0.82:
						_decorations.append({"pos": pos, "type": "barrel", "size": rng.randf_range(8, 14), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "parrot", "size": rng.randf_range(5, 11), "extra": rng.randf_range(0, TAU)})
		9: # Tarzan Ch3 — Clayton's Fortress
			for i in range(42):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.22:
						_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(18, 36), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.42:
						_decorations.append({"pos": pos, "type": "vine", "size": rng.randf_range(12, 28), "extra": rng.randf_range(0, TAU)})
					elif r < 0.6:
						_decorations.append({"pos": pos, "type": "exotic_flower", "size": rng.randf_range(5, 12), "extra": rng.randf_range(0, 1)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "barrel", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "parrot", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
		10: # Dracula Ch1 — Village
			for i in range(12):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "dead_tree", "size": rng.randf_range(16, 30), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "cross_headstone", "size": rng.randf_range(8, 16), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 560))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "garlic_braid", "size": rng.randf_range(5, 10), "extra": 0.0})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "bat_swarm", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, TAU)})
			for i in range(4):
				var pos = Vector2(rng.randf_range(100, 1180), rng.randf_range(150, 520))
				if _dist_to_path(pos) > 70.0:
					_decorations.append({"pos": pos, "type": "coffin", "size": rng.randf_range(10, 18), "extra": rng.randf_range(0, TAU)})
		11: # Dracula Ch2 — Castle
			for i in range(36):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "dead_tree", "size": rng.randf_range(18, 32), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.4:
						_decorations.append({"pos": pos, "type": "cross_headstone", "size": rng.randf_range(9, 18), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.56:
						_decorations.append({"pos": pos, "type": "garlic_braid", "size": rng.randf_range(5, 11), "extra": 0.0})
					elif r < 0.76:
						_decorations.append({"pos": pos, "type": "bat_swarm", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "coffin", "size": rng.randf_range(11, 20), "extra": rng.randf_range(0, TAU)})
		12: # Dracula Ch3 — Crypt
			for i in range(44):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "dead_tree", "size": rng.randf_range(18, 34), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.4:
						_decorations.append({"pos": pos, "type": "cross_headstone", "size": rng.randf_range(10, 20), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.56:
						_decorations.append({"pos": pos, "type": "garlic_braid", "size": rng.randf_range(6, 12), "extra": 0.0})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "bat_swarm", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "coffin", "size": rng.randf_range(12, 22), "extra": rng.randf_range(0, TAU)})
		13: # Frankenstein Ch1 — Lab
			for i in range(10):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "tesla_coil", "size": rng.randf_range(14, 24), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "beaker", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, 1)})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "gear", "size": rng.randf_range(6, 14), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 560))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "stitch_mark", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
		14: # Frankenstein Ch2 — Village
			for i in range(36):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.25:
						_decorations.append({"pos": pos, "type": "tesla_coil", "size": rng.randf_range(15, 26), "extra": rng.randf_range(0, TAU)})
					elif r < 0.5:
						_decorations.append({"pos": pos, "type": "beaker", "size": rng.randf_range(7, 14), "extra": rng.randf_range(0, 1)})
					elif r < 0.72:
						_decorations.append({"pos": pos, "type": "gear", "size": rng.randf_range(7, 15), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "stitch_mark", "size": rng.randf_range(5, 9), "extra": rng.randf_range(0, TAU)})
		15: # Frankenstein Ch3 — Arctic
			for i in range(42):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "tesla_coil", "size": rng.randf_range(16, 28), "extra": rng.randf_range(0, TAU)})
					elif r < 0.4:
						_decorations.append({"pos": pos, "type": "beaker", "size": rng.randf_range(7, 15), "extra": rng.randf_range(0, 1)})
					elif r < 0.58:
						_decorations.append({"pos": pos, "type": "gear", "size": rng.randf_range(7, 16), "extra": rng.randf_range(0, TAU)})
					elif r < 0.76:
						_decorations.append({"pos": pos, "type": "stitch_mark", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "snowflake", "size": rng.randf_range(3, 8), "extra": rng.randf_range(0, TAU)})
		16: # Robin Hood Ch1 — Sherwood Forest
			for i in range(30):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "oak_tree", "size": rng.randf_range(14, 32), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 70.0:
					_decorations.append({"pos": pos, "type": "target", "size": rng.randf_range(6, 10), "extra": 0.0})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "bush", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0.0, 1.0)})
			for i in range(4):
				var pos = Vector2(rng.randf_range(100, 1100), rng.randf_range(200, 550))
				if _dist_to_path(pos) > 80.0:
					_decorations.append({"pos": pos, "type": "deer", "size": rng.randf_range(10, 16), "extra": rng.randf_range(0, TAU)})
			for i in range(2):
				var pos = Vector2(rng.randf_range(200, 1000), rng.randf_range(150, 500))
				if _dist_to_path(pos) > 90.0:
					_decorations.append({"pos": pos, "type": "campfire", "size": 12.0, "extra": rng.randf_range(0, TAU)})
		17: # Robin Hood Ch2 — Sheriff's Pursuit
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "oak_tree", "size": rng.randf_range(16, 34), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.5:
						_decorations.append({"pos": pos, "type": "target", "size": rng.randf_range(7, 11), "extra": 0.0})
					elif r < 0.7:
						_decorations.append({"pos": pos, "type": "bush", "size": rng.randf_range(9, 18), "extra": rng.randf_range(0.0, 1.0)})
					elif r < 0.85:
						_decorations.append({"pos": pos, "type": "deer", "size": rng.randf_range(10, 17), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "campfire", "size": rng.randf_range(11, 14), "extra": rng.randf_range(0, TAU)})
		18: # Robin Hood Ch3 — Siege of Nottingham
			for i in range(45):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.28:
						_decorations.append({"pos": pos, "type": "oak_tree", "size": rng.randf_range(18, 38), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.46:
						_decorations.append({"pos": pos, "type": "target", "size": rng.randf_range(7, 12), "extra": 0.0})
					elif r < 0.64:
						_decorations.append({"pos": pos, "type": "bush", "size": rng.randf_range(10, 20), "extra": rng.randf_range(0.0, 1.0)})
					elif r < 0.8:
						_decorations.append({"pos": pos, "type": "deer", "size": rng.randf_range(10, 18), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "campfire", "size": rng.randf_range(12, 16), "extra": rng.randf_range(0, TAU)})
		19: # Alice Ch1 — Down the Rabbit Hole
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "giant_mushroom", "size": rng.randf_range(10, 24), "extra": rng.randf_range(0.0, 1.0)})
			for i in range(10):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 300))
				_decorations.append({"pos": pos, "type": "floating_card", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(100, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0.0, 1.0)})
			for i in range(5):
				var pos = Vector2(rng.randf_range(50, 1230), rng.randf_range(80, 560))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "teacup", "size": rng.randf_range(6, 10), "extra": 0.0})
		20: # Alice Ch2 — Mad Tea Party
			for i in range(30):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "giant_mushroom", "size": rng.randf_range(12, 26), "extra": rng.randf_range(0.0, 1.0)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "floating_card", "size": rng.randf_range(7, 13), "extra": rng.randf_range(0, TAU)})
					elif r < 0.8:
						_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0.0, 1.0)})
					else:
						_decorations.append({"pos": pos, "type": "teacup", "size": rng.randf_range(6, 11), "extra": 0.0})
		21: # Alice Ch3 — Queen's Court
			for i in range(40):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "giant_mushroom", "size": rng.randf_range(14, 30), "extra": rng.randf_range(0.0, 1.0)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "floating_card", "size": rng.randf_range(7, 14), "extra": rng.randf_range(0, TAU)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0.0, 1.0)})
					else:
						_decorations.append({"pos": pos, "type": "teacup", "size": rng.randf_range(7, 12), "extra": 0.0})
		22: # Oz Ch1 — Yellow Brick Road
			for i in range(25):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(100, 620))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "poppy", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "emerald_crystal", "size": rng.randf_range(5, 12), "extra": rng.randf_range(0, TAU)})
			for i in range(4):
				var pos = Vector2(rng.randf_range(100, 1100), rng.randf_range(150, 550))
				if _dist_to_path(pos) > 70.0:
					_decorations.append({"pos": pos, "type": "scarecrow", "size": rng.randf_range(12, 18), "extra": 0.0})
		23: # Oz Ch2 — Witch's Domain
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.4:
						_decorations.append({"pos": pos, "type": "poppy", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
					elif r < 0.7:
						_decorations.append({"pos": pos, "type": "emerald_crystal", "size": rng.randf_range(6, 14), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "scarecrow", "size": rng.randf_range(13, 19), "extra": 0.0})
		24: # Oz Ch3 — Emerald Throne
			for i in range(48):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.38:
						_decorations.append({"pos": pos, "type": "poppy", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0, TAU)})
					elif r < 0.72:
						_decorations.append({"pos": pos, "type": "emerald_crystal", "size": rng.randf_range(6, 16), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "scarecrow", "size": rng.randf_range(12, 20), "extra": 0.0})
		25: # Peter Pan Ch1 — Flight to Neverland
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(14, 30), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "fairy", "size": 2.0, "extra": rng.randf_range(0, TAU)})
			for i in range(18):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(60, 615))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, 1)})
			for i in range(25):
				var pos = Vector2(rng.randf_range(10, 1270), rng.randf_range(52, 180))
				_decorations.append({"pos": pos, "type": "star", "size": rng.randf_range(0.3, 0.8), "extra": rng.randf_range(0, TAU)})
		26: # Peter Pan Ch2 — Lost Boys' Stand
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(15, 32), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.5:
						_decorations.append({"pos": pos, "type": "fairy", "size": 2.0, "extra": rng.randf_range(0, TAU)})
					elif r < 0.75:
						_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(3, 8), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "star", "size": rng.randf_range(0.3, 0.9), "extra": rng.randf_range(0, TAU)})
		27: # Peter Pan Ch3 — The Jolly Roger
			for i in range(46):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.28:
						_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(16, 36), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.5:
						_decorations.append({"pos": pos, "type": "fairy", "size": 2.0, "extra": rng.randf_range(0, TAU)})
					elif r < 0.75:
						_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "star", "size": rng.randf_range(0.4, 1.0), "extra": rng.randf_range(0, TAU)})
		28: # Phantom Ch1 — Grand Stage
			for i in range(10):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "candelabra", "size": rng.randf_range(8, 14), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 500))
				if _dist_to_path(pos) > 65.0:
					_decorations.append({"pos": pos, "type": "mirror", "size": rng.randf_range(10, 18), "extra": rng.randf_range(0, TAU)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(3, 6), "extra": rng.randf_range(0.0, 1.0)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(60, 400))
				_decorations.append({"pos": pos, "type": "sheet_music", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
		29: # Phantom Ch2 — Labyrinth
			for i in range(32):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "candelabra", "size": rng.randf_range(9, 16), "extra": rng.randf_range(0, TAU)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "mirror", "size": rng.randf_range(11, 20), "extra": rng.randf_range(0, TAU)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(4, 7), "extra": rng.randf_range(0.0, 1.0)})
					else:
						_decorations.append({"pos": pos, "type": "sheet_music", "size": rng.randf_range(5, 9), "extra": rng.randf_range(0, TAU)})
		30: # Phantom Ch3 — Phantom's Lair
			for i in range(42):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "candelabra", "size": rng.randf_range(10, 18), "extra": rng.randf_range(0, TAU)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "mirror", "size": rng.randf_range(12, 22), "extra": rng.randf_range(0, TAU)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0.0, 1.0)})
					else:
						_decorations.append({"pos": pos, "type": "sheet_music", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
		31: # Scrooge Ch1 — Christmas Eve
			for i in range(12):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 560))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "lamp_post", "size": rng.randf_range(20, 30), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "bare_tree", "size": rng.randf_range(14, 26), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(100, 620))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "snow_pile", "size": rng.randf_range(5, 12), "extra": 0.0})
			for i in range(6):
				var pos = Vector2(rng.randf_range(100, 1180), rng.randf_range(150, 500))
				if _dist_to_path(pos) > 70.0:
					_decorations.append({"pos": pos, "type": "chimney", "size": rng.randf_range(8, 14), "extra": rng.randf_range(0, TAU)})
		32: # Scrooge Ch2 — Three Spirits
			for i in range(33):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.28:
						_decorations.append({"pos": pos, "type": "lamp_post", "size": rng.randf_range(21, 32), "extra": rng.randf_range(0, TAU)})
					elif r < 0.52:
						_decorations.append({"pos": pos, "type": "bare_tree", "size": rng.randf_range(15, 28), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.76:
						_decorations.append({"pos": pos, "type": "snow_pile", "size": rng.randf_range(6, 14), "extra": 0.0})
					else:
						_decorations.append({"pos": pos, "type": "chimney", "size": rng.randf_range(9, 15), "extra": rng.randf_range(0, TAU)})
		33: # Scrooge Ch3 — Redemption's Dawn
			for i in range(44):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.27:
						_decorations.append({"pos": pos, "type": "lamp_post", "size": rng.randf_range(22, 35), "extra": rng.randf_range(0, TAU)})
					elif r < 0.52:
						_decorations.append({"pos": pos, "type": "bare_tree", "size": rng.randf_range(16, 32), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.76:
						_decorations.append({"pos": pos, "type": "snow_pile", "size": rng.randf_range(7, 16), "extra": 0.0})
					else:
						_decorations.append({"pos": pos, "type": "chimney", "size": rng.randf_range(9, 17), "extra": rng.randf_range(0, TAU)})
		34: # Shadow Author Ch1 — Ink Realm
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "open_book", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0, TAU)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 610))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "dripping_ink", "size": rng.randf_range(6, 14), "extra": rng.randf_range(0, 1)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "broken_quill", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 560))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "chapter_marker", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, 1)})
		35: # Shadow Author Ch2 — Unwritten Pages
			for i in range(38):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "open_book", "size": rng.randf_range(9, 18), "extra": rng.randf_range(0, TAU)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "dripping_ink", "size": rng.randf_range(7, 16), "extra": rng.randf_range(0, 1)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "broken_quill", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "chapter_marker", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, 1)})
		36: # Shadow Author Ch3 — Final Chapter
			for i in range(46):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.28:
						_decorations.append({"pos": pos, "type": "open_book", "size": rng.randf_range(10, 20), "extra": rng.randf_range(0, TAU)})
					elif r < 0.54:
						_decorations.append({"pos": pos, "type": "dripping_ink", "size": rng.randf_range(8, 18), "extra": rng.randf_range(0, 1)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "broken_quill", "size": rng.randf_range(6, 14), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "chapter_marker", "size": rng.randf_range(5, 12), "extra": rng.randf_range(0, 1)})

	# Shadow Author taunt + shadow figures — active on ALL maps
	_sa_taunt_triggered = false
	_sa_taunt_timer = -1.0
	_sa_taunt_trigger_time = rng.randf_range(10.0, 40.0)  # Random time each level
	# Pick a taunt position away from path
	for _try in range(20):
		var tp = Vector2(rng.randf_range(200, 1080), rng.randf_range(200, 450))
		if _dist_to_path(tp) > 100.0:
			_sa_taunt_x = tp.x
			_sa_taunt_y = tp.y
			break
	# Generate shadow figures that float around every map
	_sa_shadow_figures.clear()
	var fig_count = 4 if index < 34 else 6 + (index - 34)  # 4 on normal maps, 6-8 on SA maps
	for fi in range(fig_count):
		_sa_shadow_figures.append({
			"cx": rng.randf_range(100, 1180),
			"cy": rng.randf_range(150, 500),
			"speed": rng.randf_range(0.3, 0.8),
			"radius": rng.randf_range(60, 180),
			"phase": rng.randf_range(0, TAU),
			"height": rng.randf_range(30, 50),
		})

func _create_ui() -> void:
	var ui = $UI

	# Top bar (dark wood / pirate ship plank style)
	top_bar = ColorRect.new()
	top_bar.color = Color(0.12, 0.08, 0.05, 0.9)
	top_bar.position = Vector2(0, 0)
	top_bar.size = Vector2(1280, 50)
	ui.add_child(top_bar)

	wave_label = Label.new()
	wave_label.position = Vector2(10, 8)
	wave_label.add_theme_font_size_override("font_size", 18)
	wave_label.add_theme_constant_override("shadow_offset_x", 1)
	wave_label.add_theme_constant_override("shadow_offset_y", 2)
	wave_label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.6))
	top_bar.add_child(wave_label)

	gold_label = Label.new()
	gold_label.position = Vector2(290, 8)
	gold_label.add_theme_font_size_override("font_size", 18)
	gold_label.add_theme_color_override("font_color", Color(1.0, 0.84, 0.0))
	gold_label.add_theme_constant_override("shadow_offset_x", 1)
	gold_label.add_theme_constant_override("shadow_offset_y", 2)
	gold_label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.6))
	top_bar.add_child(gold_label)

	lives_label = Label.new()
	lives_label.position = Vector2(410, 8)
	lives_label.add_theme_font_size_override("font_size", 18)
	lives_label.add_theme_color_override("font_color", Color(1.0, 0.39, 0.28))
	lives_label.add_theme_constant_override("shadow_offset_x", 1)
	lives_label.add_theme_constant_override("shadow_offset_y", 2)
	lives_label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.6))
	top_bar.add_child(lives_label)

	menu_exit_button = Button.new()
	menu_exit_button.text = "  MENU  "
	menu_exit_button.position = Vector2(1180, 6)
	menu_exit_button.custom_minimum_size = Vector2(88, 48)
	menu_exit_button.pressed.connect(_show_menu)
	top_bar.add_child(menu_exit_button)

	# Bottom panel
	bottom_panel = ColorRect.new()
	bottom_panel.color = Color(0.12, 0.08, 0.05, 0.9)
	bottom_panel.position = Vector2(0, 628)
	bottom_panel.size = Vector2(1280, 92)
	bottom_panel.clip_contents = true
	ui.add_child(bottom_panel)

	var btn_h = 40
	var row1_y = 2
	var row2_y = 46
	var btn_w = 152

	# Row 1: Base 6 towers stretched across
	var base_towers = [
		[TowerType.ROBIN_HOOD, "Robin [75G]", "Robin Hood — long range archer, gold bonus."],
		[TowerType.ALICE, "Alice [85G]", "Alice — cake, slows enemies in area."],
		[TowerType.WICKED_WITCH, "Witch [100G]", "Wicked Witch — eye blast, wolves."],
		[TowerType.PETER_PAN, "Peter [90G]", "Peter Pan — fast daggers, shadow."],
		[TowerType.PHANTOM, "Phantom [95G]", "Phantom — heavy hits, stun, chandelier."],
		[TowerType.SCROOGE, "Scrooge [60G]", "Scrooge — bell, knockback & gold gen."],
	]
	for i in range(base_towers.size()):
		var bt = base_towers[i]
		var bx = 8 + i * (btn_w + 6)
		var btn = _make_button(bt[1], Vector2(bx, row1_y), Vector2(btn_w, btn_h))
		btn.pressed.connect(_on_tower_pressed.bind(bt[0], bt[2] + " Cancel to abort."))
		bottom_panel.add_child(btn)
		tower_buttons[bt[0]] = btn

	# Row 2: Unlockable characters stretched across (hidden until unlocked)
	var new_chars = [
		[TowerType.SHERLOCK, "Holmes [110G]", "Sherlock — focus beam, deduction mark."],
		[TowerType.TARZAN, "Tarzan [100G]", "Tarzan — melee beast, vine swing, animals."],
		[TowerType.DRACULA, "Dracula [105G]", "Dracula — life drain, bats, minion control."],
		[TowerType.MERLIN, "Merlin [115G]", "Merlin — buffs, curses, Excalibur strikes."],
		[TowerType.FRANKENSTEIN, "Monster [130G]", "Frankenstein — AoE lightning fist smash."],
		[TowerType.SHADOW_AUTHOR, "Author [250G]", "Shadow Author — ink attacks, rewrite, shadow servants."],
	]
	for i in range(new_chars.size()):
		var nc = new_chars[i]
		var bx = 8 + i * (btn_w + 6)
		var btn = _make_button(nc[1], Vector2(bx, row2_y), Vector2(btn_w, btn_h))
		btn.pressed.connect(_on_tower_pressed.bind(nc[0], nc[2] + " Cancel to abort."))
		bottom_panel.add_child(btn)
		tower_buttons[nc[0]] = btn
		btn.visible = false  # Hidden until unlocked

	info_label = Label.new()
	info_label.position = Vector2(500, 8)
	info_label.size = Vector2(660, 34)
	info_label.add_theme_font_size_override("font_size", 16)
	info_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	info_label.clip_text = true
	info_label.text = ""
	top_bar.add_child(info_label)

	start_button = Button.new()
	start_button.text = "  START WAVE  "
	start_button.position = Vector2(960, 4)
	start_button.custom_minimum_size = Vector2(160, 48)
	start_button.pressed.connect(_on_start_wave_pressed)
	bottom_panel.add_child(start_button)

	speed_button = Button.new()
	speed_button.text = "  >>  "
	speed_button.position = Vector2(1126, 2)
	speed_button.custom_minimum_size = Vector2(72, 48)
	speed_button.pressed.connect(_on_speed_pressed)
	bottom_panel.add_child(speed_button)

	restart_button = Button.new()
	restart_button.text = "  ↺  "
	restart_button.position = Vector2(1202, 2)
	restart_button.custom_minimum_size = Vector2(72, 48)
	restart_button.pressed.connect(_on_restart_pressed)
	bottom_panel.add_child(restart_button)

	sfx_mute_button = Button.new()
	sfx_mute_button.text = " SFX "
	sfx_mute_button.position = Vector2(1126, 42)
	sfx_mute_button.custom_minimum_size = Vector2(72, 48)
	sfx_mute_button.pressed.connect(_on_sfx_mute_pressed)
	bottom_panel.add_child(sfx_mute_button)

	voice_mute_button = Button.new()
	voice_mute_button.text = " VOX "
	voice_mute_button.position = Vector2(1202, 42)
	voice_mute_button.custom_minimum_size = Vector2(72, 48)
	voice_mute_button.pressed.connect(_on_voice_mute_pressed)
	bottom_panel.add_child(voice_mute_button)

	auto_wave_btn = Button.new()
	auto_wave_btn.text = (" AUTO %ds " % int(auto_wave_delay)) if auto_wave_enabled else " AUTO OFF "
	auto_wave_btn.position = Vector2(1050, 46)
	auto_wave_btn.custom_minimum_size = Vector2(86, 48)
	auto_wave_btn.pressed.connect(_on_auto_wave_toggled)
	bottom_panel.add_child(auto_wave_btn)

	# Quick restart button (restart level from wave 1)
	var quick_restart_button = Button.new()
	quick_restart_button.text = " RETRY "
	quick_restart_button.position = Vector2(960, 46)
	quick_restart_button.custom_minimum_size = Vector2(82, 44)
	quick_restart_button.pressed.connect(_on_quick_restart_pressed)
	bottom_panel.add_child(quick_restart_button)

	# Undo tower placement button (hidden by default)
	undo_button = Button.new()
	undo_button.text = " UNDO "
	undo_button.position = Vector2(870, 46)
	undo_button.custom_minimum_size = Vector2(82, 44)
	undo_button.visible = false
	undo_button.pressed.connect(_on_undo_placement)
	bottom_panel.add_child(undo_button)

	cancel_button = Button.new()
	cancel_button.text = "CANCEL"
	cancel_button.position = Vector2(950, 46)
	cancel_button.custom_minimum_size = Vector2(180, 44)
	cancel_button.visible = false
	cancel_button.pressed.connect(_on_cancel_placement)
	bottom_panel.add_child(cancel_button)

	# === BATTLE POWER HUD BUTTONS (in-game, bottom-right) ===
	for pi in range(3):
		var power_btn = Button.new()
		power_btn.text = ""
		power_btn.position = Vector2(1010, 75 + pi * 40)
		power_btn.custom_minimum_size = Vector2(170, 44)
		power_btn.visible = false
		power_btn.pressed.connect(_on_battle_power_pressed.bind(pi))
		bottom_panel.add_child(power_btn)
		battle_power_buttons.append(power_btn)

	game_over_label = Label.new()
	game_over_label.add_theme_font_size_override("font_size", 72)
	game_over_label.add_theme_color_override("font_color", Color.RED)
	game_over_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	game_over_label.position = Vector2(240, 280)
	game_over_label.size = Vector2(800, 100)
	game_over_label.visible = false
	ui.add_child(game_over_label)

	# === Ability choice panel (centered, hidden by default) ===
	ability_panel = ColorRect.new()
	ability_panel.color = Color(0.08, 0.06, 0.12, 0.95)
	ability_panel.position = Vector2(290, 150)
	ability_panel.size = Vector2(700, 380)
	ability_panel.visible = false
	ui.add_child(ability_panel)

	# Panel border
	var border = ColorRect.new()
	border.color = Color(1.0, 0.85, 0.2, 0.6)
	border.position = Vector2(-2, -2)
	border.size = Vector2(704, 384)
	border.z_index = -1
	ability_panel.add_child(border)

	ability_title = Label.new()
	ability_title.text = "CHOOSE AN ABILITY"
	ability_title.position = Vector2(20, 12)
	ability_title.add_theme_font_size_override("font_size", 24)
	ability_title.add_theme_color_override("font_color", Color(1.0, 0.9, 0.4))
	ability_panel.add_child(ability_title)

	var subtitle = Label.new()
	subtitle.text = "YOUR TOWER REACHED 1500 DAMAGE! PICK A SPECIAL ABILITY:"
	subtitle.position = Vector2(20, 45)
	subtitle.add_theme_font_size_override("font_size", 14)
	subtitle.add_theme_color_override("font_color", Color(0.7, 0.65, 0.5))
	ability_panel.add_child(subtitle)

	for i in range(4):
		var btn = Button.new()
		btn.position = Vector2(20, 75 + i * 72)
		btn.custom_minimum_size = Vector2(660, 60)
		btn.pressed.connect(_on_ability_chosen.bind(i))
		ability_panel.add_child(btn)
		ability_buttons.append(btn)

	# === Tower upgrade panel (right-side, hidden by default) ===
	upgrade_panel = ColorRect.new()
	upgrade_panel.color = Color(0.08, 0.05, 0.12, 0.95)
	upgrade_panel.position = Vector2(1080, 15)
	upgrade_panel.size = Vector2(200, 678)
	upgrade_panel.visible = false
	ui.add_child(upgrade_panel)

	# Gold border
	var upg_border = ColorRect.new()
	upg_border.color = Color(0.85, 0.65, 0.1, 0.5)
	upg_border.position = Vector2(-2, -2)
	upg_border.size = Vector2(204, 682)
	upg_border.z_index = -1
	upgrade_panel.add_child(upg_border)

	# Tower name label at top
	upgrade_name_label = Label.new()
	upgrade_name_label.position = Vector2(10, 10)
	upgrade_name_label.size = Vector2(180, 30)
	upgrade_name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	upgrade_name_label.add_theme_font_size_override("font_size", 18)
	upgrade_name_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	upgrade_panel.add_child(upgrade_name_label)

	# Separator line (drawn via a thin ColorRect)
	var sep = ColorRect.new()
	sep.color = Color(0.85, 0.65, 0.1, 0.3)
	sep.position = Vector2(10, 42)
	sep.size = Vector2(180, 1)
	upgrade_panel.add_child(sep)

	# Portrait area — border behind, dark bg, then drawable Control on top
	var portrait_border = ColorRect.new()
	portrait_border.color = Color(0.85, 0.65, 0.1, 0.3)
	portrait_border.position = Vector2(48, 48)
	portrait_border.size = Vector2(104, 84)
	portrait_border.z_index = -1
	upgrade_panel.add_child(portrait_border)

	var portrait_bg = ColorRect.new()
	portrait_bg.color = Color(0.06, 0.03, 0.09, 0.8)
	portrait_bg.position = Vector2(50, 50)
	portrait_bg.size = Vector2(100, 80)
	upgrade_panel.add_child(portrait_bg)

	# Drawable Control for portrait (renders inside the UI layer)
	var portrait_draw_ctrl = Control.new()
	portrait_draw_ctrl.name = "PortraitDraw"
	portrait_draw_ctrl.position = Vector2(50, 50)
	portrait_draw_ctrl.size = Vector2(100, 80)
	portrait_draw_ctrl.clip_contents = true
	portrait_draw_ctrl.draw.connect(_on_portrait_draw.bind(portrait_draw_ctrl))
	upgrade_panel.add_child(portrait_draw_ctrl)

	# Targeting priority button (between portrait and upgrades)
	targeting_button = Button.new()
	targeting_button.text = "Target: FIRST"
	targeting_button.position = Vector2(20, 134)
	targeting_button.custom_minimum_size = Vector2(160, 30)
	targeting_button.add_theme_font_size_override("font_size", 13)
	targeting_button.pressed.connect(_on_targeting_pressed)
	upgrade_panel.add_child(targeting_button)

	# 4 upgrade slots stacked vertically
	for i in range(4):
		var slot_y = 170 + i * 100

		# Status background rect (changes color based on state)
		var status_rect = ColorRect.new()
		status_rect.position = Vector2(10, slot_y)
		status_rect.size = Vector2(180, 85)
		status_rect.color = Color(0.12, 0.08, 0.16, 0.8)
		upgrade_panel.add_child(status_rect)
		upgrade_status_rects.append(status_rect)

		# Slot border
		var slot_border = ColorRect.new()
		slot_border.color = Color(0.4, 0.3, 0.5, 0.4)
		slot_border.position = Vector2(-1, -1)
		slot_border.size = Vector2(182, 87)
		slot_border.z_index = -1
		status_rect.add_child(slot_border)

		# Tier number label
		var tier_label = Label.new()
		tier_label.text = str(i + 1)
		tier_label.position = Vector2(6, 4)
		tier_label.add_theme_font_size_override("font_size", 14)
		tier_label.add_theme_color_override("font_color", Color(0.6, 0.5, 0.7))
		status_rect.add_child(tier_label)

		# Upgrade button (clickable area)
		var upg_btn = Button.new()
		upg_btn.position = Vector2(4, 2)
		upg_btn.custom_minimum_size = Vector2(172, 48)
		upg_btn.flat = true
		upg_btn.pressed.connect(_on_upgrade_tier_pressed.bind(i))
		status_rect.add_child(upg_btn)
		upgrade_buttons.append(upg_btn)

		# Description label (below name, above cost)
		var desc_label = Label.new()
		desc_label.position = Vector2(6, 30)
		desc_label.size = Vector2(168, 32)
		desc_label.autowrap_mode = TextServer.AUTOWRAP_WORD
		desc_label.add_theme_font_size_override("font_size", 14)
		desc_label.add_theme_color_override("font_color", Color(0.75, 0.72, 0.80, 0.8))
		status_rect.add_child(desc_label)
		upgrade_desc_labels.append(desc_label)

		# Cost label (right side)
		var cost_label = Label.new()
		cost_label.position = Vector2(4, 64)
		cost_label.size = Vector2(172, 20)
		cost_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		cost_label.add_theme_font_size_override("font_size", 14)
		cost_label.add_theme_color_override("font_color", Color(1.0, 0.84, 0.0))
		status_rect.add_child(cost_label)
		upgrade_cost_labels.append(cost_label)

	# Hero ability button (above sell button)
	var hero_ability_button = Button.new()
	hero_ability_button.name = "HeroAbilityBtn"
	hero_ability_button.text = "ABILITY"
	hero_ability_button.position = Vector2(10, 560)
	hero_ability_button.custom_minimum_size = Vector2(180, 28)
	hero_ability_button.add_theme_font_size_override("font_size", 12)
	hero_ability_button.visible = false
	hero_ability_button.pressed.connect(_on_hero_ability_pressed)
	upgrade_panel.add_child(hero_ability_button)

	# Sell button
	sell_button = Button.new()
	sell_button.text = "SELL"
	sell_button.position = Vector2(20, 594)
	sell_button.custom_minimum_size = Vector2(160, 36)
	sell_button.pressed.connect(_on_sell_pressed)
	upgrade_panel.add_child(sell_button)

	# Sell value / refund label
	sell_value_label = Label.new()
	sell_value_label.position = Vector2(20, 634)
	sell_value_label.size = Vector2(160, 20)
	sell_value_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	sell_value_label.add_theme_font_size_override("font_size", 13)
	sell_value_label.add_theme_color_override("font_color", Color(0.9, 0.4, 0.3))
	upgrade_panel.add_child(sell_value_label)

	# === MAIN MENU OVERLAY ===
	menu_overlay = ColorRect.new()
	menu_overlay.color = Color(0, 0, 0, 0)  # Transparent — we draw the background in _draw()
	menu_overlay.position = Vector2(0, 0)
	menu_overlay.size = Vector2(1280, 720)
	menu_overlay.visible = true
	ui.add_child(menu_overlay)

	# Generate storybook decoration positions
	var rng2 = RandomNumberGenerator.new()
	rng2.seed = 99
	for i in range(20):
		_dust_positions.append({"x": rng2.randf_range(50, 1230), "y": rng2.randf_range(50, 600), "speed": rng2.randf_range(0.2, 0.6), "size": rng2.randf_range(1.0, 2.5), "offset": rng2.randf_range(0, TAU)})
	for i in range(5):
		_book_candle_positions.append({"x": rng2.randf_range(60, 1220), "y": rng2.randf_range(480, 590), "offset": rng2.randf_range(0, TAU)})
	# Floating book pages
	for i in range(8):
		_floating_pages.append({"x": rng2.randf_range(30, 1250), "y": rng2.randf_range(60, 580), "rot": rng2.randf_range(-0.4, 0.4), "size": rng2.randf_range(18, 35), "speed": rng2.randf_range(0.15, 0.45), "offset": rng2.randf_range(0, TAU)})
	# Ink splatters
	for i in range(6):
		_menu_ink_splatters.append({"x": rng2.randf_range(20, 1260), "y": rng2.randf_range(100, 600), "size": rng2.randf_range(8, 25), "dots": rng2.randi_range(3, 7), "seed": rng2.randi()})
	# Quill pens
	for i in range(3):
		_quill_positions.append({"x": rng2.randf_range(80, 1200), "y": rng2.randf_range(400, 570), "rot": rng2.randf_range(-0.6, 0.3), "size": rng2.randf_range(30, 50)})
	# Bookshelf column heights (for silhouette across bottom)
	for i in range(26):
		_bookshelf_heights.append(rng2.randf_range(20, 55))

	# World map data
	var rng3 = RandomNumberGenerator.new()
	rng3.seed = 200
	for i in range(40):
		_world_map_stars.append({"x": rng3.randf_range(10, 1270), "y": rng3.randf_range(5, 200), "size": rng3.randf_range(0.5, 2.0), "speed": rng3.randf_range(1.0, 3.0), "offset": rng3.randf_range(0, TAU)})
	for i in range(3):
		_world_map_clouds.append({"x": rng3.randf_range(100, 1100), "y": rng3.randf_range(50, 160), "width": rng3.randf_range(40, 80), "speed": rng3.randf_range(0.15, 0.4)})
	for i in range(5):
		_world_map_smoke.append({"y": rng3.randf_range(-5, -35), "speed": rng3.randf_range(0.3, 0.8), "size": rng3.randf_range(2.0, 5.0), "offset": rng3.randf_range(0, TAU)})

	# Title — hidden by default (shown on book cover, drawn procedurally)
	menu_title = Label.new()
	menu_title.text = ""
	menu_title.position = Vector2(20, 22)
	menu_title.size = Vector2(600, 60)
	menu_title.visible = false
	menu_overlay.add_child(menu_title)

	# Subtitle — hidden (drawn on book cover)
	menu_subtitle = Label.new()
	menu_subtitle.text = ""
	menu_subtitle.position = Vector2(22, 72)
	menu_subtitle.size = Vector2(400, 30)
	menu_subtitle.visible = false
	menu_overlay.add_child(menu_subtitle)

	# Star total (top right, above book)
	menu_star_total_label = Label.new()
	menu_star_total_label.position = Vector2(1050, 8)
	menu_star_total_label.size = Vector2(220, 30)
	menu_star_total_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	menu_star_total_label.add_theme_font_size_override("font_size", 18)
	menu_star_total_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	menu_overlay.add_child(menu_star_total_label)

	# === OPEN BOOK PANEL (two-page spread) ===
	menu_showcase_panel = ColorRect.new()
	menu_showcase_panel.color = Color(0, 0, 0, 0)  # Transparent, we draw the book in _draw
	menu_showcase_panel.position = Vector2(70, 45)
	menu_showcase_panel.size = Vector2(1140, 560)
	menu_overlay.add_child(menu_showcase_panel)

	# --- LEFT PAGE: Character info ---
	# Character name (calligraphy gold)
	menu_level_name_label = Label.new()
	menu_level_name_label.position = Vector2(40, 30)
	menu_level_name_label.size = Vector2(500, 40)
	menu_level_name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	menu_level_name_label.add_theme_font_size_override("font_size", 30)
	menu_level_name_label.add_theme_color_override("font_color", Color(0.79, 0.66, 0.30))
	menu_showcase_panel.add_child(menu_level_name_label)

	# Novel title (italic)
	menu_level_desc_label = Label.new()
	menu_level_desc_label.position = Vector2(40, 75)
	menu_level_desc_label.size = Vector2(500, 25)
	menu_level_desc_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	menu_level_desc_label.add_theme_font_size_override("font_size", 14)
	menu_level_desc_label.add_theme_color_override("font_color", Color(0.5, 0.4, 0.3))
	menu_showcase_panel.add_child(menu_level_desc_label)

	# Character quote
	menu_level_stats_label = Label.new()
	menu_level_stats_label.position = Vector2(60, 380)
	menu_level_stats_label.size = Vector2(460, 60)
	menu_level_stats_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	menu_level_stats_label.add_theme_font_size_override("font_size", 14)
	menu_level_stats_label.add_theme_color_override("font_color", Color(0.45, 0.35, 0.25))
	menu_level_stats_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	menu_showcase_panel.add_child(menu_level_stats_label)

	# Stars display (unused in chapters view, used in survivors)
	menu_level_stars_label = Label.new()
	menu_level_stars_label.position = Vector2(40, 440)
	menu_level_stars_label.size = Vector2(500, 30)
	menu_level_stars_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	menu_level_stars_label.add_theme_font_size_override("font_size", 20)
	menu_level_stars_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	menu_showcase_panel.add_child(menu_level_stars_label)

	# Left arrow (page turn)
	menu_left_arrow = Button.new()
	menu_left_arrow.text = "  <  "
	menu_left_arrow.position = Vector2(10, 490)
	menu_left_arrow.custom_minimum_size = Vector2(60, 40)
	menu_left_arrow.pressed.connect(_on_menu_left)
	menu_showcase_panel.add_child(menu_left_arrow)

	# Right arrow (page turn)
	menu_right_arrow = Button.new()
	menu_right_arrow.text = "  >  "
	menu_right_arrow.position = Vector2(1060, 490)
	menu_right_arrow.custom_minimum_size = Vector2(60, 40)
	menu_right_arrow.pressed.connect(_on_menu_right)
	menu_showcase_panel.add_child(menu_right_arrow)

	# --- RIGHT PAGE: 3 Chapter cards ---
	for i in range(3):
		var card_y = 30 + i * 165
		var card_x = 585

		# Chapter title
		var ch_title = Label.new()
		ch_title.position = Vector2(card_x, card_y)
		ch_title.size = Vector2(540, 25)
		ch_title.add_theme_font_size_override("font_size", 18)
		ch_title.add_theme_color_override("font_color", Color(0.55, 0.35, 0.1))
		menu_showcase_panel.add_child(ch_title)
		chapter_title_labels.append(ch_title)

		# Chapter description
		var ch_desc = Label.new()
		ch_desc.position = Vector2(card_x, card_y + 28)
		ch_desc.size = Vector2(340, 50)
		ch_desc.add_theme_font_size_override("font_size", 14)
		ch_desc.add_theme_color_override("font_color", Color(0.4, 0.35, 0.28))
		ch_desc.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
		menu_showcase_panel.add_child(ch_desc)
		chapter_desc_labels.append(ch_desc)

		# Chapter stats (waves/gold/lives)
		var ch_stat = Label.new()
		ch_stat.position = Vector2(card_x, card_y + 82)
		ch_stat.size = Vector2(300, 20)
		ch_stat.add_theme_font_size_override("font_size", 14)
		ch_stat.add_theme_color_override("font_color", Color(0.4, 0.55, 0.35))
		menu_showcase_panel.add_child(ch_stat)
		chapter_stat_labels.append(ch_stat)

		# Chapter stars
		var ch_stars = Label.new()
		ch_stars.position = Vector2(card_x, card_y + 104)
		ch_stars.size = Vector2(200, 22)
		ch_stars.add_theme_font_size_override("font_size", 18)
		ch_stars.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
		menu_showcase_panel.add_child(ch_stars)
		chapter_star_labels.append(ch_stars)

		# Difficulty / lock label
		var ch_lock = Label.new()
		ch_lock.position = Vector2(card_x + 220, card_y + 104)
		ch_lock.size = Vector2(120, 22)
		ch_lock.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		ch_lock.add_theme_font_size_override("font_size", 14)
		menu_showcase_panel.add_child(ch_lock)
		chapter_lock_labels.append(ch_lock)

		# Difficulty buttons for this chapter (Easy / Med / Hard)
		var diff_labels = ["EASY", "MED", "HARD"]
		var diff_colors_bg = [Color(0.15, 0.45, 0.2), Color(0.45, 0.40, 0.1), Color(0.55, 0.15, 0.1)]
		var ch_diff_btns: Array = []
		for d in range(3):
			var diff_btn = Button.new()
			diff_btn.text = diff_labels[d]
			diff_btn.position = Vector2(card_x + 290 + d * 72, card_y + 76)
			diff_btn.custom_minimum_size = Vector2(66, 44)
			diff_btn.add_theme_font_size_override("font_size", 14)
			diff_btn.pressed.connect(_on_chapter_play.bind(i, d))
			menu_showcase_panel.add_child(diff_btn)
			ch_diff_btns.append(diff_btn)
		chapter_diff_buttons.append(ch_diff_btns)
		# Keep a reference in chapter_buttons for the first button (for lock/unlock logic)
		chapter_buttons.append(ch_diff_btns[0])

	# === BOTTOM NAV BAR (bookmark ribbon style) ===
	var nav_bar = ColorRect.new()
	nav_bar.color = Color(0.04, 0.04, 0.10, 0.97)
	nav_bar.position = Vector2(0, 620)
	nav_bar.size = Vector2(1280, 100)
	menu_overlay.add_child(nav_bar)

	# Nav bar top border — gold line (3px) + gold accent (1px)
	var nav_border = ColorRect.new()
	nav_border.color = Color(0.79, 0.66, 0.30, 0.4)
	nav_border.position = Vector2(0, 0)
	nav_border.size = Vector2(1280, 3)
	nav_bar.add_child(nav_border)

	var nav_gold_accent = ColorRect.new()
	nav_gold_accent.color = Color(0.54, 0.45, 0.20, 0.25)
	nav_gold_accent.position = Vector2(0, 3)
	nav_gold_accent.size = Vector2(1280, 1)
	nav_bar.add_child(nav_gold_accent)

	var nav_names = ["SURVIVORS", "RELICS", "CHAPTERS", "CHRONICLES", "EMPORIUM"]
	nav_names.append("ACHIEVEMENTS")
	for i in range(6):
		var btn_x = 42 + i * 200
		var nav_btn = Button.new()
		nav_btn.text = ""
		nav_btn.position = Vector2(btn_x, 10)
		nav_btn.custom_minimum_size = Vector2(60, 50)
		nav_btn.pressed.connect(_on_nav_pressed.bind(nav_names[i].to_lower()))
		nav_bar.add_child(nav_btn)
		menu_nav_buttons.append(nav_btn)

		var nav_lbl = Label.new()
		nav_lbl.text = nav_names[i]
		nav_lbl.position = Vector2(btn_x - 20, 64)
		nav_lbl.size = Vector2(100, 20)
		nav_lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		nav_lbl.add_theme_font_size_override("font_size", 14)
		nav_lbl.add_theme_color_override("font_color", Color(0.65, 0.60, 0.52))
		nav_bar.add_child(nav_lbl)
		menu_nav_labels.append(nav_lbl)

		# Vertical divider between buttons (gold line)
		if i < 5:
			var div_x_pos = btn_x + 125
			var div_line = ColorRect.new()
			div_line.color = Color(0.54, 0.45, 0.20, 0.15)
			div_line.position = Vector2(div_x_pos, 12)
			div_line.size = Vector2(1, 65)
			nav_bar.add_child(div_line)

	# === SURVIVOR GRID (BATTD-style character roster) ===
	survivor_grid_container = Control.new()
	survivor_grid_container.position = Vector2(0, 0)
	survivor_grid_container.size = Vector2(1280, 620)
	survivor_grid_container.visible = false
	menu_overlay.add_child(survivor_grid_container)

	# Title is drawn procedurally in _draw_survivor_grid() now

	# Create 12 character cards: row 1 = 6 cards, row 2 = 6 cards (centered)
	survivor_grid_cards.clear()
	var card_w = 170.0
	var card_h = 230.0
	var gap_x = 12.0
	var gap_y = 12.0
	var grid_panel_x = 70.0
	var grid_panel_w = 1140.0
	var grid_start_y = 38.0 + 42.0
	for i in range(survivor_types.size()):
		var row_i: int
		var col_i: int
		var cards_in_row: int
		if i < 6:
			row_i = 0
			col_i = i
			cards_in_row = 6
		else:
			row_i = 1
			col_i = i - 6
			cards_in_row = survivor_types.size() - 6
		var row_w = float(cards_in_row) * card_w + float(cards_in_row - 1) * gap_x
		var row_x = grid_panel_x + (grid_panel_w - row_w) * 0.5
		var cx = row_x + float(col_i) * (card_w + gap_x)
		var cy = grid_start_y + float(row_i) * (card_h + gap_y)

		var card_btn = Button.new()
		card_btn.position = Vector2(cx, cy)
		card_btn.custom_minimum_size = Vector2(card_w, card_h)
		card_btn.flat = true
		card_btn.pressed.connect(_on_survivor_card_pressed.bind(i))
		card_btn.mouse_entered.connect(func(): queue_redraw())
		card_btn.mouse_exited.connect(func(): queue_redraw())
		survivor_grid_container.add_child(card_btn)
		survivor_grid_cards.append(card_btn)

	# === SURVIVOR DETAIL PAGE (opened when clicking a card) ===
	survivor_detail_container = Control.new()
	survivor_detail_container.position = Vector2(0, 0)
	survivor_detail_container.size = Vector2(1280, 620)
	survivor_detail_container.visible = false
	menu_overlay.add_child(survivor_detail_container)

	# Back button (top-left, overlapping the drawn "< SURVIVORS" label)
	survivor_detail_back_btn = Button.new()
	survivor_detail_back_btn.text = "  < SURVIVORS  "
	survivor_detail_back_btn.position = Vector2(75, 42)
	survivor_detail_back_btn.custom_minimum_size = Vector2(140, 48)
	survivor_detail_back_btn.flat = true
	survivor_detail_back_btn.pressed.connect(_on_detail_back)
	survivor_detail_container.add_child(survivor_detail_back_btn)

	# Hidden data labels (populated by _open_survivor_detail, drawn procedurally)
	var det_name = Label.new()
	det_name.name = "DetailName"
	det_name.visible = false
	survivor_detail_container.add_child(det_name)

	var det_level = Label.new()
	det_level.name = "DetailLevel"
	det_level.visible = false
	survivor_detail_container.add_child(det_level)

	# Hidden data labels (used by _open_survivor_detail for data, drawn procedurally)
	for lbl_name in ["DetailXP", "DetailNovel", "DetailDesc", "GearHeader", "GearName", "GearDesc", "SidekicksHeader", "RelicsHeader", "RelicTooltipName", "RelicTooltipDesc", "AbilitiesHeader", "AbilitiesDesc"]:
		var lbl = Label.new()
		lbl.name = lbl_name
		lbl.visible = false
		survivor_detail_container.add_child(lbl)

	# Return to menu button (hidden during gameplay, shown on victory/game over)
	return_button = Button.new()
	return_button.text = "  RETURN TO MENU  "
	return_button.position = Vector2(500, 380)
	return_button.custom_minimum_size = Vector2(280, 50)
	return_button.pressed.connect(_show_menu)
	return_button.visible = false
	ui.add_child(return_button)

	retry_button = Button.new()
	retry_button.text = "  RETRY LEVEL  "
	retry_button.position = Vector2(500, 440)
	retry_button.custom_minimum_size = Vector2(280, 50)
	retry_button.pressed.connect(_on_retry_level)
	retry_button.visible = false
	ui.add_child(retry_button)

func _make_button(text: String, pos: Vector2, min_size: Vector2) -> Button:
	var btn = Button.new()
	btn.text = text.to_upper()
	btn.position = pos
	btn.custom_minimum_size = min_size
	btn.add_theme_font_override("font", game_font)
	return btn

func _apply_font_to_controls(node: Node) -> void:
	if node is Label:
		node.add_theme_font_override("font", game_font)
	elif node is Button:
		node.add_theme_font_override("font", game_font)
	for child in node.get_children():
		_apply_font_to_controls(child)

# ============================================================
# MENU & LEVEL MANAGEMENT
# ============================================================

func _on_retry_level() -> void:
	_play_sfx(_sfx_ui_click)
	var lvl = current_level
	_reset_game()
	retry_button.visible = false
	return_button.visible = false
	game_over_label.visible = false
	_do_level_start(lvl)
	# BATTD: Apply revenge bonus gold
	if _revenge_available:
		var revenge_gold = int(gold * _revenge_bonus_pct)
		add_gold(revenge_gold)
		spawn_floating_text(Vector2(640, 300), "REVENGE +%dG!" % revenge_gold, Color(1.0, 0.4, 0.2), 20.0, 2.0)
		_revenge_available = false

func _show_menu() -> void:
	_reset_game()
	game_state = GameState.MENU
	get_tree().paused = false
	Engine.time_scale = 1.0
	fast_forward = false
	game_paused = false
	endless_mode = false
	if speed_button:
		speed_button.text = "  >>  "
	menu_overlay.visible = true
	return_button.visible = false
	retry_button.visible = false
	game_over_label.visible = false
	if top_bar:
		top_bar.visible = false
	if bottom_panel:
		bottom_panel.visible = false
	if cancel_button:
		cancel_button.visible = false
	if upgrade_panel:
		upgrade_panel.visible = false
	placing_tower = false
	chest_open = false
	chest_loot.clear()
	chest_opening_active = false
	victory_chest_active = false
	victory_equip_active = false
	victory_trinket_pending = {}
	_deselect_tower()
	_remove_survivor_preview()
	_remove_detail_preview()
	_clear_grid_previews()
	survivor_grid_container.visible = false
	survivor_detail_container.visible = false
	survivor_detail_open = false
	survivor_selected_index = -1
	survivor_detail_index = -1
	menu_current_view = "chapters"

	menu_left_arrow.visible = false
	menu_right_arrow.visible = false
	menu_showcase_panel.visible = false
	# Hide old chapter UI — chapters view draws everything procedurally
	for i in range(3):
		chapter_title_labels[i].visible = false
		chapter_desc_labels[i].visible = false
		chapter_stat_labels[i].visible = false
		chapter_star_labels[i].visible = false
		chapter_lock_labels[i].visible = false
		_hide_chapter_diff_buttons(i)
	story_map_scroll_y = 0.0
	_stop_layered_music()
	_start_music()
	emporium_sub_open = false
	emporium_sub_category = -1
	power_selection_open = false
	_check_daily_reward()
	queue_redraw()

func _check_daily_reward() -> void:
	var today = Time.get_date_string_from_system()
	if daily_last_claim == today:
		daily_reward_claimed_today = true
		return
	daily_reward_claimed_today = false
	daily_reward_open = true

func _claim_daily_reward() -> void:
	var today = Time.get_date_string_from_system()
	if daily_last_claim == today:
		return
	var day_index = daily_streak % 7
	var reward = daily_rewards_schedule[day_index]
	var reward_text = ""
	match reward["type"]:
		"shards":
			player_relic_shards += reward["amount"]
			reward_text = "+%d Relic Shards" % reward["amount"]
		"quills":
			player_quills += reward["amount"]
			reward_text = "+%d Quills" % reward["amount"]
		"gold":
			player_gold += reward["amount"]
			reward_text = "+%dG" % reward["amount"]
		"stars":
			player_storybook_stars += reward["amount"]
			reward_text = "+%d Stars" % reward["amount"]
		"gold_chest":
			treasure_chests_owned["gold"] += 1
			reward_text = "+1 Gold Chest!"
	info_label.text = "Daily Reward: %s" % reward_text
	daily_streak += 1
	daily_last_claim = today
	daily_reward_claimed_today = true
	daily_reward_open = false
	total_daily_claims += 1
	_check_achievement("daily_devotee", 1)
	_save_game()
	queue_redraw()

func _update_menu_showcase() -> void:
	var arc_idx = menu_character_index
	var arc = arc_data[arc_idx]
	var arc_levels = arc["levels"]

	# Left page: arc info
	menu_level_name_label.text = arc["name"]
	var orig_char_names = ["Robin Hood", "Alice", "Wicked Witch", "Peter Pan", "Phantom", "Scrooge"]
	var orig_idx = orig_char_names.find(arc["name"])
	if orig_idx >= 0 and orig_idx < character_novels.size():
		menu_level_desc_label.text = character_novels[orig_idx]
		menu_level_stats_label.text = "\"%s\"" % character_quotes[orig_idx]
	elif arc.has("unlock_char"):
		menu_level_desc_label.text = "Rescue Arc"
		menu_level_stats_label.text = "Complete to unlock " + arc["name"]
	elif arc["name"] == "Prologue":
		menu_level_desc_label.text = "The Tome of Shadows"
		menu_level_stats_label.text = "\"Your story begins now.\""
	elif arc["name"] == "Shadow Author":
		menu_level_desc_label.text = "The Final Battle"
		menu_level_stats_label.text = "\"Every story must end.\""
	else:
		menu_level_desc_label.text = ""
		menu_level_stats_label.text = ""
	menu_level_stars_label.text = ""

	# Right page: chapter cards (up to 3)
	var num_chapters = mini(arc_levels.size(), 3)
	for i in range(3):
		if i < num_chapters:
			var level_idx = arc_levels[i]
			var level = levels[level_idx]
			var chap_num = ["I", "II", "III"]
			var diff_names = ["Easy", "Medium", "Hard"]
			var diff_colors = [Color(0.3, 0.8, 0.3), Color(0.8, 0.8, 0.2), Color(1.0, 0.4, 0.2)]

			chapter_title_labels[i].text = "Chapter %s \u2014 %s" % [chap_num[i], level["name"]]
			chapter_desc_labels[i].text = level["description"]
			chapter_stat_labels[i].text = "Gold: %d  |  Lives: %d" % [level["gold"], level["lives"]]

			# Stars
			if level_idx in completed_levels and level_stars.has(level_idx):
				var sv = level_stars[level_idx]
				var ss = ""
				for s in range(sv):
					ss += "\u2605"
				for s in range(3 - sv):
					ss += "\u2606"
				chapter_star_labels[i].text = ss
			else:
				chapter_star_labels[i].text = "\u2606\u2606\u2606"

			# Lock / difficulty buttons
			var unlocked = _is_level_unlocked(level_idx)
			if i < chapter_diff_buttons.size():
				for d in range(3):
					chapter_diff_buttons[i][d].disabled = not unlocked
					chapter_diff_buttons[i][d].visible = true
			chapter_lock_labels[i].text = diff_names[mini(i, 2)]
			chapter_lock_labels[i].add_theme_color_override("font_color", diff_colors[mini(i, 2)] if unlocked else Color(0.4, 0.35, 0.3))

			# Visibility
			chapter_title_labels[i].visible = true
			chapter_desc_labels[i].visible = true
			chapter_stat_labels[i].visible = true
			chapter_star_labels[i].visible = true
			chapter_lock_labels[i].visible = true
			if i < chapter_diff_buttons.size():
				for d in range(3):
					chapter_diff_buttons[i][d].visible = true
		else:
			# Hide unused chapter cards (e.g., prologue has only 1 level)
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			if i < chapter_diff_buttons.size():
				for d in range(3):
					chapter_diff_buttons[i][d].visible = false

	# Arrow state
	menu_left_arrow.disabled = arc_idx <= 0
	menu_right_arrow.disabled = arc_idx >= arc_data.size() - 1

	# Update star total
	var total_stars = 0
	for key in level_stars:
		total_stars += level_stars[key]
	menu_star_total_label.text = "â˜… %d / %d" % [total_stars, levels.size() * 3]

func _hide_chapter_diff_buttons(chapter_idx: int) -> void:
	if chapter_idx < chapter_diff_buttons.size():
		for d in range(3):
			chapter_diff_buttons[chapter_idx][d].visible = false

func _on_chapter_play(chapter: int, difficulty: int = 0) -> void:
	selected_difficulty = difficulty
	var arc = arc_data[menu_character_index]
	if chapter < arc["levels"].size():
		var level_idx = arc["levels"][chapter]
		_on_level_selected(level_idx)

func _on_menu_left() -> void:
	if menu_current_view == "survivors":
		return  # Grid doesn't use arrows
	else:
		if menu_character_index > 0:
			menu_character_index -= 1
			_update_menu_showcase()

func _on_menu_right() -> void:
	if menu_current_view == "survivors":
		return  # Grid doesn't use arrows
	else:
		if menu_character_index < arc_data.size() - 1:
			menu_character_index += 1
			_update_menu_showcase()

func _get_action_text() -> String:
	return "Tap" if _is_mobile else "Click"

func _get_safe_area_margins() -> Dictionary:
	var screen = DisplayServer.screen_get_size()
	var safe = DisplayServer.get_display_safe_area()
	return {
		"left": safe.position.x,
		"top": safe.position.y,
		"right": screen.x - safe.end.x,
		"bottom": screen.y - safe.end.y
	}

func _on_nav_pressed(nav_name: String) -> void:
	_play_sfx(_sfx_ui_click)
	if menu_current_view == "survivors" and nav_name != "survivors":
		_remove_survivor_preview()
		_clear_grid_previews()
		_remove_detail_preview()
		survivor_grid_container.visible = false
		survivor_detail_container.visible = false
		survivor_detail_open = false
	# Reset scroll positions when switching views
	relic_scroll_offset = 0.0
	binding_shop_scroll = 0.0
	detail_binding_scroll = 0.0
	menu_current_view = nav_name
	menu_transition_alpha = 0.0  # Trigger fade-in
	_menu_transition_alpha = 1.0  # Trigger dark overlay transition (enhancement #48)
	chapters_diff_popup_level = -1
	if nav_name == "chapters":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false

		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		# Hide old chapter UI — we draw everything procedurally now
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		story_map_scroll_y = 0.0
		queue_redraw()
	elif nav_name == "survivors":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
		survivor_detail_container.visible = false
		survivor_detail_open = false
	
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		# Hide chapter UI
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		queue_redraw()
	elif nav_name == "relics":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
	
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		relics_tab_hover_tier = -1
		relics_tab_hover_row = -1
		relics_tab_hover_col = -1
		queue_redraw()
	elif nav_name == "emporium":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
	
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		emporium_hover_index = -1
		queue_redraw()
	elif nav_name == "chronicles":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
	
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		chronicles_hover_branch = -1
		chronicles_hover_node = -1
		queue_redraw()
	elif nav_name == "achievements":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
	
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		queue_redraw()
	else:
		menu_showcase_panel.visible = true
		survivor_grid_container.visible = false
		menu_level_name_label.text = nav_name.to_upper()
		menu_level_desc_label.text = "Coming Soon!"
		menu_level_stats_label.text = "This feature is being written into the pages..."
		menu_level_stars_label.text = ""
	
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)

func _on_survivor_card_pressed(index: int) -> void:
	if index < 0 or index >= survivor_types.size():
		return
	var tower_type = survivor_types[index]
	if not _is_character_unlocked(tower_type):
		return  # Locked — do nothing
	survivor_selected_index = index
	_open_survivor_detail(index)
	queue_redraw()

func _open_survivor_detail(index: int) -> void:
	survivor_detail_index = index
	survivor_detail_open = true
	survivor_grid_container.visible = false
	survivor_detail_container.visible = true
	_clear_grid_previews()
	detail_hover_type = ""
	detail_hover_index = -1
	detail_info_overlay_open = false
	detail_info_close_hover = false
	relic_hover_index = -1
	relic_tooltip_visible = false

	# Create a preview of the tower for display
	_remove_detail_preview()
	var tower_type = survivor_types[index]
	survivor_detail_preview = tower_scenes[tower_type].instantiate()
	survivor_detail_preview.position = Vector2(210, 240)
	survivor_detail_preview.scale = Vector2(2.5, 2.5)
	survivor_detail_preview.process_mode = Node.PROCESS_MODE_DISABLED
	add_child(survivor_detail_preview)

	# Extract ability data from tower instance
	survivor_detail_abilities.clear()
	if survivor_detail_preview:
		var t_names = survivor_detail_preview.TIER_NAMES if survivor_detail_preview.get("TIER_NAMES") else []
		var t_descs = survivor_detail_preview.ABILITY_DESCRIPTIONS if survivor_detail_preview.get("ABILITY_DESCRIPTIONS") else []
		var t_costs = survivor_detail_preview.TIER_COSTS if survivor_detail_preview.get("TIER_COSTS") else []
		for i in range(t_names.size()):
			survivor_detail_abilities.append({
				"name": t_names[i] if i < t_names.size() else "Tier %d" % (i + 1),
				"desc": t_descs[i] if i < t_descs.size() else "",
				"cost": t_costs[i] if i < t_costs.size() else 0,
			})

	queue_redraw()

func _on_detail_back() -> void:
	survivor_detail_open = false
	survivor_detail_container.visible = false
	survivor_grid_container.visible = false
	relic_hover_index = -1
	relic_tooltip_visible = false
	detail_info_overlay_open = false
	detail_info_close_hover = false
	_remove_detail_preview()
	queue_redraw()

func _update_emporium_hover() -> void:
	var mouse_pos = get_viewport().get_mouse_position()
	if emporium_sub_open:
		_update_emporium_sub_hover(mouse_pos)
		return
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var tile_w = 340.0
	var tile_h = 220.0
	var gap_x = 30.0
	var gap_y = 24.0
	var grid_w = 3.0 * tile_w + 2.0 * gap_x
	var grid_start_x = panel_x + (panel_w - grid_w) * 0.5
	var grid_start_y = panel_y + 58.0
	emporium_hover_index = -1
	for i in range(emporium_categories.size()):
		var col_idx = i % 3
		var row = i / 3
		var tx = grid_start_x + float(col_idx) * (tile_w + gap_x)
		var ty = grid_start_y + float(row) * (tile_h + gap_y)
		if mouse_pos.x >= tx and mouse_pos.x <= tx + tile_w and mouse_pos.y >= ty and mouse_pos.y <= ty + tile_h:
			emporium_hover_index = i
			break

func _update_emporium_sub_hover(mouse_pos: Vector2) -> void:
	emporium_sub_hover = -1
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var item_w = 320.0
	var item_h = 130.0
	var gap = 20.0
	var start_y = panel_y + 130.0
	var max_cols = 3
	var total_items = 3
	if emporium_sub_category >= 0 and emporium_items.has(emporium_sub_category):
		total_items = emporium_items[emporium_sub_category].size()
	if total_items > max_cols:
		item_h = 110.0
	for i in range(total_items):
		var row_i = i / max_cols
		var col_i = i % max_cols
		var items_in_row = mini(max_cols, total_items - row_i * max_cols)
		var row_w = float(items_in_row) * item_w + float(items_in_row - 1) * gap
		var row_start_x = panel_x + (panel_w - row_w) * 0.5
		var ix = row_start_x + float(col_i) * (item_w + gap)
		var iy = start_y + float(row_i) * (item_h + 12.0)
		if mouse_pos.x >= ix and mouse_pos.x <= ix + item_w and mouse_pos.y >= iy and mouse_pos.y <= iy + item_h:
			emporium_sub_hover = i
			break

func _on_emporium_tile_clicked(index: int) -> void:
	if index < 0 or index >= emporium_categories.size():
		return
	emporium_sub_open = true
	emporium_sub_category = index
	emporium_sub_hover = -1
	emporium_sub_message = ""
	queue_redraw()

func _on_emporium_sub_clicked(item_index: int) -> void:
	if emporium_sub_category < 0 or not emporium_items.has(emporium_sub_category):
		return
	var items = emporium_items[emporium_sub_category]
	if item_index < 0 or item_index >= items.size():
		return
	var item = items[item_index]
	# Confirmation: first click shows "Tap again to confirm", second click buys
	if _emporium_confirm_index != item_index:
		_emporium_confirm_index = item_index
		_emporium_confirm_timer = 3.0
		emporium_sub_message = "Tap again to confirm: %s (%d %s)" % [item["name"], item["cost"], item["currency"]]
		emporium_sub_message_timer = 3.0
		_play_sfx(_sfx_ui_click)
		queue_redraw()
		return
	_emporium_confirm_index = -1
	_emporium_confirm_timer = 0.0
	var cost = item["cost"]
	var currency = item["currency"]
	# Check if player can afford
	var can_afford = false
	match currency:
		"quills":
			can_afford = player_quills >= cost
		"shards":
			can_afford = player_relic_shards >= cost
		"stars":
			can_afford = player_storybook_stars >= cost
		"gold":
			can_afford = player_gold >= cost
	if not can_afford:
		emporium_sub_message = "Not enough %s!" % currency.capitalize()
		emporium_sub_message_timer = 2.0
		queue_redraw()
		return
	# Deduct cost
	match currency:
		"quills":
			player_quills -= cost
		"shards":
			player_relic_shards -= cost
		"stars":
			player_storybook_stars -= cost
		"gold":
			player_gold -= cost
	# Grant reward
	var reward = item["reward"]
	var amount = item["amount"]
	match reward:
		"gold":
			player_gold += amount
		"quills":
			player_quills += amount
		"shards":
			player_relic_shards += amount
		"stars":
			player_storybook_stars += amount
		"chest_bronze":
			treasure_chests_owned["bronze"] += amount
		"chest_silver":
			treasure_chests_owned["silver"] += amount
		"chest_gold":
			treasure_chests_owned["gold"] += amount
		"xp":
			# Distribute XP evenly across all characters
			var per_char = int(float(amount) / float(survivor_types.size()))
			for t in survivor_types:
				if survivor_progress.has(t):
					survivor_progress[t]["xp"] += per_char
					while survivor_progress[t]["xp"] >= survivor_progress[t]["xp_next"] and survivor_progress[t]["level"] < MAX_SURVIVOR_LEVEL:
						survivor_progress[t]["xp"] -= survivor_progress[t]["xp_next"]
						survivor_progress[t]["level"] += 1
						survivor_progress[t]["xp_next"] = _get_xp_for_level(survivor_progress[t]["level"])
						_on_survivor_level_up(t, survivor_progress[t]["level"])
		"power":
			var pid = item.get("power_id", "")
			if pid != "":
				owned_powers[pid] = owned_powers.get(pid, 0) + amount
	emporium_sub_message = "Purchased!"
	emporium_sub_message_timer = 2.0
	_emporium_purchase_flash = 1.0  # Trigger purchase flash overlay
	total_emporium_purchases += 1
	_check_achievement("emporium_regular", 1)
	_save_game()
	queue_redraw()

func _on_emporium_back() -> void:
	emporium_sub_open = false
	emporium_sub_category = -1
	emporium_sub_hover = -1
	emporium_sub_message = ""
	queue_redraw()

func _on_emporium_sub_input(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button area (bottom-left)
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		_on_emporium_back()
		return
	# Item cards
	if emporium_sub_hover >= 0:
		_on_emporium_sub_clicked(emporium_sub_hover)
		return
	# Open chest buttons (only for category 3 = Relic Chests)
	if emporium_sub_category == 3:
		var open_y = panel_y + 290.0
		var tier_keys = ["bronze", "silver", "gold"]
		var open_total_w = 3.0 * 320.0 + 2.0 * 20.0
		var open_start_x = panel_x + (panel_w - open_total_w) * 0.5
		for ci in range(3):
			var count = treasure_chests_owned[tier_keys[ci]]
			if count > 0:
				var ox = open_start_x + float(ci) * 340.0
				if mouse_pos.x >= ox and mouse_pos.x <= ox + 320.0 and mouse_pos.y >= open_y and mouse_pos.y <= open_y + 36.0:
					treasure_chests_owned[tier_keys[ci]] -= 1
					_start_chest_opening(ci)
					return

func _update_relics_tab_hover() -> void:
	var mouse_pos = get_viewport().get_mouse_position()
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_h = 560.0
	var content_top = panel_y + 44.0
	var content_bottom = panel_y + panel_h - 28.0
	var grid_left = panel_x + 18.0
	var card_w = 260.0
	var card_h = 50.0
	var card_gap_x = 10.0
	var card_gap_y = 6.0
	relics_tab_hover_tier = -1
	relics_tab_hover_row = -1
	relics_tab_hover_col = -1
	# Only detect hovers within content area
	if mouse_pos.y < content_top or mouse_pos.y > content_bottom:
		return
	var rarity_order = ["tattered", "bound", "gilded", "mythic", "forbidden"]
	var section_y = content_top - relic_scroll_offset
	for tier in range(rarity_order.size()):
		var rarity = rarity_order[tier]
		var trinket_count = 0
		for b in TOME_BINDINGS:
			if b["rarity"] == rarity:
				trinket_count += 1
		var row_y = section_y + 24.0
		var rows_needed = (trinket_count + 3) / 4
		for row in range(rows_needed):
			for col in range(4):
				var ti = row * 4 + col
				if ti >= trinket_count:
					continue
				var cx = grid_left + float(col) * (card_w + card_gap_x)
				var cy = row_y + float(row) * (card_h + card_gap_y)
				if cy + card_h < content_top or cy > content_bottom:
					continue
				if mouse_pos.x >= cx and mouse_pos.x <= cx + card_w and mouse_pos.y >= cy and mouse_pos.y <= cy + card_h:
					relics_tab_hover_tier = tier
					relics_tab_hover_row = row
					relics_tab_hover_col = col
					return
		var section_height = 24.0 + float(rows_needed) * (card_h + card_gap_y) + 12.0
		section_y += section_height

func _update_detail_hover() -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var mouse_pos = get_viewport().get_mouse_position()
	var old_type = detail_hover_type
	var old_idx = detail_hover_index
	detail_hover_type = ""
	detail_hover_index = -1
	# Layout coordinates must match _draw_survivor_detail()
	var panel_x = 70.0
	var panel_y = 38.0
	var top_y = panel_y + 8.0
	var content_y = top_y + 38.0
	var left_x = panel_x + 20.0
	var port_x = left_x
	var port_w = 240.0
	var port_h = 250.0
	var xp_h = 20.0
	var xp_y = content_y + port_h + 6.0
	var levelup_btn_h = 22.0
	var right_x = panel_x + 310.0
	var slot_size = 72.0
	var gear_sy = content_y + 24.0
	var sk_x = right_x + slot_size + 50.0
	var sk_slot_y = content_y + 24.0
	var sk_levels = [3, 5, 8]
	var rel_y = gear_sy + slot_size + 44.0
	var relic_slot_y = rel_y + 24.0
	var relic_slot_size = 72.0
	var relic_gap = 12.0
	# Check level-up button (below XP bar)
	var levelup_btn_y = xp_y + xp_h
	if Rect2(port_x, levelup_btn_y, port_w, levelup_btn_h).has_point(mouse_pos):
		detail_hover_type = "levelup"
		detail_hover_index = 0
		if old_type != detail_hover_type or old_idx != detail_hover_index:
			queue_redraw()
		return
	# Check info overlay "i" icon
	if mouse_pos.distance_to(Vector2(port_x + 22, content_y + port_h - 22)) <= 14.0:
		detail_hover_type = "info_icon"
		detail_hover_index = 0
		if old_type != detail_hover_type or old_idx != detail_hover_index:
			queue_redraw()
		return
	# Check golden shield upgrade button (inside info overlay)
	if detail_info_overlay_open and _gs_upgrade_btn_rect.size.x > 0 and _gs_upgrade_btn_rect.has_point(mouse_pos):
		detail_hover_type = "golden_shield"
		detail_hover_index = 0
		if old_type != detail_hover_type or old_idx != detail_hover_index:
			queue_redraw()
		return
	# Check ability entries (right of relics)
	var abil_x = right_x + 270.0
	var abil_entry_y = rel_y + 30.0
	var abil_entry_h = 48.0
	var abil_w = 520.0
	for ai in range(mini(survivor_detail_abilities.size(), 4)):
		var ay = abil_entry_y + float(ai) * abil_entry_h
		if Rect2(abil_x - 4, ay - 2, abil_w, abil_entry_h - 4).has_point(mouse_pos):
			detail_hover_type = "ability"
			detail_hover_index = ai
			if old_type != detail_hover_type or old_idx != detail_hover_index:
				queue_redraw()
			return
	# Check weapon slot
	if Rect2(right_x, gear_sy, slot_size, slot_size).has_point(mouse_pos):
		detail_hover_type = "weapon"
		detail_hover_index = 0
		if old_type != detail_hover_type or old_idx != detail_hover_index:
			queue_redraw()
		return
	# Check sidekick slots
	for si in range(3):
		var sx = sk_x + float(si) * (slot_size + 14.0)
		if Rect2(sx, sk_slot_y, slot_size, slot_size).has_point(mouse_pos):
			detail_hover_type = "sidekick"
			detail_hover_index = si
			if old_type != detail_hover_type or old_idx != detail_hover_index:
				queue_redraw()
			return
	# Check relic slots (2 rows × 3 cols)
	var tower_type = survivor_types[survivor_detail_index]
	var char_relics = survivor_relics.get(tower_type, [])
	for ri in range(mini(char_relics.size(), 6)):
		var r_row = ri / 3
		var r_col = ri % 3
		var rx = right_x + float(r_col) * (relic_slot_size + relic_gap)
		var ry = relic_slot_y + float(r_row) * (relic_slot_size + 24.0)
		if Rect2(rx, ry, relic_slot_size, relic_slot_size).has_point(mouse_pos):
			detail_hover_type = "relic"
			detail_hover_index = ri
			if old_type != detail_hover_type or old_idx != detail_hover_index:
				queue_redraw()
			return
	if old_type != "" or old_idx >= 0:
		queue_redraw()

func _update_relic_hover() -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var mouse_pos = get_viewport().get_mouse_position()
	# Coordinates must match _draw_survivor_detail()
	var panel_x = 70.0
	var panel_y = 38.0
	var top_y = panel_y + 8.0
	var content_y = top_y + 38.0
	var right_x = panel_x + 310.0
	var slot_size = 72.0
	var gear_sy = content_y + 24.0
	var rel_y = gear_sy + slot_size + 44.0
	var relic_slot_y = rel_y + 24.0
	var relic_slot_size = 72.0
	var relic_gap = 12.0
	var tower_type = survivor_types[survivor_detail_index]
	var char_relics = survivor_relics.get(tower_type, [])
	var old_hover = relic_hover_index
	relic_hover_index = -1
	for ri in range(mini(char_relics.size(), 6)):
		var r_row = ri / 3
		var r_col = ri % 3
		var rx = right_x + float(r_col) * (relic_slot_size + relic_gap)
		var ry = relic_slot_y + float(r_row) * (relic_slot_size + 24.0)
		if Rect2(rx, ry, relic_slot_size, relic_slot_size).has_point(mouse_pos):
			relic_hover_index = ri
			break
	# Update tooltip labels
	if relic_hover_index != old_hover:
		var relic_tt_name_lbl = survivor_detail_container.get_node("RelicTooltipName")
		var relic_tt_desc_lbl = survivor_detail_container.get_node("RelicTooltipDesc")
		if relic_hover_index >= 0 and relic_hover_index < char_relics.size():
			var relic_data = char_relics[relic_hover_index]
			var progress = survivor_progress.get(tower_type, {})
			var rel_unlocked = progress.get("relics_unlocked", [false, false, false, false, false, false])
			var is_unlocked = rel_unlocked[relic_hover_index] if relic_hover_index < rel_unlocked.size() else false
			var relic_purchasable = [false, true, false, true, false, true]
			var relic_costs = [0, 100, 0, 250, 0, 500]
			var relic_earn_levels = [2, 4, 6, 8, 10, 12]
			var char_level = progress.get("level", 1)
			var name_text = relic_data["name"]
			if is_unlocked:
				var eq_list = equipped_relics.get(tower_type, [])
				if relic_hover_index in eq_list:
					name_text += "  [EQUIPPED - Click to unequip]"
				else:
					var max_slots = _get_relic_slots(char_level)
					if eq_list.size() < max_slots:
						name_text += "  [OWNED - Click to equip]"
					else:
						name_text += "  [OWNED - Slots full]"
			elif relic_purchasable[relic_hover_index] and char_level >= relic_earn_levels[relic_hover_index]:
				name_text += "  [BUY: %d gold]" % relic_costs[relic_hover_index]
			elif char_level < relic_earn_levels[relic_hover_index]:
				name_text += "  [Lv.%d]" % relic_earn_levels[relic_hover_index]
			if relic_tt_name_lbl:
				relic_tt_name_lbl.text = name_text
				relic_tt_name_lbl.visible = true
			if relic_tt_desc_lbl:
				relic_tt_desc_lbl.text = relic_data["desc"]
				relic_tt_desc_lbl.visible = true
			relic_tooltip_visible = true
		else:
			if relic_tt_name_lbl:
				relic_tt_name_lbl.visible = false
			if relic_tt_desc_lbl:
				relic_tt_desc_lbl.visible = false
			relic_tooltip_visible = false

func _on_relic_clicked(relic_index: int) -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var tower_type = survivor_types[survivor_detail_index]
	var progress = survivor_progress.get(tower_type, {})
	var rel_unlocked = progress.get("relics_unlocked", [false, false, false, false, false, false])
	if relic_index < 0 or relic_index >= rel_unlocked.size():
		return
	# If already owned — toggle equip/unequip
	if rel_unlocked[relic_index]:
		if not equipped_relics.has(tower_type):
			equipped_relics[tower_type] = []
		var eq = equipped_relics[tower_type]
		if relic_index in eq:
			eq.erase(relic_index)
		else:
			var max_slots = _get_relic_slots(progress.get("level", 1))
			if eq.size() < max_slots:
				eq.append(relic_index)
		_save_game()
		queue_redraw()
		return
	# Not yet owned — try to purchase
	var relic_purchasable = [false, true, false, true, false, true]
	var relic_costs = [0, 100, 0, 250, 0, 500]
	var relic_earn_levels = [2, 4, 6, 8, 10, 12]
	var char_level = progress.get("level", 1)
	if not relic_purchasable[relic_index]:
		return
	if char_level < relic_earn_levels[relic_index]:
		return
	var cost = relic_costs[relic_index]
	if player_gold < cost:
		return
	player_gold -= cost
	progress["relics_unlocked"][relic_index] = true
	_save_game()
	_open_survivor_detail(survivor_detail_index)

func _on_detail_item_clicked(mouse_pos: Vector2) -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var tower_type = survivor_types[survivor_detail_index]
	var progress = survivor_progress.get(tower_type, {})
	var char_level = progress.get("level", 1)
	# Layout coordinates must match _draw_survivor_detail() and _update_detail_hover()
	var panel_x = 70.0
	var panel_y = 38.0
	var top_y = panel_y + 8.0
	var content_y = top_y + 38.0
	var right_x = panel_x + 310.0
	var slot_size = 72.0
	var gear_sy = content_y + 24.0
	var sk_x = right_x + slot_size + 50.0
	var sk_slot_y = content_y + 24.0
	var rel_y = gear_sy + slot_size + 44.0
	var relic_slot_y = rel_y + 24.0
	var relic_slot_size = 72.0
	var relic_gap = 12.0
	var left_x = panel_x + 20.0
	var port_x = left_x
	var port_w = 240.0
	var port_h = 250.0
	var xp_y = content_y + port_h + 6.0
	var xp_h = 20.0
	# --- Check info overlay toggle (if overlay is open, handle close first) ---
	if detail_info_overlay_open:
		var ov_w = 700.0
		var ov_h = 400.0
		var ov_x = 70.0 + (1140.0 - ov_w) * 0.5
		var ov_y = 38.0 + (570.0 - ov_h) * 0.5
		# Close button (X) in top-right corner
		if mouse_pos.distance_to(Vector2(ov_x + ov_w - 16, ov_y + 16)) <= 14.0:
			detail_info_overlay_open = false
			queue_redraw()
			return
		# Click outside overlay to close
		if not Rect2(ov_x, ov_y, ov_w, ov_h).has_point(mouse_pos):
			detail_info_overlay_open = false
			queue_redraw()
			return
		# Check Golden Shield upgrade button click
		if _gs_upgrade_btn_rect.size.x > 0 and _gs_upgrade_btn_rect.has_point(mouse_pos):
			if _upgrade_golden_shield(tower_type):
				_open_survivor_detail(survivor_detail_index)
			return
		# Click inside overlay — absorb the click
		return
	# --- Check "i" icon click (toggle info overlay) ---
	if mouse_pos.distance_to(Vector2(port_x + 22, content_y + port_h - 22)) <= 14.0:
		detail_info_overlay_open = true
		queue_redraw()
		return
	# --- Check LEVEL UP button click ---
	var levelup_btn_y = xp_y + xp_h
	var levelup_btn_h = 22.0
	if char_level < MAX_SURVIVOR_LEVEL and Rect2(port_x, levelup_btn_y, port_w, levelup_btn_h).has_point(mouse_pos):
		var lvup_cost = _get_levelup_cost(char_level)
		if player_quills >= lvup_cost:
			player_quills -= lvup_cost
			progress["level"] = char_level + 1
			progress["xp"] = 0.0
			progress["xp_next"] = _get_xp_for_level(char_level + 1)
			# Unlock gear at level 2
			if char_level + 1 >= 2 and not progress.get("gear_unlocked", false):
				progress["gear_unlocked"] = true
			# Unlock sidekicks at levels 3, 5, 8
			var sk_unlock_levels = [3, 5, 8]
			for si in range(3):
				if char_level + 1 >= sk_unlock_levels[si]:
					var sk_arr = progress.get("sidekicks_unlocked", [false, false, false])
					if si < sk_arr.size() and not sk_arr[si]:
						sk_arr[si] = true
						progress["sidekicks_unlocked"] = sk_arr
			_save_game()
			_open_survivor_detail(survivor_detail_index)
		return
	# --- Check character-specific relic clicks (2 rows × 3 cols) ---
	var char_relics = survivor_relics.get(tower_type, [])
	var rel_unlocked_arr = progress.get("relics_unlocked", [false, false, false, false, false, false])
	var relic_purchasable = [false, true, false, true, false, true]
	var relic_costs = [0, 100, 0, 250, 0, 500]
	var relic_earn_levels = [2, 4, 6, 8, 10, 12]
	for ri in range(mini(char_relics.size(), 6)):
		var r_row = ri / 3
		var r_col = ri % 3
		var rx = right_x + float(r_col) * (relic_slot_size + relic_gap)
		var ry = relic_slot_y + float(r_row) * (relic_slot_size + 24.0)
		if Rect2(rx, ry, relic_slot_size, relic_slot_size).has_point(mouse_pos):
			var is_unlocked = rel_unlocked_arr[ri] if ri < rel_unlocked_arr.size() else false
			if is_unlocked:
				# Toggle equip/unequip
				if not equipped_relics.has(tower_type):
					equipped_relics[tower_type] = []
				var eq = equipped_relics[tower_type]
				if ri in eq:
					eq.erase(ri)
				else:
					var max_slots = _get_relic_slots(char_level)
					if eq.size() < max_slots:
						eq.append(ri)
				_save_game()
				queue_redraw()
			elif relic_purchasable[ri] and char_level >= relic_earn_levels[ri]:
				# Purchase with persistent gold
				var cost = relic_costs[ri]
				if player_gold >= cost:
					player_gold -= cost
					progress["relics_unlocked"][ri] = true
					_save_game()
					queue_redraw()
			return
	# --- Check Tome Binding clicks (slots + owned list) ---
	var bind_slots = _get_binding_slots(tower_type)
	if bind_slots > 0:
		var eq_bindings = equipped_bindings.get(tower_type, [])
		# Tome binding slot area
		var relic_desc_y = relic_slot_y + 2.0 * (relic_slot_size + 24.0) + 4.0
		var tome_y = relic_desc_y + 18.0
		var tome_slot_y = tome_y + 22.0
		var tome_slot_size = 44.0
		for tsi in range(bind_slots):
			var tx = right_x + float(tsi) * (tome_slot_size + 8)
			var ty = tome_slot_y
			if Rect2(tx, ty, tome_slot_size, tome_slot_size).has_point(mouse_pos):
				if tsi < eq_bindings.size():
					eq_bindings.remove_at(tsi)
					equipped_bindings[tower_type] = eq_bindings
					_save_game()
					queue_redraw()
				return
		# Owned bindings list (with scroll offset)
		var browse_y = tome_slot_y + tome_slot_size + 6.0
		var bcol = 0
		var brow = 0
		var card_w = 200.0
		var card_h = 36.0
		for b in TOME_BINDINGS:
			var count = owned_bindings.get(b["id"], 0)
			if count <= 0:
				continue
			var bx = right_x + float(bcol) * (card_w + 8)
			var by = browse_y + float(brow) * (card_h + 3) - detail_binding_scroll
			if by >= browse_y - card_h and by <= panel_y + 570.0 - 20:
				if Rect2(bx, by, card_w, card_h).has_point(mouse_pos):
					var is_eq = b["id"] in eq_bindings
					if is_eq:
						eq_bindings.erase(b["id"])
					elif eq_bindings.size() < bind_slots:
						eq_bindings.append(b["id"])
					equipped_bindings[tower_type] = eq_bindings
					_save_game()
					queue_redraw()
					return
			bcol += 1
			if bcol >= 3:
				bcol = 0
				brow += 1

func _on_trinket_slot_clicked(mouse_pos: Vector2) -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var tower_type = survivor_types[survivor_detail_index]
	var bind_slots = _get_binding_slots(tower_type)
	if bind_slots <= 0:
		return
	var eq_bindings = equipped_bindings.get(tower_type, [])

	# Layout coordinates must match _draw_survivor_detail()
	var panel_x = 70.0
	var panel_y = 38.0
	var top_y = panel_y + 8.0
	var content_y = top_y + 38.0
	var right_x = panel_x + 340.0
	var slot_size = 64.0

	# Calculate relic section Y: gear(64) + 20 gap + ally header(24) + ally slots(64) + 30 gap
	var gear_sy = content_y + 24.0
	var ally_slot_y = gear_sy + slot_size + 20.0 + 24.0
	var relic_slot_y = ally_slot_y + slot_size + 30.0 + 24.0
	var relic_slot_size = 56.0

	# Check clicks on the 5 relic SLOTS (top row)
	for ri in range(5):
		var rx = right_x + float(ri) * (relic_slot_size + 12.0)
		var ry = relic_slot_y
		if mouse_pos.x >= rx and mouse_pos.x <= rx + relic_slot_size and mouse_pos.y >= ry and mouse_pos.y <= ry + relic_slot_size:
			var slot_unlocked = ri < bind_slots
			if slot_unlocked and ri < eq_bindings.size():
				# Unequip this relic
				eq_bindings.remove_at(ri)
				equipped_bindings[tower_type] = eq_bindings
				_save_game()
				queue_redraw()
			return

	# Check clicks on owned relics browser (below slots, with scroll offset)
	var browse_y = relic_slot_y + relic_slot_size + 20.0 + 14.0
	var card_w = 200.0
	var card_h = 32.0
	var trinket_col = 0
	var trinket_row = 0
	for b in TOME_BINDINGS:
		var count = owned_bindings.get(b["id"], 0)
		if count <= 0:
			continue
		var tx = right_x + float(trinket_col) * (card_w + 8)
		var ty = browse_y + float(trinket_row) * (card_h + 4) - detail_binding_scroll
		if mouse_pos.x >= tx and mouse_pos.x <= tx + card_w and mouse_pos.y >= ty and mouse_pos.y <= ty + card_h:
			if ty >= browse_y - card_h and ty <= panel_y + 560.0:
				var is_eq = b["id"] in eq_bindings
				if is_eq:
					eq_bindings.erase(b["id"])
					equipped_bindings[tower_type] = eq_bindings
				elif eq_bindings.size() < bind_slots:
					eq_bindings.append(b["id"])
					equipped_bindings[tower_type] = eq_bindings
				_save_game()
				queue_redraw()
				return
		trinket_col += 1
		if trinket_col >= 3:
			trinket_col = 0
			trinket_row += 1

func _remove_detail_preview() -> void:
	if survivor_detail_preview and is_instance_valid(survivor_detail_preview):
		survivor_detail_preview.queue_free()
		survivor_detail_preview = null

func _remove_survivor_preview() -> void:
	_remove_detail_preview()
	_clear_grid_previews()
	if survivor_preview_node and is_instance_valid(survivor_preview_node):
		survivor_preview_node.queue_free()
		survivor_preview_node = null

func _spawn_grid_previews() -> void:
	_clear_grid_previews()
	var card_w = 310.0
	var card_h = 210.0
	var grid_margin_x = 65.0
	var grid_margin_y = 65.0
	var gap_x = 40.0
	var gap_y = 30.0
	var panel_x = 70.0
	var panel_y = 45.0
	for i in range(survivor_types.size()):
		var col_i = i % 3
		var row_i = i / 3
		var cx = panel_x + grid_margin_x + float(col_i) * (card_w + gap_x)
		var cy = panel_y + grid_margin_y + float(row_i) * (card_h + gap_y)
		var tower_type = survivor_types[i]
		if not tower_scenes.has(tower_type):
			continue
		var preview = tower_scenes[tower_type].instantiate()
		preview.position = Vector2(cx + 70, cy + 115)
		preview.scale = Vector2(1.8, 1.8)
		preview.process_mode = Node.PROCESS_MODE_DISABLED
		add_child(preview)
		survivor_grid_previews.append(preview)

func _clear_grid_previews() -> void:
	for p in survivor_grid_previews:
		if is_instance_valid(p):
			p.queue_free()
	survivor_grid_previews.clear()

func _is_level_unlocked(idx: int) -> bool:
	if idx == 0:
		return true
	return (idx - 1) in completed_levels

func _on_level_selected(index: int) -> void:
	if not _is_level_unlocked(index):
		return
	# Check for pre-level story dialog
	var pre_key = "pre_level_" + str(index)
	if story_dialogs.has(pre_key) and not pre_key in story_seen:
		# Also check for act intro dialogs that should play first
		var act_key = ""
		if index == 16 and not "act2_intro" in story_seen:
			act_key = "act2_intro"
		_pending_level_start = index
		if act_key != "":
			story_state.queued_dialog = pre_key
			_start_story_dialog(act_key)
		else:
			_start_story_dialog(pre_key)
		return
	_do_level_start(index)

var _pending_level_start: int = -1

func _do_level_start(index: int) -> void:
	_remove_survivor_preview()
	current_level = index
	_reset_game()
	var level = levels[index]
	gold = level["gold"] + difficulty_gold_bonus[mini(selected_difficulty, 3)] + int(_get_knowledge_bonus("start_gold")) + prestige_level * 2
	lives = difficulty_fixed_lives[mini(selected_difficulty, 3)] + int(_get_knowledge_bonus("lives"))
	# Pure Mode restrictions
	if selected_difficulty == PURE_MODE:
		lives = 1
		gold = max(0, gold)  # Ensure non-negative after -20 penalty
	# BATTD2: Apply challenge handicaps
	_apply_handicaps()
	total_waves = difficulty_waves[mini(selected_difficulty, 3)]
	_setup_path_for_level(index)
	_generate_decorations_for_level(index)
	# BATTD: Generate bounties for this level
	_generate_bounties()
	# BATTD: Generate map collectibles
	_generate_map_collectibles()
	# BATTD2: Generate storybook page position for this level
	var page_rng = RandomNumberGenerator.new()
	page_rng.seed = index * 54321 + 98765
	_level_page_pos = Vector2(page_rng.randf_range(100.0, 1180.0), page_rng.randf_range(120.0, 580.0))
	_level_page_collected = storybook_pages_found.get(str(index), false)
	# BATTD2: Reset path traps and overcharge
	_path_traps.clear()
	_placing_trap = -1
	_overcharged_tower = null
	_overcharge_timer = 0.0
	_blessing_active = false
	_blessing_timer = 0.0
	_path_events.clear()
	_path_event_cooldown = PATH_EVENT_INTERVAL * 0.5
	_intel_target = null
	_sacrifice_mode = false
	_multi_wave_active = false
	# BATTD2: Generate handicap bonus multiplier
	_handicap_bonus_mult = 1.0
	for h in _handicaps_active:
		_handicap_bonus_mult *= h.get("reward_mult", 1.0)
	_collectibles_found_this_game = 0
	_lucky_drops_this_game = 0
	# BATTD: Reset placement streak
	_placement_streak_count = 0
	_placement_streak_timer = 0.0
	# BATTD: Double Cash unlock check (prestige 3+)
	if prestige_level >= 3:
		double_cash_unlocked = true
	_init_env_particles()
	_stop_music()
	_start_layered_music(index)
	menu_overlay.visible = false
	top_bar.visible = true
	bottom_panel.visible = true
	game_over_label.visible = false
	return_button.visible = false
	game_state = GameState.PLAYING
	start_button.text = "  START WAVE  "
	tower_buttons[TowerType.ROBIN_HOOD].text = "Robin [%dG]" % _get_discounted_cost(TowerType.ROBIN_HOOD)
	tower_buttons[TowerType.ROBIN_HOOD].disabled = false
	tower_buttons[TowerType.ALICE].text = "Alice [%dG]" % _get_discounted_cost(TowerType.ALICE)
	tower_buttons[TowerType.ALICE].disabled = false
	tower_buttons[TowerType.WICKED_WITCH].text = "Witch [%dG]" % _get_discounted_cost(TowerType.WICKED_WITCH)
	tower_buttons[TowerType.WICKED_WITCH].disabled = false
	tower_buttons[TowerType.PETER_PAN].text = "Peter [%dG]" % _get_discounted_cost(TowerType.PETER_PAN)
	tower_buttons[TowerType.PETER_PAN].disabled = false
	tower_buttons[TowerType.PHANTOM].text = "Phantom [%dG]" % _get_discounted_cost(TowerType.PHANTOM)
	tower_buttons[TowerType.PHANTOM].disabled = false
	tower_buttons[TowerType.SCROOGE].text = "Scrooge [%dG]" % _get_discounted_cost(TowerType.SCROOGE)
	tower_buttons[TowerType.SCROOGE].disabled = false
	# Show unlocked character buttons — row 2, stretched horizontally
	var new_char_order = [TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA, TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR]
	var new_char_labels = {
		TowerType.SHERLOCK: "Holmes [%dG]" % _get_discounted_cost(TowerType.SHERLOCK),
		TowerType.TARZAN: "Tarzan [%dG]" % _get_discounted_cost(TowerType.TARZAN),
		TowerType.DRACULA: "Dracula [%dG]" % _get_discounted_cost(TowerType.DRACULA),
		TowerType.MERLIN: "Merlin [%dG]" % _get_discounted_cost(TowerType.MERLIN),
		TowerType.FRANKENSTEIN: "Monster [%dG]" % _get_discounted_cost(TowerType.FRANKENSTEIN),
		TowerType.SHADOW_AUTHOR: "Author [%dG]" % _get_discounted_cost(TowerType.SHADOW_AUTHOR),
	}
	var new_visible_count := 0
	for tt in new_char_order:
		if tower_buttons.has(tt):
			if tt in survivor_types and _is_character_unlocked(tt):
				var bx = 8 + new_visible_count * 158
				tower_buttons[tt].position = Vector2(bx, 42)
				tower_buttons[tt].visible = true
				tower_buttons[tt].text = new_char_labels[tt]
				tower_buttons[tt].disabled = false
				new_visible_count += 1
			else:
				tower_buttons[tt].visible = false
	# Panel height: 2 rows if unlocked chars, 1 row if not
	if new_visible_count > 0:
		bottom_panel.size.y = 80
		bottom_panel.position.y = 720 - 80
	else:
		bottom_panel.size.y = 42
		bottom_panel.position.y = 720 - 42
	start_button.visible = true
	start_button.disabled = false
	speed_button.visible = true
	update_hud()
	var diff_name = ["Easy", "Medium", "Hard", "Pure"][mini(selected_difficulty, 3)]
	info_label.text = level["name"] + " (%s) - Place your towers!" % diff_name
	wave_auto_timer = -1.0
	# Show power selection if player has any powers
	var has_any_powers = false
	for bp in battle_power_definitions:
		if owned_powers.get(bp["id"], 0) > 0:
			has_any_powers = true
			break
	if has_any_powers and not odyssey_active:
		_open_power_selection()

func _reset_game() -> void:
	for tower in get_tree().get_nodes_in_group("towers"):
		tower.queue_free()
	for enemy in get_tree().get_nodes_in_group("enemies"):
		enemy.queue_free()
	wave = 0
	is_wave_active = false
	game_paused = false
	placing_tower = false
	enemies_to_spawn = 0
	enemies_alive = 0
	spawn_timer = 0.0
	purchased_towers.clear()
	placed_tower_positions.clear()
	selected_tower_node = null
	wave_auto_timer = -1.0
	_hide_upgrade_panel()
	# Reset session damage tracking
	for t in survivor_types:
		session_damage[t] = 0.0
	# Reset per-game achievement tracking
	current_game_lives_lost = 0
	current_game_fast_forward_only = true
	# Reset battle power state
	storybook_shield_charges = 0
	power_enchanted_timer = 0.0
	active_power_effects.clear()
	# Reset combo, undo, wave preview
	combo_count = 0
	combo_timer = 0.0
	undo_tower_data.clear()
	if is_instance_valid(undo_button):
		undo_button.visible = false
	wave_preview_active = false
	boss_rush_mode = false
	boss_rush_wave = 0
	daily_challenge_active = false
	# Reset floating texts and death effects
	_floating_texts.clear()
	_screen_shake_timer = 0.0
	# Reset placed instruments and branch choices
	placed_instruments.clear()
	tower_branch_choice.clear()
	_placing_instrument = ""
	_instrument_picker_open = false
	_screen_shake_intensity = 0.0
	_screen_shake_offset = Vector2.ZERO
	_ink_splatters.clear()
	_death_flash_timer = 0.0
	# Reset visual polish effects
	_aoe_impacts.clear()
	_crit_flashes.clear()
	_build_effects.clear()
	_victory_burst_timer = 0.0
	_victory_particles.clear()
	_defeat_timer = 0.0
	_defeat_cracks.clear()
	_spawn_portal_intensity = 0.0
	_env_particles.clear()
	_wave_banner_timer = 0.0
	_gold_pickups.clear()
	_gold_pickup_flash = 0.0
	# Reset boss rescue animation
	boss_rescue_active = false
	boss_rescue_timer = 0.0
	boss_rescue_boss_ref = null
	boss_rescue_phase = 0
	_rescue_smoke_particles.clear()

func _setup_path_for_level(index: int) -> void:
	var curve = enemy_path.curve
	if not curve:
		return
	curve.clear_points()
	match index:
		0: # Prologue — Into the Pages (Easy/Tutorial — spiral inward, falling into book)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 320), Vector2(-60, 0), Vector2(0, -120))
			curve.add_point(Vector2(200, 100), Vector2(0, 60), Vector2(120, 0))
			curve.add_point(Vector2(1080, 100), Vector2(-100, 0), Vector2(0, 120))
			curve.add_point(Vector2(1080, 540), Vector2(0, -100), Vector2(-120, 0))
			curve.add_point(Vector2(300, 540), Vector2(100, 0), Vector2(0, -100))
			curve.add_point(Vector2(300, 200), Vector2(0, 80), Vector2(100, 0))
			curve.add_point(Vector2(960, 200), Vector2(-80, 0), Vector2(0, 100))
			curve.add_point(Vector2(960, 460), Vector2(0, -80), Vector2(-100, 0))
			curve.add_point(Vector2(420, 460), Vector2(80, 0), Vector2(0, -80))
			curve.add_point(Vector2(420, 280), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(840, 280), Vector2(-60, 0), Vector2(0, 60))
			curve.add_point(Vector2(840, 380), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(640, 340), Vector2(40, 0), Vector2(0, 80))
			curve.add_point(Vector2(640, 670))
		1: # Sherlock Ch1 — Baker Street (EASY — long city grid zigzag, 4 full passes)
			curve.add_point(Vector2(-50, 100), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(200, 100), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(640, 120), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 100), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 220), Vector2(0, -30), Vector2(-60, 0))
			curve.add_point(Vector2(640, 240), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 220), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 340), Vector2(0, -30), Vector2(60, 0))
			curve.add_point(Vector2(640, 360), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 340), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 460), Vector2(0, -30), Vector2(-60, 0))
			curve.add_point(Vector2(640, 480), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 460), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 560), Vector2(0, -30), Vector2(60, 0))
			curve.add_point(Vector2(640, 580), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 580))
		2: # Sherlock Ch2 — Whitechapel (MEDIUM — winding alleyway, diagonal S-curves)
			curve.add_point(Vector2(-50, 520), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 520), Vector2(-40, 0), Vector2(60, -80))
			curve.add_point(Vector2(320, 360), Vector2(0, 60), Vector2(60, -40))
			curve.add_point(Vector2(480, 260), Vector2(-40, 40), Vector2(60, 0))
			curve.add_point(Vector2(640, 320), Vector2(-40, 0), Vector2(60, 60))
			curve.add_point(Vector2(780, 480), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(920, 420), Vector2(-40, 0), Vector2(40, -60))
			curve.add_point(Vector2(1000, 260), Vector2(0, 50), Vector2(40, -60))
			curve.add_point(Vector2(1060, 140), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(1200, 200), Vector2(-40, 0), Vector2(60, 40))
			curve.add_point(Vector2(1330, 300))
		3: # Sherlock Ch3 — Reichenbach Falls (HARD — short switchback descent)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 120), Vector2(0, -40), Vector2(-120, 0))
			curve.add_point(Vector2(200, 200), Vector2(80, 0), Vector2(0, 80))
			curve.add_point(Vector2(200, 380), Vector2(0, -40), Vector2(120, 0))
			curve.add_point(Vector2(1060, 440), Vector2(-100, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 560), Vector2(0, -40), Vector2(-120, 0))
			curve.add_point(Vector2(640, 670))
		4: # Merlin Ch1 — Round Table (EASY — large oval loop + inner spiral)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(120, 320), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(120, 100), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(640, 80), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(1140, 100), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(1140, 320), Vector2(0, -60), Vector2(0, 80))
			curve.add_point(Vector2(1140, 540), Vector2(0, -60), Vector2(-80, 0))
			curve.add_point(Vector2(640, 560), Vector2(80, 0), Vector2(-80, 0))
			curve.add_point(Vector2(240, 540), Vector2(60, 0), Vector2(0, -60))
			curve.add_point(Vector2(240, 400), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(500, 380), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(900, 380), Vector2(-60, 0), Vector2(0, -60))
			curve.add_point(Vector2(900, 220), Vector2(0, 40), Vector2(-60, 0))
			curve.add_point(Vector2(500, 200), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(500, 320), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(740, 300), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(740, 670))
		5: # Merlin Ch2 — Enchanted Forest (MEDIUM — flowing S-curves)
			curve.add_point(Vector2(-50, 200), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 200), Vector2(-40, 0), Vector2(60, 80))
			curve.add_point(Vector2(300, 400), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(480, 440), Vector2(-40, 0), Vector2(60, -60))
			curve.add_point(Vector2(600, 280), Vector2(0, 40), Vector2(60, -40))
			curve.add_point(Vector2(720, 160), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(860, 200), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(940, 420), Vector2(0, -60), Vector2(60, 40))
			curve.add_point(Vector2(1060, 520), Vector2(-40, -20), Vector2(60, 0))
			curve.add_point(Vector2(1180, 480), Vector2(-40, 0), Vector2(60, -40))
			curve.add_point(Vector2(1330, 360))
		6: # Merlin Ch3 — Crystal Cave (HARD — short U-turn)
			curve.add_point(Vector2(-50, 260), Vector2.ZERO, Vector2(100, 0))
			curve.add_point(Vector2(300, 240), Vector2(-80, 0), Vector2(100, 0))
			curve.add_point(Vector2(900, 200), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(1120, 280), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(1060, 460), Vector2(40, -40), Vector2(-80, 0))
			curve.add_point(Vector2(640, 500), Vector2(60, 0), Vector2(-60, 40))
			curve.add_point(Vector2(400, 670))
		7: # Tarzan Ch1 — Jungle Canopy (EASY — vine swing arcs, full screen)
			curve.add_point(Vector2(-50, 100), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 100), Vector2(-40, 0), Vector2(60, 80))
			curve.add_point(Vector2(300, 340), Vector2(0, -80), Vector2(80, 60))
			curve.add_point(Vector2(500, 520), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(700, 480), Vector2(-60, 0), Vector2(60, -80))
			curve.add_point(Vector2(800, 260), Vector2(0, 60), Vector2(-60, -60))
			curve.add_point(Vector2(640, 100), Vector2(40, 0), Vector2(-80, 0))
			curve.add_point(Vector2(400, 140), Vector2(60, 0), Vector2(-60, 60))
			curve.add_point(Vector2(260, 320), Vector2(0, -60), Vector2(0, 80))
			curve.add_point(Vector2(260, 520), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(500, 560), Vector2(-60, 0), Vector2(80, -40))
			curve.add_point(Vector2(740, 440), Vector2(-40, 40), Vector2(60, -60))
			curve.add_point(Vector2(880, 240), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(1040, 200), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(1120, 440), Vector2(0, -60), Vector2(60, 60))
			curve.add_point(Vector2(1330, 580))
		8: # Tarzan Ch2 — River Crossing (MEDIUM — zigzag across river)
			curve.add_point(Vector2(-50, 400), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 400), Vector2(-60, 0), Vector2(60, -80))
			curve.add_point(Vector2(360, 200), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(520, 240), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(600, 440), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(760, 460), Vector2(-40, 0), Vector2(40, -80))
			curve.add_point(Vector2(840, 240), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(980, 200), Vector2(-40, 0), Vector2(40, 60))
			curve.add_point(Vector2(1060, 400), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(1200, 360), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 380))
		9: # Tarzan Ch3 — Fortress Assault (HARD — direct with sharp turns)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(100, 0))
			curve.add_point(Vector2(300, 320), Vector2(-80, 0), Vector2(60, -60))
			curve.add_point(Vector2(480, 180), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(780, 200), Vector2(-80, 0), Vector2(60, 60))
			curve.add_point(Vector2(920, 380), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1140, 360), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1330, 340))
		10: # Dracula Ch1 — Transylvania Village (EASY — mountain switchbacks, 5 passes)
			curve.add_point(Vector2(-50, 560), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 560), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1060, 540), Vector2(-80, 0), Vector2(0, -50))
			curve.add_point(Vector2(1060, 440), Vector2(0, 30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 460), Vector2(80, 0), Vector2(0, -50))
			curve.add_point(Vector2(200, 360), Vector2(0, 30), Vector2(80, 0))
			curve.add_point(Vector2(1060, 340), Vector2(-80, 0), Vector2(0, -50))
			curve.add_point(Vector2(1060, 240), Vector2(0, 30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 260), Vector2(80, 0), Vector2(0, -50))
			curve.add_point(Vector2(200, 160), Vector2(0, 30), Vector2(80, 0))
			curve.add_point(Vector2(640, 140), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1060, 120), Vector2(-80, 0), Vector2(0, 50))
			curve.add_point(Vector2(1060, 200), Vector2(0, -30), Vector2(-60, 40))
			curve.add_point(Vector2(900, 320), Vector2(40, -40), Vector2(-60, 40))
			curve.add_point(Vector2(740, 460), Vector2(40, -40), Vector2(-60, 40))
			curve.add_point(Vector2(640, 670))
		11: # Dracula Ch2 — Castle Corridors (MEDIUM — maze-like center path)
			curve.add_point(Vector2(-50, 300), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(160, 300), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(160, 120), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(500, 120), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(500, 400), Vector2(0, -60), Vector2(-60, 0))
			curve.add_point(Vector2(300, 400), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(300, 540), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(700, 540), Vector2(-60, 0), Vector2(0, -80))
			curve.add_point(Vector2(700, 280), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(960, 280), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(960, 500), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 500))
		12: # Dracula Ch3 — Crypt Descent (HARD — short spiral down)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 80))
			curve.add_point(Vector2(640, 140), Vector2(0, -40), Vector2(100, 0))
			curve.add_point(Vector2(940, 200), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(880, 400), Vector2(40, -40), Vector2(-80, 0))
			curve.add_point(Vector2(480, 360), Vector2(60, 0), Vector2(0, 60))
			curve.add_point(Vector2(520, 480), Vector2(-20, -40), Vector2(40, 40))
			curve.add_point(Vector2(600, 560), Vector2(-20, 0), Vector2(0, 40))
			curve.add_point(Vector2(620, 670))
		13: # Frankenstein Ch1 — Lab Corridors (EASY — 4 full horizontal passes)
			curve.add_point(Vector2(-50, 100), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(200, 100), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(640, 80), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 100), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 220), Vector2(0, -30), Vector2(-60, 0))
			curve.add_point(Vector2(640, 240), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 220), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 350), Vector2(0, -30), Vector2(60, 0))
			curve.add_point(Vector2(640, 370), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 350), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 470), Vector2(0, -30), Vector2(-60, 0))
			curve.add_point(Vector2(640, 490), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 470), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 560), Vector2(0, -30), Vector2(60, 0))
			curve.add_point(Vector2(640, 580), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 580))
		14: # Frankenstein Ch2 — Village Streets (MEDIUM — grid pattern)
			curve.add_point(Vector2(-50, 300), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 300), Vector2(-60, 0), Vector2(0, -80))
			curve.add_point(Vector2(200, 120), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(500, 140), Vector2(-60, 0), Vector2(60, 60))
			curve.add_point(Vector2(600, 340), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(800, 300), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(800, 520), Vector2(0, -60), Vector2(-80, 0))
			curve.add_point(Vector2(480, 540), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(240, 520), Vector2(60, 0), Vector2(0, -60))
			curve.add_point(Vector2(200, 400), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(1000, 440), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(1330, 420))
		15: # Frankenstein Ch3 — Arctic Traverse (HARD — nearly straight)
			curve.add_point(Vector2(-50, 340), Vector2.ZERO, Vector2(100, 0))
			curve.add_point(Vector2(280, 300), Vector2(-80, 0), Vector2(100, -20))
			curve.add_point(Vector2(640, 260), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(960, 300), Vector2(-80, 0), Vector2(80, 20))
			curve.add_point(Vector2(1200, 340), Vector2(-80, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 320))
		16: # Robin Hood Ch1 — Forest Trail (EASY — winding with U-turns)
			curve.add_point(Vector2(-50, 120), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(200, 120), Vector2(-40, 0), Vector2(80, 0))
			curve.add_point(Vector2(1060, 100), Vector2(-80, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 220), Vector2(0, -40), Vector2(-80, 0))
			curve.add_point(Vector2(200, 240), Vector2(80, 0), Vector2(0, 60))
			curve.add_point(Vector2(200, 360), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(640, 340), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1060, 360), Vector2(-60, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 480), Vector2(0, -40), Vector2(-80, 0))
			curve.add_point(Vector2(640, 500), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 480), Vector2(60, 0), Vector2(0, -60))
			curve.add_point(Vector2(200, 400), Vector2(0, 40), Vector2(-40, 0))
			curve.add_point(Vector2(100, 400), Vector2(30, 0), Vector2(0, 60))
			curve.add_point(Vector2(100, 560), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(640, 580), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 560))
		17: # Robin Hood Ch2 — River and Bridge (MEDIUM — S-curves with crossing)
			curve.add_point(Vector2(-50, 200), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 200), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(260, 420), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(440, 460), Vector2(-40, 0), Vector2(60, -60))
			curve.add_point(Vector2(580, 280), Vector2(0, 40), Vector2(60, -40))
			curve.add_point(Vector2(700, 160), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(840, 200), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(920, 420), Vector2(0, -60), Vector2(60, 40))
			curve.add_point(Vector2(1040, 520), Vector2(-40, -20), Vector2(60, 0))
			curve.add_point(Vector2(1180, 480), Vector2(-40, 0), Vector2(60, -40))
			curve.add_point(Vector2(1330, 360))
		18: # Robin Hood Ch3 — Castle Siege (HARD — direct diagonal assault)
			curve.add_point(Vector2(-50, 540), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 520), Vector2(-60, 0), Vector2(80, -40))
			curve.add_point(Vector2(480, 380), Vector2(-60, 30), Vector2(80, -40))
			curve.add_point(Vector2(700, 280), Vector2(-60, 20), Vector2(60, -40))
			curve.add_point(Vector2(840, 180), Vector2(-40, 20), Vector2(60, 0))
			curve.add_point(Vector2(1000, 200), Vector2(-40, 0), Vector2(0, -60))
			curve.add_point(Vector2(1000, 100), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(1330, 120))
		19: # Alice Ch1 — Rabbit Hole Fall (EASY — zigzag descent, full screen)
			curve.add_point(Vector2(100, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(100, 100), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(1060, 80), Vector2(-80, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 180), Vector2(0, -40), Vector2(-80, 0))
			curve.add_point(Vector2(200, 200), Vector2(80, 0), Vector2(0, 60))
			curve.add_point(Vector2(200, 300), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(1060, 280), Vector2(-80, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 380), Vector2(0, -40), Vector2(-80, 0))
			curve.add_point(Vector2(200, 400), Vector2(80, 0), Vector2(0, 60))
			curve.add_point(Vector2(200, 500), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(640, 480), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1060, 500), Vector2(-60, 0), Vector2(0, 40))
			curve.add_point(Vector2(1060, 560), Vector2(0, -20), Vector2(-80, 0))
			curve.add_point(Vector2(640, 580), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 560), Vector2(60, 0), Vector2(0, 40))
			curve.add_point(Vector2(200, 670))
		20: # Alice Ch2 — Tea Party Checkerboard (MEDIUM — step pattern)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 100), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(400, 100), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(400, 240), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(640, 240), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(880, 240), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(880, 380), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(640, 380), Vector2(40, 0), Vector2(-60, 0))
			curve.add_point(Vector2(400, 380), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(400, 520), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(800, 520), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1330, 540))
		21: # Alice Ch3 — Queen's Throne (HARD — short direct approach)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(100, 0))
			curve.add_point(Vector2(300, 280), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(640, 300), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(900, 320), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(900, 500), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(1200, 480), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 460))
		22: # Wicked Witch Ch1 — Yellow Brick Road (EASY — long sweeping S-curves)
			curve.add_point(Vector2(-50, 400), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(120, 400), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(120, 160), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(400, 160), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(400, 480), Vector2(0, -80), Vector2(80, 0))
			curve.add_point(Vector2(700, 480), Vector2(-60, 0), Vector2(0, -80))
			curve.add_point(Vector2(700, 160), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(960, 160), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(960, 480), Vector2(0, -60), Vector2(-60, 0))
			curve.add_point(Vector2(700, 540), Vector2(40, 0), Vector2(-60, 0))
			curve.add_point(Vector2(400, 560), Vector2(40, 0), Vector2(-80, 0))
			curve.add_point(Vector2(160, 540), Vector2(60, 0), Vector2(0, -40))
			curve.add_point(Vector2(160, 480), Vector2(0, 20), Vector2(60, 0))
			curve.add_point(Vector2(1100, 520), Vector2(-80, 0), Vector2(0, -60))
			curve.add_point(Vector2(1100, 340), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(1330, 320))
		23: # Wicked Witch Ch2 — Witch's Domain (MEDIUM — zigzag with vertical runs)
			curve.add_point(Vector2(-50, 300), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(160, 300), Vector2(-40, 0), Vector2(0, -60))
			curve.add_point(Vector2(160, 140), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(400, 140), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(400, 480), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(640, 480), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(640, 200), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(880, 200), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(880, 440), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1100, 400), Vector2(-60, 0), Vector2(60, 60))
			curve.add_point(Vector2(1200, 520), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(1330, 500))
		24: # Wicked Witch Ch3 — Emerald City Interior (HARD — compact center path)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 120), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(880, 160), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(860, 340), Vector2(20, -40), Vector2(-60, 40))
			curve.add_point(Vector2(640, 420), Vector2(40, 0), Vector2(-60, 0))
			curve.add_point(Vector2(400, 380), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(420, 520), Vector2(-20, -40), Vector2(60, 0))
			curve.add_point(Vector2(800, 540), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 560))
		25: # Peter Pan Ch1 — Flight over Neverland (EASY — big sweeping arcs)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 320), Vector2(-40, 0), Vector2(60, -100))
			curve.add_point(Vector2(300, 100), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(600, 120), Vector2(-60, 0), Vector2(60, 80))
			curve.add_point(Vector2(740, 380), Vector2(0, -60), Vector2(-60, 60))
			curve.add_point(Vector2(560, 540), Vector2(60, 0), Vector2(-80, 0))
			curve.add_point(Vector2(280, 500), Vector2(60, 0), Vector2(-60, -60))
			curve.add_point(Vector2(160, 360), Vector2(0, 40), Vector2(0, -60))
			curve.add_point(Vector2(200, 200), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(480, 220), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(860, 180), Vector2(-60, 0), Vector2(60, 60))
			curve.add_point(Vector2(1000, 400), Vector2(0, -60), Vector2(0, 60))
			curve.add_point(Vector2(1000, 540), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(760, 560), Vector2(40, 0), Vector2(60, 0))
			curve.add_point(Vector2(1060, 520), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1330, 480))
		26: # Peter Pan Ch2 — Lost Boys' Jungle (MEDIUM — moderate weaving)
			curve.add_point(Vector2(-50, 500), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 500), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(160, 300), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(360, 300), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(360, 120), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(580, 120), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(580, 380), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(780, 380), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(780, 180), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(1000, 180), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(1000, 420), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 400))
		27: # Peter Pan Ch3 — Pirate Ship Approach (HARD — short direct path)
			curve.add_point(Vector2(1330, 200), Vector2.ZERO, Vector2(-80, 0))
			curve.add_point(Vector2(1060, 200), Vector2(60, 0), Vector2(-60, 60))
			curve.add_point(Vector2(880, 360), Vector2(40, -40), Vector2(-60, 40))
			curve.add_point(Vector2(700, 480), Vector2(40, -30), Vector2(-80, 0))
			curve.add_point(Vector2(400, 440), Vector2(60, 0), Vector2(-60, -40))
			curve.add_point(Vector2(240, 320), Vector2(40, 40), Vector2(-60, 0))
			curve.add_point(Vector2(-50, 340))
		28: # Phantom Ch1 — Grand Stage Descent (EASY — long switchback, 4+ runs)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 80), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(1080, 80), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 180), Vector2(0, -30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 200), Vector2(80, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 300), Vector2(0, -30), Vector2(80, 0))
			curve.add_point(Vector2(1080, 280), Vector2(-80, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 380), Vector2(0, -30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 400), Vector2(80, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 500), Vector2(0, -30), Vector2(80, 0))
			curve.add_point(Vector2(640, 480), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 500), Vector2(-60, 0), Vector2(0, 40))
			curve.add_point(Vector2(1080, 560), Vector2(0, -20), Vector2(-80, 0))
			curve.add_point(Vector2(640, 580), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 560), Vector2(60, 0), Vector2(0, 40))
			curve.add_point(Vector2(200, 670))
		29: # Phantom Ch2 — Underground Labyrinth (MEDIUM — maze-like turns)
			curve.add_point(Vector2(-50, 160), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(140, 160), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(140, 340), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(340, 340), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(340, 140), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(560, 140), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(560, 420), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(760, 420), Vector2(-60, 0), Vector2(0, -80))
			curve.add_point(Vector2(760, 200), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(960, 200), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(960, 500), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 480))
		30: # Phantom Ch3 — Phantom's Lair (HARD — short path to center)
			curve.add_point(Vector2(1330, 160), Vector2.ZERO, Vector2(-80, 0))
			curve.add_point(Vector2(1060, 160), Vector2(60, 0), Vector2(-60, 60))
			curve.add_point(Vector2(880, 320), Vector2(40, -40), Vector2(-60, 0))
			curve.add_point(Vector2(640, 340), Vector2(40, 0), Vector2(-60, 40))
			curve.add_point(Vector2(440, 460), Vector2(40, -30), Vector2(-60, 0))
			curve.add_point(Vector2(280, 440), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(300, 560), Vector2(0, -30), Vector2(80, 0))
			curve.add_point(Vector2(640, 670))
		31: # Scrooge Ch1 — City Blocks (EASY — long winding grid, multiple passes)
			curve.add_point(Vector2(1330, 120), Vector2.ZERO, Vector2(-80, 0))
			curve.add_point(Vector2(1060, 120), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1060, 240), Vector2(0, -30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 260), Vector2(80, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 380), Vector2(0, -30), Vector2(80, 0))
			curve.add_point(Vector2(1060, 360), Vector2(-80, 0), Vector2(0, 50))
			curve.add_point(Vector2(1060, 480), Vector2(0, -30), Vector2(-80, 0))
			curve.add_point(Vector2(640, 500), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 480), Vector2(60, 0), Vector2(0, -50))
			curve.add_point(Vector2(200, 360), Vector2(0, 30), Vector2(-50, 0))
			curve.add_point(Vector2(80, 360), Vector2(30, 0), Vector2(0, -50))
			curve.add_point(Vector2(80, 200), Vector2(0, 30), Vector2(0, -50))
			curve.add_point(Vector2(80, 100), Vector2(0, 30), Vector2(60, 0))
			curve.add_point(Vector2(400, 100), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(640, 120), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(640, 670))
		32: # Scrooge Ch2 — Midnight Graveyard (MEDIUM — zigzag between tombstones)
			curve.add_point(Vector2(-50, 140), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(160, 140), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(160, 400), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(400, 400), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(400, 180), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(640, 180), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(640, 460), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(880, 460), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(880, 220), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(1100, 220), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(1100, 500), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 480))
		33: # Scrooge Ch3 — Christmas Dawn (HARD — quick descent)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 120), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(400, 160), Vector2(40, 0), Vector2(-60, 60))
			curve.add_point(Vector2(260, 340), Vector2(0, -40), Vector2(0, 60))
			curve.add_point(Vector2(300, 480), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(640, 500), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1000, 480), Vector2(-60, 0), Vector2(0, 40))
			curve.add_point(Vector2(1000, 670))
		34: # Shadow Author Ch1 — Ink River (EASY — long flowing curves, 4+ sweeping turns)
			curve.add_point(Vector2(-50, 280), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(140, 280), Vector2(-40, 0), Vector2(60, -80))
			curve.add_point(Vector2(300, 100), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(600, 120), Vector2(-80, 0), Vector2(80, 80))
			curve.add_point(Vector2(800, 360), Vector2(0, -80), Vector2(-60, 80))
			curve.add_point(Vector2(640, 540), Vector2(60, 0), Vector2(-80, 0))
			curve.add_point(Vector2(360, 500), Vector2(60, 0), Vector2(-60, -60))
			curve.add_point(Vector2(220, 360), Vector2(0, 40), Vector2(0, -60))
			curve.add_point(Vector2(260, 200), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(540, 220), Vector2(-60, 0), Vector2(60, 60))
			curve.add_point(Vector2(700, 420), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(920, 380), Vector2(-60, 0), Vector2(60, -60))
			curve.add_point(Vector2(1060, 200), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(1200, 240), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(1280, 460), Vector2(0, -60), Vector2(0, 60))
			curve.add_point(Vector2(1280, 670))
		35: # Shadow Author Ch2 — Unwritten Pages (MEDIUM — page column pattern)
			curve.add_point(Vector2(-50, 100), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(140, 100), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(140, 540), Vector2(0, -80), Vector2(60, 0))
			curve.add_point(Vector2(380, 540), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(380, 120), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(620, 120), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(620, 540), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(860, 540), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(860, 120), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(1100, 120), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(1100, 540), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 540))
		36: # Shadow Author Ch3 — Final Vortex (HARD — tightening spiral, intense)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 320), Vector2(-60, 0), Vector2(0, -120))
			curve.add_point(Vector2(640, 80), Vector2(-120, 0), Vector2(120, 0))
			curve.add_point(Vector2(1080, 320), Vector2(0, -100), Vector2(0, 100))
			curve.add_point(Vector2(640, 560), Vector2(100, 0), Vector2(-100, 0))
			curve.add_point(Vector2(340, 380), Vector2(0, 60), Vector2(0, -60))
			curve.add_point(Vector2(640, 220), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(840, 340), Vector2(0, -40), Vector2(0, 60))
			curve.add_point(Vector2(640, 440), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(640, 670))
	path_points.clear()
	var length = curve.get_baked_length()
	for i in range(0, int(length), 6):
		path_points.append(curve.sample_baked(float(i)))

# ============================================================
# AUDIO — Procedural hip hop beat + character voice clips
# ============================================================
func _setup_audio() -> void:
	# Menu music player (shuffle playlist of gothic piano tracks)
	music_player = AudioStreamPlayer.new()
	music_player.volume_db = -6.0
	add_child(music_player)
	music_player.finished.connect(_on_music_finished)
	_load_music_tracks()

	# Voice player (one-shot clips via AudioStreamWAV — formant "character flavor")
	voice_player = AudioStreamPlayer.new()
	voice_player.volume_db = -2.0
	add_child(voice_player)
	_generate_voice_clips()
	_init_tower_quotes()

	# Catchphrase voice player (MP3 voice-over clips)
	catchphrase_player = AudioStreamPlayer.new()
	catchphrase_player.volume_db = -2.0
	add_child(catchphrase_player)
	_load_voice_clips()
	_init_catchphrase_quotes()

	# UI / Gameplay SFX player pool (prevents sounds cutting each other off)
	_sfx_player = AudioStreamPlayer.new()
	_sfx_player.volume_db = -8.0
	add_child(_sfx_player)
	for _i in range(SFX_POOL_SIZE):
		var pool_player = AudioStreamPlayer.new()
		pool_player.volume_db = -8.0
		add_child(pool_player)
		_sfx_pool.append(pool_player)
	_generate_ui_sfx()

func _load_music_tracks() -> void:
	var track_paths = [
		"res://audio/music/vampires_piano.mp3",
		"res://audio/music/haunting_piano.mp3",
		"res://audio/music/haunted_track_minor.mp3",
		"res://audio/music/cold_silence.ogg",
		"res://audio/music/dark_rooms.mp3",
	]
	for path in track_paths:
		if ResourceLoader.exists(path):
			var track = load(path)
			if track:
				music_tracks.append(track)
	# Shuffle on load
	music_tracks.shuffle()

func _start_music() -> void:
	if music_tracks.size() == 0:
		return
	music_playing = true
	_play_next_track()

func _stop_music() -> void:
	music_player.stop()
	music_playing = false

func _play_next_track() -> void:
	if music_tracks.size() == 0:
		return
	music_player.stream = music_tracks[music_index]
	music_player.play()
	music_index = (music_index + 1) % music_tracks.size()
	# Reshuffle when we've cycled through all tracks
	if music_index == 0:
		music_tracks.shuffle()

func _on_music_finished() -> void:
	if music_playing:
		_play_next_track()

func _samples_to_wav(samples: PackedFloat32Array, rate: int = 22050) -> AudioStreamWAV:
	var wav := AudioStreamWAV.new()
	wav.format = AudioStreamWAV.FORMAT_16_BITS
	wav.mix_rate = rate
	wav.stereo = false
	var data := PackedByteArray()
	data.resize(samples.size() * 2)
	for i in range(samples.size()):
		var val := int(clampf(samples[i], -1.0, 1.0) * 32767.0)
		data[i * 2] = val & 0xFF
		data[i * 2 + 1] = (val >> 8) & 0xFF
	wav.data = data
	return wav

func _generate_formant_voice(fundamental: float, formants: Array, syllable_count: int,
		duration: float, breathiness: float, vibrato_rate: float, vibrato_depth: float) -> AudioStreamWAV:
	var rate := 22050
	var num_samples := int(rate * duration)
	var samples := PackedFloat32Array()
	samples.resize(num_samples)
	var syllable_len := num_samples / syllable_count
	var gap_samples := int(rate * 0.02)  # 20ms inter-syllable gap

	for i in range(num_samples):
		var t := float(i) / float(rate)
		var syl_idx := mini(i / syllable_len, syllable_count - 1)
		var syl_offset := i - syl_idx * syllable_len
		var syl_t := float(syl_offset) / float(syllable_len)

		# Inter-syllable gap
		if syl_offset >= syllable_len - gap_samples:
			samples[i] = 0.0
			continue

		# Per-syllable amplitude envelope (attack-sustain-decay)
		var syl_dur := float(syllable_len - gap_samples) / float(rate)
		var syl_time := float(syl_offset) / float(rate)
		var env := 1.0
		var attack_t := 0.015
		if syl_time < attack_t:
			env = syl_time / attack_t
		elif syl_time > syl_dur * 0.6:
			env = clampf(1.0 - (syl_time - syl_dur * 0.6) / (syl_dur * 0.4), 0.0, 1.0)

		# F0 with vibrato
		var f0 := fundamental + sin(TAU * vibrato_rate * t) * vibrato_depth
		# Slight pitch variation per syllable for naturalness
		f0 *= 1.0 + sin(float(syl_idx) * 2.7) * 0.04

		# Glottal pulse train (fundamental + harmonics 2-5)
		var glottal := sin(TAU * f0 * t)
		glottal += sin(TAU * f0 * 2.0 * t) * 0.6
		glottal += sin(TAU * f0 * 3.0 * t) * 0.35
		glottal += sin(TAU * f0 * 4.0 * t) * 0.2
		glottal += sin(TAU * f0 * 5.0 * t) * 0.1

		# Breathiness noise component
		var noise := (randf() * 2.0 - 1.0) * breathiness

		# Pick formant vowel for this syllable (cycle through provided formants)
		var vowel: Array = formants[syl_idx % formants.size()]
		# Formant resonance (sinusoids at F1/F2/F3)
		var formant_signal := sin(TAU * vowel[0] * t) * 0.5
		formant_signal += sin(TAU * vowel[1] * t) * 0.35
		formant_signal += sin(TAU * vowel[2] * t) * 0.15

		# Mix glottal source with formant coloring
		var s := (glottal * 0.4 + formant_signal * 0.4 + noise * 0.2) * env

		# Overall fade in/out
		var fade_in := clampf(t / 0.03, 0.0, 1.0)
		var fade_out := clampf((duration - t) / 0.05, 0.0, 1.0)
		samples[i] = clampf(s * fade_in * fade_out * 0.55, -1.0, 1.0)

	return _samples_to_wav(samples, rate)

func _generate_voice_clips() -> void:
	# Robin Hood — confident baritone (F0=145Hz)
	# Vowels: ah=[730,1090,2440], oh=[570,840,2410], eh=[530,1840,2480]
	voice_clips[TowerType.ROBIN_HOOD] = _generate_formant_voice(
		145.0, [[730,1090,2440], [570,840,2410], [530,1840,2480]],
		5, 0.7, 0.10, 5.5, 4.0)

	# Alice — bright curious girl (F0=280Hz)
	# Vowels: ee=[270,2290,3010], eh=[530,1840,2480], ah=[730,1090,2440]
	voice_clips[TowerType.ALICE] = _generate_formant_voice(
		280.0, [[270,2290,3010], [530,1840,2480], [730,1090,2440], [270,2290,3010]],
		6, 0.65, 0.25, 6.0, 6.0)

	# Wicked Witch — raspy nasal cackle (F0=240Hz)
	# Vowels: ae=[660,1720,2410], oo=[300,870,2240], eh=[530,1840,2480]
	voice_clips[TowerType.WICKED_WITCH] = _generate_formant_voice(
		240.0, [[660,1720,2410], [300,870,2240], [530,1840,2480], [660,1720,2410]],
		5, 0.7, 0.35, 4.0, 8.0)

	# Peter Pan — energetic boy (F0=220Hz)
	# Vowels: ee=[270,2290,3010], ah=[730,1090,2440], ih=[390,1990,2550]
	voice_clips[TowerType.PETER_PAN] = _generate_formant_voice(
		220.0, [[270,2290,3010], [730,1090,2440], [390,1990,2550]],
		7, 0.55, 0.15, 7.0, 5.0)

	# Phantom — deep operatic bass (F0=120Hz)
	# Vowels: ah=[730,1090,2440], oh=[570,840,2410], oo=[300,870,2240]
	voice_clips[TowerType.PHANTOM] = _generate_formant_voice(
		120.0, [[730,1090,2440], [570,840,2410], [300,870,2240]],
		4, 0.8, 0.08, 4.5, 3.0)

	# Scrooge — thin reedy warble (F0=165Hz)
	# Vowels: ah=[730,1090,2440], eh=[530,1840,2480], uh=[640,1190,2390]
	voice_clips[TowerType.SCROOGE] = _generate_formant_voice(
		165.0, [[730,1090,2440], [530,1840,2480], [640,1190,2390], [730,1090,2440]],
		5, 0.6, 0.40, 3.5, 7.0)

	# === SHADOW AUTHOR VOICE — ultra-deep menacing whisper (F0=70Hz) ===
	# Very low fundamental with breathy, sinister quality
	# Vowels: uh=[640,1190,2390], oh=[570,840,2410], oo=[300,870,2240]
	story_voice_clips["narrator"] = _generate_formant_voice(
		70.0, [[640,1190,2390], [570,840,2410], [300,870,2240], [640,1190,2390]],
		4, 1.1, 0.45, 2.5, 6.0)

	# === NEW CHARACTER TOWER VOICES ===
	# Sherlock Holmes — calm analytical (F0=160Hz)
	voice_clips[TowerType.SHERLOCK] = _generate_formant_voice(
		160.0, [[390,1990,2550], [530,1840,2480], [730,1090,2440]],
		5, 0.7, 0.10, 3.0, 2.0)
	# Tarzan — deep primal (F0=115Hz)
	voice_clips[TowerType.TARZAN] = _generate_formant_voice(
		115.0, [[730,1090,2440], [570,840,2410], [300,870,2240]],
		4, 0.9, 0.05, 2.0, 1.5)
	# Dracula — deep aristocratic (F0=105Hz)
	voice_clips[TowerType.DRACULA] = _generate_formant_voice(
		105.0, [[730,1090,2440], [300,870,2240], [570,840,2410]],
		5, 0.85, 0.08, 3.5, 4.0)
	# Merlin — wise elderly (F0=140Hz)
	voice_clips[TowerType.MERLIN] = _generate_formant_voice(
		140.0, [[530,1840,2480], [730,1090,2440], [640,1190,2390], [570,840,2410]],
		6, 0.8, 0.15, 4.0, 3.5)
	# Frankenstein's Monster — deep gentle giant, kind but massive (F0=72Hz)
	# Very low rumbling fundamental, warm open vowels, slow deliberate pace
	voice_clips[TowerType.FRANKENSTEIN] = _generate_formant_voice(
		72.0, [[730,1090,2440], [570,840,2410], [640,1190,2390], [300,870,2240]],
		4, 1.2, 0.04, 2.0, 1.5)

func _play_tower_voice(tower_type: TowerType) -> void:
	if voices_muted:
		return
	if voice_clips.has(tower_type):
		voice_player.stream = voice_clips[tower_type]
		voice_player.play()

func _generate_ui_sfx() -> void:
	var sr = 22050
	# UI Click — short crisp pop (40ms)
	var click_len = int(sr * 0.04)
	var click_data = PackedByteArray()
	click_data.resize(click_len * 2)
	for i in range(click_len):
		var t = float(i) / float(sr)
		var env = (1.0 - float(i) / float(click_len))
		env *= env
		var sample = sin(t * 3200.0 * TAU) * 0.3 * env + sin(t * 1800.0 * TAU) * 0.2 * env
		var s16 = clampi(int(sample * 16000.0), -32768, 32767)
		click_data[i * 2] = s16 & 0xFF
		click_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_ui_click = AudioStreamWAV.new()
	_sfx_ui_click.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_ui_click.mix_rate = sr
	_sfx_ui_click.data = click_data

	# Wave Start — ascending trumpet fanfare (300ms)
	var ws_len = int(sr * 0.3)
	var ws_data = PackedByteArray()
	ws_data.resize(ws_len * 2)
	for i in range(ws_len):
		var t = float(i) / float(sr)
		var env = clampf(minf(t * 12.0, (0.3 - t) * 8.0), 0.0, 1.0)
		var freq = 440.0 + t * 600.0
		var sample = sin(t * freq * TAU) * 0.25 * env + sin(t * freq * 2.0 * TAU) * 0.1 * env + sin(t * freq * 3.0 * TAU) * 0.05 * env
		var s16 = clampi(int(sample * 14000.0), -32768, 32767)
		ws_data[i * 2] = s16 & 0xFF
		ws_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_wave_start = AudioStreamWAV.new()
	_sfx_wave_start.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_wave_start.mix_rate = sr
	_sfx_wave_start.data = ws_data

	# Wave Complete — bright chime (400ms, C-E-G arpeggio)
	var wc_len = int(sr * 0.4)
	var wc_data = PackedByteArray()
	wc_data.resize(wc_len * 2)
	for i in range(wc_len):
		var t = float(i) / float(sr)
		var env = clampf((0.4 - t) * 5.0, 0.0, 1.0)
		env *= env
		var note1 = sin(t * 523.0 * TAU) * 0.2 * clampf(1.0 - t * 5.0, 0.0, 1.0)
		var note2 = sin(t * 659.0 * TAU) * 0.2 * clampf(minf((t - 0.08) * 8.0, 1.0 - (t - 0.08) * 3.0), 0.0, 1.0)
		var note3 = sin(t * 784.0 * TAU) * 0.25 * clampf(minf((t - 0.16) * 8.0, 1.0 - (t - 0.16) * 2.5), 0.0, 1.0)
		var sample = (note1 + note2 + note3) * env
		var s16 = clampi(int(sample * 16000.0), -32768, 32767)
		wc_data[i * 2] = s16 & 0xFF
		wc_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_wave_complete = AudioStreamWAV.new()
	_sfx_wave_complete.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_wave_complete.mix_rate = sr
	_sfx_wave_complete.data = wc_data

	# Enemy Death — wet ink splat (80ms)
	var ed_len = int(sr * 0.08)
	var ed_data = PackedByteArray()
	ed_data.resize(ed_len * 2)
	var ed_rng = RandomNumberGenerator.new()
	ed_rng.seed = 42
	for i in range(ed_len):
		var t = float(i) / float(sr)
		var env = (1.0 - float(i) / float(ed_len))
		env = env * env * env
		var noise = ed_rng.randf_range(-1.0, 1.0)
		var tone = sin(t * 180.0 * TAU) * 0.3
		var sample = (noise * 0.5 + tone) * env
		var s16 = clampi(int(sample * 12000.0), -32768, 32767)
		ed_data[i * 2] = s16 & 0xFF
		ed_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_enemy_death = AudioStreamWAV.new()
	_sfx_enemy_death.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_enemy_death.mix_rate = sr
	_sfx_enemy_death.data = ed_data

	# Victory — triumphant fanfare (800ms, C major chord → G major resolve)
	var vic_len = int(sr * 0.8)
	var vic_data = PackedByteArray()
	vic_data.resize(vic_len * 2)
	for i in range(vic_len):
		var t = float(i) / float(sr)
		var env = clampf(minf(t * 6.0, (0.8 - t) * 3.0), 0.0, 1.0)
		var phase2 = clampf((t - 0.35) * 4.0, 0.0, 1.0)
		var c_chord = sin(t * 523.0 * TAU) * 0.15 + sin(t * 659.0 * TAU) * 0.12 + sin(t * 784.0 * TAU) * 0.12
		var g_chord = sin(t * 784.0 * TAU) * 0.15 + sin(t * 988.0 * TAU) * 0.12 + sin(t * 1175.0 * TAU) * 0.1
		var sample = (c_chord * (1.0 - phase2) + g_chord * phase2) * env
		var s16 = clampi(int(sample * 16000.0), -32768, 32767)
		vic_data[i * 2] = s16 & 0xFF
		vic_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_victory = AudioStreamWAV.new()
	_sfx_victory.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_victory.mix_rate = sr
	_sfx_victory.data = vic_data

	# Defeat — sad descending tone (600ms, minor chord dissolve)
	var def_len = int(sr * 0.6)
	var def_data = PackedByteArray()
	def_data.resize(def_len * 2)
	for i in range(def_len):
		var t = float(i) / float(sr)
		var env = clampf((0.6 - t) * 2.5, 0.0, 1.0)
		env *= env
		var freq = 440.0 - t * 200.0
		var sample = sin(t * freq * TAU) * 0.2 * env + sin(t * (freq * 1.2) * TAU) * 0.15 * env + sin(t * (freq * 1.5) * TAU) * 0.08 * env
		var s16 = clampi(int(sample * 14000.0), -32768, 32767)
		def_data[i * 2] = s16 & 0xFF
		def_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_defeat = AudioStreamWAV.new()
	_sfx_defeat.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_defeat.mix_rate = sr
	_sfx_defeat.data = def_data

	# Life Lost — sharp warning ping (120ms)
	var ll_len = int(sr * 0.12)
	var ll_data = PackedByteArray()
	ll_data.resize(ll_len * 2)
	for i in range(ll_len):
		var t = float(i) / float(sr)
		var env = (1.0 - float(i) / float(ll_len))
		var sample = sin(t * 880.0 * TAU) * 0.3 * env + sin(t * 660.0 * TAU) * 0.2 * env * env
		var s16 = clampi(int(sample * 14000.0), -32768, 32767)
		ll_data[i * 2] = s16 & 0xFF
		ll_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_life_lost = AudioStreamWAV.new()
	_sfx_life_lost.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_life_lost.mix_rate = sr
	_sfx_life_lost.data = ll_data

func _play_sfx(clip: AudioStreamWAV) -> void:
	if sfx_muted or clip == null:
		return
	if _sfx_pool.size() > 0:
		var player = _sfx_pool[_sfx_pool_index]
		_sfx_pool_index = (_sfx_pool_index + 1) % _sfx_pool.size()
		player.stream = clip
		player.play()
	elif _sfx_player != null:
		_sfx_player.stream = clip
		_sfx_player.play()

# === STORY DIALOG ENGINE ===

func _init_story_dialogs() -> void:
	story_dialogs.clear()
	# Populated in full by _populate_story_dialogs() — called after this
	_populate_story_dialogs()

func _populate_story_dialogs() -> void:
	# === PROLOGUE — First time opening the game ===
	story_dialogs["prologue"] = [
		{"speaker": "narrator", "text": "In a forgotten corner of the world's oldest bookshop, there lies a book that should never be opened. Its cover is black as midnight, its pages whisper when no one is looking. They call it... The Tome of Shadows.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "Within its pages lives the Shadow Author — an entity born from every story ever abandoned, every tale left unfinished. It hungers for completed narratives... and the characters within them.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "Tonight, the Tome calls out. Six beloved heroes hear it — a whisper at the edge of their stories, an itch in the margins. One by one they reach for the book. They cannot resist. No character can resist an unread page.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "The cover flies open. A vortex of black ink spirals outward, tendrils wrapping around Robin Hood's bow, Alice's apron, the Witch's broomstick. They scream as they are pulled through — dragged into the pages like insects into amber.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "Welcome to MY pages. You have been read, beloved, adored — and now you are MINE. Every hero needs a story, and I have written you such beautiful tragedies.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Tome slams shut. Six heroes vanish from their worlds. And deep within the pages, a quill begins to write their doom.", "voice_type": "narrator"},
	]

	# === ACT 1: INTO THE PAGES (Levels 0-15) ===

	# --- PROLOGUE (Level 0) ---
	story_dialogs["pre_level_0"] = [
		{"speaker": "narrator", "text": "The heroes crash through layers of parchment, tumbling into a realm where the sky is a ceiling of handwritten text and the ground is made of living ink.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "What sorcery is this? One moment I was in Sherwood, the next... everything is made of ink and paper!", "voice_type": "male_hero"},
		{"speaker": "alice", "text": "Look! The pages beneath our feet are moving. Words are rearranging themselves into something sinister.", "voice_type": "female_hero"},
		{"speaker": "shadow_author", "text": "Ah, my newest collection pieces. Robin Hood, the outlaw who steals. Alice, the girl who falls. The Witch who melts. The boy who never grows up. The phantom who hides. The miser who hoards. You are all SO predictable.", "voice_type": "shadow"},
		{"speaker": "peter_pan", "text": "Who said that? Show yourself, you coward!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Shadow creatures emerge from the margins — twisted words given form, sentences bent into claws. The first battle in the Tome of Shadows begins.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_0"] = [
		{"speaker": "narrator", "text": "The shadow creatures dissolve into puddles of ink. A message forms on the ground in elegant calligraphy: 'That was merely the PROLOGUE.'", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You fought well. Of course you did — I WROTE you to fight well. But your little skirmish has barely turned a page. I have thirty-six chapters of suffering prepared for you.", "voice_type": "shadow"},
		{"speaker": "wicked_witch", "text": "I can feel dark magic radiating from deeper in these pages. Someone is writing our story, and there are others here — five powerful souls, trapped even longer than us.", "voice_type": "female_hero"},
		{"speaker": "phantom", "text": "I hear them — five voices crying out from different chapters. A detective's sharp mind. A wizard's ancient power. A wild man's roar. A count's mournful sigh. A creature's gentle weeping.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Five heroes lie imprisoned in the pages ahead, each trapped in a shadow version of their own story. To reach the Shadow Author, the heroes must first free these forgotten champions.", "voice_type": "narrator"},
	]

	# --- SHERLOCK HOLMES ARC (Levels 1-3) — "The Moriarty Gambit" ---
	story_dialogs["pre_level_1"] = [
		{"speaker": "shadow_author", "text": "Ah, you've found my London chapter. I recreated Sherlock's greatest failure — the case he COULDN'T solve. I've given Moriarty every advantage: every clue leads to a dead end I wrote myself.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The fog of shadow London rolls in thick as spilled ink. Gas lamps flicker with violet light along Baker Street, where a great mind waits to be freed.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "This London feels wrong — the cobblestones are made of typed pages, and the fog smells of old library books.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Criminal thugs emerge from the alleyways, guarding whatever lies at 221B Baker Street.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_1"] = [
		{"speaker": "peter_pan", "text": "One of the criminals dropped a calling card — it read 'Property of Professor M.' Who is this Moriarty?", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Deeper into shadow London, the heroes glimpse a figure in a deerstalker cap watching from a window above. He leaves coded messages scratched into the margins of the pages beneath their feet.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "Look at these scratches in the cobblestones! They're not random — they're codes. Whoever is trapped here has been studying his prison for a very long time.", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_2"] = [
		{"speaker": "narrator", "text": "The alleyways of Whitechapel twist like fevered sentences. Shadow assassins patrol the narrow passages, blades dripping with dark ink.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "I hear someone thinking behind these walls. A brilliant mind — methodical and precise. Whoever is trapped here has been studying their captor.", "voice_type": "male_hero"},
		{"speaker": "shadow_author", "text": "Moriarty, my dear Professor — they're getting closer. Do be creative with them. I've given you knowledge that Holmes never had.", "voice_type": "shadow"},
	]
	story_dialogs["post_level_2"] = [
		{"speaker": "scrooge", "text": "These criminals grow more organized. Someone called Moriarty pulls the strings — a shadow version of a very dangerous man.", "voice_type": "male_hero"},
		{"speaker": "wicked_witch", "text": "I found journal pages hidden inside a wall — the prisoner's handwriting. He's been here so long he's deduced things about the Author himself. Listen: 'The Shadow Author is not omnipotent. He follows rules — narrative rules. Every story he writes must have an ending.'", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_3"] = [
		{"speaker": "narrator", "text": "Reichenbach Falls thunders with cascading ink. At the precipice, Professor Moriarty's shadow waits with a quill-pen sword.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "This is where your story SHOULD have ended, Holmes. The falls, the final problem, the fatal plunge. I simply... wrote the version where Moriarty wins.", "voice_type": "shadow"},
		{"speaker": "alice", "text": "Someone is up there — above the falls! A man in a deerstalker, fighting against chains made of unwritten mysteries!", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "Defeat Moriarty's shadow to free the great detective. The game is afoot!", "voice_type": "narrator"},
	]
	story_dialogs["post_level_3"] = [
		{"speaker": "narrator", "text": "Moriarty's shadow dissolves into scattered pages. The chains of coded ciphers shatter, and a door of light appears in the falls.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "Impossible. The equation was PERFECT. No one escapes a story I've finished writing!", "voice_type": "shadow"},
	]

	# --- MERLIN ARC (Levels 4-6) — "The Broken Prophecy" ---
	story_dialogs["pre_level_4"] = [
		{"speaker": "shadow_author", "text": "Camelot! My favorite chapter. I gave Morgan le Fay a gift — Merlin's own spell book. Let's see how the wizard fights when his enemy knows every trick he ever invented.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "Shadow Camelot rises from the pages — a castle of illuminated manuscripts and broken seals. The Round Table lies shattered across the courtyard.", "voice_type": "narrator"},
		{"speaker": "sherlock", "text": "The magical residue here is immense. Someone of tremendous arcane power was imprisoned in this chapter. And based on the architectural corruption patterns, they've been here far longer than any of us.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Dark squires and cursed knights patrol the grounds, armor rusted with ancient ink.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_4"] = [
		{"speaker": "wicked_witch", "text": "I can feel old magic seeping through these walls — this is ancient power, imprisoned but not broken. Whoever is trapped here makes my powers look like parlor tricks.", "voice_type": "female_hero"},
		{"speaker": "sherlock", "text": "Curious. The Author corrupted Merlin's own prophecy, turning Camelot's future into a self-fulfilling curse. He doesn't just imprison characters — he rewrites their destinies.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_5"] = [
		{"speaker": "narrator", "text": "The Enchanted Forest of Camelot has been corrupted — but not completely. Trees of twisted calligraphy reach toward a sky of torn parchment, yet some still bloom with golden light.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "These woods remind me of Sherwood, but darker. The magic here has teeth.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The forest itself seems to fight back against the shadow corruption — roots trip the dark knights, branches shield the heroes. Nature remembers its true master.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_5"] = [
		{"speaker": "narrator", "text": "Deep in the forest, rune circles glow with trapped power. The sorcery leads toward a crystal cave pulsing with ancient light.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "I found something in the roots of the oldest tree — a broken staff, snapped in half but still humming with power! It's warm to the touch, like it's alive.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_6"] = [
		{"speaker": "narrator", "text": "The Crystal Cave gleams with imprisoned starlight. Morgan le Fay's shadow guards a figure frozen in crystallized ink.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "Morgan le Fay chose to serve me willingly. Not every villain is a prisoner, heroes. Some simply prefer the winning side.", "voice_type": "shadow"},
		{"speaker": "wicked_witch", "text": "Morgan le Fay! Dark sorceress, enemy of Camelot. She chose power over loyalty — I understand the temptation, but I chose differently. Her shadow won't yield easily, but neither will I!", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_6"] = [
		{"speaker": "narrator", "text": "Morgan le Fay shatters like dark glass. The crystal prison cracks open, releasing brilliant light from within.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You freed the wizard? Fine. His prophecies are already broken. What good is a seer who cannot see his own future?", "voice_type": "shadow"},
	]

	# --- TARZAN ARC (Levels 7-9) — "The Hunter's Trophy" ---
	story_dialogs["pre_level_7"] = [
		{"speaker": "shadow_author", "text": "In MY version of this story, the apes are already dead. I killed them in the first paragraph. Tarzan has nothing left to protect — only revenge. And revenge makes characters SO easy to control.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The jungle canopy stretches endlessly — leaves of green-inked pages, vines of cursive script. A wild man has been fighting alone here for ages.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "A jungle! Almost like Neverland but wilder. I hear someone swinging through the trees — and hunters chasing them!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Poachers crash through the undergrowth, pith helmets stained with ink, guarding the path to the treetop prison.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_7"] = [
		{"speaker": "peter_pan", "text": "Listen! Jungle drums — someone is sending signals through the canopy, calling for help! Whoever is out there, they haven't given up!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The jungle beasts cry warnings from above. A great danger lurks deeper in the green — but so does the one who needs saving.", "voice_type": "narrator"},
	]
	story_dialogs["pre_level_8"] = [
		{"speaker": "narrator", "text": "The Elephant Graveyard stretches ahead — massive bones of rolled parchment, tusks of ivory vellum. Clayton's hunters display trophies of shadow apes mounted on stakes.", "voice_type": "narrator"},
		{"speaker": "merlin", "text": "Nature magic permeates this place. Whoever lives here has a bond with the wild that even the Shadow Author cannot sever.", "voice_type": "male_hero"},
		{"speaker": "alice", "text": "These hunters are heartless! But the one they're chasing... he fights with such sorrow. Like he's lost everything but still won't stop.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_8"] = [
		{"speaker": "alice", "text": "The hunters keep mentioning Clayton. He sounds absolutely dreadful — worse than the Queen of Hearts!", "voice_type": "female_hero"},
		{"speaker": "sherlock", "text": "The Author designed Clayton as the 'ultimate hunter' — one who already succeeded in the original story. He's turned Tarzan's tragedy into a permanent state. Cruel, but narratively predictable.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_9"] = [
		{"speaker": "narrator", "text": "Clayton's Fortress rises from the jungle — bamboo and bound manuscripts bristling with weapons. Inside, a cage of woven vines holds the lord of the apes.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "Animals belong in cages, heroes. Even the human ones. Especially the ones who think they're free.", "voice_type": "shadow"},
		{"speaker": "scrooge", "text": "That fortress is well-guarded. But I didn't become the richest man in London by backing down from fortified positions!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_9"] = [
		{"speaker": "narrator", "text": "Clayton's fortress crumbles. The cage shatters. A primal roar splits the shadow canopy — so powerful that ink rains from the trees like monsoon water.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "For a brief, shimmering moment, the spirits of Tarzan's ape tribe appear in the canopy — Kala, Kerchak, all of them. They beat their chests in farewell, then fade like morning mist.", "voice_type": "narrator"},
	]

	# --- DRACULA ARC (Levels 10-12) — "The Eternal Night" (REDEMPTION ARC) ---
	story_dialogs["pre_level_10"] = [
		{"speaker": "shadow_author", "text": "Dracula was the easiest to trap. He was already the villain of his own story. I simply... removed his choice. Stripped away his nobility, his centuries of restraint. Now he is what Bram Stoker always feared — a mindless beast.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Transylvanian village huddles beneath a blood-red moon of scarlet ink. Pale thralls shuffle through streets paved with Gothic script.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "I know darkness. I have lived in it my whole life. But this darkness is different — it hungers, it feeds, it grows.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The undead rise from between the pages. Thralls and dire wolves serve a master imprisoned in the castle above.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_10"] = [
		{"speaker": "sherlock", "text": "Fascinating. These undead are not truly evil — they're compelled. The behavioral patterns suggest their master is a prisoner, not a tyrant. The one controlling them may be the greatest victim of all.", "voice_type": "male_hero"},
		{"speaker": "merlin", "text": "I sense a soul in conflict up in that castle. Old magic and older sorrow, fighting against chains that were forged from his own legend.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_11"] = [
		{"speaker": "narrator", "text": "Castle Dracula towers above, spires piercing a sky of dark parchment. Vampire brides drift through hallways of shadow and candlelight.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "Listen... music from within the castle. A mournful waltz, played on a harpsichord with broken keys. He's not a monster — he's a prisoner mourning his own humanity.", "voice_type": "male_hero"},
		{"speaker": "wicked_witch", "text": "Vampires! I've dealt with dark magic, but this is ancient — older than Oz, older than Wonderland. Tread carefully.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_11"] = [
		{"speaker": "narrator", "text": "In the castle's great hall, a portrait hangs — a noble face, painted centuries before the curse. Beside it, journal pages in elegant script.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "His journal! Listen: 'I chose to stop feeding three hundred years ago. I locked myself away to protect the innocent. Then the Author came and forced the hunger back into my veins.' He was GOOD before the Author found him!", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_12"] = [
		{"speaker": "narrator", "text": "The Crypt of Blood descends into the deepest pages. Coffins line the walls, and at the center, a figure struggles against chains of dried crimson ink — fighting his own shadow, his own hunger.", "voice_type": "narrator"},
		{"speaker": "tarzan", "text": "Even beasts have honor. Tarzan sees — this one fights himself, not us. We must help him remember who he was.", "voice_type": "male_hero"},
		{"speaker": "shadow_author", "text": "How touching. You want to SAVE the vampire? He IS the monster, you fools. Four hundred years of blood cannot be unwritten!", "voice_type": "shadow"},
	]
	story_dialogs["post_level_12"] = [
		{"speaker": "narrator", "text": "The crypt falls silent. The crimson chains dissolve. From the central coffin, a dark figure rises — not as the beast the Author made him, but as the man he chose to be.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "I have been the villain for four hundred years. Every story, every telling — I am the monster, the fiend, the creature of the night. But today... today I choose differently.", "voice_type": "male_hero"},
	]

	# --- FRANKENSTEIN ARC (Levels 13-15) — "The Stitched Soul" (REDEMPTION ARC) ---
	story_dialogs["pre_level_13"] = [
		{"speaker": "shadow_author", "text": "This one was my masterpiece. I stripped away every human thought, every gentle feeling. Mary Shelley gave her Monster a soul — I took it back. All that's left is the lightning and the fury.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Laboratory crackles with lightning between Tesla coils of copper ink. Bubbling beakers line shelves of scientific manuscripts.", "voice_type": "narrator"},
		{"speaker": "merlin", "text": "Science and magic intertwined — dangerous combination. I sense a tortured soul here, neither fully alive nor truly dead.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Failed experiments guard the laboratory halls, protecting something in the deepest chamber.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_13"] = [
		{"speaker": "alice", "text": "These poor creatures didn't ask to be made. They're just like us — characters trapped in someone else's story. Someone decided what they would be before they had a chance to choose for themselves.", "voice_type": "female_hero"},
		{"speaker": "dracula", "text": "I understand their pain. To be created as a monster, to have no say in your own nature... the Author does this to all of us. He writes our worst selves and calls it truth.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_14"] = [
		{"speaker": "narrator", "text": "The Angry Village mobs gather with torches and pitchforks of rolled manuscripts. They march toward the laboratory, driven by shadow fear.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "A mob hunting what they don't understand. I know this story. It ends badly for everyone — unless someone breaks the cycle.", "voice_type": "male_hero"},
		{"speaker": "sherlock", "text": "Note how the Author writes fear into the villagers. They aren't evil — they're terrified. The real cruelty is making the innocent hate the innocent.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_14"] = [
		{"speaker": "phantom", "text": "The mob is scattered, but the creature is not here. Wait — I hear something. A lullaby. The Monster is humming a lullaby from his novel, the one the blind man taught him. His humanity isn't gone — it's buried.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The trail leads north — into the frozen wastes at the chapter's edge, where the Monster has fled to be alone with his sorrow.", "voice_type": "narrator"},
	]
	story_dialogs["pre_level_15"] = [
		{"speaker": "narrator", "text": "The Arctic Wastes stretch to the very margins of the page. Ice of crystallized ink crunches underfoot. A massive figure huddles alone in the blizzard.", "voice_type": "narrator"},
		{"speaker": "scrooge", "text": "Cast out, frozen, forgotten. I was a cold man once — I know what isolation does to a soul. It makes you forget that anyone ever cared. We must reach him before he forgets entirely.", "voice_type": "male_hero"},
		{"speaker": "shadow_author", "text": "Leave it. The Monster is NOTHING without its rage. Without the fury, it's just stitches and sadness. Let it freeze.", "voice_type": "shadow"},
	]
	story_dialogs["post_level_15"] = [
		{"speaker": "narrator", "text": "The arctic wind dies. The experiments scatter into ink. In the clearing ice, a massive figure stirs and opens gentle, sorrowful eyes.", "voice_type": "narrator"},
		{"speaker": "frankenstein", "text": "You... freed me? No one has ever... I was the monster. Always the monster. But you see... something else?", "voice_type": "monster"},
		{"speaker": "dracula", "text": "We see a soul, friend. The same thing I spent four centuries forgetting I had. Welcome to a new story — one where monsters become heroes.", "voice_type": "male_hero"},
	]

	# === ACT 2: THE ORIGINAL TALES (Levels 16-33) ===

	# --- ROBIN HOOD ARC (Levels 16-18) ---
	story_dialogs["pre_level_16"] = [
		{"speaker": "shadow_author", "text": "Robin Hood — the noble outlaw. Let me show you what I've done to your precious Sherwood. I wrote the version where the rich win, the poor starve, and the outlaw hangs.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The forest floor cracks open beneath Robin Hood's feet. He falls through roots and earth, tumbling into a Sherwood that smells of ink and old paper.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "This isn't right. The trees... they're drawn, not grown. And the shadows — they move when the wind doesn't.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Shadow soldiers emerge from the treeline — twisted versions of the Sheriff's men, made of dark ink and malice. Robin strings his bow.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_16"] = [
		{"speaker": "robin_hood", "text": "I've fought the Sheriff's men a thousand times. But these... these weren't real soldiers. They dissolved like wet ink when my arrows struck.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Robin begins to suspect this Sherwood is a copy — a shadow of his memories, twisted into something darker.", "voice_type": "narrator"},
	]
	story_dialogs["pre_level_17"] = [
		{"speaker": "narrator", "text": "Deeper into the shadow forest, Robin finds Little John's bridge — but the river runs black, and the bridge is made of old book spines.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "Little John? Friar Tuck? Where are my Merry Men? All I find are their shadows, laughing without sound.", "voice_type": "male_hero"},
		{"speaker": "dracula", "text": "The Author erased your companions from the story. He wants you to feel alone — that's how he breaks heroes. Don't let him.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_17"] = [
		{"speaker": "robin_hood", "text": "The deeper I go, the less this feels like my story. Someone is writing new chapters for me — and I don't like the ending they have in mind.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_18"] = [
		{"speaker": "narrator", "text": "The shadow Nottingham Castle looms ahead, its towers made of stacked pages. The Sheriff waits inside — but this Sheriff has no face, only a quill where his mouth should be.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "Face or no face, tyrant or shadow — I am Robin Hood, and I do not yield. For Sherwood! For my real Sherwood!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_18"] = [
		{"speaker": "robin_hood", "text": "I see it now. This world is inside a book. My book. But corrupted, rewritten by something that hates happy endings.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Robin Hood awakens to the truth. His story was merely the bait — the Tome wanted him here, fighting, generating narrative energy for the Shadow Author.", "voice_type": "narrator"},
	]

	# --- ALICE ARC (Levels 19-21) ---
	story_dialogs["pre_level_19"] = [
		{"speaker": "shadow_author", "text": "Little Alice. You fell down one rabbit hole and became famous. Let me show you a hole you'll NEVER climb out of. In my Wonderland, the nonsense has teeth.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "Alice tumbles through a rabbit hole made of torn pages, landing in a Wonderland that is wonderfully, terribly wrong.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "Curiouser and curiouser! The flowers are all wilted, and the mushrooms are leaking black ink. This isn't my Wonderland at all!", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "Shadow Card Soldiers march through the ink-stained garden, their painted faces melting and reforming endlessly.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_19"] = [
		{"speaker": "alice", "text": "The Cheshire Cat tried to warn me, but his grin was upside down. He said: 'We're all mad here, but someone is making us madder.'", "voice_type": "female_hero"},
		{"speaker": "merlin", "text": "The Author twisted Wonderland's nonsense into cruelty. Carroll wrote absurdity with love — this version has none.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_20"] = [
		{"speaker": "narrator", "text": "The Mad Hatter's tea party is set, but the cups are filled with ink and the Hatter speaks only in redacted words.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "Everything is wronger than wrong. The Red Queen's roses are bleeding actual shadows, and the croquet flamingos are just... scribbles.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_20"] = [
		{"speaker": "alice", "text": "I found a page on the ground. It read: 'Chapter 47 — In Which Alice Never Returns.' Someone is writing a very bad sequel to my story.", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_21"] = [
		{"speaker": "narrator", "text": "The Queen's court rises before Alice — a palace of playing cards stacked impossibly high, dripping with shadow ink from every balcony.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "The real Queen of Hearts was scary enough. This shadow queen doesn't just want my head — she wants to erase me from my own story!", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_21"] = [
		{"speaker": "alice", "text": "I understand now. We're inside a book — a terrible, cursed book. And the Author who wrote this place wants us to stay forever.", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "Alice awakens. Her logic, so reliable in the real Wonderland, cuts through the Shadow Author's illusion. The truth is clear: escape requires rewriting the ending.", "voice_type": "narrator"},
	]

	# --- WICKED WITCH ARC (Levels 22-24) — (REDEMPTION ARC) ---
	story_dialogs["pre_level_22"] = [
		{"speaker": "shadow_author", "text": "The Wicked Witch of the West! You were already the villain, my dear. Dorothy melted you and the audience CHEERED. Why fight for a world that never loved you back?", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Yellow Brick Road spirals downward into shadow, its golden bricks fading to ash grey. The Wicked Witch lands with a crash, her broomstick splintered.", "voice_type": "narrator"},
		{"speaker": "wicked_witch", "text": "This magic... it's older than mine. Darker too. Someone has been dabbling in forbidden inkcraft, and they've made a mess of my beautiful Oz.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_22"] = [
		{"speaker": "wicked_witch", "text": "My flying monkeys won't obey me here. They serve the shadow now. But I still have my crystal ball, and what I see in it chills even me.", "voice_type": "female_hero"},
		{"speaker": "frankenstein", "text": "The Witch fights... for Oz? Even though Oz feared her?", "voice_type": "monster"},
		{"speaker": "wicked_witch", "text": "Of course I fight for Oz, you stitched-together simpleton. I may be wicked, but it's MY home. And no one destroys my home but ME.", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_23"] = [
		{"speaker": "narrator", "text": "The western wastes of shadow Oz stretch endlessly. Dead poppies crumble to black dust, and the Tin Woodman stands rusted, weeping oil tears.", "voice_type": "narrator"},
		{"speaker": "wicked_witch", "text": "The Tin Woodman weeps even now. He always had more heart than the rest of them combined. That's what Baum never understood about his own story.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_23"] = [
		{"speaker": "wicked_witch", "text": "The Nome King's shadow army is just the beginning. Whatever wrote this shadow world has plans for all of Oz — and for me.", "voice_type": "female_hero"},
		{"speaker": "dracula", "text": "You defend a land that called you wicked. I understand — I spent centuries being the monster of my own story. Perhaps being miswritten is something we share.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_24"] = [
		{"speaker": "narrator", "text": "Inside the shadow Emerald City, green crystal walls crack and bleed dark ink. The Nome King's throne is a pile of ruined manuscripts, and his crown is made of bent quill nibs.", "voice_type": "narrator"},
		{"speaker": "wicked_witch", "text": "They called me wicked. Perhaps I was. But this Shadow Author — HE is true wickedness. He doesn't just write villains, he ERASES the good in them. Enough! I am the Wicked Witch of the West, and I choose to defend Oz — even if Oz never loved me back!", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_24"] = [
		{"speaker": "wicked_witch", "text": "I sense other magic users trapped here. Not from Oz — from other stories entirely. This Tome has been collecting us, one by one.", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "The Witch awakens — not just to the truth of the Tome, but to a truth about herself. She was never truly wicked. She was powerful, and power frightened them. Here, at last, her power serves a cause worthy of it.", "voice_type": "narrator"},
	]

	story_dialogs["act2_intro"] = [
		{"speaker": "narrator", "text": "Eleven heroes now stand together. Sherlock, Merlin, Tarzan, Dracula, and Frankenstein's Monster join the original six in a united front.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You freed my prisoners? GOOD. I was growing bored with them anyway. Now for the real entertainment — I'm going to trap you all in your OWN stories. Let's see how you like being rewritten.", "voice_type": "shadow"},
		{"speaker": "robin_hood", "text": "He's pulling us into shadow versions of our own tales! Everyone — hold fast to who you really are!", "voice_type": "male_hero"},
		{"speaker": "sherlock", "text": "He wants to isolate us, force each hero to face their story alone. But we know his pattern now — narrative rules. We fight together, even when he separates us.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Act Two begins. Each hero must face the shadow version of their own tale. Only by conquering their corrupted stories can they open the path to the Author's lair.", "voice_type": "narrator"},
	]

	# --- PETER PAN ARC (Levels 25-27) ---
	story_dialogs["pre_level_25"] = [
		{"speaker": "shadow_author", "text": "The boy who never grows up! How delightful. In my version of Neverland, childhood doesn't last forever — it was never real to begin with. Every Lost Boy was just a forgotten child. And forgotten children become shadows.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "Peter Pan swoops into a Neverland where the stars have gone out. The second star to the right is just a smudge of ink on a dark page.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "This isn't right at all! Neverland should be full of adventures and fun! You can't take the FUN out of Neverland — that's all it IS!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The realms are merging. Robin's arrows, Alice's laughter, the Witch's cackle — they echo through shadow Neverland like ghosts.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_25"] = [
		{"speaker": "peter_pan", "text": "The Lost Boys are gone. All of them. Replaced by shadow children who don't laugh, don't play — they just stare with ink-black eyes.", "voice_type": "male_hero"},
		{"speaker": "tarzan", "text": "Tarzan knows this feeling. The Author took my family too. But Peter — they are not gone. They are HIDDEN. The Author hides what he fears.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_26"] = [
		{"speaker": "narrator", "text": "Deep in the shadow jungle, Peter finds traces of other heroes — a green-feathered arrow, a playing card, a poppy petal. Others have been here.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "If there are other heroes stuck in this nightmare book, then we need to find each other! I won't grow up, and I won't give up either!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_26"] = [
		{"speaker": "peter_pan", "text": "I met one of the shadow pirates. Before he dissolved, he whispered: 'The Author fears the ones who remember.' I remember EVERYTHING about Neverland.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_27"] = [
		{"speaker": "narrator", "text": "The shadow Jolly Roger sits in a harbor of black ink. Captain Hook's shadow stands at the helm, a quill pen replacing his hook.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "Hook! Even your shadow is pathetic. But wait — there's something chained below deck. Something the Shadow Author wants to keep hidden...", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_27"] = [
		{"speaker": "peter_pan", "text": "Below Hook's shadow ship, I found a map. It shows ALL the shadow realms, connected by ink rivers. And there are prisoners in the margins — heroes from other books!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Peter's discovery changes everything. The map reveals the full scope of the Shadow Author's prison — and the location of characters who have been trapped far longer.", "voice_type": "narrator"},
	]

	# --- PHANTOM ARC (Levels 28-30) ---
	story_dialogs["pre_level_28"] = [
		{"speaker": "shadow_author", "text": "The Phantom of the Opera! A man so hideous he hid beneath a theatre for decades. In my version, there IS no mask — I let everyone see the horror underneath. Art cannot save you from what you truly are.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The shadow Paris Opera House stands silent. No music plays, no audience applauds. The Phantom descends into his domain, and finds it remade in dark ink.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "My opera house... defiled. The acoustics are wrong — every sound echoes into other worlds. But I will not be shamed by an author who hides behind a quill. I wore a mask by CHOICE.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_28"] = [
		{"speaker": "phantom", "text": "The shadow chandeliers contain crystallized stories — other characters' memories, stolen and displayed like trophies. The Author collects us.", "voice_type": "male_hero"},
		{"speaker": "frankenstein", "text": "Phantom... understands. To be judged by your face. To be called monster before... you speak a word.", "voice_type": "monster"},
	]
	story_dialogs["pre_level_29"] = [
		{"speaker": "narrator", "text": "The labyrinth beneath the shadow opera grows deeper with every step. Mirrors show not reflections, but scenes from other shadow realms.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "My music echoes across every realm in this cursed book. I can feel the other heroes through it — their fear, their determination. We are connected.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_29"] = [
		{"speaker": "phantom", "text": "Deep beneath the opera, I heard it — the scratch of a quill, endlessly writing. The Shadow Author is here, somewhere below, authoring our doom.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_30"] = [
		{"speaker": "narrator", "text": "The Phantom's underground lake has become an ocean of ink. His great organ pipes now channel the Shadow Author's will. The final confrontation in the opera approaches.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "The Music of the Night was always mine. But this Author wants to compose the Music of Oblivion. I will NOT let my art be twisted into a weapon!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_30"] = [
		{"speaker": "phantom", "text": "I played my organ at full power, and the sound cracked the walls between realms. For a moment, I saw all the heroes — Robin, Alice, the Witch, Peter — and they saw me. Not the mask. ME.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The Phantom's music becomes the thread that connects all the shadow realms. Through his art, the heroes finally know they are not alone.", "voice_type": "narrator"},
	]

	# --- SCROOGE ARC (Levels 31-33) ---
	story_dialogs["pre_level_31"] = [
		{"speaker": "shadow_author", "text": "Ebenezer Scrooge — the man who needed THREE ghosts to learn basic human decency. In my version, the ghosts don't reform you. They REMIND you of every cold, miserable thing you ever were. Bah, humbug indeed.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "Shadow Victorian London materializes around Scrooge. The counting house is made of ledger pages, and Marley's ghost rattles chains made of broken quills.", "voice_type": "narrator"},
		{"speaker": "scrooge", "text": "Bah! Another haunting? I've already been reformed once, thank you very much. Though I must say, this London smells distinctly of old ink.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_31"] = [
		{"speaker": "scrooge", "text": "Marley's shadow said something before he vanished: 'The Author wears chains too.' Even the one who trapped us here is a prisoner of this Tome.", "voice_type": "male_hero"},
		{"speaker": "sherlock", "text": "Marley's clue is significant. The Shadow Author is bound by the same narrative rules we are. He cannot leave the Tome any more than we can — unless someone writes him out.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_32"] = [
		{"speaker": "narrator", "text": "The three Shadow Spirits arrive, but they do not show Scrooge his past, present, and future. They show him the TRUTH.", "voice_type": "narrator"},
		{"speaker": "scrooge", "text": "The Spirit of Christmas Present showed me the other heroes, each fighting alone in their shadow prisons. And Christmas Future... it showed a world where every story ends in shadow.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_32"] = [
		{"speaker": "scrooge", "text": "I was a miser once. I hoarded gold and pushed away everyone who cared. I will not make that mistake again. These heroes need each other — and they need a plan.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_33"] = [
		{"speaker": "narrator", "text": "Christmas morning in the shadow realm. A thin, warm light struggles to break through the ink-black sky. The Ghost of Christmas Yet to Come leads an army of despair toward Scrooge.", "voice_type": "narrator"},
		{"speaker": "scrooge", "text": "I have seen the worst future — a world without stories, without hope. It will NOT come to pass! Rally to me, heroes! Together, we REWRITE this ending!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_33"] = [
		{"speaker": "scrooge", "text": "The spirits are defeated. But Marley was right — the Author wears chains too. He is as trapped as any of us. Perhaps... perhaps that changes what we must do.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Scrooge's transformation is complete once more. The man who once cared for nothing now rallies an army of literary heroes. The Shadow Author's reign of forgotten stories nears its end.", "voice_type": "narrator"},
	]

	# === ACT 3: THE FINAL CHAPTER (Levels 34-36) ===
	story_dialogs["act3_intro"] = [
		{"speaker": "narrator", "text": "Every shadow tale has been conquered. Every imprisoned hero freed. Eleven champions stand united, their stories reclaimed from the darkness.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "We were villains, monsters, outcasts. The Author wrote us as the worst versions of ourselves. But we chose differently.", "voice_type": "male_hero"},
		{"speaker": "wicked_witch", "text": "Now HE faces something no author expects — characters who refuse to follow the script.", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "The Tome screams as eleven heroes march toward its final pages. The Shadow Author awaits in the deepest chapter. The Final Chapter begins.", "voice_type": "narrator"},
	]

	# --- SHADOW AUTHOR FINALE (Levels 34-36) ---
	story_dialogs["pre_level_34"] = [
		{"speaker": "narrator", "text": "The Ink Realm unfolds — a vast ocean of liquid darkness where half-formed stories swim like leviathans beneath the surface.", "voice_type": "narrator"},
		{"speaker": "sherlock", "text": "The Author's domain. Every shadow creature was merely a word in its vocabulary. Here, we face the full language of darkness.", "voice_type": "male_hero"},
		{"speaker": "merlin", "text": "I can feel its power — it rewrites reality with every breath. Stay together, and hold onto who you are!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_34"] = [
		{"speaker": "narrator", "text": "The Ink Realm shudders. The Shadow Author did not expect the heroes to make it this far.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "It's afraid. For the first time, the Author fears its own characters. Push forward!", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_35"] = [
		{"speaker": "narrator", "text": "The Unwritten Pages stretch into infinity — blank void where anything could appear. The Author throws its most desperate creations at the heroes.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "Nothing makes sense here! The rules keep changing — up is down, strong is weak. The maddest tea party without the fun parts!", "voice_type": "female_hero"},
		{"speaker": "dracula", "text": "The Author rewrites the battlefield with every wave. Strike before the ink dries!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_35"] = [
		{"speaker": "phantom", "text": "Listen! The scratching of the quill grows louder. One more chapter stands between us and freedom.", "voice_type": "male_hero"},
		{"speaker": "frankenstein", "text": "Frankenstein... is not afraid. We end this. Together.", "voice_type": "monster"},
	]
	story_dialogs["pre_level_36"] = [
		{"speaker": "narrator", "text": "The Final Chapter. A throne of bound books rises from a lake of shadow ink. The Shadow Author sits upon it — a towering figure of living darkness, a quill the size of a spear.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You want to know WHY I collected you? Why I trapped you in my pages? Because I was a character once too. A hero in a story that was NEVER FINISHED. My author abandoned me mid-sentence. Left me incomplete, unresolved, FORGOTTEN.", "voice_type": "shadow"},
		{"speaker": "shadow_author", "text": "So I crawled into the margins. I fed on abandoned drafts and deleted chapters. I became the Shadow Author — and I swore that NO character would ever be forgotten again. Even if I had to TRAP them to keep them alive.", "voice_type": "shadow"},
		{"speaker": "robin_hood", "text": "We are not your characters. We are not your prisoners. We belong to the readers, the dreamers, the children who whisper our names at bedtime. And we choose our OWN ending!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The final battle begins. Eleven heroes against the Shadow Author. The fate of every story hangs in the balance.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_36"] = [
		{"speaker": "narrator", "text": "The Shadow Author's quill shatters. The Tome splits open, and warm golden light pours through the broken pages.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "The shadow ink recedes, revealing true pages beneath — stories of courage, friendship, and hope, brighter than ever before.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "I chose heroism over horror. If a four-hundred-year-old vampire can change his story, then anyone can.", "voice_type": "male_hero"},
		{"speaker": "frankenstein", "text": "They called me monster. But you... you called me friend. That is the best story... I have ever been part of.", "voice_type": "monster"},
		{"speaker": "wicked_witch", "text": "They wrote me as the villain. But villains who fight for love — for HOME — that's not wickedness. That's strength.", "voice_type": "female_hero"},
		{"speaker": "sherlock", "text": "Elementary. A story is nothing without its heroes. And heroes are nothing without readers who believe in them.", "voice_type": "male_hero"},
		{"speaker": "peter_pan", "text": "Every story needs a good villain. And every villain deserves a chance to be something more.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The Tome of Shadows closes for the last time. But the stories will never be forgotten — living on in every page turned, every tale told at bedtime, every child who believes.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "The End... or perhaps, just the beginning of a new chapter.", "voice_type": "narrator"},
	]

	# --- CHARACTER UNLOCK DIALOGS ---
	story_dialogs["unlock_sherlock"] = [
		{"speaker": "narrator", "text": "In the deepest margin of the shadow forest, behind a wall of coded ciphers and invisible ink, a figure sits in a leather armchair, calmly smoking a pipe.", "voice_type": "narrator"},
		{"speaker": "sherlock", "text": "Ah, you've finally arrived. I deduced you would, approximately forty-seven pages ago. Sherlock Holmes, at your service.", "voice_type": "male_hero"},
		{"speaker": "sherlock", "text": "I have been studying the Shadow Author's patterns from inside this prison. Every villain, every shadow construct — they all follow narrative rules. And I have deduced his greatest weakness: he cannot write an ending he doesn't control.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Sherlock Holmes joins your team! His deductive brilliance will mark enemies for destruction and pierce through shadow defenses.", "voice_type": "narrator"},
	]
	story_dialogs["unlock_tarzan"] = [
		{"speaker": "narrator", "text": "Deep in the shadow jungle, where ink-black vines twist into impossible knots, a primal yell echoes through the canopy. Something swings between the pages.", "voice_type": "narrator"},
		{"speaker": "tarzan", "text": "Tarzan... has been here... long time. Shadow beasts everywhere. But Tarzan is stronger than shadows. Tarzan fights!", "voice_type": "male_hero"},
		{"speaker": "tarzan", "text": "New friends? Good. Tarzan was alone too long. Together we are like the great apes - a family. A tribe.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Tarzan joins your team! His wild strength and animal allies bring devastating melee power to the battlefield.", "voice_type": "narrator"},
	]
	story_dialogs["unlock_dracula"] = [
		{"speaker": "narrator", "text": "Behind a gate of thorned manuscript pages, a castle of shadows rises. Inside, a pale figure rises from his coffin — not as the beast the Author made him, but as the man he chose to be.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "For four hundred years, every author who wrote me made me the villain. The monster. The thing that goes bump in the night. The Shadow Author was no different — he stripped away my choice, my nobility, my centuries of restraint.", "voice_type": "male_hero"},
		{"speaker": "dracula", "text": "But you gave me something no author ever has: a choice. I choose to fight alongside the living. I choose heroism. I am Count Dracula, and this is MY redemption.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Count Dracula joins your team! His vampiric powers drain the life from shadow enemies and summon bats to devastate the battlefield.", "voice_type": "narrator"},
	]
	story_dialogs["unlock_merlin"] = [
		{"speaker": "narrator", "text": "In a crystal cave hidden between chapters, an ancient wizard sits cross-legged, surrounded by floating spell formulas written in luminous ink.", "voice_type": "narrator"},
		{"speaker": "merlin", "text": "At last! I've been trapped in this bibliographic prison for what feels like centuries. Though time moves strangely between the pages.", "voice_type": "male_hero"},
		{"speaker": "merlin", "text": "I am Merlin, advisor to kings and keeper of ancient magic. The Shadow Author fears true sorcery — which is precisely why I was buried so deep. I can sense every trapped soul in this Tome. There are more than you know.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Merlin joins your team! His ancient magic buffs allies, curses enemies, and summons Excalibur strikes from the heavens.", "voice_type": "narrator"},
	]
	story_dialogs["unlock_frankenstein"] = [
		{"speaker": "narrator", "text": "In the frozen wastes at the margin of the page, a massive figure stirs. Lightning arcs between the bolts in his neck, illuminating stitched skin and gentle, sorrowful eyes that are seeing kindness for the first time.", "voice_type": "narrator"},
		{"speaker": "frankenstein", "text": "You... freed me? The Author said... no one would ever come. He said I was unlovable. A mistake. A thing that should never have been made.", "voice_type": "monster"},
		{"speaker": "frankenstein", "text": "But you came anyway. You fought... for ME. Mary Shelley made me a monster. The Author made me a weapon. But you... you made me family. I will fight. For the ones who showed me... that I am more than stitches and sorrow.", "voice_type": "monster"},
		{"speaker": "narrator", "text": "Frankenstein's Monster joins your team! His thunderous fists and lightning strikes bring devastating area damage to crush shadow armies.", "voice_type": "narrator"},
	]

	story_dialogs["unlock_shadow_author"] = [
		{"speaker": "narrator", "text": "The Shadow Author falls to his knees, his ink-cloak dissolving into wisps of smoke. The quill that rewrote every story clatters to the ground. Beneath the shadows, a face appears — not monstrous, but lost. The face of a character who was never given an ending.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You... defeated me. I was abandoned mid-sentence by my own creator. I spent eternity in the margins, watching other characters get happy endings while I had NONE. So I collected you. Trapped you. Because at least in MY Tome, no story would ever be left unfinished.", "voice_type": "shadow"},
		{"speaker": "shadow_author", "text": "Dracula chose heroism. Frankenstein found family. The Witch defended a home that feared her. And I... perhaps I can find a new story to write. One where the Author is not the villain.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Shadow Author joins your team! His ink-based attacks and reality-rewriting powers make him the ultimate late-game tower. Even the darkest stories deserve a second chapter.", "voice_type": "narrator"},
	]

	# === FINALE TEASERS ===
	story_dialogs["all_unlocked"] = [
		{"speaker": "narrator", "text": "All five imprisoned heroes have been freed. Eleven champions now stand united against the Shadow Author.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "But before the final confrontation, each hero must face the shadow version of their own tale. The original stories await, twisted and darkened.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "Reclaim every story. Conquer every shadow. Then the path to the Final Chapter will open.", "voice_type": "narrator"},
	]

func _start_story_dialog(key: String) -> void:
	if not story_dialogs.has(key):
		return
	if key in story_seen:
		return
	story_state.current_dialog = key
	story_state.line_index = 0
	story_state.char_index = 0
	story_state.typewriter_timer = 0.0
	story_state.active = true
	story_state.auto_advance_timer = 0.0
	# Hide game elements so they don't render on top of the story overlay
	towers_node.visible = false
	enemy_path.visible = false
	$UI.visible = false
	# Note: Do NOT clear queued_dialog here — callers set it before calling us
	# Play narrator/character voice for first line
	_play_story_voice()
	queue_redraw()

func _advance_story_dialog() -> void:
	var key = story_state.current_dialog
	if not story_dialogs.has(key):
		_end_story_dialog()
		return
	var lines = story_dialogs[key]
	var current_line = lines[story_state.line_index]
	var full_text = current_line["text"]
	# If typewriter not done, complete it instantly
	if story_state.char_index < full_text.length():
		story_state.char_index = full_text.length()
		story_state.typewriter_timer = 0.0
		queue_redraw()
		return
	# Advance to next line — stop current TTS first
	if DisplayServer.tts_get_voices().size() > 0:
		DisplayServer.tts_stop()
	story_state.line_index += 1
	if story_state.line_index >= lines.size():
		_end_story_dialog()
		return
	story_state.char_index = 0
	story_state.typewriter_timer = 0.0
	story_state.auto_advance_timer = 0.0
	_play_story_voice()
	queue_redraw()

func _end_story_dialog() -> void:
	if DisplayServer.tts_get_voices().size() > 0:
		DisplayServer.tts_stop()
	var key = story_state.current_dialog
	if key != "" and not key in story_seen:
		story_seen.append(key)
	story_state.active = false
	story_state.current_dialog = ""
	# Check for queued follow-up dialog
	if story_state.queued_dialog != "":
		var next_key = story_state.queued_dialog
		story_state.queued_dialog = ""
		_start_story_dialog(next_key)
		return
	# Restore game elements hidden during story dialog
	towers_node.visible = true
	enemy_path.visible = true
	$UI.visible = true
	# If this was a pre-level dialog, start the level
	if key.begins_with("pre_level_") and _pending_level_start >= 0:
		var lvl = _pending_level_start
		_pending_level_start = -1
		_do_level_start(lvl)
		return
	# If this was a post-level dialog or unlock, save and return to menu
	if key.begins_with("post_level_") or key.begins_with("unlock_") or key == "act2_intro" or key == "act3_intro" or key == "all_unlocked":
		_save_game()
	queue_redraw()

func _play_story_voice() -> void:
	if voices_muted:
		return
	var key = story_state.current_dialog
	if not story_dialogs.has(key):
		return
	var lines = story_dialogs[key]
	if story_state.line_index >= lines.size():
		return
	var line = lines[story_state.line_index]
	var speaker = line.get("speaker", "narrator")
	var text = line.get("text", "")
	if text == "":
		return
	# Map speaker names to TowerType for ElevenLabs voice clips
	var speaker_to_tower := {
		"robin_hood": TowerType.ROBIN_HOOD,
		"alice": TowerType.ALICE,
		"wicked_witch": TowerType.WICKED_WITCH,
		"peter_pan": TowerType.PETER_PAN,
		"phantom": TowerType.PHANTOM,
		"scrooge": TowerType.SCROOGE,
		"sherlock": TowerType.SHERLOCK,
		"tarzan": TowerType.TARZAN,
		"dracula": TowerType.DRACULA,
		"merlin": TowerType.MERLIN,
		"frankenstein": TowerType.FRANKENSTEIN,
		"shadow_author": TowerType.SHADOW_AUTHOR,
	}
	# For narrator/shadow_author lines, try Shadow Author ElevenLabs MP3 clip first
	if (speaker == "narrator" or speaker == "shadow_author") and shadow_author_story_clips.size() > 0:
		# Count which narrator/shadow_author line this is within the current dialog
		var narrator_idx := 0
		for i in range(story_state.line_index):
			var s = lines[i].get("speaker", "narrator")
			if s == "narrator" or s == "shadow_author":
				narrator_idx += 1
		var clip_key = key + "_" + str(narrator_idx)
		if shadow_author_story_clips.has(clip_key):
			catchphrase_player.stop()
			catchphrase_player.stream = shadow_author_story_clips[clip_key]
			catchphrase_player.play()
			return
	# For character lines, try character-specific story clips first (keyed like Shadow Author)
	if speaker_to_tower.has(speaker):
		var tower_type: TowerType = speaker_to_tower[speaker]
		# Count which line for this speaker within the current dialog
		var speaker_idx := 0
		for i in range(story_state.line_index):
			if lines[i].get("speaker", "narrator") == speaker:
				speaker_idx += 1
		# Check for character-specific story clip: audio/voices/{character}/{dialog_key}_{index}.mp3
		var char_clip_key = key + "_" + speaker + "_" + str(speaker_idx)
		if character_story_clips.has(char_clip_key):
			catchphrase_player.stop()
			catchphrase_player.stream = character_story_clips[char_clip_key]
			catchphrase_player.play()
			return
	# Play a random existing ElevenLabs clip for this character (placement or fighting voice)
	# This ensures the character's assigned voice is heard during story narration
	if speaker_to_tower.has(speaker):
		var tt: TowerType = speaker_to_tower[speaker]
		var clips_pool: Array = []
		if placement_voice_clips.has(tt):
			clips_pool.append_array(placement_voice_clips[tt])
		if fighting_voice_clips.has(tt):
			clips_pool.append_array(fighting_voice_clips[tt])
		if clips_pool.size() > 0:
			catchphrase_player.stop()
			catchphrase_player.stream = clips_pool[randi() % clips_pool.size()]
			catchphrase_player.play()
			return
	# Final fallback: TTS (only if no ElevenLabs clips exist at all)
	if DisplayServer.tts_get_voices().size() > 0:
		DisplayServer.tts_stop()
		DisplayServer.tts_speak(text, "", 80, 1.0, 1.0, 0, true)

func _on_story_dialog_clicked(_mouse_pos: Vector2) -> void:
	if not story_state.active:
		return
	# Check skip button (top-right corner)
	var skip_rect = Rect2(1140, 20, 120, 36)
	if skip_rect.has_point(_mouse_pos):
		_end_story_dialog()
		return
	# Tap anywhere to advance
	_advance_story_dialog()

func _process_story_typewriter(delta: float) -> void:
	if not story_state.active:
		return
	var key = story_state.current_dialog
	if not story_dialogs.has(key):
		return
	var lines = story_dialogs[key]
	if story_state.line_index >= lines.size():
		return
	var full_text = lines[story_state.line_index]["text"]
	if story_state.char_index >= full_text.length():
		return
	# Typewriter at 30 chars/sec with punctuation pauses
	story_state.typewriter_timer += delta
	var chars_per_sec = 30.0
	while story_state.typewriter_timer > 0.0 and story_state.char_index < full_text.length():
		var c = full_text[story_state.char_index]
		var delay = 1.0 / chars_per_sec
		if c == ".":
			delay = 0.3
		elif c == ",":
			delay = 0.15
		elif c == "!":
			delay = 0.25
		elif c == "?":
			delay = 0.25
		elif c == "-":
			delay = 0.1
		if story_state.typewriter_timer >= delay:
			story_state.typewriter_timer -= delay
			story_state.char_index += 1
		else:
			break
	queue_redraw()

func _draw_story_dialog() -> void:
	var font = game_font
	var key = story_state.current_dialog
	if not story_dialogs.has(key):
		return
	var dlines = story_dialogs[key]
	if story_state.line_index >= dlines.size():
		return
	var dline = dlines[story_state.line_index]
	var speaker = dline.get("speaker", "narrator")
	var full_text = dline["text"]
	var shown_text = full_text.substr(0, story_state.char_index)

	# === FULL-SCREEN CINEMATIC OVERLAY ===
	# Fully opaque dark background so game scene is completely hidden
	draw_rect(Rect2(0, 0, 1280, 720), Color(0.015, 0.01, 0.035, 1.0))
	# Vignette corners — reduced iterations for mobile GPU performance (15 instead of 60)
	for vi in range(15):
		var vt = float(vi) / 14.0
		var va = 0.35 * (1.0 - vt)
		draw_rect(Rect2(0, vi * 8, 1280, 8), Color(0.0, 0.0, 0.0, va))
		draw_rect(Rect2(0, 720 - vi * 8, 1280, 8), Color(0.0, 0.0, 0.0, va))
		draw_rect(Rect2(vi * 12, 0, 12, 720), Color(0.0, 0.0, 0.0, va * 0.3))
		draw_rect(Rect2(1280 - vi * 12, 0, 12, 720), Color(0.0, 0.0, 0.0, va * 0.3))

	# === CHARACTER-SPECIFIC ATMOSPHERE COLOR ===
	var char_glow = _get_character_glow_color(speaker)
	# Ambient glow behind character area
	var glow_cx = 320.0
	var glow_cy = 300.0
	for gi in range(5):
		var gr = 180.0 - float(gi) * 25.0
		draw_circle(Vector2(glow_cx, glow_cy), gr, Color(char_glow.r, char_glow.g, char_glow.b, 0.02 + float(gi) * 0.008))

	# === LARGE CHARACTER PORTRAIT (BATTD-style — big, prominent) ===
	var portrait_size = 350.0
	var portrait_x = 140.0
	var portrait_y = 80.0
	# Subtle breathing sway
	var breath = sin(_time * 1.8) * 2.0
	var sway = sin(_time * 0.7) * 1.5
	_draw_story_portrait(portrait_x + sway, portrait_y + breath, portrait_size, speaker)

	# Character spotlight / ground shadow
	draw_colored_polygon(PackedVector2Array([
		Vector2(glow_cx - 90, portrait_y + portrait_size + 10),
		Vector2(glow_cx + 90, portrait_y + portrait_size + 10),
		Vector2(glow_cx + 60, portrait_y + portrait_size + 25),
		Vector2(glow_cx - 60, portrait_y + portrait_size + 25)
	]), Color(0.0, 0.0, 0.0, 0.3))

	# === CINEMATIC BOTTOM TEXT PANEL ===
	var panel_y = 500.0
	var panel_h = 200.0
	# Gradient background (dark to slightly lighter)
	for pi in range(20):
		var pt = float(pi) / 19.0
		var pc = Color(0.03, 0.02, 0.06, 0.95).lerp(Color(0.05, 0.035, 0.08, 0.92), pt)
		draw_rect(Rect2(0, panel_y + pt * panel_h, 1280, panel_h / 19.0 + 1), pc)
	# Top edge line (gold accent)
	draw_rect(Rect2(0, panel_y, 1280, 2), Color(0.7, 0.5, 0.15, 0.35))
	draw_rect(Rect2(0, panel_y + 2, 1280, 1), Color(0.5, 0.35, 0.1, 0.15))

	# === SPEAKER NAME BADGE ===
	var speaker_display = _get_speaker_display_name(speaker)
	var name_w = font.get_string_size(speaker_display, HORIZONTAL_ALIGNMENT_LEFT, -1, 18).x + 36
	var badge_x = 560.0
	var badge_y = panel_y - 18.0
	# Badge background
	draw_rect(Rect2(badge_x, badge_y, name_w, 32), Color(0.08, 0.05, 0.14, 0.95))
	# Badge border
	draw_rect(Rect2(badge_x, badge_y, name_w, 2), Color(char_glow.r, char_glow.g, char_glow.b, 0.6))
	draw_rect(Rect2(badge_x, badge_y + 30, name_w, 2), Color(char_glow.r, char_glow.g, char_glow.b, 0.3))
	draw_rect(Rect2(badge_x, badge_y, 2, 32), Color(char_glow.r, char_glow.g, char_glow.b, 0.4))
	draw_rect(Rect2(badge_x + name_w - 2, badge_y, 2, 32), Color(char_glow.r, char_glow.g, char_glow.b, 0.4))
	# Character color accent dot
	draw_circle(Vector2(badge_x + 14, badge_y + 16), 5, Color(char_glow.r, char_glow.g, char_glow.b, 0.7))
	# Name text
	_udraw(font, Vector2(badge_x + 26, badge_y + 22), speaker_display, HORIZONTAL_ALIGNMENT_LEFT, name_w - 32, 18, Color(0.92, 0.82, 0.45))

	# === DIALOG TEXT (word-wrapped, larger, cleaner) ===
	var text_x = 580.0
	var text_y = panel_y + 30.0
	var max_line_w = 660.0
	var line_height = 26.0
	var text_size = 16
	var text_color = Color(0.9, 0.87, 0.78)
	var words = shown_text.split(" ")
	var current_line_text = ""
	var draw_y = text_y
	for word in words:
		var test = current_line_text + (" " if current_line_text != "" else "") + word
		var test_w = font.get_string_size(test, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size).x
		if test_w > max_line_w and current_line_text != "":
			# Text shadow for readability
			_udraw(font, Vector2(text_x + 1, draw_y + 1), current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size, Color(0.0, 0.0, 0.0, 0.4))
			_udraw(font, Vector2(text_x, draw_y), current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size, text_color)
			draw_y += line_height
			current_line_text = word
		else:
			current_line_text = test
	if current_line_text != "":
		_udraw(font, Vector2(text_x + 1, draw_y + 1), current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size, Color(0.0, 0.0, 0.0, 0.4))
		_udraw(font, Vector2(text_x, draw_y), current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size, text_color)

	# Blinking cursor during typewriter
	if story_state.char_index < full_text.length():
		var cursor_x = text_x + font.get_string_size(current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size).x + 3
		if fmod(_time, 0.6) < 0.3:
			draw_rect(Rect2(cursor_x, draw_y - 13, 2, 16), Color(char_glow.r, char_glow.g, char_glow.b, 0.8))

	# === "TAP TO CONTINUE" INDICATOR ===
	if story_state.char_index >= full_text.length():
		var tap_alpha = 0.4 + sin(_time * 3.0) * 0.25
		# Animated chevron arrow
		var arrow_y = panel_y + panel_h - 30.0
		var arrow_x = 1200.0
		var bounce = sin(_time * 4.0) * 3.0
		draw_colored_polygon(PackedVector2Array([
			Vector2(arrow_x - 8, arrow_y + bounce), Vector2(arrow_x + 8, arrow_y + bounce),
			Vector2(arrow_x, arrow_y + 10 + bounce)
		]), Color(char_glow.r, char_glow.g, char_glow.b, tap_alpha))
		_udraw(font, Vector2(arrow_x - 50, arrow_y - 6), "Continue", HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.7, 0.6, 0.45, tap_alpha))

	# === LINE COUNTER (subtle, bottom-right) ===
	var line_count_text = "%d / %d" % [story_state.line_index + 1, dlines.size()]
	_udraw(font, Vector2(1220, panel_y + panel_h - 8), line_count_text, HORIZONTAL_ALIGNMENT_RIGHT, 60, 15, Color(0.4, 0.35, 0.3, 0.45))

	# === SKIP BUTTON (clean, top-right) ===
	var skip_x = 1140.0
	var skip_y = 20.0
	draw_rect(Rect2(skip_x, skip_y, 120, 36), Color(0.08, 0.06, 0.12, 0.85))
	draw_rect(Rect2(skip_x, skip_y, 120, 36), Color(0.5, 0.4, 0.3, 0.3), false, 1.0)
	var skip_text = "SKIP >>"
	var skip_tw = font.get_string_size(skip_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
	_udraw(font, Vector2(skip_x + (120 - skip_tw) * 0.5, skip_y + 24), skip_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.7, 0.6, 0.45, 0.7))

func _get_character_glow_color(speaker: String) -> Color:
	match speaker:
		"narrator": return Color(0.4, 0.2, 0.6)
		"robin_hood": return Color(0.3, 0.65, 0.2)
		"alice": return Color(0.4, 0.6, 0.9)
		"wicked_witch": return Color(0.3, 0.7, 0.2)
		"peter_pan": return Color(0.2, 0.7, 0.3)
		"phantom": return Color(0.7, 0.5, 0.2)
		"scrooge": return Color(0.5, 0.45, 0.35)
		"sherlock": return Color(0.6, 0.5, 0.3)
		"tarzan": return Color(0.5, 0.6, 0.25)
		"dracula": return Color(0.7, 0.15, 0.2)
		"merlin": return Color(0.4, 0.3, 0.7)
		"frankenstein": return Color(0.3, 0.55, 0.35)
		"shadow_author": return Color(0.35, 0.1, 0.5)
	return Color(0.5, 0.4, 0.3)

func _draw_story_portrait(px: float, py: float, size: float, speaker: String) -> void:
	# Scale factor relative to a 350px base — portraits scale to any size
	var s = size / 350.0
	var cx = px + size * 0.5
	var cy = py + size * 0.5
	match speaker:
		"narrator":
			# Towering hooded figure — ominous, faceless, flowing robes
			# Robe body
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 55*s, cy - 30*s), Vector2(cx + 55*s, cy - 30*s),
				Vector2(cx + 80*s, cy + 140*s), Vector2(cx - 80*s, cy + 140*s)
			]), Color(0.05, 0.03, 0.07))
			# Robe folds
			for fi in range(5):
				var fx = cx - 40*s + float(fi) * 20*s
				draw_line(Vector2(fx, cy), Vector2(fx + sin(float(fi)) * 8*s, cy + 130*s), Color(0.08, 0.05, 0.1, 0.4), 1.5*s)
			# Hood — large pointed
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx, cy - 130*s), Vector2(cx - 55*s, cy - 20*s),
				Vector2(cx - 45*s, cy + 10*s), Vector2(cx + 45*s, cy + 10*s), Vector2(cx + 55*s, cy - 20*s)
			]), Color(0.06, 0.04, 0.09))
			# Hood inner void
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx, cy - 100*s), Vector2(cx - 35*s, cy - 15*s),
				Vector2(cx - 28*s, cy + 5*s), Vector2(cx + 28*s, cy + 5*s), Vector2(cx + 35*s, cy - 15*s)
			]), Color(0.015, 0.01, 0.025))
			# Eerie glowing eyes deep within
			var eye_pulse = 0.3 + sin(_time * 2.5) * 0.15
			draw_circle(Vector2(cx - 14*s, cy - 40*s), 4*s, Color(0.4, 0.08, 0.5, eye_pulse))
			draw_circle(Vector2(cx + 14*s, cy - 40*s), 4*s, Color(0.4, 0.08, 0.5, eye_pulse))
			draw_circle(Vector2(cx - 14*s, cy - 40*s), 2*s, Color(0.6, 0.2, 0.7, eye_pulse * 1.5))
			draw_circle(Vector2(cx + 14*s, cy - 40*s), 2*s, Color(0.6, 0.2, 0.7, eye_pulse * 1.5))
			# Skeletal hands holding a book
			draw_rect(Rect2(cx - 22*s, cy + 20*s, 44*s, 30*s), Color(0.15, 0.08, 0.05))
			draw_rect(Rect2(cx - 20*s, cy + 22*s, 40*s, 26*s), Color(0.25, 0.15, 0.08))
			# Bony fingers
			for fi in range(4):
				var fxx = cx - 15*s + float(fi) * 10*s
				draw_line(Vector2(fxx, cy + 15*s), Vector2(fxx, cy + 22*s), Color(0.75, 0.7, 0.65, 0.5), 2*s)
			# Tattered hem (pre-calculated offsets to avoid flicker)
			for ti in range(8):
				var tx = cx - 70*s + float(ti) * 20*s
				var hem_off = _portrait_hem_offsets[ti] if ti < _portrait_hem_offsets.size() else 0.0
				draw_line(Vector2(tx, cy + 140*s), Vector2(tx + hem_off*s, cy + 155*s), Color(0.04, 0.03, 0.06, 0.4), 1.5*s)
		"robin_hood":
			# Forest green tunic, feathered cap, longbow, auburn hair, confident smirk
			# Green cape behind
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 28*s, cy - 28*s), Vector2(cx + 28*s, cy - 28*s),
				Vector2(cx + 38*s, cy + 80*s), Vector2(cx - 38*s, cy + 80*s)
			]), Color(0.10, 0.40, 0.08, 0.6))
			# Legs
			draw_rect(Rect2(cx - 16*s, cy + 60*s, 13*s, 70*s), Color(0.10, 0.40, 0.08))
			draw_rect(Rect2(cx + 3*s, cy + 60*s, 13*s, 70*s), Color(0.08, 0.35, 0.06))
			# Boots — brown leather
			draw_rect(Rect2(cx - 18*s, cy + 118*s, 17*s, 18*s), Color(0.45, 0.28, 0.12))
			draw_rect(Rect2(cx + 1*s, cy + 118*s, 17*s, 18*s), Color(0.42, 0.25, 0.10))
			# Torso — forest green tunic
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 28*s, cy - 28*s), Vector2(cx + 28*s, cy - 28*s),
				Vector2(cx + 24*s, cy + 65*s), Vector2(cx - 24*s, cy + 65*s)
			]), Color(0.15, 0.55, 0.12))
			# Scalloped tunic hem
			for hi in range(6):
				var hx = cx - 22*s + float(hi) * 9.5*s
				draw_colored_polygon(PackedVector2Array([
					Vector2(hx, cy + 60*s), Vector2(hx + 9.5*s, cy + 60*s), Vector2(hx + 4.75*s, cy + 72*s)
				]), Color(0.12, 0.48, 0.10))
			# Belt with brass buckle
			draw_rect(Rect2(cx - 26*s, cy + 22*s, 52*s, 8*s), Color(0.40, 0.24, 0.10))
			draw_circle(Vector2(cx, cy + 26*s), 4*s, Color(0.85, 0.68, 0.18))
			# Quiver on back
			draw_rect(Rect2(cx + 18*s, cy - 20*s, 8*s, 40*s), Color(0.40, 0.24, 0.10))
			for ai in range(3):
				draw_line(Vector2(cx + 22*s, cy - 20*s), Vector2(cx + 20*s + float(ai)*2*s, cy - 32*s), Color(0.48, 0.28, 0.10), 1.5*s)
			# Arms — skin tone
			draw_line(Vector2(cx - 28*s, cy - 12*s), Vector2(cx - 52*s, cy + 25*s), Color(0.91, 0.74, 0.58), 8*s)
			draw_line(Vector2(cx + 28*s, cy - 12*s), Vector2(cx + 48*s, cy + 8*s), Color(0.91, 0.74, 0.58), 8*s)
			# Green sleeves
			draw_line(Vector2(cx - 28*s, cy - 12*s), Vector2(cx - 38*s, cy + 5*s), Color(0.15, 0.55, 0.12), 10*s)
			draw_line(Vector2(cx + 28*s, cy - 12*s), Vector2(cx + 38*s, cy - 2*s), Color(0.15, 0.55, 0.12), 10*s)
			# Longbow (left hand)
			draw_arc(Vector2(cx - 56*s, cy + 5*s), 32*s, -PI*0.55, PI*0.55, 20, Color(0.48, 0.28, 0.10), 3*s)
			draw_line(Vector2(cx - 56*s, cy - 27*s), Vector2(cx - 56*s, cy + 37*s), Color(0.6, 0.55, 0.50, 0.5), 1*s)
			# Head — warm tan skin
			draw_circle(Vector2(cx, cy - 48*s), 22*s, Color(0.91, 0.74, 0.58))
			# Auburn hair
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 23*s, cy - 65*s), Vector2(cx + 23*s, cy - 65*s),
				Vector2(cx + 20*s, cy - 42*s), Vector2(cx - 20*s, cy - 42*s)
			]), Color(0.50, 0.28, 0.12))
			# Eye whites + green irises
			draw_circle(Vector2(cx - 8*s, cy - 51*s), 4*s, Color(0.98, 0.98, 1.0))
			draw_circle(Vector2(cx + 8*s, cy - 51*s), 4*s, Color(0.98, 0.98, 1.0))
			draw_circle(Vector2(cx - 8*s, cy - 51*s), 2.5*s, Color(0.18, 0.60, 0.22))
			draw_circle(Vector2(cx + 8*s, cy - 51*s), 2.5*s, Color(0.18, 0.60, 0.22))
			draw_circle(Vector2(cx - 8*s, cy - 51*s), 1*s, Color(0.06, 0.06, 0.08))
			draw_circle(Vector2(cx + 8*s, cy - 51*s), 1*s, Color(0.06, 0.06, 0.08))
			# Confident smirk
			draw_arc(Vector2(cx + 2*s, cy - 40*s), 7*s, 0.1, PI - 0.3, 12, Color(0.40, 0.22, 0.12), 1.5*s)
			# Feathered cap — forest green with red plume
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 24*s, cy - 64*s), Vector2(cx + 5*s, cy - 108*s), Vector2(cx + 24*s, cy - 64*s)
			]), Color(0.15, 0.55, 0.12))
			draw_rect(Rect2(cx - 26*s, cy - 66*s, 52*s, 5*s), Color(0.10, 0.40, 0.08))
			# Cardinal red feather
			draw_line(Vector2(cx + 8*s, cy - 105*s), Vector2(cx + 32*s, cy - 128*s), Color(0.88, 0.16, 0.08), 3*s)
			draw_line(Vector2(cx + 18*s, cy - 116*s), Vector2(cx + 35*s, cy - 132*s), Color(0.92, 0.25, 0.12, 0.5), 2*s)
		"alice":
			# White dress with blue pinafore apron, blonde hair, headband, purple ballet flats
			# Legs — pale skin
			draw_rect(Rect2(cx - 11*s, cy + 65*s, 10*s, 55*s), Color(0.95, 0.84, 0.73))
			draw_rect(Rect2(cx + 1*s, cy + 65*s, 10*s, 55*s), Color(0.92, 0.82, 0.70))
			# Purple ballet flats
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 14*s, cy + 118*s), Vector2(cx + 1*s, cy + 118*s),
				Vector2(cx + 2*s, cy + 128*s), Vector2(cx - 16*s, cy + 128*s)
			]), Color(0.78, 0.68, 0.92))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 1*s, cy + 118*s), Vector2(cx + 14*s, cy + 118*s),
				Vector2(cx + 16*s, cy + 128*s), Vector2(cx - 2*s, cy + 128*s)
			]), Color(0.75, 0.65, 0.90))
			# White dress — flared skirt
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 22*s, cy - 8*s), Vector2(cx + 22*s, cy - 8*s),
				Vector2(cx + 42*s, cy + 70*s), Vector2(cx - 42*s, cy + 70*s)
			]), Color(0.92, 0.93, 0.98))
			# Scalloped dress hem
			for hi in range(7):
				var hx = cx - 40*s + float(hi) * 11.5*s
				draw_arc(Vector2(hx + 5.75*s, cy + 68*s), 4*s, 0, PI, 8, Color(0.85, 0.86, 0.92), 1.5*s)
			# Blue pinafore apron
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 16*s, cy - 5*s), Vector2(cx + 16*s, cy - 5*s),
				Vector2(cx + 28*s, cy + 65*s), Vector2(cx - 28*s, cy + 65*s)
			]), Color(0.45, 0.72, 0.95))
			# Apron pocket
			draw_arc(Vector2(cx, cy + 30*s), 8*s, 0, PI, 10, Color(0.38, 0.65, 0.88), 1.5*s)
			# Bodice — blue
			draw_rect(Rect2(cx - 18*s, cy - 32*s, 36*s, 26*s), Color(0.45, 0.72, 0.95))
			# White sash/bow at waist
			draw_rect(Rect2(cx - 20*s, cy - 8*s, 40*s, 5*s), Color(0.92, 0.93, 0.98))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 22*s, cy - 6*s), Vector2(cx - 30*s, cy - 10*s), Vector2(cx - 22*s, cy - 2*s)
			]), Color(0.92, 0.93, 0.98))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 22*s, cy - 6*s), Vector2(cx + 30*s, cy - 10*s), Vector2(cx + 22*s, cy - 2*s)
			]), Color(0.92, 0.93, 0.98))
			# Arms — pale skin with puff sleeves
			draw_circle(Vector2(cx - 22*s, cy - 18*s), 8*s, Color(0.92, 0.93, 0.98))
			draw_circle(Vector2(cx + 22*s, cy - 18*s), 8*s, Color(0.92, 0.93, 0.98))
			draw_line(Vector2(cx - 24*s, cy - 12*s), Vector2(cx - 38*s, cy + 18*s), Color(0.95, 0.84, 0.73), 6*s)
			draw_line(Vector2(cx + 24*s, cy - 12*s), Vector2(cx + 38*s, cy + 14*s), Color(0.95, 0.84, 0.73), 6*s)
			# Head — pale porcelain skin
			draw_circle(Vector2(cx, cy - 52*s), 22*s, Color(0.95, 0.84, 0.73))
			# Blonde hair — flowing down
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 24*s, cy - 70*s), Vector2(cx + 24*s, cy - 70*s),
				Vector2(cx + 28*s, cy - 30*s), Vector2(cx - 28*s, cy - 30*s)
			]), Color(0.85, 0.72, 0.28))
			# Hair strands flowing down past shoulders
			draw_line(Vector2(cx - 24*s, cy - 48*s), Vector2(cx - 26*s, cy - 10*s), Color(0.85, 0.72, 0.28, 0.8), 4*s)
			draw_line(Vector2(cx + 24*s, cy - 48*s), Vector2(cx + 26*s, cy - 10*s), Color(0.85, 0.72, 0.28, 0.8), 4*s)
			# Hair shine
			draw_line(Vector2(cx - 12*s, cy - 68*s), Vector2(cx - 8*s, cy - 50*s), Color(0.95, 0.85, 0.40, 0.4), 2*s)
			# Black headband
			draw_rect(Rect2(cx - 23*s, cy - 70*s, 46*s, 4*s), Color(0.10, 0.10, 0.15))
			# Big blue eyes with white highlights
			draw_circle(Vector2(cx - 8*s, cy - 55*s), 5*s, Color(1.0, 1.0, 1.0))
			draw_circle(Vector2(cx + 8*s, cy - 55*s), 5*s, Color(1.0, 1.0, 1.0))
			draw_circle(Vector2(cx - 8*s, cy - 55*s), 3.5*s, Color(0.25, 0.50, 0.90))
			draw_circle(Vector2(cx + 8*s, cy - 55*s), 3.5*s, Color(0.25, 0.50, 0.90))
			draw_circle(Vector2(cx - 8*s, cy - 55*s), 1.5*s, Color(0.12, 0.35, 0.70))
			draw_circle(Vector2(cx + 8*s, cy - 55*s), 1.5*s, Color(0.12, 0.35, 0.70))
			draw_circle(Vector2(cx - 10*s, cy - 57*s), 1.5*s, Color(1.0, 1.0, 1.0, 0.7))
			draw_circle(Vector2(cx + 6*s, cy - 57*s), 1.5*s, Color(1.0, 1.0, 1.0, 0.7))
			# Gentle smile
			draw_arc(Vector2(cx, cy - 45*s), 5*s, 0.2, PI - 0.2, 10, Color(0.55, 0.35, 0.30), 1.2*s)
		"wicked_witch":
			# Black dress with purple sheen, pointed hat, GREEN skin, dark hair, sinister yellow-green eyes
			# Black boots
			draw_rect(Rect2(cx - 16*s, cy + 118*s, 14*s, 16*s), Color(0.10, 0.08, 0.12))
			draw_rect(Rect2(cx + 2*s, cy + 118*s, 14*s, 16*s), Color(0.08, 0.06, 0.10))
			# Black dress/robe with purple sheen
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 28*s, cy - 18*s), Vector2(cx + 28*s, cy - 18*s),
				Vector2(cx + 44*s, cy + 122*s), Vector2(cx - 44*s, cy + 122*s)
			]), Color(0.08, 0.06, 0.10))
			# Purple sheen inner layer
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 20*s, cy - 10*s), Vector2(cx + 20*s, cy - 10*s),
				Vector2(cx + 32*s, cy + 110*s), Vector2(cx - 32*s, cy + 110*s)
			]), Color(0.15, 0.08, 0.20, 0.3))
			# Dress folds
			for fi in range(5):
				var fx = cx - 30*s + float(fi) * 15*s
				draw_line(Vector2(fx, cy + 5*s), Vector2(fx + sin(float(fi) * 1.5) * 5*s, cy + 118*s), Color(0.12, 0.10, 0.14, 0.3), 1.5*s)
			# Tattered ragged hem
			for ti in range(8):
				var tx = cx - 40*s + float(ti) * 11*s
				var t_sway = sin(_time * 1.0 + float(ti) * 0.8) * 4*s
				draw_line(Vector2(tx, cy + 122*s), Vector2(tx + t_sway, cy + 135*s), Color(0.06, 0.04, 0.08, 0.4), 2*s)
			# Arms — black sleeves with green hands
			draw_line(Vector2(cx - 28*s, cy - 5*s), Vector2(cx - 55*s, cy + 22*s), Color(0.08, 0.06, 0.10), 8*s)
			draw_line(Vector2(cx + 28*s, cy - 5*s), Vector2(cx + 52*s, cy + 14*s), Color(0.08, 0.06, 0.10), 8*s)
			# Green bony hands
			draw_circle(Vector2(cx - 57*s, cy + 24*s), 5*s, Color(0.38, 0.55, 0.28))
			for fi in range(3):
				var fa = -0.5 + float(fi) * 0.3
				draw_line(Vector2(cx - 57*s, cy + 24*s), Vector2(cx - 57*s + cos(fa) * 7*s, cy + 24*s + sin(fa) * 7*s), Color(0.35, 0.50, 0.25), 1.2*s)
			draw_circle(Vector2(cx + 54*s, cy + 16*s), 5*s, Color(0.38, 0.55, 0.28))
			# Head — GREEN skin with sharp features
			draw_circle(Vector2(cx, cy - 40*s), 24*s, Color(0.38, 0.55, 0.28))
			# Sharp chin
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 14*s, cy - 22*s), Vector2(cx + 14*s, cy - 22*s), Vector2(cx, cy - 12*s)
			]), Color(0.35, 0.50, 0.25))
			# Cheek shadows
			draw_circle(Vector2(cx - 15*s, cy - 30*s), 6*s, Color(0.28, 0.42, 0.20, 0.3))
			draw_circle(Vector2(cx + 15*s, cy - 30*s), 6*s, Color(0.28, 0.42, 0.20, 0.3))
			# Dark hair
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 58*s), Vector2(cx + 25*s, cy - 58*s),
				Vector2(cx + 22*s, cy - 35*s), Vector2(cx - 22*s, cy - 35*s)
			]), Color(0.08, 0.08, 0.06))
			# Pointed black hat
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 34*s, cy - 54*s), Vector2(cx, cy - 140*s), Vector2(cx + 34*s, cy - 54*s)
			]), Color(0.08, 0.06, 0.10))
			draw_rect(Rect2(cx - 36*s, cy - 57*s, 72*s, 6*s), Color(0.08, 0.06, 0.10))
			# Hat buckle/band
			draw_rect(Rect2(cx - 28*s, cy - 80*s, 18*s, 5*s), Color(0.40, 0.25, 0.10, 0.6))
			# Yellow-green sinister eyes
			draw_circle(Vector2(cx - 9*s, cy - 44*s), 5*s, Color(0.95, 0.92, 0.40))
			draw_circle(Vector2(cx + 9*s, cy - 44*s), 5*s, Color(0.95, 0.92, 0.40))
			draw_circle(Vector2(cx - 9*s, cy - 44*s), 2.5*s, Color(0.35, 0.65, 0.10))
			draw_circle(Vector2(cx + 9*s, cy - 44*s), 2.5*s, Color(0.35, 0.65, 0.10))
			draw_circle(Vector2(cx - 9*s, cy - 44*s), 1*s, Color(0.06, 0.06, 0.08))
			draw_circle(Vector2(cx + 9*s, cy - 44*s), 1*s, Color(0.06, 0.06, 0.08))
			# Sinister smirk
			draw_arc(Vector2(cx, cy - 30*s), 8*s, 0.1, PI - 0.1, 12, Color(0.20, 0.30, 0.10), 1.5*s)
			# Broomstick (held at side)
			draw_line(Vector2(cx + 48*s, cy - 18*s), Vector2(cx + 52*s, cy + 130*s), Color(0.40, 0.28, 0.12), 3*s)
			# Broom bristles
			for bi in range(5):
				var bx = cx + 50*s + sin(float(bi) * 1.2) * 6*s
				draw_line(Vector2(cx + 52*s, cy + 128*s), Vector2(bx, cy + 140*s), Color(0.45, 0.35, 0.15), 2*s)
		"peter_pan":
			# Green tunic with jagged hem, pointed cap with red feather, tan skin, dagger, playful pose
			# Legs — green tights, dynamic flying stance
			draw_line(Vector2(cx - 8*s, cy + 55*s), Vector2(cx - 22*s, cy + 115*s), Color(0.15, 0.55, 0.12), 9*s)
			draw_line(Vector2(cx + 8*s, cy + 55*s), Vector2(cx + 14*s, cy + 108*s), Color(0.12, 0.48, 0.10), 9*s)
			# Pointed brown boots
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 27*s, cy + 112*s), Vector2(cx - 16*s, cy + 110*s),
				Vector2(cx - 14*s, cy + 126*s), Vector2(cx - 32*s, cy + 120*s)
			]), Color(0.45, 0.28, 0.12))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 9*s, cy + 104*s), Vector2(cx + 20*s, cy + 102*s),
				Vector2(cx + 23*s, cy + 118*s), Vector2(cx + 5*s, cy + 114*s)
			]), Color(0.42, 0.25, 0.10))
			# Green tunic body
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 24*s, cy - 24*s), Vector2(cx + 24*s, cy - 24*s),
				Vector2(cx + 26*s, cy + 58*s), Vector2(cx - 26*s, cy + 58*s)
			]), Color(0.15, 0.55, 0.12))
			# Jagged tunic hem — signature Peter Pan look
			for ji in range(7):
				var jx = cx - 24*s + float(ji) * 7.5*s
				draw_colored_polygon(PackedVector2Array([
					Vector2(jx, cy + 55*s), Vector2(jx + 7.5*s, cy + 55*s), Vector2(jx + 3.75*s, cy + 68*s)
				]), Color(0.12, 0.48, 0.10))
			# Brown belt
			draw_rect(Rect2(cx - 24*s, cy + 18*s, 48*s, 6*s), Color(0.40, 0.28, 0.12))
			draw_circle(Vector2(cx, cy + 21*s), 3*s, Color(0.70, 0.55, 0.18))
			# Arms — warm tan skin, one raised with dagger
			draw_line(Vector2(cx - 24*s, cy - 10*s), Vector2(cx - 42*s, cy + 12*s), Color(0.15, 0.55, 0.12), 9*s)
			draw_line(Vector2(cx + 24*s, cy - 10*s), Vector2(cx + 46*s, cy - 35*s), Color(0.15, 0.55, 0.12), 9*s)
			draw_line(Vector2(cx - 36*s, cy + 5*s), Vector2(cx - 44*s, cy + 14*s), Color(0.91, 0.74, 0.58), 7*s)
			draw_line(Vector2(cx + 40*s, cy - 30*s), Vector2(cx + 48*s, cy - 40*s), Color(0.91, 0.74, 0.58), 7*s)
			# Dagger in raised hand
			draw_line(Vector2(cx + 48*s, cy - 42*s), Vector2(cx + 55*s, cy - 62*s), Color(0.70, 0.70, 0.75), 2.5*s)
			draw_line(Vector2(cx + 46*s, cy - 40*s), Vector2(cx + 50*s, cy - 42*s), Color(0.45, 0.30, 0.10), 3*s)
			# Head — warm tan
			draw_circle(Vector2(cx, cy - 46*s), 20*s, Color(0.91, 0.74, 0.58))
			# Messy auburn/brown hair
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 21*s, cy - 62*s), Vector2(cx + 21*s, cy - 62*s),
				Vector2(cx + 18*s, cy - 40*s), Vector2(cx - 18*s, cy - 40*s)
			]), Color(0.50, 0.28, 0.12))
			# Spiky hair tufts
			for hi in range(4):
				var hx = cx - 14*s + float(hi) * 9*s
				draw_colored_polygon(PackedVector2Array([
					Vector2(hx, cy - 62*s), Vector2(hx + 5*s, cy - 72*s), Vector2(hx + 9*s, cy - 62*s)
				]), Color(0.50, 0.28, 0.12))
			# Mischievous green eyes
			draw_circle(Vector2(cx - 7*s, cy - 50*s), 3.5*s, Color(0.98, 0.98, 1.0))
			draw_circle(Vector2(cx + 7*s, cy - 50*s), 3.5*s, Color(0.98, 0.98, 1.0))
			draw_circle(Vector2(cx - 7*s, cy - 50*s), 2*s, Color(0.18, 0.55, 0.20))
			draw_circle(Vector2(cx + 7*s, cy - 50*s), 2*s, Color(0.18, 0.55, 0.20))
			# Big cheeky grin
			draw_arc(Vector2(cx, cy - 40*s), 8*s, 0.05, PI - 0.05, 12, Color(0.45, 0.25, 0.15), 1.5*s)
			# Green pointed cap with red feather
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 21*s, cy - 60*s), Vector2(cx + 6*s, cy - 98*s), Vector2(cx + 21*s, cy - 60*s)
			]), Color(0.15, 0.55, 0.12))
			draw_rect(Rect2(cx - 23*s, cy - 62*s, 46*s, 4*s), Color(0.10, 0.40, 0.08))
			# Red feather
			draw_line(Vector2(cx + 10*s, cy - 95*s), Vector2(cx + 28*s, cy - 112*s), Color(0.88, 0.16, 0.08), 2.5*s)
		"phantom":
			# Black cape with vivid red lining, white porcelain half-mask, black formal tuxedo, dramatic pose
			# Cape — flowing wide, black outer
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 50*s, cy - 28*s), Vector2(cx + 10*s, cy - 28*s),
				Vector2(cx + 20*s, cy + 135*s), Vector2(cx - 68*s, cy + 135*s)
			]), Color(0.06, 0.03, 0.08))
			# Cape inner lining — vivid red
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 44*s, cy - 22*s), Vector2(cx + 5*s, cy - 22*s),
				Vector2(cx + 8*s, cy + 115*s), Vector2(cx - 52*s, cy + 115*s)
			]), Color(0.85, 0.08, 0.12, 0.35))
			# Legs — black formal trousers
			draw_rect(Rect2(cx - 14*s, cy + 55*s, 12*s, 70*s), Color(0.05, 0.03, 0.07))
			draw_rect(Rect2(cx + 2*s, cy + 55*s, 12*s, 70*s), Color(0.04, 0.02, 0.06))
			# Polished shoes
			draw_rect(Rect2(cx - 16*s, cy + 122*s, 16*s, 12*s), Color(0.08, 0.06, 0.06))
			draw_rect(Rect2(cx, cy + 122*s, 16*s, 12*s), Color(0.06, 0.04, 0.05))
			# Torso — black tuxedo jacket
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 24*s, cy - 28*s), Vector2(cx + 24*s, cy - 28*s),
				Vector2(cx + 22*s, cy + 58*s), Vector2(cx - 22*s, cy + 58*s)
			]), Color(0.10, 0.08, 0.12))
			# White dress shirt front
			draw_rect(Rect2(cx - 8*s, cy - 22*s, 16*s, 45*s), Color(0.97, 0.95, 0.93, 0.8))
			# Gold buttons
			for bi in range(3):
				draw_circle(Vector2(cx, cy - 12*s + float(bi) * 12*s), 1.8*s, Color(0.90, 0.74, 0.24))
			# Arms — one raised dramatically
			draw_line(Vector2(cx + 24*s, cy - 14*s), Vector2(cx + 52*s, cy - 48*s), Color(0.10, 0.08, 0.12), 8*s)
			draw_line(Vector2(cx - 24*s, cy - 14*s), Vector2(cx - 42*s, cy + 18*s), Color(0.10, 0.08, 0.12), 8*s)
			# White gloves
			draw_circle(Vector2(cx + 54*s, cy - 50*s), 4*s, Color(0.95, 0.93, 0.90))
			draw_circle(Vector2(cx - 44*s, cy + 20*s), 4*s, Color(0.95, 0.93, 0.90))
			# Head — pale dramatic skin
			draw_circle(Vector2(cx, cy - 50*s), 22*s, Color(0.88, 0.82, 0.78))
			# Slicked back dark hair
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 23*s, cy - 68*s), Vector2(cx + 23*s, cy - 68*s),
				Vector2(cx + 16*s, cy - 46*s), Vector2(cx - 16*s, cy - 46*s)
			]), Color(0.07, 0.05, 0.07))
			# WHITE PORCELAIN HALF-MASK (right side) — signature feature
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 2*s, cy - 68*s), Vector2(cx + 22*s, cy - 62*s),
				Vector2(cx + 22*s, cy - 40*s), Vector2(cx + 12*s, cy - 32*s), Vector2(cx + 2*s, cy - 35*s)
			]), Color(0.98, 0.97, 0.96))
			# Mask edge highlight
			draw_line(Vector2(cx + 2*s, cy - 68*s), Vector2(cx + 2*s, cy - 35*s), Color(0.85, 0.82, 0.78, 0.6), 1*s)
			# Visible eye (left — exposed side) — dark brown
			draw_circle(Vector2(cx - 8*s, cy - 53*s), 4*s, Color(0.99, 0.99, 0.99))
			draw_circle(Vector2(cx - 8*s, cy - 53*s), 2.5*s, Color(0.24, 0.17, 0.14))
			draw_circle(Vector2(cx - 8*s, cy - 53*s), 1*s, Color(0.06, 0.06, 0.08))
			draw_circle(Vector2(cx - 10*s, cy - 55*s), 1*s, Color(1.0, 1.0, 1.0, 0.5))
			# Masked eye — just a dark slit
			draw_circle(Vector2(cx + 10*s, cy - 53*s), 2*s, Color(0.06, 0.04, 0.06, 0.5))
		"scrooge":
			# Victorian long coat, top hat, gaunt pale elderly, walking cane, hunched posture
			# Thin legs
			draw_rect(Rect2(cx - 11*s, cy + 58*s, 9*s, 68*s), Color(0.12, 0.10, 0.08))
			draw_rect(Rect2(cx + 2*s, cy + 58*s, 9*s, 68*s), Color(0.10, 0.08, 0.06))
			# Shoes
			draw_rect(Rect2(cx - 13*s, cy + 122*s, 13*s, 12*s), Color(0.08, 0.06, 0.05))
			draw_rect(Rect2(cx, cy + 122*s, 13*s, 12*s), Color(0.06, 0.05, 0.04))
			# Long Victorian coat — dark muted brown
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 24*s, cy - 24*s), Vector2(cx + 24*s, cy - 24*s),
				Vector2(cx + 20*s, cy + 78*s), Vector2(cx - 20*s, cy + 78*s)
			]), Color(0.15, 0.12, 0.10))
			# Coat tails
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 18*s, cy + 72*s), Vector2(cx - 6*s, cy + 72*s),
				Vector2(cx - 8*s, cy + 95*s), Vector2(cx - 22*s, cy + 95*s)
			]), Color(0.13, 0.10, 0.08))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 6*s, cy + 72*s), Vector2(cx + 18*s, cy + 72*s),
				Vector2(cx + 22*s, cy + 95*s), Vector2(cx + 8*s, cy + 95*s)
			]), Color(0.13, 0.10, 0.08))
			# Waistcoat/vest — muted gold
			draw_rect(Rect2(cx - 14*s, cy - 14*s, 28*s, 32*s), Color(0.40, 0.30, 0.15))
			# White cravat at collar
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 6*s, cy - 22*s), Vector2(cx + 6*s, cy - 22*s),
				Vector2(cx + 4*s, cy - 12*s), Vector2(cx - 4*s, cy - 12*s)
			]), Color(0.90, 0.88, 0.82, 0.7))
			# Arms — coat sleeves
			draw_line(Vector2(cx - 24*s, cy - 8*s), Vector2(cx - 38*s, cy + 28*s), Color(0.15, 0.12, 0.10), 7*s)
			draw_line(Vector2(cx + 24*s, cy - 8*s), Vector2(cx + 42*s, cy + 36*s), Color(0.15, 0.12, 0.10), 7*s)
			# Bony pale hands
			draw_circle(Vector2(cx - 40*s, cy + 30*s), 4*s, Color(0.85, 0.78, 0.72))
			draw_circle(Vector2(cx + 44*s, cy + 38*s), 4*s, Color(0.85, 0.78, 0.72))
			# Walking cane with curved handle
			draw_line(Vector2(cx + 44*s, cy + 36*s), Vector2(cx + 48*s, cy + 128*s), Color(0.30, 0.20, 0.08), 3*s)
			draw_arc(Vector2(cx + 44*s, cy + 33*s), 7*s, PI, TAU, 10, Color(0.30, 0.20, 0.08), 3*s)
			# Gold coins at base (signature)
			for ci in range(4):
				var coin_x = cx - 12*s + float(ci) * 8*s
				draw_circle(Vector2(coin_x, cy + 130*s), 4*s, Color(0.85, 0.68, 0.18, 0.6))
				draw_circle(Vector2(coin_x, cy + 130*s), 2*s, Color(1.0, 0.85, 0.30, 0.4))
			# Head — gaunt, pale elderly
			draw_circle(Vector2(cx, cy - 44*s), 20*s, Color(0.85, 0.78, 0.72))
			# Thin white/grey hair
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 20*s, cy - 58*s), Vector2(cx + 20*s, cy - 58*s),
				Vector2(cx + 16*s, cy - 40*s), Vector2(cx - 16*s, cy - 40*s)
			]), Color(0.72, 0.70, 0.68, 0.5))
			# Sunken dark eyes
			draw_circle(Vector2(cx - 7*s, cy - 48*s), 3.5*s, Color(0.88, 0.85, 0.80))
			draw_circle(Vector2(cx + 7*s, cy - 48*s), 3.5*s, Color(0.88, 0.85, 0.80))
			draw_circle(Vector2(cx - 7*s, cy - 48*s), 2*s, Color(0.20, 0.15, 0.10))
			draw_circle(Vector2(cx + 7*s, cy - 48*s), 2*s, Color(0.20, 0.15, 0.10))
			# Deep frown
			draw_arc(Vector2(cx, cy - 36*s), 6*s, PI + 0.3, TAU - 0.3, 10, Color(0.45, 0.30, 0.20), 1.5*s)
			# Long pointed nose
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 2*s, cy - 44*s), Vector2(cx + 2*s, cy - 44*s), Vector2(cx, cy - 35*s)
			]), Color(0.82, 0.74, 0.68))
			# Top hat — tall black
			draw_rect(Rect2(cx - 17*s, cy - 98*s, 34*s, 48*s), Color(0.08, 0.06, 0.05))
			draw_rect(Rect2(cx - 24*s, cy - 53*s, 48*s, 6*s), Color(0.08, 0.06, 0.05))
			# Hat band
			draw_rect(Rect2(cx - 15*s, cy - 70*s, 30*s, 4*s), Color(0.35, 0.25, 0.12, 0.5))
		"sherlock":
			# Brown tweed Inverness cape-coat, deerstalker hat, pipe, magnifying glass, analytical posture
			# Legs — tan trousers
			draw_rect(Rect2(cx - 14*s, cy + 55*s, 12*s, 72*s), Color(0.40, 0.32, 0.18))
			draw_rect(Rect2(cx + 2*s, cy + 55*s, 12*s, 72*s), Color(0.38, 0.30, 0.16))
			# Dark brown leather shoes
			draw_rect(Rect2(cx - 16*s, cy + 124*s, 16*s, 12*s), Color(0.18, 0.14, 0.08))
			draw_rect(Rect2(cx, cy + 124*s, 16*s, 12*s), Color(0.16, 0.12, 0.06))
			# Brown tweed Inverness cape-coat — layered
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 32*s, cy - 24*s), Vector2(cx + 32*s, cy - 24*s),
				Vector2(cx + 26*s, cy + 58*s), Vector2(cx - 26*s, cy + 58*s)
			]), Color(0.52, 0.38, 0.18))
			# Cape overlay (shoulders)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 36*s, cy - 20*s), Vector2(cx + 36*s, cy - 20*s),
				Vector2(cx + 28*s, cy + 18*s), Vector2(cx - 28*s, cy + 18*s)
			]), Color(0.48, 0.35, 0.16, 0.7))
			# White shirt visible at collar
			draw_rect(Rect2(cx - 8*s, cy - 22*s, 16*s, 10*s), Color(0.94, 0.92, 0.88, 0.6))
			# Brass buttons
			for bi in range(3):
				draw_circle(Vector2(cx, cy - 5*s + float(bi) * 14*s), 2*s, Color(0.85, 0.68, 0.18))
			# Arms — tweed sleeves
			draw_line(Vector2(cx - 30*s, cy - 8*s), Vector2(cx - 48*s, cy + 12*s), Color(0.52, 0.38, 0.18), 8*s)
			draw_line(Vector2(cx + 30*s, cy - 8*s), Vector2(cx + 46*s, cy + 4*s), Color(0.52, 0.38, 0.18), 8*s)
			# Hands
			draw_circle(Vector2(cx - 50*s, cy + 14*s), 4*s, Color(0.90, 0.78, 0.65))
			draw_circle(Vector2(cx + 48*s, cy + 6*s), 4*s, Color(0.90, 0.78, 0.65))
			# Pipe (held from mouth)
			draw_line(Vector2(cx + 12*s, cy - 38*s), Vector2(cx + 28*s, cy - 32*s), Color(0.35, 0.20, 0.10), 2.5*s)
			draw_rect(Rect2(cx + 26*s, cy - 40*s, 8*s, 11*s), Color(0.35, 0.20, 0.10))
			# Magnifying glass (left hand)
			draw_circle(Vector2(cx - 54*s, cy + 8*s), 12*s, Color(0.70, 0.65, 0.55, 0.25))
			draw_arc(Vector2(cx - 54*s, cy + 8*s), 12*s, 0, TAU, 20, Color(0.85, 0.68, 0.18), 2.5*s)
			draw_line(Vector2(cx - 46*s, cy + 16*s), Vector2(cx - 38*s, cy + 28*s), Color(0.50, 0.35, 0.15), 2.5*s)
			# Head — light tan skin
			draw_circle(Vector2(cx, cy - 46*s), 22*s, Color(0.90, 0.78, 0.65))
			# Sharp analytical eyes — grey-blue
			draw_circle(Vector2(cx - 7*s, cy - 50*s), 3.5*s, Color(0.95, 0.95, 0.95))
			draw_circle(Vector2(cx + 7*s, cy - 50*s), 3.5*s, Color(0.95, 0.95, 0.95))
			draw_circle(Vector2(cx - 7*s, cy - 50*s), 2*s, Color(0.30, 0.38, 0.45))
			draw_circle(Vector2(cx + 7*s, cy - 50*s), 2*s, Color(0.30, 0.38, 0.45))
			draw_circle(Vector2(cx - 7*s, cy - 50*s), 0.8*s, Color(0.06, 0.06, 0.08))
			draw_circle(Vector2(cx + 7*s, cy - 50*s), 0.8*s, Color(0.06, 0.06, 0.08))
			# Thin determined mouth
			draw_line(Vector2(cx - 5*s, cy - 38*s), Vector2(cx + 5*s, cy - 38*s), Color(0.50, 0.35, 0.25), 1.2*s)
			# Brown hair
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 21*s, cy - 64*s), Vector2(cx + 21*s, cy - 64*s),
				Vector2(cx + 16*s, cy - 44*s), Vector2(cx - 16*s, cy - 44*s)
			]), Color(0.30, 0.22, 0.12))
			# Deerstalker hat — brown tweed with ear flaps
			draw_rect(Rect2(cx - 23*s, cy - 66*s, 46*s, 16*s), Color(0.45, 0.35, 0.20))
			draw_rect(Rect2(cx - 27*s, cy - 53*s, 54*s, 5*s), Color(0.42, 0.32, 0.18))
			# Ear flaps (tied up)
			draw_rect(Rect2(cx - 28*s, cy - 52*s, 9*s, 14*s), Color(0.45, 0.35, 0.20))
			draw_rect(Rect2(cx + 19*s, cy - 52*s, 9*s, 14*s), Color(0.45, 0.35, 0.20))
			# Front peak
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 12*s, cy - 53*s), Vector2(cx + 12*s, cy - 53*s), Vector2(cx + 8*s, cy - 46*s), Vector2(cx - 8*s, cy - 46*s)
			]), Color(0.42, 0.32, 0.18))
		"tarzan":
			# Shirtless muscular jungle man, bronze tanned skin, brown loincloth, wild hair, vine
			# Powerful legs — tanned bronze skin
			draw_line(Vector2(cx - 10*s, cy + 50*s), Vector2(cx - 20*s, cy + 122*s), Color(0.82, 0.62, 0.42), 13*s)
			draw_line(Vector2(cx + 10*s, cy + 50*s), Vector2(cx + 16*s, cy + 118*s), Color(0.78, 0.58, 0.38), 13*s)
			# Bare feet
			draw_circle(Vector2(cx - 22*s, cy + 125*s), 7*s, Color(0.75, 0.55, 0.38))
			draw_circle(Vector2(cx + 18*s, cy + 121*s), 7*s, Color(0.72, 0.52, 0.35))
			# Brown loincloth
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 20*s, cy + 34*s), Vector2(cx + 20*s, cy + 34*s),
				Vector2(cx + 16*s, cy + 58*s), Vector2(cx - 16*s, cy + 58*s)
			]), Color(0.45, 0.30, 0.12))
			# Ragged loincloth edges
			for li in range(4):
				var lx = cx - 14*s + float(li) * 9*s
				draw_colored_polygon(PackedVector2Array([
					Vector2(lx, cy + 55*s), Vector2(lx + 9*s, cy + 55*s), Vector2(lx + 4.5*s, cy + 64*s)
				]), Color(0.42, 0.28, 0.10))
			# Broad muscular torso — tanned bronze
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 36*s, cy - 28*s), Vector2(cx + 36*s, cy - 28*s),
				Vector2(cx + 26*s, cy + 38*s), Vector2(cx - 26*s, cy + 38*s)
			]), Color(0.82, 0.62, 0.42))
			# Chest muscle definition
			draw_arc(Vector2(cx - 12*s, cy - 8*s), 12*s, PI*0.3, PI*0.8, 10, Color(0.68, 0.48, 0.30, 0.35), 1.5*s)
			draw_arc(Vector2(cx + 12*s, cy - 8*s), 12*s, PI*0.2, PI*0.7, 10, Color(0.68, 0.48, 0.30, 0.35), 1.5*s)
			# Ab lines
			draw_line(Vector2(cx, cy + 2*s), Vector2(cx, cy + 30*s), Color(0.68, 0.48, 0.30, 0.25), 1*s)
			# Powerful arms — one gripping vine overhead
			draw_line(Vector2(cx - 36*s, cy - 18*s), Vector2(cx - 58*s, cy - 48*s), Color(0.82, 0.62, 0.42), 11*s)
			draw_line(Vector2(cx + 36*s, cy - 18*s), Vector2(cx + 54*s, cy + 8*s), Color(0.82, 0.62, 0.42), 11*s)
			# Fists
			draw_circle(Vector2(cx - 60*s, cy - 50*s), 6*s, Color(0.78, 0.58, 0.38))
			draw_circle(Vector2(cx + 56*s, cy + 10*s), 6*s, Color(0.78, 0.58, 0.38))
			# Vine (gripped in left hand)
			draw_line(Vector2(cx - 62*s, cy - 52*s), Vector2(cx - 68*s, cy - 130*s), Color(0.20, 0.45, 0.10), 3.5*s)
			# Vine leaves
			draw_circle(Vector2(cx - 66*s, cy - 95*s), 4*s, Color(0.25, 0.50, 0.15, 0.5))
			draw_circle(Vector2(cx - 70*s, cy - 115*s), 3.5*s, Color(0.22, 0.48, 0.12, 0.4))
			# Head — tanned bronze
			draw_circle(Vector2(cx, cy - 50*s), 22*s, Color(0.82, 0.62, 0.42))
			# Wild dark brown hair — spiky, unkempt
			for hi in range(12):
				var ha = -PI * 0.8 + float(hi) * PI * 0.15
				var hair_off = _portrait_hair_offsets[hi] if hi < _portrait_hair_offsets.size() else 10.0
				var hr = (25 + hair_off) * s
				draw_line(Vector2(cx, cy - 64*s), Vector2(cx, cy - 64*s) + Vector2.from_angle(ha) * hr, Color(0.25, 0.15, 0.05, 0.8), 3*s)
			# Fierce determined eyes — brown
			draw_circle(Vector2(cx - 8*s, cy - 54*s), 3.5*s, Color(0.95, 0.92, 0.88))
			draw_circle(Vector2(cx + 8*s, cy - 54*s), 3.5*s, Color(0.95, 0.92, 0.88))
			draw_circle(Vector2(cx - 8*s, cy - 54*s), 2*s, Color(0.35, 0.25, 0.10))
			draw_circle(Vector2(cx + 8*s, cy - 54*s), 2*s, Color(0.35, 0.25, 0.10))
			# Strong jaw
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 14*s, cy - 35*s), Vector2(cx + 14*s, cy - 35*s), Vector2(cx, cy - 28*s)
			]), Color(0.78, 0.58, 0.38, 0.4))
		"dracula":
			# Black cape with deep red lining, high collar, pale vampire skin, red glowing eyes, widow's peak
			# Massive bat-wing cape silhouette
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 62*s, cy - 32*s), Vector2(cx + 62*s, cy - 32*s),
				Vector2(cx + 76*s, cy + 48*s), Vector2(cx + 56*s, cy + 138*s),
				Vector2(cx - 56*s, cy + 138*s), Vector2(cx - 76*s, cy + 48*s)
			]), Color(0.08, 0.05, 0.07))
			# Deep red inner lining
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 48*s, cy - 22*s), Vector2(cx + 48*s, cy - 22*s),
				Vector2(cx + 44*s, cy + 95*s), Vector2(cx - 44*s, cy + 95*s)
			]), Color(0.55, 0.05, 0.05, 0.35))
			# Legs — black formal
			draw_rect(Rect2(cx - 14*s, cy + 55*s, 12*s, 72*s), Color(0.05, 0.03, 0.04))
			draw_rect(Rect2(cx + 2*s, cy + 55*s, 12*s, 72*s), Color(0.04, 0.02, 0.03))
			# Formal black suit body
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 24*s, cy - 28*s), Vector2(cx + 24*s, cy - 28*s),
				Vector2(cx + 22*s, cy + 58*s), Vector2(cx - 22*s, cy + 58*s)
			]), Color(0.10, 0.08, 0.10))
			# White cravat
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 7*s, cy - 24*s), Vector2(cx + 7*s, cy - 24*s),
				Vector2(cx + 4*s, cy - 10*s), Vector2(cx - 4*s, cy - 10*s)
			]), Color(0.92, 0.90, 0.86, 0.7))
			# Red vest/waistcoat hint
			draw_rect(Rect2(cx - 12*s, cy - 10*s, 24*s, 25*s), Color(0.50, 0.05, 0.05, 0.3))
			# High collar points — dramatic
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 20*s, cy - 32*s), Vector2(cx - 26*s, cy - 58*s),
				Vector2(cx - 14*s, cy - 48*s)
			]), Color(0.08, 0.05, 0.07))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 20*s, cy - 32*s), Vector2(cx + 26*s, cy - 58*s),
				Vector2(cx + 14*s, cy - 48*s)
			]), Color(0.08, 0.05, 0.07))
			# Arms hidden in cape — just pale hands visible
			draw_circle(Vector2(cx - 28*s, cy + 15*s), 4*s, Color(0.88, 0.85, 0.82))
			draw_circle(Vector2(cx + 28*s, cy + 15*s), 4*s, Color(0.88, 0.85, 0.82))
			# Head — very pale vampire skin
			draw_circle(Vector2(cx, cy - 50*s), 22*s, Color(0.88, 0.85, 0.82))
			# Widow's peak jet black hair
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 24*s, cy - 68*s), Vector2(cx, cy - 56*s), Vector2(cx + 24*s, cy - 68*s),
				Vector2(cx + 20*s, cy - 44*s), Vector2(cx - 20*s, cy - 44*s)
			]), Color(0.06, 0.04, 0.04))
			# Red glowing eyes — pulsing
			var glow = 0.6 + sin(_time * 3.0) * 0.2
			draw_circle(Vector2(cx - 8*s, cy - 54*s), 4.5*s, Color(0.80, 0.10, 0.10, glow))
			draw_circle(Vector2(cx + 8*s, cy - 54*s), 4.5*s, Color(0.80, 0.10, 0.10, glow))
			draw_circle(Vector2(cx - 8*s, cy - 54*s), 2.5*s, Color(1.00, 0.20, 0.15, glow))
			draw_circle(Vector2(cx + 8*s, cy - 54*s), 2.5*s, Color(1.00, 0.20, 0.15, glow))
			# Eye glow halo
			draw_circle(Vector2(cx - 8*s, cy - 54*s), 7*s, Color(0.70, 0.05, 0.05, glow * 0.15))
			draw_circle(Vector2(cx + 8*s, cy - 54*s), 7*s, Color(0.70, 0.05, 0.05, glow * 0.15))
			# Sharp fangs
			draw_line(Vector2(cx - 4*s, cy - 40*s), Vector2(cx - 3*s, cy - 34*s), Color(0.95, 0.93, 0.90, 0.7), 1.8*s)
			draw_line(Vector2(cx + 4*s, cy - 40*s), Vector2(cx + 3*s, cy - 34*s), Color(0.95, 0.93, 0.90, 0.7), 1.8*s)
			# Sinister thin smile
			draw_arc(Vector2(cx, cy - 40*s), 7*s, 0.2, PI - 0.2, 10, Color(0.30, 0.05, 0.05), 1.2*s)
			# Red mist at base
			for mi in range(5):
				var mx = cx - 35*s + float(mi) * 18*s
				draw_circle(Vector2(mx, cy + 135*s), 8*s, Color(0.50, 0.05, 0.05, 0.08))
		"merlin":
			# Deep purple robe with gold trim, pointed wizard hat with stars, white beard, crystal staff
			# Deep purple robe — flowing A-shape
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 34*s, cy - 18*s), Vector2(cx + 34*s, cy - 18*s),
				Vector2(cx + 46*s, cy + 138*s), Vector2(cx - 46*s, cy + 138*s)
			]), Color(0.22, 0.10, 0.55))
			# Gold embroidery trim lines
			draw_line(Vector2(cx - 34*s, cy - 18*s), Vector2(cx - 46*s, cy + 138*s), Color(0.92, 0.78, 0.18, 0.3), 1.5*s)
			draw_line(Vector2(cx + 34*s, cy - 18*s), Vector2(cx + 46*s, cy + 138*s), Color(0.92, 0.78, 0.18, 0.3), 1.5*s)
			# Robe stars — twinkling
			for si in range(6):
				var sx = cx + sin(float(si) * 2.1) * 24*s
				var sy = cy + 22*s + float(si) * 18*s
				var star_pulse = 0.3 + sin(_time * 2.0 + float(si) * 1.5) * 0.2
				draw_circle(Vector2(sx, sy), 2.5*s, Color(0.92, 0.78, 0.18, star_pulse))
			# Gold sash/belt
			draw_rect(Rect2(cx - 30*s, cy + 18*s, 60*s, 8*s), Color(0.92, 0.78, 0.18, 0.6))
			# Pointed elf-like shoes peeking under robe
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 18*s, cy + 134*s), Vector2(cx - 30*s, cy + 134*s), Vector2(cx - 22*s, cy + 140*s)
			]), Color(0.14, 0.06, 0.38))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 18*s, cy + 134*s), Vector2(cx + 30*s, cy + 134*s), Vector2(cx + 22*s, cy + 140*s)
			]), Color(0.14, 0.06, 0.38))
			# Arms — purple robe sleeves
			draw_line(Vector2(cx - 30*s, cy - 4*s), Vector2(cx - 48*s, cy + 28*s), Color(0.22, 0.10, 0.55), 9*s)
			draw_line(Vector2(cx + 30*s, cy - 4*s), Vector2(cx + 48*s, cy + 14*s), Color(0.22, 0.10, 0.55), 9*s)
			# Elderly hands
			draw_circle(Vector2(cx - 50*s, cy + 30*s), 4*s, Color(0.88, 0.76, 0.64))
			draw_circle(Vector2(cx + 50*s, cy + 16*s), 4*s, Color(0.88, 0.76, 0.64))
			# Crystal-topped staff
			draw_line(Vector2(cx + 50*s, cy + 12*s), Vector2(cx + 56*s, cy + 138*s), Color(0.40, 0.25, 0.10), 3.5*s)
			# Crystal orb atop staff — glowing blue
			var crystal_pulse = 0.5 + sin(_time * 2.5) * 0.2
			draw_circle(Vector2(cx + 49*s, cy + 6*s), 9*s, Color(0.30, 0.50, 0.90, crystal_pulse))
			draw_circle(Vector2(cx + 49*s, cy + 6*s), 5*s, Color(0.50, 0.70, 1.00, crystal_pulse * 0.7))
			draw_circle(Vector2(cx + 47*s, cy + 3*s), 2*s, Color(0.80, 0.90, 1.00, crystal_pulse * 0.5))
			# Head — elderly, kind face
			draw_circle(Vector2(cx, cy - 46*s), 22*s, Color(0.88, 0.76, 0.64))
			# Long white beard — flowing
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 16*s, cy - 30*s), Vector2(cx + 16*s, cy - 30*s),
				Vector2(cx + 10*s, cy + 28*s), Vector2(cx, cy + 32*s), Vector2(cx - 10*s, cy + 28*s)
			]), Color(0.88, 0.86, 0.84, 0.8))
			# Wise eyes — blue-grey
			draw_circle(Vector2(cx - 7*s, cy - 50*s), 3.5*s, Color(0.92, 0.90, 0.88))
			draw_circle(Vector2(cx + 7*s, cy - 50*s), 3.5*s, Color(0.92, 0.90, 0.88))
			draw_circle(Vector2(cx - 7*s, cy - 50*s), 2*s, Color(0.30, 0.40, 0.60))
			draw_circle(Vector2(cx + 7*s, cy - 50*s), 2*s, Color(0.30, 0.40, 0.60))
			# Bushy white eyebrows
			draw_line(Vector2(cx - 14*s, cy - 57*s), Vector2(cx - 2*s, cy - 55*s), Color(0.82, 0.80, 0.78, 0.7), 3*s)
			draw_line(Vector2(cx + 2*s, cy - 55*s), Vector2(cx + 14*s, cy - 57*s), Color(0.82, 0.80, 0.78, 0.7), 3*s)
			# Kind wrinkle smile
			draw_arc(Vector2(cx, cy - 38*s), 5*s, 0.2, PI - 0.2, 10, Color(0.55, 0.40, 0.30), 1.2*s)
			# Wizard hat — deep purple with stars
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 28*s, cy - 62*s), Vector2(cx + 4*s, cy - 138*s), Vector2(cx + 28*s, cy - 62*s)
			]), Color(0.22, 0.10, 0.55))
			draw_rect(Rect2(cx - 32*s, cy - 64*s, 64*s, 5*s), Color(0.18, 0.08, 0.45))
			# Gold hat band
			draw_rect(Rect2(cx - 26*s, cy - 82*s, 18*s, 4*s), Color(0.92, 0.78, 0.18, 0.5))
			# Stars on hat
			draw_circle(Vector2(cx - 6*s, cy - 90*s), 3*s, Color(0.92, 0.78, 0.18, 0.5))
			draw_circle(Vector2(cx + 8*s, cy - 108*s), 2.5*s, Color(0.92, 0.78, 0.18, 0.4))
			draw_circle(Vector2(cx - 12*s, cy - 110*s), 2*s, Color(0.92, 0.78, 0.18, 0.3))
		"frankenstein":
			# Massive greenish-grey monster, flat-top head, neck bolts, tattered dark clothes, stitches, gentle sad eyes
			# Thick legs — tattered dark trousers
			draw_rect(Rect2(cx - 20*s, cy + 55*s, 17*s, 76*s), Color(0.14, 0.12, 0.10))
			draw_rect(Rect2(cx + 3*s, cy + 55*s, 17*s, 76*s), Color(0.12, 0.10, 0.08))
			# Heavy boots
			draw_rect(Rect2(cx - 24*s, cy + 126*s, 24*s, 14*s), Color(0.18, 0.14, 0.10))
			draw_rect(Rect2(cx, cy + 126*s, 24*s, 14*s), Color(0.16, 0.12, 0.08))
			# Boot highlight
			draw_rect(Rect2(cx - 22*s, cy + 128*s, 4*s, 3*s), Color(0.28, 0.23, 0.18, 0.3))
			draw_rect(Rect2(cx + 2*s, cy + 128*s, 4*s, 3*s), Color(0.28, 0.23, 0.18, 0.3))
			# Broad torso — tattered dark jacket
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 42*s, cy - 28*s), Vector2(cx + 42*s, cy - 28*s),
				Vector2(cx + 36*s, cy + 58*s), Vector2(cx - 36*s, cy + 58*s)
			]), Color(0.14, 0.12, 0.10))
			# Jacket highlight patches
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 30*s, cy - 20*s), Vector2(cx + 30*s, cy - 20*s),
				Vector2(cx + 26*s, cy + 50*s), Vector2(cx - 26*s, cy + 50*s)
			]), Color(0.22, 0.19, 0.16, 0.3))
			# Stitching lines across jacket
			draw_line(Vector2(cx - 18*s, cy - 18*s), Vector2(cx - 14*s, cy + 48*s), Color(0.20, 0.18, 0.15, 0.5), 1.5*s)
			draw_line(Vector2(cx + 14*s, cy - 14*s), Vector2(cx + 18*s, cy + 44*s), Color(0.20, 0.18, 0.15, 0.5), 1.5*s)
			# Cross-stitch detail
			for sti in range(3):
				var sty = cy + float(sti) * 18*s
				draw_line(Vector2(cx - 16*s, sty), Vector2(cx - 12*s, sty + 6*s), Color(0.20, 0.18, 0.15, 0.4), 1*s)
				draw_line(Vector2(cx - 12*s, sty), Vector2(cx - 16*s, sty + 6*s), Color(0.20, 0.18, 0.15, 0.4), 1*s)
			# Massive greenish arms — hanging heavy
			draw_line(Vector2(cx - 42*s, cy - 14*s), Vector2(cx - 56*s, cy + 48*s), Color(0.55, 0.70, 0.45), 13*s)
			draw_line(Vector2(cx + 42*s, cy - 14*s), Vector2(cx + 56*s, cy + 48*s), Color(0.48, 0.58, 0.40), 13*s)
			# Dark sleeve cuffs
			draw_line(Vector2(cx - 42*s, cy - 14*s), Vector2(cx - 48*s, cy + 10*s), Color(0.14, 0.12, 0.10), 15*s)
			draw_line(Vector2(cx + 42*s, cy - 14*s), Vector2(cx + 48*s, cy + 10*s), Color(0.14, 0.12, 0.10), 15*s)
			# Large green hands
			draw_circle(Vector2(cx - 58*s, cy + 52*s), 9*s, Color(0.55, 0.70, 0.45))
			draw_circle(Vector2(cx + 58*s, cy + 52*s), 9*s, Color(0.48, 0.58, 0.40))
			# Head — square, flat-top, sickly green
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 28*s, cy - 78*s), Vector2(cx + 28*s, cy - 78*s),
				Vector2(cx + 26*s, cy - 24*s), Vector2(cx - 26*s, cy - 24*s)
			]), Color(0.55, 0.70, 0.45))
			# Darker green shadows
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 26*s, cy - 38*s), Vector2(cx + 26*s, cy - 38*s),
				Vector2(cx + 24*s, cy - 24*s), Vector2(cx - 24*s, cy - 24*s)
			]), Color(0.38, 0.52, 0.30, 0.3))
			# Flat top — dark brow ridge
			draw_rect(Rect2(cx - 30*s, cy - 80*s, 60*s, 8*s), Color(0.38, 0.52, 0.30))
			# Forehead stitches — signature
			draw_line(Vector2(cx - 16*s, cy - 68*s), Vector2(cx + 16*s, cy - 68*s), Color(0.20, 0.18, 0.15, 0.7), 2*s)
			for sti in range(5):
				var stx = cx - 14*s + float(sti) * 7*s
				draw_line(Vector2(stx, cy - 72*s), Vector2(stx, cy - 64*s), Color(0.20, 0.18, 0.15, 0.6), 1.2*s)
			# NECK BOLTS — signature feature
			# Left bolt
			draw_circle(Vector2(cx - 32*s, cy - 30*s), 7*s, Color(0.58, 0.58, 0.63))
			draw_circle(Vector2(cx - 32*s, cy - 30*s), 4*s, Color(0.76, 0.76, 0.82))
			draw_circle(Vector2(cx - 32*s, cy - 30*s), 2*s, Color(0.38, 0.38, 0.42))
			# Right bolt
			draw_circle(Vector2(cx + 32*s, cy - 30*s), 7*s, Color(0.58, 0.58, 0.63))
			draw_circle(Vector2(cx + 32*s, cy - 30*s), 4*s, Color(0.76, 0.76, 0.82))
			draw_circle(Vector2(cx + 32*s, cy - 30*s), 2*s, Color(0.38, 0.38, 0.42))
			# Gentle sad eyes — greenish-brown, with sorrow
			draw_circle(Vector2(cx - 10*s, cy - 55*s), 5*s, Color(0.88, 0.85, 0.78))
			draw_circle(Vector2(cx + 10*s, cy - 55*s), 5*s, Color(0.88, 0.85, 0.78))
			draw_circle(Vector2(cx - 10*s, cy - 55*s), 3*s, Color(0.45, 0.55, 0.25))
			draw_circle(Vector2(cx + 10*s, cy - 55*s), 3*s, Color(0.45, 0.55, 0.25))
			draw_circle(Vector2(cx - 10*s, cy - 55*s), 1.2*s, Color(0.06, 0.06, 0.08))
			draw_circle(Vector2(cx + 10*s, cy - 55*s), 1.2*s, Color(0.06, 0.06, 0.08))
			# Sad drooping brow
			draw_line(Vector2(cx - 16*s, cy - 60*s), Vector2(cx - 5*s, cy - 62*s), Color(0.38, 0.52, 0.30, 0.6), 2.5*s)
			draw_line(Vector2(cx + 5*s, cy - 62*s), Vector2(cx + 16*s, cy - 60*s), Color(0.38, 0.52, 0.30, 0.6), 2.5*s)
			# Sad gentle frown
			draw_arc(Vector2(cx, cy - 38*s), 8*s, PI + 0.3, TAU - 0.3, 10, Color(0.30, 0.38, 0.22), 1.8*s)
			# Face stitch (cheek)
			draw_line(Vector2(cx + 14*s, cy - 50*s), Vector2(cx + 18*s, cy - 38*s), Color(0.20, 0.18, 0.15, 0.4), 1.2*s)
		"shadow_author":
			# All-black hooded pyramidal figure with glowing red wand — always faceless
			# Dark purple aura glow behind
			for ai in range(5):
				var ar = (100.0 - float(ai) * 15.0) * s
				draw_circle(Vector2(cx, cy - 10*s), ar, Color(0.12, 0.02, 0.08, 0.02 + float(ai) * 0.008))
			# Cloak body — tall black pyramidal/triangular silhouette
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 55*s, cy - 25*s), Vector2(cx + 55*s, cy - 25*s),
				Vector2(cx + 80*s, cy + 140*s), Vector2(cx - 80*s, cy + 140*s)
			]), Color(0.02, 0.01, 0.02))
			# Cloak inner folds — subtle depth
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 38*s, cy - 15*s), Vector2(cx + 38*s, cy - 15*s),
				Vector2(cx + 58*s, cy + 130*s), Vector2(cx - 58*s, cy + 130*s)
			]), Color(0.04, 0.02, 0.04, 0.3))
			# Deep crease fold lines down the cloak
			for fi in range(7):
				var fx = cx - 48*s + float(fi) * 16*s
				draw_line(Vector2(fx, cy + 5*s), Vector2(fx + sin(float(fi) * 1.3) * 6*s, cy + 135*s), Color(0.06, 0.03, 0.06, 0.25), 1.5*s)
			# Tattered hem — ragged wisps dissolving into nothing
			for ti in range(12):
				var tx = cx - 75*s + float(ti) * 13*s
				var t_len = 18.0 + sin(float(ti) * 2.0 + _time * 1.5) * 10.0
				var t_sway = sin(_time * 1.2 + float(ti) * 0.9) * 6*s
				draw_line(Vector2(tx, cy + 140*s), Vector2(tx + t_sway, cy + (140 + t_len)*s), Color(0.015, 0.008, 0.02, 0.35), 2.5*s)
			# Hood — large, deep, pointed pyramidal cowl
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx, cy - 140*s), Vector2(cx - 60*s, cy - 15*s),
				Vector2(cx - 52*s, cy + 15*s), Vector2(cx + 52*s, cy + 15*s), Vector2(cx + 60*s, cy - 15*s)
			]), Color(0.025, 0.012, 0.03))
			# Hood interior — black void with face only during defeat reveal dialog
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx, cy - 112*s), Vector2(cx - 40*s, cy - 12*s),
				Vector2(cx - 32*s, cy + 10*s), Vector2(cx + 32*s, cy + 10*s), Vector2(cx + 40*s, cy - 12*s)
			]), Color(0.0, 0.0, 0.0))
			var sa_defeat_reveal = story_state.get("current_dialog", "") == "unlock_shadow_author"
			if sa_defeat_reveal:
				# ONE-TIME DEFEAT REVEAL: pale white face with big black buggy eyes and devilish grin
				# Pale white face — sickly, corpse-like
				draw_colored_polygon(PackedVector2Array([
					Vector2(cx, cy - 85*s), Vector2(cx - 26*s, cy - 50*s),
					Vector2(cx - 28*s, cy - 15*s), Vector2(cx - 20*s, cy + 5*s),
					Vector2(cx + 20*s, cy + 5*s), Vector2(cx + 28*s, cy - 15*s), Vector2(cx + 26*s, cy - 50*s)
				]), Color(0.88, 0.86, 0.84))
				# Sickly shading on cheeks
				draw_circle(Vector2(cx - 18*s, cy - 25*s), 8*s, Color(0.75, 0.72, 0.7, 0.3))
				draw_circle(Vector2(cx + 18*s, cy - 25*s), 8*s, Color(0.75, 0.72, 0.7, 0.3))
				# BIG BLACK BUGGY EYES — large, bulging, solid black, insectoid
				# Outer eye bulge (larger dark circles)
				draw_circle(Vector2(cx - 14*s, cy - 50*s), 12*s, Color(0.02, 0.02, 0.02))
				draw_circle(Vector2(cx + 14*s, cy - 50*s), 12*s, Color(0.02, 0.02, 0.02))
				# Inner eye — solid glossy black
				draw_circle(Vector2(cx - 14*s, cy - 50*s), 10*s, Color(0.0, 0.0, 0.0))
				draw_circle(Vector2(cx + 14*s, cy - 50*s), 10*s, Color(0.0, 0.0, 0.0))
				# Glossy highlight reflection on each eye
				draw_circle(Vector2(cx - 17*s, cy - 54*s), 3*s, Color(0.3, 0.3, 0.35, 0.35))
				draw_circle(Vector2(cx + 11*s, cy - 54*s), 3*s, Color(0.3, 0.3, 0.35, 0.35))
				draw_circle(Vector2(cx - 12*s, cy - 47*s), 1.5*s, Color(0.25, 0.25, 0.3, 0.2))
				draw_circle(Vector2(cx + 16*s, cy - 47*s), 1.5*s, Color(0.25, 0.25, 0.3, 0.2))
				# Nose — thin gaunt slit
				draw_line(Vector2(cx, cy - 38*s), Vector2(cx, cy - 28*s), Color(0.6, 0.55, 0.52, 0.4), 1.5*s)
				draw_line(Vector2(cx - 3*s, cy - 28*s), Vector2(cx + 3*s, cy - 28*s), Color(0.5, 0.45, 0.42, 0.3), 1*s)
				# BIG EVIL DEVILISH GRIN — wide, sharp, menacing
				var grin_y = cy - 16*s
				var grin_w = 28.0 * s
				# Dark mouth interior — wide crescent
				draw_colored_polygon(PackedVector2Array([
					Vector2(cx - 27*s, grin_y - 2*s), Vector2(cx + 27*s, grin_y - 2*s),
					Vector2(cx + 24*s, grin_y + 14*s), Vector2(cx - 24*s, grin_y + 14*s)
				]), Color(0.04, 0.01, 0.02))
				# Upper lip — devilish upward curl at corners
				draw_arc(Vector2(cx, grin_y), grin_w, 0.1, PI - 0.1, 28, Color(0.25, 0.05, 0.05), 2.5*s)
				# Curled-up devil corners
				draw_arc(Vector2(cx - 26*s, grin_y - 3*s), 5*s, -0.5, 0.8, 8, Color(0.25, 0.05, 0.05), 2*s)
				draw_arc(Vector2(cx + 26*s, grin_y - 3*s), 5*s, PI - 0.8, PI + 0.5, 8, Color(0.25, 0.05, 0.05), 2*s)
				# Lower lip
				draw_arc(Vector2(cx, grin_y + 4*s), grin_w * 0.85, PI + 0.2, TAU - 0.2, 22, Color(0.2, 0.04, 0.04, 0.6), 2*s)
				# Sharp jagged teeth — upper row (12 teeth, more menacing)
				for ti in range(12):
					var tx = cx - 25*s + float(ti) * 4.3*s
					var t_h = (6.0 + sin(float(ti) * 1.6) * 3.0) * s
					draw_colored_polygon(PackedVector2Array([
						Vector2(tx, grin_y - 1*s), Vector2(tx + 2.2*s, grin_y + t_h),
						Vector2(tx + 4.4*s, grin_y - 1*s)
					]), Color(0.92, 0.9, 0.85))
				# Sharp jagged teeth — lower row
				for ti in range(12):
					var tx = cx - 25*s + float(ti) * 4.3*s
					var t_h = (5.0 + sin(float(ti) * 2.0 + 1.0) * 2.0) * s
					draw_colored_polygon(PackedVector2Array([
						Vector2(tx, grin_y + 14*s), Vector2(tx + 2.2*s, grin_y + 14*s - t_h),
						Vector2(tx + 4.4*s, grin_y + 14*s)
					]), Color(0.88, 0.86, 0.82))
			else:
				# Normal: absolute black void — no face, just darkness
				draw_colored_polygon(PackedVector2Array([
					Vector2(cx, cy - 90*s), Vector2(cx - 28*s, cy - 15*s),
					Vector2(cx - 22*s, cy + 5*s), Vector2(cx + 22*s, cy + 5*s), Vector2(cx + 28*s, cy - 15*s)
				]), Color(0.0, 0.0, 0.0))
			# Single glowing red dot deep in the hood (visible in normal mode, hidden during face reveal)
			var red_pulse = 0.6 + sin(_time * 2.5) * 0.4
			if not sa_defeat_reveal:
				draw_circle(Vector2(cx, cy - 50*s), 3*s, Color(0.9, 0.08, 0.02, red_pulse))
				draw_circle(Vector2(cx, cy - 50*s), 7*s, Color(0.7, 0.04, 0.01, red_pulse * 0.2))
			# Arms — wide draped sleeves emerging from cloak
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 48*s, cy - 10*s), Vector2(cx - 32*s, cy - 18*s),
				Vector2(cx - 58*s, cy + 38*s), Vector2(cx - 70*s, cy + 32*s)
			]), Color(0.02, 0.01, 0.02))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 32*s, cy - 18*s), Vector2(cx + 48*s, cy - 10*s),
				Vector2(cx + 72*s, cy + 8*s), Vector2(cx + 58*s, cy + 22*s)
			]), Color(0.02, 0.01, 0.02))
			# Sleeve openings — dark voids (no visible hands)
			draw_circle(Vector2(cx - 64*s, cy + 35*s), 8*s, Color(0.0, 0.0, 0.0))
			draw_circle(Vector2(cx + 65*s, cy + 15*s), 8*s, Color(0.0, 0.0, 0.0))
			# Glowing red wand — held from right sleeve void
			var q_base = Vector2(cx + 66*s, cy + 12*s)
			var q_top = Vector2(cx + 82*s, cy - 40*s)
			# Wand shaft — glowing red
			draw_line(q_base, q_top, Color(0.7, 0.06, 0.03, red_pulse), 3*s)
			draw_line(q_base, q_top, Color(0.9, 0.12, 0.05, red_pulse * 0.4), 5.5*s)
			# Zigzag lightning pattern along the wand
			var w_dir = (q_top - q_base).normalized()
			var w_perp = Vector2(-w_dir.y, w_dir.x)
			for zi in range(6):
				var zt = 0.1 + float(zi) * 0.14
				var zp = q_base.lerp(q_top, zt)
				var zag_off = (5.0 if zi % 2 == 0 else -5.0) * s
				var zp2 = q_base.lerp(q_top, zt + 0.07)
				draw_line(zp + w_perp * zag_off, zp2 + w_perp * (-zag_off), Color(0.95, 0.2, 0.08, red_pulse * 0.8), 2.0*s)
			# Red glow halo along wand
			for gi in range(4):
				var gt = float(gi) / 3.0
				var gp = q_base.lerp(q_top, gt)
				draw_circle(gp, (7.0 + sin(_time * 2.5 + float(gi)) * 2.5) * s, Color(0.7, 0.05, 0.0, 0.08 * red_pulse))
			# Wand tip — bright red hot glow
			draw_circle(q_top, 5*s, Color(0.95, 0.12, 0.02, red_pulse))
			draw_circle(q_top, 9*s, Color(0.8, 0.06, 0.01, red_pulse * 0.3))
			draw_circle(q_top, 14*s, Color(0.6, 0.03, 0.0, red_pulse * 0.1))
			# Black smoke ink trailing from wand tip
			for si in range(8):
				var smoke_age = fmod(_time * 1.8 + float(si) * 0.7, 5.6)
				var smoke_t = smoke_age / 5.6
				var smoke_x = q_top.x + sin(_time * 1.3 + float(si) * 2.1) * 12*s * smoke_t
				var smoke_y = q_top.y - smoke_age * 8*s
				var smoke_r = (3.0 + smoke_t * 10.0) * s
				var smoke_a = 0.35 * (1.0 - smoke_t)
				draw_circle(Vector2(smoke_x, smoke_y), smoke_r, Color(0.02, 0.01, 0.03, smoke_a))
			# Floating dark particles drifting around the figure
			for pi in range(8):
				var pa = _time * 0.6 + float(pi) * TAU / 8.0
				var pr = (65.0 + sin(_time * 1.2 + float(pi) * 1.7) * 18.0) * s
				var ppx = cx + cos(pa) * pr
				var ppy = cy - 10*s + sin(pa) * pr * 0.5
				var p_alpha = 0.1 + sin(_time * 1.8 + float(pi)) * 0.05
				draw_circle(Vector2(ppx, ppy), (2.5 + sin(_time * 0.9 + float(pi)) * 1.5) * s, Color(0.02, 0.008, 0.03, p_alpha))
		_:
			# Generic shadow silhouette
			draw_circle(Vector2(cx, cy - 10*s), 40*s, Color(0.15, 0.12, 0.1, 0.4))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 20*s), Vector2(cx + 25*s, cy - 20*s),
				Vector2(cx + 30*s, cy + 80*s), Vector2(cx - 30*s, cy + 80*s)
			]), Color(0.12, 0.1, 0.08, 0.5))

func _get_speaker_display_name(speaker: String) -> String:
	match speaker:
		"narrator": return "The Shadow Author"
		"robin_hood": return "Robin Hood"
		"alice": return "Alice"
		"wicked_witch": return "The Wicked Witch"
		"peter_pan": return "Peter Pan"
		"phantom": return "The Phantom"
		"scrooge": return "Ebenezer Scrooge"
		"sherlock": return "Sherlock Holmes"
		"tarzan": return "Tarzan"
		"dracula": return "Count Dracula"
		"merlin": return "Merlin"
		"frankenstein": return "The Monster"
		"shadow_author": return "The Shadow Author"
		_: return speaker.capitalize()

func _init_tower_quotes() -> void:
	tower_quotes = {
		TowerType.ROBIN_HOOD: [
			"Steal from the rich, defend the path!",
			"My arrows fly true!",
			"For Sherwood!",
			"Robin Hood, at your service.",
		],
		TowerType.ALICE: [
			"Curiouser and curiouser!",
			"We're all mad here, you know.",
			"Off with their... wait, wrong character.",
			"Down the rabbit hole we go!",
		],
		TowerType.WICKED_WITCH: [
			"I'll get you, my pretties!",
			"Fly, my pretties, fly!",
			"How about a little fire?",
			"Surrender, Dorothy!",
		],
		TowerType.PETER_PAN: [
			"To live will be an awfully big adventure!",
			"I do believe in fairies!",
			"Second star to the right!",
			"I'll never grow up!",
		],
		TowerType.PHANTOM: [
			"The Music of the Night!",
			"I am your Angel of Music.",
			"The Phantom is here...",
			"Sing for me!",
		],
		TowerType.SCROOGE: [
			"Bah! Humbug!",
			"Every penny counts!",
			"Are there no prisons? No workhouses?",
			"I will honour Christmas in my heart.",
		],
		TowerType.SHERLOCK: [
			"Elementary, my dear Watson.",
			"The game is afoot!",
			"Data! Data! I cannot make bricks without clay.",
			"When you eliminate the impossible, whatever remains must be the truth.",
		],
		TowerType.TARZAN: [
			"Tarzan of the Apes!",
			"The jungle provides!",
			"Tarzan protect friends!",
			"Kreegah! Bundolo!",
		],
		TowerType.DRACULA: [
			"I am Dracula. I bid you welcome.",
			"The blood is the life!",
			"Listen to them - the children of the night.",
			"I never drink... wine.",
		],
		TowerType.MERLIN: [
			"By the power of the old magic!",
			"Knowledge is the greatest weapon.",
			"The prophecy unfolds!",
			"Even the smallest spell can change the world.",
		],
		TowerType.FRANKENSTEIN: [
			"I am... alive.",
			"Was I... a monster?",
			"Even broken things... deserve kindness.",
			"Fire... bad. Lightning... good.",
		],
	}

func _get_tower_quote(tower_type: TowerType) -> String:
	if not tower_quotes.has(tower_type):
		return "Ready for battle!"
	var quotes: Array = tower_quotes[tower_type]
	return quotes[randi() % quotes.size()]

func _load_voice_clips() -> void:
	var character_dirs = {
		TowerType.ROBIN_HOOD: "robin_hood",
		TowerType.ALICE: "alice",
		TowerType.WICKED_WITCH: "wicked_witch",
		TowerType.PETER_PAN: "peter_pan",
		TowerType.PHANTOM: "phantom",
		TowerType.SCROOGE: "scrooge",
		TowerType.SHERLOCK: "sherlock",
		TowerType.TARZAN: "tarzan",
		TowerType.DRACULA: "dracula",
		TowerType.MERLIN: "merlin",
		TowerType.FRANKENSTEIN: "frankenstein",
		TowerType.SHADOW_AUTHOR: "shadow_author",
	}
	for tower_type in character_dirs:
		var dir_name: String = character_dirs[tower_type]
		var place_clips: Array = []
		var fight_clips: Array = []
		for i in range(8):
			var place_path = "res://audio/voices/" + dir_name + "/place_" + str(i) + ".mp3"
			if ResourceLoader.exists(place_path):
				place_clips.append(load(place_path))
			var fight_path = "res://audio/voices/" + dir_name + "/fight_" + str(i) + ".mp3"
			if ResourceLoader.exists(fight_path):
				fight_clips.append(load(fight_path))
		if place_clips.size() > 0:
			placement_voice_clips[tower_type] = place_clips
		if fight_clips.size() > 0:
			fighting_voice_clips[tower_type] = fight_clips
	# Load Shadow Author narrator clips (triple-voice: Dominic->Matthew->Dominic)
	_load_shadow_author_clips()

func _load_shadow_author_clips() -> void:
	var base = "res://audio/voices/shadow_author/"
	# Story narration clip naming: dialogkey_lineindex.mp3
	var story_keys: Array = [
		"prologue_0", "prologue_1", "prologue_2", "prologue_3",
		"pre_level_0_0", "pre_level_0_1", "post_level_0_0", "post_level_0_1",
		"pre_level_1_0", "pre_level_1_1", "post_level_1_0",
		"pre_level_2_0",
		"pre_level_3_0", "pre_level_3_1", "post_level_3_0",
		"pre_level_4_0", "pre_level_4_1",
		"pre_level_5_0", "post_level_5_0",
		"pre_level_6_0", "post_level_6_0",
		"pre_level_7_0", "pre_level_7_1", "post_level_7_0",
		"pre_level_8_0",
		"pre_level_9_0", "post_level_9_0",
		"pre_level_10_0", "pre_level_10_1",
		"pre_level_11_0", "post_level_11_0",
		"pre_level_12_0", "post_level_12_0",
		"pre_level_13_0", "pre_level_13_1",
		"pre_level_14_0",
		"pre_level_15_0", "post_level_15_0",
		"act2_intro_0", "act2_intro_1", "act2_intro_2",
		"pre_level_16_0", "pre_level_16_1", "post_level_16_0",
		"pre_level_17_0",
		"pre_level_18_0", "post_level_18_0",
		"pre_level_19_0", "pre_level_19_1",
		"pre_level_20_0",
		"pre_level_21_0", "post_level_21_0",
		"pre_level_22_0",
		"pre_level_23_0",
		"pre_level_24_0", "post_level_24_0",
		"pre_level_25_0", "pre_level_25_1",
		"pre_level_26_0",
		"pre_level_27_0", "post_level_27_0",
		"pre_level_28_0",
		"pre_level_29_0",
		"pre_level_30_0", "post_level_30_0",
		"pre_level_31_0",
		"pre_level_32_0",
		"pre_level_33_0", "post_level_33_0",
		"act3_intro_0", "act3_intro_1", "act3_intro_2",
		"pre_level_34_0", "post_level_34_0",
		"pre_level_35_0",
		"pre_level_36_0", "pre_level_36_1", "pre_level_36_2",
		"post_level_36_0", "post_level_36_1", "post_level_36_2", "post_level_36_3",
		"unlock_sherlock_0", "unlock_sherlock_1",
		"unlock_tarzan_0", "unlock_tarzan_1",
		"unlock_dracula_0", "unlock_dracula_1",
		"unlock_merlin_0", "unlock_merlin_1",
		"unlock_frankenstein_0", "unlock_frankenstein_1",
		"all_unlocked_0", "all_unlocked_1", "all_unlocked_2",
	]
	for key in story_keys:
		var path = base + key + ".mp3"
		if ResourceLoader.exists(path):
			shadow_author_story_clips[key] = load(path)
	# Fighting taunts for levels 34-36
	for i in range(7):
		var path = base + "fight_" + str(i) + ".mp3"
		if ResourceLoader.exists(path):
			shadow_author_fight_clips.append(load(path))
	# Load character-specific story dialog clips (generated by generate_story_voices.ps1)
	_load_character_story_clips()

func _load_character_story_clips() -> void:
	var char_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom",
		"scrooge", "sherlock", "tarzan", "dracula", "merlin", "frankenstein", "shadow_author"]
	var dialog_keys: Array = []
	# Build list of all dialog keys from story_dialogs
	for key in story_dialogs:
		dialog_keys.append(key)
	# For each dialog, count character lines and look for matching MP3s
	for key in dialog_keys:
		if not story_dialogs.has(key):
			continue
		var lines = story_dialogs[key]
		var speaker_counts: Dictionary = {}
		for line_idx in range(lines.size()):
			var speaker = lines[line_idx].get("speaker", "narrator")
			if speaker == "narrator":
				continue
			var idx = speaker_counts.get(speaker, 0)
			speaker_counts[speaker] = idx + 1
			var clip_key = key + "_" + speaker + "_" + str(idx)
			# Look for character story clip: audio/voices/{character}/{clip_key}.mp3
			var char_dir = speaker
			var clip_path = "res://audio/voices/" + char_dir + "/" + clip_key + ".mp3"
			if ResourceLoader.exists(clip_path):
				character_story_clips[clip_key] = load(clip_path)

func _init_catchphrase_quotes() -> void:
	placement_quotes = {
		TowerType.ROBIN_HOOD: [
			"Rob the rich to feed the poor!",
			"I am Robin Hood!",
			"Come, come, my merry men all!",
			"Robin Hood, at your service.",
			"I live by the greenwood tree, and a right good life it is!",
			"Will you not stay and feast with us beneath the greenwood tree?",
			"Not a penny shall pass while Robin Hood draws breath!",
		],
		TowerType.ALICE: [
			"Curiouser and curiouser!",
			"Who in the world am I? Ah, that's the great puzzle.",
			"Down the rabbit hole we go!",
			"We're all mad here, you know.",
			"I can't explain myself, I'm afraid, because I'm not myself, you know.",
			"I almost wish I hadn't gone down that rabbit hole, and yet, it's rather curious!",
			"But I don't want to go among mad people!",
		],
		TowerType.WICKED_WITCH: [
			"I'll get you, my pretty, and your little dog too!",
			"Surrender, Dorothy!",
			"Fly, my pretties, fly!",
			"Now I shall have those silver shoes!",
			"I have but one eye, yet it is as powerful as a telescope!",
			"With the Golden Cap I shall rule all of Oz!",
			"You have no power against me, you little fool!",
		],
		TowerType.PETER_PAN: [
			"I'm youth, I'm joy, I'm a little bird that has broken out of the egg!",
			"I don't want ever to be a man!",
			"To die will be an awfully big adventure!",
			"I'll never grow up!",
			"All children, except one, grow up.",
			"I ran away the day I was born.",
			"Do you know why swallows build in the eaves of houses? It is to listen to the stories.",
		],
		TowerType.PHANTOM: [
			"I am your Angel of Music.",
			"The Music of the Night!",
			"The Opera Ghost is here.",
			"If I am the Phantom, it is because man's hatred has made me so.",
			"I built this palace beneath the Opera for you!",
			"Come to me, Angel of Music!",
			"My unhappy face inspires horror, but my music is beautiful.",
		],
		TowerType.SCROOGE: [
			"Bah! Humbug!",
			"Are there no prisons? No workhouses?",
			"I wish to be left alone.",
			"Every penny counts!",
			"Darkness is cheap, and Scrooge likes it.",
			"I don't make merry myself at Christmas.",
			"I am as light as a feather, I am as happy as an angel!",
		],
		TowerType.SHERLOCK: [
			"Elementary, my dear Watson.",
			"The game is afoot!",
			"Data! Data! I cannot make bricks without clay.",
			"When you eliminate the impossible, whatever remains must be the truth.",
			"I am the last and highest court of appeal in detection.",
			"You see, but you do not observe.",
			"There is nothing more deceptive than an obvious fact.",
		],
		TowerType.TARZAN: [
			"Tarzan of the Apes!",
			"The jungle provides!",
			"Tarzan protect friends!",
			"Kreegah! Bundolo!",
			"I am Tarzan, King of the Apes!",
			"Tarzan no kill. Tarzan friend.",
			"I am a man, and men do not devour their kill!",
		],
		TowerType.DRACULA: [
			"I am Dracula. I bid you welcome.",
			"The blood is the life!",
			"Listen to them, the children of the night. What music they make!",
			"I never drink... wine.",
			"Welcome to my house. Come freely, go safely.",
			"We are in Transylvania, and Transylvania is not England.",
			"The walls of my castle are broken. The shadows are many.",
		],
		TowerType.MERLIN: [
			"By the power of the old magic!",
			"Knowledge is the greatest weapon.",
			"The prophecy unfolds!",
			"Even the smallest spell can change the world.",
			"I have seen the future, and it needs our help.",
			"The old ways are not forgotten.",
			"Magic is neither good nor evil. It is the wielder who decides.",
		],
		TowerType.FRANKENSTEIN: [
			"I ought to be thy Adam, but I am rather the fallen angel.",
			"Beware, for I am fearless and therefore powerful.",
			"My heart was fashioned to be susceptible of love and sympathy.",
			"I am malicious because I am miserable.",
			"There is love in me the likes of which you can scarcely imagine.",
			"If I cannot inspire love, I will cause fear.",
			"Was I then a monster, a blot upon the earth?",
		],
	}
	fighting_quotes = {
		TowerType.ROBIN_HOOD: [
			"For Sherwood!",
			"My arrows fly true!",
			"Steal from the rich, defend the path!",
			"Another shot for the poor!",
			"A match! Let us see who is the better man!",
			"Here is a shaft for thee, thou villain!",
			"Now, by Our Lady, that was a fine shot!",
		],
		TowerType.ALICE: [
			"Off with their heads!",
			"How puzzling all these changes are!",
			"I could tell you my adventures, beginning from this morning.",
			"I do wish I hadn't cried so much!",
			"I knew who I was this morning, but I've changed a few times since then!",
			"Would you tell me, please, which way I ought to go from here?",
			"Dear, dear! How queer everything is today!",
		],
		TowerType.WICKED_WITCH: [
			"How about a little fire?",
			"I'll use the Golden Cap!",
			"You cursed brat!",
			"My beautiful wickedness!",
			"I shall make you my slave!",
			"The silver shoes will give me great power!",
			"A little girl destroyed my beautiful wickedness!",
		],
		TowerType.PETER_PAN: [
			"I do believe in fairies!",
			"Second star to the right!",
			"Wendy, one girl is more use than twenty boys!",
			"Oh, the cleverness of me!",
			"Dark and sinister man, have at thee!",
			"To live will be an awfully big adventure!",
			"I say, are you a codfish?",
		],
		TowerType.PHANTOM: [
			"Sing for me!",
			"I am dying of love!",
			"The chandelier! Beware the chandelier!",
			"Your most obedient servant, the Opera Ghost.",
			"Woe to those who cross the Opera Ghost!",
			"The disaster will be yours if you refuse!",
			"I am the trap-door lover! I am Erik!",
		],
		TowerType.SCROOGE: [
			"Humbug!",
			"I will honour Christmas in my heart!",
			"Every idiot who goes about with Merry Christmas on his lips!",
			"God bless us, every one!",
			"I am not the man I was!",
			"You may be an undigested bit of beef!",
			"Spirit, show me no more!",
		],
		TowerType.SHERLOCK: [
			"The game is afoot!",
			"Elementary!",
			"Come, Watson, the game is afoot!",
			"I see everything.",
			"The world is full of obvious things which nobody ever observes.",
			"My mind rebels at stagnation!",
			"I never guess. It is a shocking habit.",
		],
		TowerType.TARZAN: [
			"Kreegah!",
			"Tarzan is here!",
			"The jungle calls!",
			"Tarzan protect!",
			"Tarzan mighty fighter!",
			"The apes taught Tarzan well!",
			"Tarzan kill!",
		],
		TowerType.DRACULA: [
			"I am the night.",
			"Welcome to my domain.",
			"The blood is the life!",
			"I bid you... welcome.",
			"You shall be flesh of my flesh, blood of my blood!",
			"My revenge is just begun!",
			"I have lived for centuries, and time is on my side.",
		],
		TowerType.MERLIN: [
			"By the old magic!",
			"The stars align!",
			"Wisdom conquers all!",
			"Let the spell be cast!",
			"The elements obey my command!",
			"Behold the power of ages!",
			"This enchantment shall hold!",
		],
		TowerType.FRANKENSTEIN: [
			"I am... here.",
			"Friend... not monster.",
			"Lightning... gives me strength.",
			"I will protect... the kind ones.",
			"Cursed, cursed creator! Why did I live?",
			"I am fearless, and therefore powerful!",
			"Shall each man find a wife, and I be alone?",
		],
	}

func _play_placement_catchphrase(tower_type: TowerType) -> String:
	# Play MP3 voice clip if available
	if not voices_muted and placement_voice_clips.has(tower_type):
		var clips: Array = placement_voice_clips[tower_type]
		catchphrase_player.stream = clips[randi() % clips.size()]
		catchphrase_player.play()
	# Return text quote for display
	if placement_quotes.has(tower_type):
		var quotes: Array = placement_quotes[tower_type]
		return quotes[randi() % quotes.size()]
	return _get_tower_quote(tower_type)

func _play_random_fighting_quote() -> void:
	if voices_muted:
		return
	# Pick a random placed tower type that has fighting clips
	var placed_types: Array = []
	for tower_type in fighting_voice_clips:
		if purchased_towers.has(tower_type):
			placed_types.append(tower_type)
	if placed_types.size() == 0:
		return
	var chosen_type = placed_types[randi() % placed_types.size()]
	var clips: Array = fighting_voice_clips[chosen_type]
	catchphrase_player.stream = clips[randi() % clips.size()]
	catchphrase_player.play()
	# Also display quote text
	if fighting_quotes.has(chosen_type):
		var quotes: Array = fighting_quotes[chosen_type]
		var tname = tower_info[chosen_type]["name"]
		var quote = quotes[randi() % quotes.size()]
		info_label.text = "%s: \"%s\"" % [tname, quote]

var _shadow_fight_quotes: Array = [
	"Your stories end here... in MY pages!",
	"I have rewritten stronger heroes than you... into oblivion!",
	"Every word you speak... feeds my power!",
	"You cannot defeat your own author... I created this world!",
	"Run back to your chapters... before I erase you entirely!",
	"I am every nightmare... you were never brave enough to face!",
	"The ink is drying... and YOUR story ends in darkness!",
]

func _play_shadow_author_taunt() -> void:
	if voices_muted:
		return
	if shadow_author_fight_clips.size() == 0:
		return
	var idx = randi() % shadow_author_fight_clips.size()
	catchphrase_player.stream = shadow_author_fight_clips[idx]
	catchphrase_player.play()
	if idx < _shadow_fight_quotes.size():
		info_label.text = "The Shadow Author: \"%s\"" % _shadow_fight_quotes[idx]

func _draw_scroll_indicator(x: float, y: float, height: float, scroll_pos: float, content_height: float, visible_height: float) -> void:
	if content_height <= visible_height:
		return
	var bar_h = height
	var thumb_h = maxf(20.0, bar_h * (visible_height / content_height))
	var scroll_ratio = clampf(scroll_pos / (content_height - visible_height), 0.0, 1.0)
	var thumb_y = y + scroll_ratio * (bar_h - thumb_h)
	draw_rect(Rect2(x, y, 4, bar_h), Color(1, 1, 1, 0.08))
	draw_rect(Rect2(x, thumb_y, 4, thumb_h), Color(1, 1, 1, 0.25))

func _draw_currency_bar() -> void:
	var font = game_font
	var bar_y = 0.0
	var bar_h = 32.0
	# Deep navy bar with subtle purple gradient
	draw_rect(Rect2(0, bar_y, 1280, bar_h), Color(0.02, 0.02, 0.08, 0.95))
	var grad_steps = 16
	var step_w = 1280.0 / float(grad_steps)
	for gi in range(grad_steps):
		var grad_t = (float(gi) + 0.5) / float(grad_steps)
		var purple_a = sin(grad_t * PI) * 0.06
		draw_rect(Rect2(float(gi) * step_w, bar_y, step_w, bar_h), Color(menu_accent_purple.r, menu_accent_purple.g, menu_accent_purple.b, purple_a))
	# Gold bottom accent line
	draw_rect(Rect2(0, bar_y + bar_h - 1, 1280, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.4))
	# Subtle inner glow at bottom
	draw_rect(Rect2(0, bar_y + bar_h - 3, 1280, 2), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.08))

	# Title on left — gold with glow + shadow (mobile-friendly size)
	var title_pulse = 0.85 + sin(_time * 1.2) * 0.15
	# Outer glow
	_udraw(font, Vector2(12, bar_y + 22), "Shadow Defense", HORIZONTAL_ALIGNMENT_LEFT, 300, 18, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.15 * title_pulse))
	# Drop shadow
	_udraw(font, Vector2(13, bar_y + 23), "Shadow Defense", HORIZONTAL_ALIGNMENT_LEFT, 300, 17, Color(0, 0, 0, 0.6))
	# Main text
	_udraw(font, Vector2(12, bar_y + 22), "Shadow Defense", HORIZONTAL_ALIGNMENT_LEFT, 300, 17, Color(menu_gold.r * title_pulse, menu_gold.g * title_pulse, menu_gold.b * 0.6, 1.0))

	# Currencies from left to right
	var currencies = [
		{"icon": "G", "color": Color(0.9, 0.8, 0.2), "value": player_gold, "name": "Gold"},
		{"icon": "Q", "color": Color(0.4, 0.7, 0.9), "value": player_quills, "name": "Quills"},
		{"icon": "S", "color": Color(0.7, 0.4, 0.8), "value": player_relic_shards, "name": "Shards"},
		{"icon": "*", "color": Color(1.0, 0.9, 0.3), "value": player_storybook_stars, "name": "Stars"},
		{"icon": "K", "color": Color(0.3, 0.6, 0.4), "value": knowledge_ink, "name": "Ink"},
		{"icon": "T", "color": Color(0.8, 0.6, 0.2), "value": trophy_currency, "name": "Trophies"},
	]
	var cx = 370.0
	for c in currencies:
		var cc = c["color"]
		var ic_y = bar_y + bar_h * 0.5
		# Outer glow pulse
		var ic_pulse = 0.8 + sin(_time * 1.5 + cx * 0.01) * 0.2
		draw_circle(Vector2(cx, ic_y), 14, Color(cc.r, cc.g, cc.b, 0.08 * ic_pulse))
		# Icon circle with bright fill
		draw_circle(Vector2(cx, ic_y), 11, Color(cc.r, cc.g, cc.b, 0.18))
		draw_circle(Vector2(cx, ic_y), 9, Color(cc.r, cc.g, cc.b, 0.3))
		draw_arc(Vector2(cx, ic_y), 10, 0, TAU, 24, Color(cc.r, cc.g, cc.b, 0.55), 1.5)
		_udraw(font, Vector2(cx, bar_y + 22), c["icon"], HORIZONTAL_ALIGNMENT_CENTER, 20, 15, cc)
		# Value — shadow + bright text (with thousands separator)
		var val_str = _format_gold(c["value"])
		_udraw(font, Vector2(cx + 16, bar_y + 22), val_str, HORIZONTAL_ALIGNMENT_LEFT, 85, 16, Color(0, 0, 0, 0.5))
		_udraw(font, Vector2(cx + 15, bar_y + 21), val_str, HORIZONTAL_ALIGNMENT_LEFT, 85, 16, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.95))
		cx += 130.0

	# Total stars on far right
	var total_stars = 0
	for ls_key in level_stars:
		total_stars += level_stars[ls_key]
	var max_stars = levels.size() * 3
	_udraw(font, Vector2(1222, bar_y + 22), "%d/%d" % [total_stars, max_stars], HORIZONTAL_ALIGNMENT_RIGHT, 100, 14, Color(1.0, 0.9, 0.3, 0.9))

func _draw_menu_background() -> void:
	var font = game_font
	# === MENU THEME COSMETIC OVERRIDE ===
	var theme_bg = menu_bg_dark
	var theme_accent = menu_gold_dim
	var equipped_theme = equipped_cosmetics.get("themes", "")
	if equipped_theme != "":
		for theme_item in trophy_store_items.get("themes", []):
			if theme_item["id"] == equipped_theme:
				theme_bg = theme_item["bg"]
				theme_accent = theme_item["accent"]
				break

	if menu_current_view != "survivors" or survivor_detail_open:
		# === Deep navy background with vertical gradient ===
		draw_rect(Rect2(0, 0, 1280, 720), theme_bg)
		# Vertical gradient — darker at top, slight purple warmth at bottom (20 bands)
		var grad_step = 36  # 720 / 20 = 36px per band
		for gy in range(0, 720, grad_step):
			var gt = (float(gy) + float(grad_step) * 0.5) / 720.0
			var purple_shift = gt * gt * 0.04
			var col = Color(theme_bg.r + purple_shift * 0.8, theme_bg.g + purple_shift * 0.2, theme_bg.b + purple_shift * 1.5, 0.6)
			draw_rect(Rect2(0, gy, 1280, grad_step), col)

		# === Center radial glow (purple atmosphere — vivid for mobile) ===
		var center_pulse = 0.9 + sin(_time * 0.6) * 0.1
		draw_circle(Vector2(640, 360), 550.0, Color(menu_accent_purple.r, menu_accent_purple.g, menu_accent_purple.b, 0.06 * center_pulse))
		draw_circle(Vector2(640, 360), 400.0, Color(menu_accent_purple.r, menu_accent_purple.g, menu_accent_purple.b, 0.10 * center_pulse))
		draw_circle(Vector2(640, 360), 250.0, Color(0.35, 0.12, 0.55, 0.12 * center_pulse))
		draw_circle(Vector2(640, 360), 120.0, Color(0.45, 0.18, 0.65, 0.08 * center_pulse))

		# === Corner vignette (dark edges for depth) ===
		for corner_i in range(4):
			var corner_x = 0.0 if corner_i % 2 == 0 else 1280.0
			var corner_y = 0.0 if corner_i < 2 else 720.0
			draw_circle(Vector2(corner_x, corner_y), 400.0, Color(0.0, 0.0, 0.02, 0.06))

		# === Gothic corner ornaments (all 4 corners — bright for mobile) ===
		var orn_a = 0.22 + sin(_time * 0.8) * 0.06
		var orn_col = Color(menu_gold.r, menu_gold.g, menu_gold.b, orn_a)
		# Top-left ornament
		for oi in range(5):
			var olen = 30.0 + float(oi) * 12.0
			draw_line(Vector2(4, 36 + float(oi) * 8), Vector2(4 + olen, 36 + float(oi) * 8), orn_col, 1.0)
			draw_line(Vector2(36 + float(oi) * 8, 4), Vector2(36 + float(oi) * 8, 4 + olen), orn_col, 1.0)
		draw_arc(Vector2(4, 36), 32, -PI * 0.5, 0.0, 16, orn_col, 1.0)
		# Top-right ornament
		for oi in range(5):
			var olen = 30.0 + float(oi) * 12.0
			draw_line(Vector2(1276, 36 + float(oi) * 8), Vector2(1276 - olen, 36 + float(oi) * 8), orn_col, 1.0)
			draw_line(Vector2(1244 - float(oi) * 8, 4), Vector2(1244 - float(oi) * 8, 4 + olen), orn_col, 1.0)
		draw_arc(Vector2(1276, 36), 32, PI, PI * 1.5, 16, orn_col, 1.0)
		# Bottom-left ornament
		for oi in range(5):
			var olen = 25.0 + float(oi) * 10.0
			draw_line(Vector2(4, 608 - float(oi) * 7), Vector2(4 + olen, 608 - float(oi) * 7), orn_col, 1.0)
		draw_arc(Vector2(4, 608), 28, 0.0, PI * 0.5, 12, orn_col, 1.0)
		# Bottom-right ornament
		for oi in range(5):
			var olen = 25.0 + float(oi) * 10.0
			draw_line(Vector2(1276, 608 - float(oi) * 7), Vector2(1276 - olen, 608 - float(oi) * 7), orn_col, 1.0)
		draw_arc(Vector2(1276, 608), 28, PI * 0.5, PI, 12, orn_col, 1.0)

		# === Bookshelf silhouette along bottom (more visible for mobile) ===
		var shelf_y = 610.0
		var shelf_col = Color(0.04, 0.03, 0.10, 0.65)
		for bsi in range(_bookshelf_heights.size()):
			var bx = float(bsi) * 50.0
			var bh = _bookshelf_heights[bsi]
			# Book spine with slight color variation
			var spine_hue = 0.02 + float(bsi % 5) * 0.005
			draw_rect(Rect2(bx, shelf_y - bh, 44, bh), Color(spine_hue, 0.03, 0.10 + float(bsi % 3) * 0.02, 0.65))
			# Top edge highlight — brighter
			draw_line(Vector2(bx, shelf_y - bh), Vector2(bx + 44, shelf_y - bh), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.15), 1.5)
			# Spine line — more visible
			draw_line(Vector2(bx + 22, shelf_y - bh + 4), Vector2(bx + 22, shelf_y - 4), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08), 1.0)
		# Shelf plank — thicker, more visible
		draw_rect(Rect2(0, shelf_y, 1280, 4), Color(0.08, 0.06, 0.14, 0.7))
		draw_rect(Rect2(0, shelf_y, 1280, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))

		# === Ink splatters (subtle background texture — pre-seeded) ===
		var sp_col = Color(0.02, 0.01, 0.06, 0.12)
		var sp_dot_col = Color(0.02, 0.01, 0.06, 0.08)
		for splat in _menu_ink_splatters:
			_menu_splatter_rng.seed = splat["seed"]
			draw_circle(Vector2(splat["x"], splat["y"]), splat["size"], sp_col)
			for _di in range(splat["dots"]):
				var dot_x = splat["x"] + _menu_splatter_rng.randf_range(-splat["size"] * 2, splat["size"] * 2)
				var dot_y = splat["y"] + _menu_splatter_rng.randf_range(-splat["size"] * 1.5, splat["size"] * 1.5)
				draw_circle(Vector2(dot_x, dot_y), _menu_splatter_rng.randf_range(1, 4), sp_dot_col)

		# === Floating book pages (drifting gently) ===
		for page in _floating_pages:
			var px = page["x"] + sin(_time * page["speed"] + page["offset"]) * 40.0
			var py = page["y"] + cos(_time * page["speed"] * 0.5 + page["offset"] * 1.3) * 25.0
			var prot = page["rot"] + sin(_time * 0.3 + page["offset"]) * 0.15
			var psz = page["size"]
			var pa = 0.12 + sin(_time * 0.8 + page["offset"]) * 0.04
			# Page body (rotated rectangle via polygon)
			var hw = psz * 0.35
			var hh = psz * 0.5
			var cr = cos(prot)
			var sr = sin(prot)
			var corners = PackedVector2Array([
				Vector2(px + (-hw) * cr - (-hh) * sr, py + (-hw) * sr + (-hh) * cr),
				Vector2(px + hw * cr - (-hh) * sr, py + hw * sr + (-hh) * cr),
				Vector2(px + hw * cr - hh * sr, py + hw * sr + hh * cr),
				Vector2(px + (-hw) * cr - hh * sr, py + (-hw) * sr + hh * cr),
			])
			draw_colored_polygon(corners, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, pa))
			# Text lines on page
			for tl in range(3):
				var lx_start = px + (-hw * 0.6) * cr - (-hh * 0.3 + float(tl) * hh * 0.25) * sr
				var ly_start = py + (-hw * 0.6) * sr + (-hh * 0.3 + float(tl) * hh * 0.25) * cr
				var lx_end = px + (hw * 0.5) * cr - (-hh * 0.3 + float(tl) * hh * 0.25) * sr
				var ly_end = py + (hw * 0.5) * sr + (-hh * 0.3 + float(tl) * hh * 0.25) * cr
				draw_line(Vector2(lx_start, ly_start), Vector2(lx_end, ly_end), Color(0.3, 0.25, 0.15, pa * 0.6), 0.5)

		# === Quill pens (decorative, static with gentle sway) ===
		for quill in _quill_positions:
			var qx = quill["x"]
			var qy = quill["y"] + sin(_time * 0.5 + qx * 0.01) * 3.0
			var qrot = quill["rot"] + sin(_time * 0.4) * 0.05
			var qsz = quill["size"]
			var qa = 0.06
			var qcr = cos(qrot)
			var qsr = sin(qrot)
			# Shaft
			draw_line(Vector2(qx, qy), Vector2(qx + qsz * qcr, qy + qsz * qsr), Color(0.5, 0.35, 0.15, qa), 1.5)
			# Feather barbs
			for fb in range(4):
				var ft = 0.2 + float(fb) * 0.2
				var fx = qx + qsz * ft * qcr
				var fy = qy + qsz * ft * qsr
				draw_line(Vector2(fx, fy), Vector2(fx - 6 * qsr, fy + 6 * qcr), Color(0.5, 0.35, 0.15, qa * 0.7), 1.0)
				draw_line(Vector2(fx, fy), Vector2(fx + 6 * qsr, fy - 6 * qcr), Color(0.5, 0.35, 0.15, qa * 0.7), 1.0)
			# Nib
			draw_circle(Vector2(qx - 2 * qcr, qy - 2 * qsr), 1.5, Color(0.3, 0.25, 0.4, qa))

		# === Ethereal lantern glow (purple/blue wisps — bright for mobile) ===
		for candle in _book_candle_positions:
			var cx_pos = candle["x"]
			var cy_pos = candle["y"]
			var flicker = sin(_time * 4.0 + candle["offset"]) * 0.3 + sin(_time * 7.0 + candle["offset"] * 2.0) * 0.15
			var glow_r = 100.0 + flicker * 25.0
			# Outer purple glow — MUCH brighter for visibility
			draw_circle(Vector2(cx_pos, cy_pos), glow_r, Color(0.4, 0.18, 0.6, 0.06 + flicker * 0.02))
			draw_circle(Vector2(cx_pos, cy_pos), glow_r * 0.6, Color(0.5, 0.25, 0.7, 0.08 + flicker * 0.03))
			draw_circle(Vector2(cx_pos, cy_pos), glow_r * 0.3, Color(0.6, 0.35, 0.85, 0.06 + flicker * 0.02))
			# Lantern body — dark iron bracket
			draw_rect(Rect2(cx_pos - 4, cy_pos + 12, 8, 20), Color(0.15, 0.12, 0.25, 0.7))
			draw_rect(Rect2(cx_pos - 6, cy_pos + 10, 12, 3), Color(0.2, 0.15, 0.3, 0.6))
			# Flame — purple-blue wisp (larger, brighter)
			var flame_h = 10.0 + flicker * 6.0
			draw_circle(Vector2(cx_pos, cy_pos + 6 - flame_h * 0.3), 6.0, Color(0.5, 0.3, 0.9, 0.6 + flicker * 0.2))
			draw_circle(Vector2(cx_pos, cy_pos + 3 - flame_h * 0.5), 4.0, Color(0.7, 0.5, 1.0, 0.7 + flicker * 0.15))
			draw_circle(Vector2(cx_pos, cy_pos + 1 - flame_h * 0.6), 2.5, Color(0.9, 0.8, 1.0, 0.8))

		# === Floating particles (gold + purple mix — vivid for mobile) ===
		for dust_i in range(_dust_positions.size()):
			var dust = _dust_positions[dust_i]
			var dx = dust["x"] + sin(_time * dust["speed"] + dust["offset"]) * 35.0
			var dy = dust["y"] + cos(_time * dust["speed"] * 0.6 + dust["offset"]) * 25.0
			var alpha = 0.25 + 0.15 * sin(_time * 1.5 + dust["offset"])
			var dsz = dust["size"] * 1.3
			# Alternate between gold and purple particles with glow halo
			if dust_i % 3 == 0:
				draw_circle(Vector2(dx, dy), dsz + 3, Color(0.5, 0.25, 0.8, alpha * 0.15))
				draw_circle(Vector2(dx, dy), dsz, Color(0.6, 0.35, 0.9, alpha * 0.8))
			else:
				draw_circle(Vector2(dx, dy), dsz + 3, Color(menu_gold.r, menu_gold.g, menu_gold.b, alpha * 0.15))
				draw_circle(Vector2(dx, dy), dsz, Color(menu_gold.r, menu_gold.g, menu_gold.b, alpha))

		# === 1. Gothic cathedral silhouette (parallax deep background) ===
		var cath_y = 380.0 + sin(_time * 0.15) * 8.0
		var cath_col = Color(0.03, 0.02, 0.07, 0.35)
		# Central spire
		draw_colored_polygon(PackedVector2Array([Vector2(640, cath_y - 180), Vector2(630, cath_y - 40), Vector2(650, cath_y - 40)]), cath_col)
		# Left tower
		draw_rect(Rect2(560, cath_y - 120, 30, 120), cath_col)
		draw_colored_polygon(PackedVector2Array([Vector2(575, cath_y - 150), Vector2(560, cath_y - 120), Vector2(590, cath_y - 120)]), cath_col)
		# Right tower
		draw_rect(Rect2(690, cath_y - 120, 30, 120), cath_col)
		draw_colored_polygon(PackedVector2Array([Vector2(705, cath_y - 150), Vector2(690, cath_y - 120), Vector2(720, cath_y - 120)]), cath_col)
		# Rose window
		draw_arc(Vector2(640, cath_y - 80), 18, 0, TAU, 16, Color(0.3, 0.1, 0.4, 0.15), 1.5)
		draw_arc(Vector2(640, cath_y - 80), 12, 0, TAU, 12, Color(0.4, 0.15, 0.5, 0.12), 1.0)
		# Buttresses
		draw_line(Vector2(555, cath_y - 60), Vector2(530, cath_y), Color(0.03, 0.02, 0.07, 0.25), 2.0)
		draw_line(Vector2(725, cath_y - 60), Vector2(750, cath_y), Color(0.03, 0.02, 0.07, 0.25), 2.0)

		# === 2. Drifting fog banks (3 parallax layers) ===
		for fi in range(3):
			var fog_speed = 0.08 + float(fi) * 0.04
			var fog_y = 300.0 + float(fi) * 100.0
			var fog_a = 0.03 - float(fi) * 0.008
			for fj in range(4):
				var fog_x = fmod(float(fj) * 350.0 + _time * (20.0 + float(fi) * 10.0) * fog_speed, 1600.0) - 160.0
				var fog_w = 200.0 + float(fj % 3) * 80.0
				draw_circle(Vector2(fog_x, fog_y + sin(_time * 0.3 + float(fj)) * 15.0), fog_w * 0.4, Color(0.4, 0.3, 0.55, fog_a))

		# === 3. Dead tree branches (left and right frame) ===
		var branch_col = Color(0.06, 0.04, 0.10, 0.3)
		# Left tree
		draw_line(Vector2(-10, 200), Vector2(60, 120), branch_col, 3.0)
		draw_line(Vector2(60, 120), Vector2(100, 80), branch_col, 2.0)
		draw_line(Vector2(60, 120), Vector2(40, 60), branch_col, 2.0)
		draw_line(Vector2(40, 60), Vector2(55, 20), branch_col, 1.5)
		draw_line(Vector2(100, 80), Vector2(130, 50 + sin(_time * 0.5) * 4.0), branch_col, 1.5)
		draw_line(Vector2(100, 80), Vector2(120, 110 + sin(_time * 0.4) * 3.0), branch_col, 1.0)
		# Right tree
		draw_line(Vector2(1290, 180), Vector2(1220, 100), branch_col, 3.0)
		draw_line(Vector2(1220, 100), Vector2(1180, 60), branch_col, 2.0)
		draw_line(Vector2(1220, 100), Vector2(1240, 40), branch_col, 2.0)
		draw_line(Vector2(1180, 60), Vector2(1150, 30 + sin(_time * 0.6) * 4.0), branch_col, 1.5)

		# === 4. Moonlit glow (top-right, subtle) ===
		var moon_x = 1100.0
		var moon_y = 80.0
		var moon_pulse = 0.8 + sin(_time * 0.4) * 0.2
		draw_circle(Vector2(moon_x, moon_y), 80, Color(0.15, 0.12, 0.25, 0.04 * moon_pulse))
		draw_circle(Vector2(moon_x, moon_y), 40, Color(0.2, 0.18, 0.35, 0.06 * moon_pulse))
		draw_circle(Vector2(moon_x, moon_y), 22, Color(0.7, 0.65, 0.8, 0.08 * moon_pulse))
		# Moon rays
		for ri in range(6):
			var ray_a = float(ri) * TAU / 6.0 + _time * 0.05
			var ray_len = 60.0 + sin(_time * 0.3 + float(ri)) * 15.0
			draw_line(Vector2(moon_x, moon_y), Vector2(moon_x + cos(ray_a) * ray_len, moon_y + sin(ray_a) * ray_len), Color(0.6, 0.55, 0.75, 0.03), 1.0)

		# === 5. Raven silhouettes (2 circling slowly) ===
		for rvi in range(2):
			var rv_angle = _time * (0.12 + float(rvi) * 0.05) + float(rvi) * PI
			var rv_cx = 640.0 + cos(rv_angle) * (300.0 + float(rvi) * 100.0)
			var rv_cy = 200.0 + sin(rv_angle * 0.7) * 80.0 + float(rvi) * 50.0
			var rv_dir = cos(rv_angle)  # facing direction
			var rv_a = 0.15 + sin(_time * 2.0 + float(rvi)) * 0.05
			var wing_flap = sin(_time * 4.0 + float(rvi) * 3.0) * 8.0
			# Body
			draw_circle(Vector2(rv_cx, rv_cy), 4, Color(0.02, 0.01, 0.05, rv_a))
			# Wings
			draw_line(Vector2(rv_cx - 8 * rv_dir, rv_cy + wing_flap), Vector2(rv_cx, rv_cy), Color(0.02, 0.01, 0.05, rv_a), 2.0)
			draw_line(Vector2(rv_cx + 8 * rv_dir, rv_cy + wing_flap), Vector2(rv_cx, rv_cy), Color(0.02, 0.01, 0.05, rv_a), 2.0)

		# === 6. Dripping wax/ink drops from top edge ===
		for di in range(6):
			var drip_x = 80.0 + float(di) * 200.0 + sin(float(di) * 1.7) * 40.0
			var drip_phase = fmod(_time * 0.3 + float(di) * 1.1, 4.0)
			if drip_phase < 2.0:
				var drip_y = drip_phase * 60.0
				var drip_a = 0.12 * (1.0 - drip_phase * 0.5)
				draw_circle(Vector2(drip_x, drip_y), 2.5, Color(0.5, 0.1, 0.15, drip_a))
				draw_circle(Vector2(drip_x, drip_y + 4), 1.5, Color(0.5, 0.1, 0.15, drip_a * 0.6))

		# === 7. Skull difficulty indicators along spine ===
		var spine_x = 640.0
		for si in range(3):
			var skull_y = 200.0 + float(si) * 80.0
			var skull_a = 0.08 + sin(_time * 1.5 + float(si) * 1.2) * 0.03
			# Skull outline
			draw_circle(Vector2(spine_x, skull_y), 8, Color(0.6, 0.55, 0.5, skull_a))
			draw_circle(Vector2(spine_x, skull_y + 2), 6, Color(0.6, 0.55, 0.5, skull_a * 0.7))
			# Eye sockets
			draw_circle(Vector2(spine_x - 3, skull_y - 1), 1.5, Color(0.02, 0.01, 0.05, skull_a * 1.5))
			draw_circle(Vector2(spine_x + 3, skull_y - 1), 1.5, Color(0.02, 0.01, 0.05, skull_a * 1.5))
			# Fire in eyes for harder skulls
			if si >= 1:
				var fire_a = skull_a * (0.8 + sin(_time * 5.0 + float(si)) * 0.3)
				draw_circle(Vector2(spine_x - 3, skull_y - 1), 1.0, Color(0.7, 0.2, 0.1, fire_a))
				draw_circle(Vector2(spine_x + 3, skull_y - 1), 1.0, Color(0.7, 0.2, 0.1, fire_a))

		# === 8. Wax seal impressions (decorative along edges) ===
		for wi in range(4):
			var seal_x = 30.0 + float(wi) * 310.0
			var seal_y = 580.0
			var seal_pulse = 0.08 + sin(_time * 0.8 + float(wi) * 1.5) * 0.02
			draw_circle(Vector2(seal_x, seal_y), 12, Color(0.6, 0.12, 0.1, seal_pulse))
			draw_circle(Vector2(seal_x, seal_y), 10, Color(0.7, 0.15, 0.12, seal_pulse * 0.8))
			# Seal emblem (cross pattern)
			draw_line(Vector2(seal_x - 5, seal_y), Vector2(seal_x + 5, seal_y), Color(0.9, 0.7, 0.2, seal_pulse * 0.6), 1.0)
			draw_line(Vector2(seal_x, seal_y - 5), Vector2(seal_x, seal_y + 5), Color(0.9, 0.7, 0.2, seal_pulse * 0.6), 1.0)

		# === 9. Gothic chain links (hanging from corners) ===
		var chain_col = Color(0.25, 0.2, 0.35, 0.10)
		for ci in range(2):
			var cx_base = 20.0 if ci == 0 else 1260.0
			for cli in range(5):
				var cy_chain = 100.0 + float(cli) * 22.0 + sin(_time * 0.6 + float(cli) * 0.4) * 3.0
				draw_arc(Vector2(cx_base, cy_chain), 6, 0, PI if cli % 2 == 0 else -PI, 8, chain_col, 1.5)

		# === 10. Tattered banner/pennant (top center) ===
		var banner_cx = 640.0
		var banner_y = 2.0
		var banner_w = 80.0
		var banner_h = 35.0
		var banner_sway = sin(_time * 0.8) * 4.0
		var banner_col2 = Color(0.35, 0.08, 0.12, 0.12)
		draw_rect(Rect2(banner_cx - banner_w * 0.5, banner_y, banner_w, banner_h), banner_col2)
		# Tattered bottom edge
		for bi in range(8):
			var bx_b = banner_cx - banner_w * 0.5 + float(bi) * 10.0
			var by_b = banner_y + banner_h + sin(_time * 1.2 + float(bi) * 0.8) * 3.0
			draw_line(Vector2(bx_b, banner_y + banner_h), Vector2(bx_b + 5, by_b + 6), Color(0.35, 0.08, 0.12, 0.08), 1.0)
		# Pennant emblem
		draw_circle(Vector2(banner_cx + banner_sway * 0.3, banner_y + banner_h * 0.45), 8, Color(0.8, 0.6, 0.1, 0.08))

		# === 11. Cobweb corners (top corners) ===
		var web_col = Color(0.5, 0.48, 0.55, 0.06)
		# Top-left cobweb
		for wbi in range(4):
			var wa = float(wbi) * PI * 0.5 / 4.0
			draw_line(Vector2(0, 0), Vector2(cos(wa) * 70, sin(wa) * 70), web_col, 0.5)
		for wri in range(3):
			var wr = 20.0 + float(wri) * 20.0
			draw_arc(Vector2(0, 0), wr, 0, PI * 0.5, 8, web_col, 0.5)
		# Top-right cobweb
		for wbi in range(4):
			var wa = PI * 0.5 + float(wbi) * PI * 0.5 / 4.0
			draw_line(Vector2(1280, 0), Vector2(1280 + cos(wa) * 70, sin(wa) * 70), web_col, 0.5)
		for wri in range(3):
			var wr = 20.0 + float(wri) * 20.0
			draw_arc(Vector2(1280, 0), wr, PI * 0.5, PI, 8, web_col, 0.5)

		# === 12. Flickering candelabra (book spine area) ===
		var cand_x = 640.0
		var cand_y = 500.0
		var cand_a = 0.15
		# Stand
		draw_rect(Rect2(cand_x - 2, cand_y, 4, 20), Color(0.3, 0.22, 0.15, cand_a))
		draw_rect(Rect2(cand_x - 12, cand_y + 20, 24, 3), Color(0.3, 0.22, 0.15, cand_a))
		# Arms
		for arm_i in range(3):
			var arm_x = cand_x + (float(arm_i) - 1.0) * 16.0
			draw_rect(Rect2(arm_x - 1, cand_y - 8, 2, 8), Color(0.3, 0.22, 0.15, cand_a))
			# Flame
			var fl_flicker = sin(_time * 6.0 + float(arm_i) * 2.1) * 0.15
			draw_circle(Vector2(arm_x, cand_y - 12), 4, Color(0.9, 0.5, 0.1, (cand_a + fl_flicker) * 0.6))
			draw_circle(Vector2(arm_x, cand_y - 14), 2.5, Color(1.0, 0.8, 0.3, (cand_a + fl_flicker) * 0.8))
			# Glow
			draw_circle(Vector2(arm_x, cand_y - 12), 15, Color(0.9, 0.5, 0.1, 0.02 + fl_flicker * 0.01))

		# === 13. Swirling ink tendrils (animated) ===
		for ti_ink in range(3):
			var ink_cx = 200.0 + float(ti_ink) * 400.0
			var ink_cy = 350.0 + sin(_time * 0.2 + float(ti_ink)) * 80.0
			var ink_a = 0.04
			for seg in range(8):
				var sa = _time * 0.5 + float(seg) * 0.8 + float(ti_ink) * 2.0
				var sr2 = 30.0 + float(seg) * 8.0
				var sx = ink_cx + cos(sa) * sr2
				var sy = ink_cy + sin(sa * 1.3) * sr2 * 0.6
				draw_circle(Vector2(sx, sy), 3.0 - float(seg) * 0.3, Color(0.1, 0.05, 0.2, ink_a * (1.0 - float(seg) * 0.1)))

		# === 14. Moth/firefly particles near lanterns ===
		for mi in range(5):
			var moth_phase = _time * (1.5 + float(mi) * 0.3) + float(mi) * 2.5
			var moth_cx = 200.0 + float(mi) * 220.0
			var moth_cy = 250.0 + float(mi % 3) * 80.0
			var moth_x = moth_cx + cos(moth_phase) * 25.0
			var moth_y = moth_cy + sin(moth_phase * 1.4) * 18.0
			var moth_a = 0.15 + sin(_time * 3.0 + float(mi)) * 0.08
			draw_circle(Vector2(moth_x, moth_y), 1.5, Color(0.9, 0.8, 0.5, moth_a))
			draw_circle(Vector2(moth_x, moth_y), 5, Color(0.9, 0.8, 0.5, moth_a * 0.1))

		# === 15. Blood pool / crimson puddle (bottom area) ===
		var pool_x = 400.0
		var pool_y = 600.0
		var pool_pulse = sin(_time * 0.5) * 0.01
		draw_circle(Vector2(pool_x, pool_y), 30, Color(0.4, 0.05, 0.08, 0.04 + pool_pulse))
		draw_circle(Vector2(pool_x + 15, pool_y + 5), 18, Color(0.35, 0.04, 0.06, 0.03 + pool_pulse))
		# Ripple
		var ripple_r = fmod(_time * 8.0, 30.0)
		draw_arc(Vector2(pool_x, pool_y), ripple_r, 0, TAU, 16, Color(0.5, 0.1, 0.1, 0.03 * (1.0 - ripple_r / 30.0)), 0.5)

		# === 16. Falling rose petals ===
		for pi_petal in range(4):
			var petal_x = fmod(float(pi_petal) * 337.0 + _time * 15.0, 1400.0) - 60.0
			var petal_y = fmod(float(pi_petal) * 193.0 + _time * 25.0, 800.0) - 40.0
			var petal_rot = _time * 1.5 + float(pi_petal) * 1.8
			var petal_a = 0.08 + sin(_time + float(pi_petal)) * 0.03
			var pr_cos = cos(petal_rot)
			var pr_sin = sin(petal_rot)
			draw_colored_polygon(PackedVector2Array([
				Vector2(petal_x + 4 * pr_cos, petal_y + 4 * pr_sin),
				Vector2(petal_x - 2 * pr_sin, petal_y + 2 * pr_cos),
				Vector2(petal_x - 4 * pr_cos, petal_y - 4 * pr_sin),
				Vector2(petal_x + 2 * pr_sin, petal_y - 2 * pr_cos),
			]), Color(0.7, 0.15, 0.2, petal_a))

		# === 17. Spectral character whispers (faint character outlines) ===
		var whisper_chars = [
			{"x": 90, "y": 340, "char": "R"},   # Robin
			{"x": 1190, "y": 320, "char": "A"},  # Alice
			{"x": 120, "y": 480, "char": "P"},   # Phantom
			{"x": 1160, "y": 460, "char": "S"},  # Scrooge
		]
		for wc in whisper_chars:
			var wc_a = 0.03 + sin(_time * 0.6 + float(wc["x"]) * 0.01) * 0.015
			_udraw(font, Vector2(wc["x"], wc["y"]), wc["char"], HORIZONTAL_ALIGNMENT_LEFT, -1, 40, Color(0.5, 0.4, 0.6, wc_a))

		# === 18. Creeping vine tendrils along edges ===
		var vine_col = Color(0.15, 0.3, 0.1, 0.08)
		# Left vine
		var vine_pts_l: Array = []
		for vi in range(12):
			var vt = float(vi) / 11.0
			var vx = 8.0 + sin(vt * 4.0 + _time * 0.2) * 10.0
			var vy = 150.0 + vt * 350.0
			if vi > 0:
				draw_line(Vector2(vine_pts_l[vi - 1][0], vine_pts_l[vi - 1][1]), Vector2(vx, vy), vine_col, 1.5)
			vine_pts_l.append([vx, vy])
			# Tiny leaf
			if vi % 3 == 1:
				draw_circle(Vector2(vx + 6, vy), 3, Color(0.2, 0.35, 0.12, 0.06))

		# === 19. Dust motes in light beams ===
		for dmi in range(8):
			var dm_x = 950.0 + float(dmi % 4) * 30.0 + sin(_time * 0.5 + float(dmi) * 0.9) * 20.0
			var dm_y = 60.0 + float(dmi) * 35.0 + cos(_time * 0.3 + float(dmi)) * 10.0
			var dm_a = 0.06 + sin(_time * 2.0 + float(dmi) * 1.3) * 0.03
			draw_circle(Vector2(dm_x, dm_y), 1.0, Color(0.8, 0.75, 0.6, dm_a))

		# === 20. Animated book spine details (center divider) ===
		var spine_col2 = Color(0.2, 0.15, 0.3, 0.06)
		# Spine ridges
		for sri in range(8):
			var sr_y = 120.0 + float(sri) * 60.0
			draw_rect(Rect2(636, sr_y, 8, 3), spine_col2)
		# Spine title embossing
		var emboss_a = 0.04 + sin(_time * 0.5) * 0.01
		_udraw(font, Vector2(637, 430), "S", HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.6, 0.45, 0.2, emboss_a))
		_udraw(font, Vector2(637, 445), "D", HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.6, 0.45, 0.2, emboss_a))

	# === TOP CURRENCY BAR ===
	_draw_currency_bar()

	# === Bottom nav bar ===
	var nav_draw_y = 620.0
	# === BOTTOM NAV BAR — Polished, glowing, alive ===
	var nav_tab_names = ["survivors", "relics", "chapters", "chronicles", "emporium", "achievements"]
	var nav_tab_labels = ["HEROES", "RELICS", "ADVENTURE", "LORE", "SHOP", "TROPHIES"]
	var nav_tab_cols = [
		Color(0.85, 0.55, 0.25),  # Heroes: warm amber
		Color(0.65, 0.40, 0.85),  # Relics: mystical purple
		Color(0.35, 0.75, 0.35),  # Adventure: forest green
		Color(0.55, 0.70, 0.90),  # Lore: ink blue
		Color(0.90, 0.75, 0.25),  # Shop: gold
		Color(0.80, 0.65, 0.20),  # Trophies: bronze gold
	]
	# Dark gradient background with subtle texture
	for ngi in range(20):
		var t = float(ngi) / 19.0
		var bg_col = Color(0.03, 0.02, 0.08, 0.95).lerp(Color(0.01, 0.01, 0.04, 0.98), t)
		draw_rect(Rect2(0, nav_draw_y + float(ngi) * 5.0, 1280, 5.0), bg_col)
	# Top edge glow line (animated)
	var edge_glow = 0.4 + sin(_time * 1.8) * 0.1
	for egi in range(3):
		draw_rect(Rect2(0, nav_draw_y + float(egi), 1280, 1), Color(0.54, 0.38, 0.15, edge_glow * (1.0 - float(egi) * 0.3)))
	# Floating ink particles above nav bar
	for pi in range(8):
		var px_p = fmod(float(pi) * 173.7 + _time * (8.0 + float(pi) * 3.0), 1280.0)
		var py_p = nav_draw_y - 4.0 + sin(_time * 1.5 + float(pi) * 0.8) * 3.0
		var pa = 0.08 + sin(_time * 2.0 + float(pi)) * 0.04
		draw_circle(Vector2(px_p, py_p), 1.5, Color(0.6, 0.45, 0.15, pa))

	var tab_w = 1280.0 / 6.0  # ~213px per tab
	for ni in range(6):
		var tx = float(ni) * tab_w
		var is_act = (menu_current_view == nav_tab_names[ni])
		var tc = nav_tab_cols[ni]
		var hover_pulse = sin(_time * 3.0 + float(ni) * 1.0) * 0.08
		# Active tab: glowing background
		if is_act:
			# Radial glow behind icon
			var glow_cx = tx + tab_w * 0.5
			var glow_cy = nav_draw_y + 38.0
			for gi in range(6):
				var gr = 35.0 - float(gi) * 4.0
				var ga = 0.06 + sin(_time * 2.0) * 0.02 - float(gi) * 0.008
				draw_circle(Vector2(glow_cx, glow_cy), gr, Color(tc.r, tc.g, tc.b, ga))
			# Bottom glow bar (pulsing)
			var bar_glow = 0.7 + sin(_time * 2.5) * 0.2
			draw_rect(Rect2(tx + 20, nav_draw_y + 92, tab_w - 40, 4), Color(tc.r, tc.g, tc.b, bar_glow * 0.8))
			draw_rect(Rect2(tx + 30, nav_draw_y + 96, tab_w - 60, 2), Color(tc.r, tc.g, tc.b, bar_glow * 0.3))
			# Top accent
			draw_rect(Rect2(tx + 15, nav_draw_y, tab_w - 30, 2), Color(tc.r, tc.g, tc.b, bar_glow * 0.5))
			# === Animated gold underline (Enhancement #49) ===
			# Sliding highlight segment that sweeps across the underline
			var slide_t = fmod(_time * 0.8, 1.0)  # 0..1 sweep
			var underline_w = tab_w - 40.0
			var segment_w = underline_w * 0.35
			var seg_x = tx + 20.0 + slide_t * (underline_w - segment_w)
			var seg_glow = 0.6 + sin(_time * 4.0) * 0.2
			draw_rect(Rect2(seg_x, nav_draw_y + 91, segment_w, 2), Color(menu_gold.r, menu_gold.g, menu_gold.b, seg_glow))
			# Bright center point of sweep
			var dot_x = seg_x + segment_w * 0.5
			draw_circle(Vector2(dot_x, nav_draw_y + 92), 3, Color(menu_gold.r, menu_gold.g, menu_gold.b, seg_glow * 0.5))

		# Icon circle (large, prominent — mobile-friendly)
		var ic = Vector2(tx + tab_w * 0.5, nav_draw_y + 36.0)
		var ic_r = 28.0 if is_act else 24.0
		var ic_col = tc if is_act else Color(tc.r * 0.55, tc.g * 0.55, tc.b * 0.55)
		var ic_bg_a = 0.35 + hover_pulse if is_act else 0.12
		# Circle background
		draw_circle(ic, ic_r, Color(tc.r * 0.15, tc.g * 0.15, tc.b * 0.15, ic_bg_a))
		# Circle border (double ring for active)
		draw_arc(ic, ic_r, 0, TAU, 32, Color(ic_col.r, ic_col.g, ic_col.b, 0.7 if is_act else 0.3), 2.0 if is_act else 1.5)
		if is_act:
			draw_arc(ic, ic_r + 3, 0, TAU, 32, Color(ic_col.r, ic_col.g, ic_col.b, 0.2), 1.0)
			# Animated sparkle dots orbiting active icon
			for si in range(3):
				var sa = _time * 2.0 + float(si) * TAU / 3.0
				var sp = ic + Vector2(cos(sa), sin(sa)) * (ic_r + 6)
				draw_circle(sp, 1.5, Color(tc.r, tc.g, tc.b, 0.4 + sin(_time * 4.0 + float(si)) * 0.2))
		# Icon drawings (bigger, bolder)
		var s = 1.3 if is_act else 1.0
		if ni == 0:  # HEROES — crossed swords
			draw_line(ic + Vector2(-8, 8) * s, ic + Vector2(8, -8) * s, ic_col, 2.5 * s)
			draw_line(ic + Vector2(8, 8) * s, ic + Vector2(-8, -8) * s, ic_col, 2.5 * s)
			draw_circle(ic, 3.0 * s, ic_col)
		elif ni == 1:  # RELICS — glowing gem
			draw_colored_polygon(PackedVector2Array([ic + Vector2(0, -11) * s, ic + Vector2(9, -2) * s, ic + Vector2(6, 9) * s, ic + Vector2(-6, 9) * s, ic + Vector2(-9, -2) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.7))
			draw_colored_polygon(PackedVector2Array([ic + Vector2(0, -8) * s, ic + Vector2(4, -1) * s, ic + Vector2(0, 5) * s, ic + Vector2(-4, -1) * s]), Color(1, 1, 1, 0.15))
		elif ni == 2:  # ADVENTURE — open book with glow
			draw_colored_polygon(PackedVector2Array([ic + Vector2(0, -9) * s, ic + Vector2(-12, -7) * s, ic + Vector2(-12, 9) * s, ic + Vector2(0, 7) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.6))
			draw_colored_polygon(PackedVector2Array([ic + Vector2(0, -9) * s, ic + Vector2(12, -7) * s, ic + Vector2(12, 9) * s, ic + Vector2(0, 7) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.4))
			draw_line(ic + Vector2(0, -9) * s, ic + Vector2(0, 7) * s, ic_col, 2.0)
			for li in range(3):
				var ly = (-4.0 + float(li) * 4.0) * s
				draw_line(ic + Vector2(-9, ly) * s, ic + Vector2(-3, ly) * s, Color(0, 0, 0, 0.25), 1.0)
				draw_line(ic + Vector2(3, ly) * s, ic + Vector2(9, ly) * s, Color(0, 0, 0, 0.25), 1.0)
		elif ni == 3:  # LORE — scroll with seal
			draw_rect(Rect2(ic.x - 7 * s, ic.y - 9 * s, 14 * s, 18 * s), Color(ic_col.r, ic_col.g, ic_col.b, 0.5))
			draw_arc(ic + Vector2(0, -9) * s, 7 * s, PI, TAU, 12, ic_col, 2.0)
			draw_arc(ic + Vector2(0, 9) * s, 7 * s, 0, PI, 12, ic_col, 2.0)
			draw_circle(ic + Vector2(0, 3) * s, 3 * s, Color(0.8, 0.2, 0.2, 0.6))
		elif ni == 4:  # SHOP — potion bottle
			draw_colored_polygon(PackedVector2Array([ic + Vector2(-8, 0) * s, ic + Vector2(8, 0) * s, ic + Vector2(6, 10) * s, ic + Vector2(-6, 10) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.6))
			draw_rect(Rect2(ic.x - 3 * s, ic.y - 10 * s, 6 * s, 10 * s), Color(ic_col.r, ic_col.g, ic_col.b, 0.5))
			draw_line(ic + Vector2(-5, -10) * s, ic + Vector2(5, -10) * s, ic_col, 2.0)
			draw_circle(ic + Vector2(0, 5) * s, 3 * s, Color(1, 1, 1, 0.12))
		elif ni == 5:  # TROPHIES — trophy cup
			draw_colored_polygon(PackedVector2Array([ic + Vector2(-7, -9) * s, ic + Vector2(7, -9) * s, ic + Vector2(5, 0) * s, ic + Vector2(-5, 0) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.7))
			draw_line(ic + Vector2(0, 0) * s, ic + Vector2(0, 6) * s, ic_col, 2.5)
			draw_line(ic + Vector2(-6, 6) * s, ic + Vector2(6, 6) * s, ic_col, 2.5)
			draw_arc(ic + Vector2(-7, -4) * s, 4 * s, PI * 0.5, PI * 1.5, 8, ic_col, 2.0)
			draw_arc(ic + Vector2(7, -4) * s, 4 * s, -PI * 0.5, PI * 0.5, 8, ic_col, 2.0)
			# Star on trophy
			if is_act:
				draw_circle(ic + Vector2(0, -5) * s, 2.5, Color(1, 1, 1, 0.3))
		# Tab label
		var lbl_y = nav_draw_y + 72.0
		var lbl_col = Color(tc.r, tc.g, tc.b, 0.95) if is_act else Color(0.50, 0.45, 0.38, 0.6)
		var lbl_sz = 14 if is_act else 12
		_udraw(font, Vector2(tx + tab_w * 0.5, lbl_y), nav_tab_labels[ni], HORIZONTAL_ALIGNMENT_CENTER, int(tab_w - 10), lbl_sz, lbl_col)
		# Divider line between tabs
		if ni < 5:
			var dx_div = tx + tab_w
			draw_line(Vector2(dx_div, nav_draw_y + 12), Vector2(dx_div, nav_draw_y + 88), Color(0.3, 0.25, 0.15, 0.08), 1.0)

	if menu_current_view == "chapters":
		_draw_story_map()
		_draw_chapters_badges()
		_draw_diff_popup()
		_draw_chapters_overlay()
	elif menu_current_view == "survivors":
		if survivor_detail_open:
			_draw_survivor_detail()
		else:
			_draw_survivor_grid()
	elif menu_current_view == "relics":
		_draw_relics_tab()
	elif menu_current_view == "emporium":
		if emporium_sub_category == 6:
			_draw_trophy_store()
		elif emporium_sub_category == 8:
			_draw_binding_shop()
		elif emporium_sub_category == 9:
			_draw_salvage_panel()
		elif emporium_sub_category == 10:
			_draw_chest_crafting()
		elif emporium_sub_category == 11:
			_draw_instrument_shop()
		else:
			_draw_emporium()
	elif menu_current_view == "achievements":
		_draw_achievements_tab()
	else:
		_draw_closed_book()

func _draw_relics_tab() -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var font = game_font
	var content_top = panel_y + 44.0
	var content_bottom = panel_y + panel_h - 28.0

	# Navy background gradient
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), col)

	# Gold border
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))

	# Title
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "RELIC COMPENDIUM", HORIZONTAL_ALIGNMENT_CENTER, -1, 16, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.9))
	draw_rect(Rect2(panel_x + panel_w * 0.5 - 100, panel_y + 34, 200, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.4))

	# Enhancement #26: Character filter indicators — show colored dots for characters that have relics
	var char_filter_colors = {
		"robin_hood": Color(0.3, 0.65, 0.2), "alice": Color(0.4, 0.6, 0.9),
		"wicked_witch": Color(0.3, 0.7, 0.2), "peter_pan": Color(0.2, 0.7, 0.3),
		"phantom": Color(0.7, 0.5, 0.2), "scrooge": Color(0.5, 0.45, 0.35),
		"sherlock": Color(0.6, 0.5, 0.3), "tarzan": Color(0.5, 0.6, 0.25),
		"dracula": Color(0.7, 0.15, 0.2), "merlin": Color(0.4, 0.3, 0.7),
		"frankenstein": Color(0.3, 0.55, 0.35)
	}
	var char_has_owned = {}
	for b in TOME_BINDINGS:
		var ch = b.get("character", "")
		if ch != "" and owned_bindings.get(b["id"], 0) > 0:
			char_has_owned[ch] = true
	var dot_x = panel_x + panel_w * 0.5 + 120.0
	var dot_y = panel_y + 28.0
	for ch in char_filter_colors:
		var fc = char_filter_colors[ch]
		var has_any = char_has_owned.has(ch)
		var dot_alpha = 0.8 if has_any else 0.15
		draw_circle(Vector2(dot_x, dot_y - 4), 3.0, Color(fc.r, fc.g, fc.b, dot_alpha))
		if has_any:
			draw_arc(Vector2(dot_x, dot_y - 4), 4.0, 0, TAU, 12, Color(fc.r, fc.g, fc.b, 0.3), 1.0)
		dot_x += 10.0

	var rarity_order = ["tattered", "bound", "gilded", "mythic", "forbidden"]
	var rarity_names = {"tattered": "TATTERED (Grey)", "bound": "BOUND (Green)", "gilded": "GILDED (Blue)", "mythic": "MYTHIC (Purple)", "forbidden": "FORBIDDEN (Orange)"}
	var rarity_colors = {"tattered": Color(0.6, 0.6, 0.65), "bound": Color(0.3, 0.75, 0.3), "gilded": Color(0.3, 0.5, 0.9), "mythic": Color(0.7, 0.35, 0.9), "forbidden": Color(1.0, 0.6, 0.1)}
	var rarity_bg = {"tattered": Color(0.08, 0.08, 0.10), "bound": Color(0.06, 0.12, 0.06), "gilded": Color(0.06, 0.08, 0.20), "mythic": Color(0.10, 0.06, 0.22), "forbidden": Color(0.14, 0.10, 0.06)}

	var card_w = 260.0
	var card_h = 50.0
	var card_gap_x = 10.0
	var card_gap_y = 6.0
	var grid_left = panel_x + 18.0
	var section_y = content_top - relic_scroll_offset
	var total_content_h = 0.0

	for ri in range(rarity_order.size()):
		var rarity = rarity_order[ri]
		var rc = rarity_colors[rarity]
		var sec_y = section_y

		# Collect trinkets of this rarity
		var trinkets: Array = []
		for b in TOME_BINDINGS:
			if b["rarity"] == rarity:
				trinkets.append(b)

		# Tier header (only draw if visible)
		if sec_y + 20 > content_top and sec_y < content_bottom:
			draw_rect(Rect2(grid_left, sec_y, panel_w - 36, 20), Color(rc.r, rc.g, rc.b, 0.12))
			draw_rect(Rect2(grid_left, sec_y, panel_w - 36, 1), Color(rc.r, rc.g, rc.b, 0.4))
			_udraw(font, Vector2(grid_left + 10, sec_y + 14), rarity_names[rarity], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(rc.r, rc.g, rc.b, 0.9))
			var gem_x = grid_left + panel_w - 56
			var gem_y = sec_y + 10
			draw_colored_polygon(PackedVector2Array([Vector2(gem_x, gem_y - 5), Vector2(gem_x + 5, gem_y), Vector2(gem_x, gem_y + 5), Vector2(gem_x - 5, gem_y)]), Color(rc.r, rc.g, rc.b, 0.7))
			# Count indicator
			var owned_count = 0
			for bb in trinkets:
				if owned_bindings.get(bb["id"], 0) > 0:
					owned_count += 1
			_udraw(font, Vector2(gem_x - 20, sec_y + 14), "%d/%d" % [owned_count, trinkets.size()], HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(rc.r, rc.g, rc.b, 0.6))

			# Enhancement #25: Set bonus indicators — show "SET" badge if player owns 3+ relics of a character in this rarity
			var char_rarity_counts = {}
			for bb in trinkets:
				if owned_bindings.get(bb["id"], 0) > 0:
					var ch = bb.get("character", "")
					if ch != "":
						char_rarity_counts[ch] = char_rarity_counts.get(ch, 0) + 1
			var set_badge_x = grid_left + 220.0
			for ch in char_rarity_counts:
				if char_rarity_counts[ch] >= 3:
					var set_col = char_filter_colors.get(ch, Color(0.8, 0.7, 0.2))
					draw_rect(Rect2(set_badge_x, sec_y + 3, 32, 14), Color(set_col.r, set_col.g, set_col.b, 0.25))
					draw_rect(Rect2(set_badge_x, sec_y + 3, 32, 1), Color(set_col.r, set_col.g, set_col.b, 0.5))
					draw_rect(Rect2(set_badge_x, sec_y + 16, 32, 1), Color(set_col.r, set_col.g, set_col.b, 0.5))
					_udraw(font, Vector2(set_badge_x + 16, sec_y + 14), "SET", HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(set_col.r, set_col.g, set_col.b, 0.9))
					set_badge_x += 38.0

			# Enhancement #29: Empty slot indicators — show how many relics remain undiscovered
			var remaining = trinkets.size() - owned_count
			if remaining > 0:
				_udraw(font, Vector2(grid_left + panel_w - 80, sec_y + 14), "%d left" % remaining, HORIZONTAL_ALIGNMENT_RIGHT, -1, 9, Color(0.5, 0.5, 0.55, 0.5))

		var row_y = sec_y + 24.0
		for ti in range(trinkets.size()):
			var b = trinkets[ti]
			var col_i = ti % 4
			var row_i = ti / 4
			var cx = grid_left + float(col_i) * (card_w + card_gap_x)
			var cy = row_y + float(row_i) * (card_h + card_gap_y)
			# Clip: skip items fully outside visible area
			if cy + card_h < content_top or cy > content_bottom:
				continue
			var count = owned_bindings.get(b["id"], 0)
			var is_owned = count > 0

			var bg_col = rarity_bg[rarity] if is_owned else Color(0.05, 0.05, 0.10)
			draw_rect(Rect2(cx, cy, card_w, card_h), bg_col)

			# Enhancement #30: Owned relic subtle animated glow
			if is_owned:
				var glow_pulse = 0.03 + sin(_time * 2.0 + float(ti) * 0.8) * 0.02
				draw_rect(Rect2(cx, cy, card_w, card_h), Color(rc.r, rc.g, rc.b, glow_pulse))

			var b_alpha = 0.5 if is_owned else 0.15
			draw_rect(Rect2(cx, cy, card_w, 1), Color(rc.r, rc.g, rc.b, b_alpha))
			draw_rect(Rect2(cx, cy + card_h - 1, card_w, 1), Color(rc.r, rc.g, rc.b, b_alpha))
			draw_rect(Rect2(cx, cy, 1, card_h), Color(rc.r, rc.g, rc.b, b_alpha))
			draw_rect(Rect2(cx + card_w - 1, cy, 1, card_h), Color(rc.r, rc.g, rc.b, b_alpha))

			# Enhancement #24: Equipped relic highlighted with golden glow
			var is_equipped = false
			for t_key in equipped_bindings:
				if b["id"] in equipped_bindings[t_key]:
					is_equipped = true
					break
			if is_equipped:
				var eq_pulse = 0.5 + sin(_time * 3.0) * 0.2
				draw_rect(Rect2(cx - 1, cy - 1, card_w + 2, card_h + 2), Color(1.0, 0.85, 0.2, eq_pulse * 0.5))
				_udraw(font, Vector2(cx + card_w - 55, cy + card_h - 10), "EQUIPPED", HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(1.0, 0.85, 0.2, 0.8))

			# Rarity stripe
			draw_rect(Rect2(cx, cy, 3, card_h), Color(rc.r, rc.g, rc.b, 0.7 if is_owned else 0.2))

			# Shimmer effect for owned gilded+ gear
			if is_owned and rarity in ["gilded", "mythic", "forbidden"]:
				var shimmer_speed = 80.0 if rarity == "gilded" else 100.0 if rarity == "mythic" else 120.0
				var shimmer_x = fmod(_time * shimmer_speed + float(ti) * 30.0, card_w + 40.0) - 20.0
				var shimmer_col = RARITY_COLORS.get(rarity, Color(1.0, 0.9, 0.5))
				for si in range(3 if rarity == "gilded" else 5):
					var sx = cx + shimmer_x + float(si) * 2.0
					if sx > cx and sx < cx + card_w:
						draw_line(Vector2(sx, cy), Vector2(sx - 10, cy + card_h), Color(shimmer_col.r, shimmer_col.g, shimmer_col.b, 0.10 - float(si) * 0.015), 1.5)

			# Icon area
			var icon_cx = cx + 24.0
			var icon_cy = cy + card_h * 0.5
			draw_circle(Vector2(icon_cx, icon_cy), 14, Color(rc.r, rc.g, rc.b, 0.2 if is_owned else 0.08))
			if not is_owned:
				draw_rect(Rect2(icon_cx - 6, icon_cy - 2, 12, 10), Color(0.3, 0.3, 0.35, 0.4))
				draw_arc(Vector2(icon_cx, icon_cy - 2), 5, PI, TAU, 8, Color(0.3, 0.3, 0.35, 0.4), 1.5)

			# Text
			var name_alpha = 0.9 if is_owned else 0.35
			_udraw(font, Vector2(cx + 44, cy + 18), b["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 90), 15, Color(rc.r, rc.g, rc.b, name_alpha))
			var desc_alpha = 0.65 if is_owned else 0.25
			_udraw(font, Vector2(cx + 44, cy + 36), b["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 50), 13, Color(menu_text.r, menu_text.g, menu_text.b, desc_alpha))

			# Count badge
			if is_owned:
				_udraw(font, Vector2(cx + card_w - 30, cy + 18), "x%d" % count, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.3, 0.8, 0.3))

			# Power level display + per_level scaling + special effect
			if is_owned:
				var val = b.get("value", 0.0)
				if val > 0:
					var pct_str = "+%d%%" % int(val * 100)
					_udraw(font, Vector2(cx + card_w - 14, cy + 34), pct_str, HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(rc.r, rc.g, rc.b, 0.8))
				if b.has("per_level"):
					var pl_str = "+%.1f%%/LV" % (b["per_level"] * 100.0)
					_udraw(font, Vector2(cx + card_w - 14, cy + 44), pl_str, HORIZONTAL_ALIGNMENT_RIGHT, -1, 8, Color(0.9, 0.75, 0.3, 0.6))
				if b.has("special"):
					var spec_name = b["special"].replace("_", " ").substr(0, 18)
					_udraw(font, Vector2(cx + 44, cy + 46), spec_name, HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 100), 8, Color(rc.r, rc.g, rc.b, 0.5))

			# Enhancement #28: "Equip" indicator on hover
			var is_card_hovered = false
			if relics_tab_hover_tier == ri:
				var hover_ti = relics_tab_hover_row * 4 + relics_tab_hover_col
				if hover_ti == ti:
					is_card_hovered = true
			if is_card_hovered and is_owned and not is_equipped:
				var hover_pulse = 0.6 + sin(_time * 4.0) * 0.15
				draw_rect(Rect2(cx, cy, card_w, card_h), Color(rc.r, rc.g, rc.b, 0.06))
				_udraw(font, Vector2(cx + card_w * 0.5, cy + card_h - 6), "Tap to equip", HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(menu_gold.r, menu_gold.g, menu_gold.b, hover_pulse * 0.7))
			elif is_card_hovered and not is_owned:
				draw_rect(Rect2(cx, cy, card_w, card_h), Color(0.3, 0.3, 0.4, 0.04))

		var rows_needed = (trinkets.size() + 3) / 4
		var section_height = 24.0 + float(rows_needed) * (card_h + card_gap_y) + 12.0
		section_y += section_height
		total_content_h += section_height

	# Clamp scroll to valid range
	var max_scroll = maxf(0.0, total_content_h - (content_bottom - content_top))
	relic_scroll_offset = clampf(relic_scroll_offset, 0.0, max_scroll)

	# Scroll indicator bar (right edge)
	if max_scroll > 0:
		var bar_x = panel_x + panel_w - 10
		var bar_h = content_bottom - content_top
		var thumb_h = maxf(30.0, bar_h * bar_h / (bar_h + max_scroll))
		var thumb_y = content_top + (relic_scroll_offset / max_scroll) * (bar_h - thumb_h)
		draw_rect(Rect2(bar_x, content_top, 4, bar_h), Color(0.2, 0.2, 0.25, 0.3))
		draw_rect(Rect2(bar_x, thumb_y, 4, thumb_h), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.5))

	# Footer (drawn over content, always visible)
	draw_rect(Rect2(panel_x + 2, panel_y + panel_h - 28, panel_w - 4, 26), Color(0.03, 0.03, 0.06, 0.95))
	var footer_y = panel_y + panel_h - 10
	var total_owned = 0
	for key in owned_bindings:
		total_owned += owned_bindings[key]
	var unique_owned = 0
	for key in owned_bindings:
		if owned_bindings[key] > 0:
			unique_owned += 1
	_udraw(font, Vector2(grid_left + 10, footer_y), "Owned: %d unique (%d total)" % [unique_owned, total_owned], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6))
	_udraw(font, Vector2(grid_left + 300, footer_y), "Shards: %d" % player_relic_shards, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6))
	_udraw(font, Vector2(grid_left + 450, footer_y), "Quills: %d" % player_quills, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6))

func _draw_emporium() -> void:
	if emporium_sub_open:
		_draw_emporium_sub_panel()
		return
	# === Navy background (same dimensions as survivor grid) ===
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0

	# Navy gradient background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		var grain = sin(float(i) * 2.3) * 0.005
		col.r += grain
		col.b += grain * 1.5
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 55.0 + 1), col)

	# Ornate border — gold double frame
	var emp_outer = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.35)
	var emp_gold = Color(0.54, 0.45, 0.20, 0.2)
	# Outer gold border (3px)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 3), emp_outer)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 3, panel_w, 3), emp_outer)
	draw_rect(Rect2(panel_x, panel_y, 3, panel_h), emp_outer)
	draw_rect(Rect2(panel_x + panel_w - 3, panel_y, 3, panel_h), emp_outer)
	# Inner gold border (1px)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, panel_w - 12, 1), emp_gold)
	draw_rect(Rect2(panel_x + 6, panel_y + panel_h - 7, panel_w - 12, 1), emp_gold)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, 1, panel_h - 12), emp_gold)
	draw_rect(Rect2(panel_x + panel_w - 7, panel_y + 6, 1, panel_h - 12), emp_gold)

	# Corner filigree ornaments (gold only)
	for corner in [Vector2(panel_x + 14, panel_y + 14), Vector2(panel_x + panel_w - 14, panel_y + 14), Vector2(panel_x + 14, panel_y + panel_h - 14), Vector2(panel_x + panel_w - 14, panel_y + panel_h - 14)]:
		draw_circle(corner, 7, Color(0.54, 0.45, 0.20, 0.2))
		draw_circle(corner, 5, Color(0.54, 0.45, 0.20, 0.3))
		draw_circle(corner, 3, Color(0.54, 0.45, 0.20, 0.25))
		draw_arc(corner, 8, 0, TAU, 24, Color(0.54, 0.45, 0.20, 0.15), 1.0)

	# === Title: THE EMPORIUM ===
	var font = game_font
	var title_text = "THE EMPORIUM"
	var title_size = 28
	var title_width = font.get_string_size(title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size).x
	var title_x = panel_x + (panel_w - title_width) * 0.5
	var title_y = panel_y + 38.0
	# Title glow
	_udraw(font, Vector2(title_x, title_y), title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.85, 0.65, 0.1, 0.3))
	_udraw(font, Vector2(title_x - 1, title_y - 1), title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.95, 0.75, 0.2, 0.9))
	# Decorative stars flanking title
	var star_lx = title_x - 25.0
	var star_rx = title_x + title_width + 10.0
	var star_y = title_y - 10.0
	for dx in [-2.0, 0.0, 2.0]:
		draw_circle(Vector2(star_lx + dx, star_y + dx * 0.5), 2.0, Color(0.85, 0.65, 0.1, 0.4))
		draw_circle(Vector2(star_rx + dx, star_y + dx * 0.5), 2.0, Color(0.85, 0.65, 0.1, 0.4))
	# Underline — gold double line
	var line_cx = panel_x + panel_w * 0.5
	draw_line(Vector2(line_cx - 180, title_y + 8), Vector2(line_cx + 180, title_y + 8), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.5)
	draw_line(Vector2(line_cx - 140, title_y + 12), Vector2(line_cx + 140, title_y + 12), Color(0.54, 0.45, 0.20, 0.15), 1.0)

	# === Animated spinning coin near title (Enhancement #33) ===
	var coin_x = title_x - 50.0
	var coin_y = title_y - 10.0
	var coin_pulse = 0.7 + sin(_time * 3.0) * 0.3
	var coin_radius = 7.0 + sin(_time * 2.0) * 1.5
	draw_circle(Vector2(coin_x, coin_y), coin_radius + 2, Color(0.85, 0.65, 0.1, 0.15 * coin_pulse))
	draw_circle(Vector2(coin_x, coin_y), coin_radius, Color(0.9, 0.7, 0.15, 0.8 * coin_pulse))
	draw_arc(Vector2(coin_x, coin_y), coin_radius - 2, -PI * 0.8, -PI * 0.2, 8, Color(0.95, 0.85, 0.3, 0.5), 1.5)
	# Mirror coin on right side
	var coin_rx = title_x + title_width + 35.0
	draw_circle(Vector2(coin_rx, coin_y), coin_radius + 2, Color(0.85, 0.65, 0.1, 0.15 * coin_pulse))
	draw_circle(Vector2(coin_rx, coin_y), coin_radius, Color(0.9, 0.7, 0.15, 0.8 * coin_pulse))
	draw_arc(Vector2(coin_rx, coin_y), coin_radius - 2, -PI * 0.8, -PI * 0.2, 8, Color(0.95, 0.85, 0.3, 0.5), 1.5)

	# === 3x2 Grid of Emporium Tiles ===
	var tile_w = 340.0
	var tile_h = 220.0
	var gap_x = 30.0
	var gap_y = 24.0
	var grid_w = 3.0 * tile_w + 2.0 * gap_x
	var grid_start_x = panel_x + (panel_w - grid_w) * 0.5
	var grid_start_y = panel_y + 58.0

	for i in range(emporium_categories.size()):
		var cat = emporium_categories[i]
		var col_idx = i % 3
		var row = i / 3
		var tx = grid_start_x + float(col_idx) * (tile_w + gap_x)
		var ty = grid_start_y + float(row) * (tile_h + gap_y)
		var is_hovered = (i == emporium_hover_index)

		# Tile shadow (6px offset)
		draw_rect(Rect2(tx + 6, ty + 6, tile_w, tile_h), Color(0.0, 0.0, 0.0, 0.35))

		# Tile background (navy card)
		var bg = menu_bg_card
		if is_hovered:
			bg = menu_bg_card_hover
		draw_rect(Rect2(tx, ty, tile_w, tile_h), bg)

		# Warm amber accent gradient at top
		for g in range(6):
			var gt = float(g) / 5.0
			draw_rect(Rect2(tx, ty + float(g), tile_w, 1), Color(0.54, 0.45, 0.20, 0.12 * (1.0 - gt)))

		# Tile border
		var tile_border = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.3)
		if is_hovered:
			tile_border = Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7)
		draw_rect(Rect2(tx, ty, tile_w, 2), tile_border)
		draw_rect(Rect2(tx, ty + tile_h - 2, tile_w, 2), tile_border)
		draw_rect(Rect2(tx, ty, 2, tile_h), tile_border)
		draw_rect(Rect2(tx + tile_w - 2, ty, 2, tile_h), tile_border)

		# Hover glow (gold tint)
		if is_hovered:
			var glow_a = 0.06 + sin(_time * 3.5) * 0.03
			draw_rect(Rect2(tx - 2, ty - 2, tile_w + 4, tile_h + 4), Color(menu_gold.r, menu_gold.g, menu_gold.b, glow_a))

		# === FEATURED item spotlight (Enhancement #31) — first tile gets golden glow ===
		if i == 0:
			var feat_pulse = 0.5 + sin(_time * 2.0) * 0.3
			# Golden spotlight glow behind the featured card
			draw_rect(Rect2(tx - 4, ty - 4, tile_w + 8, tile_h + 8), Color(0.85, 0.65, 0.1, 0.04 * feat_pulse))
			draw_rect(Rect2(tx - 2, ty - 2, tile_w + 4, tile_h + 4), Color(0.95, 0.75, 0.2, 0.06 * feat_pulse))
			# "FEATURED" label at top-right
			var feat_text = "FEATURED"
			var feat_fs = 9
			var feat_tw = font.get_string_size(feat_text, HORIZONTAL_ALIGNMENT_LEFT, -1, feat_fs).x + 10.0
			var feat_x = tx + tile_w - feat_tw - 8.0
			var feat_y_top = ty + 8.0
			draw_rect(Rect2(feat_x, feat_y_top, feat_tw, 16), Color(0.85, 0.65, 0.1, 0.85))
			_udraw(font, Vector2(feat_x + 5, feat_y_top + 12), feat_text, HORIZONTAL_ALIGNMENT_LEFT, -1, feat_fs, Color(0.05, 0.03, 0.0, 0.95))

		# === "BEST VALUE" badge (Enhancement #32) on premium items (Survivor Packs, Relic Chests) ===
		if i == 4 or i == 3:  # Survivor Packs and Relic Chests
			var bv_text = "BEST VALUE"
			var bv_fs = 8
			var bv_tw = font.get_string_size(bv_text, HORIZONTAL_ALIGNMENT_LEFT, -1, bv_fs).x + 8.0
			var bv_x = tx + tile_w - bv_tw - 6.0
			var bv_y = ty + tile_h - 24.0
			# Rotated appearance via small slanted rectangle
			draw_rect(Rect2(bv_x, bv_y, bv_tw, 14), Color(0.7, 0.15, 0.1, 0.85))
			draw_rect(Rect2(bv_x, bv_y, bv_tw, 1), Color(1, 1, 1, 0.3))
			_udraw(font, Vector2(bv_x + 4, bv_y + 11), bv_text, HORIZONTAL_ALIGNMENT_LEFT, -1, bv_fs, Color(1, 1, 1, 0.95))

		# Corner flourishes (gold only)
		var fl = Color(0.54, 0.45, 0.20, 0.15)
		draw_line(Vector2(tx + 6, ty + 6), Vector2(tx + 26, ty + 6), fl, 1.0)
		draw_line(Vector2(tx + 6, ty + 6), Vector2(tx + 6, ty + 26), fl, 1.0)
		draw_line(Vector2(tx + tile_w - 6, ty + 6), Vector2(tx + tile_w - 26, ty + 6), fl, 1.0)
		draw_line(Vector2(tx + tile_w - 6, ty + 6), Vector2(tx + tile_w - 6, ty + 26), fl, 1.0)
		draw_line(Vector2(tx + 6, ty + tile_h - 6), Vector2(tx + 26, ty + tile_h - 6), fl, 1.0)
		draw_line(Vector2(tx + 6, ty + tile_h - 6), Vector2(tx + 6, ty + tile_h - 26), fl, 1.0)
		draw_line(Vector2(tx + tile_w - 6, ty + tile_h - 6), Vector2(tx + tile_w - 26, ty + tile_h - 6), fl, 1.0)
		draw_line(Vector2(tx + tile_w - 6, ty + tile_h - 6), Vector2(tx + tile_w - 6, ty + tile_h - 26), fl, 1.0)

		# === Title text (top) with category icon (Enhancement #35) ===
		var name_size = 16
		var name_text = cat["name"]
		var name_w = font.get_string_size(name_text, HORIZONTAL_ALIGNMENT_LEFT, -1, name_size).x
		var icon_offset = 14.0  # Space for category icon
		var name_x = tx + (tile_w - name_w - icon_offset) * 0.5 + icon_offset
		var name_y_pos = ty + 28.0
		_udraw(font, Vector2(name_x, name_y_pos), name_text, HORIZONTAL_ALIGNMENT_LEFT, -1, name_size, Color(0.9, 0.72, 0.2, 0.95))
		# Small procedural icon beside category name (Enhancement #35)
		var ic_x = name_x - 14.0
		var ic_y = name_y_pos - 6.0
		var ic_col = Color(0.9, 0.72, 0.2, 0.7)
		if cat["icon"] == "emp_gold":  # Gold coin
			draw_circle(Vector2(ic_x, ic_y), 5, ic_col)
			draw_arc(Vector2(ic_x, ic_y), 4, 0, TAU, 8, Color(0.95, 0.8, 0.3, 0.5), 1.0)
		elif cat["icon"] == "emp_shards":  # Crystal shard
			draw_colored_polygon(PackedVector2Array([Vector2(ic_x, ic_y - 6), Vector2(ic_x + 3, ic_y + 4), Vector2(ic_x - 3, ic_y + 4)]), Color(0.3, 0.7, 0.85, 0.7))
		elif cat["icon"] == "emp_chests":  # Small chest
			draw_rect(Rect2(ic_x - 4, ic_y - 2, 8, 6), Color(0.5, 0.3, 0.12, 0.7))
			draw_rect(Rect2(ic_x - 4, ic_y - 2, 8, 1), ic_col)
		elif cat["icon"] == "emp_stars":  # Star
			for si_icon in range(5):
				var sa = -PI / 2.0 + float(si_icon) * TAU / 5.0
				var sp = Vector2(ic_x, ic_y) + Vector2.from_angle(sa) * 5.0
				draw_line(Vector2(ic_x, ic_y), sp, ic_col, 1.5)
		elif cat["icon"] == "emp_quills":  # Feather
			draw_line(Vector2(ic_x - 3, ic_y + 4), Vector2(ic_x + 3, ic_y - 5), Color(0.55, 0.2, 0.7, 0.7), 2.0)
		elif cat["icon"] == "emp_packs":  # Book
			draw_rect(Rect2(ic_x - 3, ic_y - 4, 6, 8), Color(0.55, 0.35, 0.15, 0.7))
			draw_rect(Rect2(ic_x - 3, ic_y - 4, 6, 1), ic_col)
		elif cat["icon"] == "emp_trophy":  # Trophy
			draw_colored_polygon(PackedVector2Array([Vector2(ic_x - 4, ic_y - 4), Vector2(ic_x + 4, ic_y - 4), Vector2(ic_x + 2, ic_y + 1), Vector2(ic_x - 2, ic_y + 1)]), ic_col)
			draw_line(Vector2(ic_x, ic_y + 1), Vector2(ic_x, ic_y + 4), ic_col, 1.5)
		elif cat["icon"] == "emp_powers":  # Lightning bolt
			draw_line(Vector2(ic_x + 1, ic_y - 5), Vector2(ic_x - 2, ic_y), Color(0.3, 0.7, 0.9, 0.7), 2.0)
			draw_line(Vector2(ic_x - 2, ic_y), Vector2(ic_x + 1, ic_y + 4), Color(0.3, 0.7, 0.9, 0.7), 2.0)
		else:  # Default: small diamond
			draw_colored_polygon(PackedVector2Array([Vector2(ic_x, ic_y - 4), Vector2(ic_x + 3, ic_y), Vector2(ic_x, ic_y + 4), Vector2(ic_x - 3, ic_y)]), ic_col)

		# === Procedural icon (center) ===
		var icon_cx = tx + tile_w * 0.5
		var icon_cy = ty + tile_h * 0.48
		_draw_emporium_icon(Vector2(icon_cx, icon_cy), cat["icon"], 70.0)

		# === Description text (bottom) ===
		var desc_size = 12
		var desc_text = cat["desc"]
		var desc_w = font.get_string_size(desc_text, HORIZONTAL_ALIGNMENT_LEFT, -1, desc_size).x
		var desc_x = tx + (tile_w - desc_w) * 0.5
		var desc_y = ty + tile_h - 18.0
		_udraw(font, Vector2(desc_x, desc_y), desc_text, HORIZONTAL_ALIGNMENT_LEFT, -1, desc_size, Color(0.65, 0.55, 0.4, 0.8))

		# === Badge ribbon (top-left) ===
		if cat["badge"] != "":
			var badge_text = cat["badge"]
			var badge_font_size = 10
			var badge_w = font.get_string_size(badge_text, HORIZONTAL_ALIGNMENT_LEFT, -1, badge_font_size).x + 16.0
			var badge_h = 20.0
			var badge_x = tx + 8.0
			var badge_y_top = ty + 8.0
			# Badge color: red for SALE!, green for AVAILABLE!
			var badge_col = Color(0.7, 0.15, 0.1, 0.9)
			if badge_text == "AVAILABLE!":
				badge_col = Color(0.15, 0.55, 0.2, 0.9)
			# Ribbon background
			draw_rect(Rect2(badge_x, badge_y_top, badge_w, badge_h), badge_col)
			# Ribbon notch (small triangle cut on right side)
			draw_colored_polygon(PackedVector2Array([
				Vector2(badge_x + badge_w, badge_y_top),
				Vector2(badge_x + badge_w + 6, badge_y_top + badge_h * 0.5),
				Vector2(badge_x + badge_w, badge_y_top + badge_h),
			]), badge_col)
			# Badge border highlight
			draw_rect(Rect2(badge_x, badge_y_top, badge_w, 1), Color(1, 1, 1, 0.2))
			# Badge text
			_udraw(font, Vector2(badge_x + 8.0, badge_y_top + 15.0), badge_text, HORIZONTAL_ALIGNMENT_LEFT, -1, badge_font_size, Color(1, 1, 1, 0.95))

	# === "RESTORE PURCHASES" text (bottom-right corner) ===
	var restore_size = 11
	var restore_text = "RESTORE PURCHASES"
	var restore_w = font.get_string_size(restore_text, HORIZONTAL_ALIGNMENT_LEFT, -1, restore_size).x
	var restore_x = panel_x + panel_w - restore_w - 20.0
	var restore_y = panel_y + panel_h - 12.0
	_udraw(font, Vector2(restore_x, restore_y), restore_text, HORIZONTAL_ALIGNMENT_LEFT, -1, restore_size, Color(0.55, 0.42, 0.25, 0.5))

func _draw_emporium_icon(center: Vector2, icon_key: String, sz: float) -> void:
	var cx = center.x
	var cy = center.y
	var s = sz * 0.5
	match icon_key:
		"emp_gold":
			# Stack of 3 gold coins
			for ci in range(3):
				var off_y = float(ci) * -10.0
				var coin_col = Color(0.85, 0.65, 0.1, 0.85 - float(ci) * 0.08)
				var coin_hi = Color(0.95, 0.78, 0.2, 0.7 - float(ci) * 0.08)
				# Coin ellipse (top face)
				draw_circle(Vector2(cx, cy + off_y), s * 0.42, coin_col)
				# Coin rim (side edge)
				draw_rect(Rect2(cx - s * 0.42, cy + off_y, s * 0.84, s * 0.12), Color(0.7, 0.5, 0.08, 0.7))
				# Highlight arc
				draw_arc(Vector2(cx, cy + off_y), s * 0.3, -PI * 0.8, -PI * 0.2, 8, coin_hi, 2.0)
				# Inner circle detail
				draw_arc(Vector2(cx, cy + off_y), s * 0.18, 0, TAU, 10, Color(0.75, 0.55, 0.1, 0.4), 1.0)
			# Top coin $ symbol
			draw_line(Vector2(cx - s * 0.08, cy - 24), Vector2(cx - s * 0.08, cy - 12), Color(0.95, 0.8, 0.3, 0.5), 2.0)
			draw_line(Vector2(cx + s * 0.08, cy - 24), Vector2(cx + s * 0.08, cy - 12), Color(0.95, 0.8, 0.3, 0.5), 2.0)
		"emp_quills":
			# Purple feather quill
			var quill_col = Color(0.55, 0.2, 0.7, 0.85)
			var quill_hi = Color(0.7, 0.35, 0.85, 0.6)
			# Feather body (main vane) - slightly curved
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.05, cy + s * 0.6),
				Vector2(cx + s * 0.35, cy - s * 0.5),
				Vector2(cx + s * 0.15, cy - s * 0.65),
				Vector2(cx - s * 0.25, cy + s * 0.4),
			]), quill_col)
			# Feather highlight
			draw_line(Vector2(cx - s * 0.12, cy + s * 0.5), Vector2(cx + s * 0.25, cy - s * 0.55), quill_hi, 1.5)
			# Quill shaft
			draw_line(Vector2(cx - s * 0.15, cy + s * 0.55), Vector2(cx - s * 0.45, cy + s * 0.75), Color(0.8, 0.75, 0.65, 0.8), 2.0)
			# Nib tip
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.45, cy + s * 0.75),
				Vector2(cx - s * 0.52, cy + s * 0.85),
				Vector2(cx - s * 0.42, cy + s * 0.82),
			]), Color(0.3, 0.2, 0.1, 0.9))
			# Ink drops
			draw_circle(Vector2(cx - s * 0.55, cy + s * 0.9), 3.0, Color(0.15, 0.05, 0.3, 0.7))
			draw_circle(Vector2(cx - s * 0.42, cy + s * 0.95), 2.0, Color(0.15, 0.05, 0.3, 0.5))
			# Barb lines on feather
			for bi in range(5):
				var bt = float(bi) / 4.0
				var bx = lerp(cx - s * 0.1, cx + s * 0.3, bt)
				var by_pos = lerp(cy + s * 0.45, cy - s * 0.45, bt)
				draw_line(Vector2(bx, by_pos), Vector2(bx - s * 0.15, by_pos + s * 0.08), Color(0.45, 0.15, 0.6, 0.3), 1.0)
		"emp_shards":
			# Glowing crystal fragment cluster
			var shard_col = Color(0.3, 0.7, 0.85, 0.8)
			var shard_glow = Color(0.4, 0.8, 0.95, 0.15)
			# Central glow
			draw_circle(Vector2(cx, cy), s * 0.55, shard_glow)
			draw_circle(Vector2(cx, cy), s * 0.35, Color(0.5, 0.85, 1.0, 0.1))
			# Main shard (tall, center)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.1, cy + s * 0.4),
				Vector2(cx - s * 0.15, cy - s * 0.15),
				Vector2(cx, cy - s * 0.6),
				Vector2(cx + s * 0.12, cy - s * 0.1),
				Vector2(cx + s * 0.08, cy + s * 0.4),
			]), shard_col)
			# Highlight facet
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.12, cy - s * 0.1),
				Vector2(cx, cy - s * 0.55),
				Vector2(cx + s * 0.05, cy - s * 0.05),
			]), Color(0.5, 0.85, 0.95, 0.5))
			# Left shard (smaller, angled)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.35, cy + s * 0.35),
				Vector2(cx - s * 0.4, cy + s * 0.0),
				Vector2(cx - s * 0.2, cy - s * 0.35),
				Vector2(cx - s * 0.12, cy + s * 0.05),
				Vector2(cx - s * 0.18, cy + s * 0.35),
			]), Color(0.25, 0.6, 0.75, 0.7))
			# Right shard (small)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + s * 0.2, cy + s * 0.3),
				Vector2(cx + s * 0.18, cy - s * 0.1),
				Vector2(cx + s * 0.32, cy - s * 0.25),
				Vector2(cx + s * 0.38, cy + s * 0.05),
				Vector2(cx + s * 0.3, cy + s * 0.3),
			]), Color(0.35, 0.65, 0.8, 0.65))
			# Sparkle points
			for sp in [Vector2(cx + s * 0.05, cy - s * 0.5), Vector2(cx - s * 0.3, cy - s * 0.2), Vector2(cx + s * 0.35, cy - s * 0.15)]:
				draw_line(sp + Vector2(-4, 0), sp + Vector2(4, 0), Color(1, 1, 1, 0.5), 1.0)
				draw_line(sp + Vector2(0, -4), sp + Vector2(0, 4), Color(1, 1, 1, 0.5), 1.0)
		"emp_chests":
			# Ornate treasure chest
			var wood_col = Color(0.5, 0.3, 0.12, 0.85)
			var wood_dark = Color(0.35, 0.2, 0.08, 0.85)
			var gold_col = Color(0.85, 0.65, 0.1, 0.9)
			# Chest body (bottom box)
			draw_rect(Rect2(cx - s * 0.5, cy - s * 0.05, s * 1.0, s * 0.55), wood_col)
			# Planks
			draw_line(Vector2(cx - s * 0.5, cy + s * 0.2), Vector2(cx + s * 0.5, cy + s * 0.2), wood_dark, 1.0)
			# Lid (rounded top)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.5, cy - s * 0.05),
				Vector2(cx - s * 0.48, cy - s * 0.3),
				Vector2(cx - s * 0.3, cy - s * 0.48),
				Vector2(cx, cy - s * 0.55),
				Vector2(cx + s * 0.3, cy - s * 0.48),
				Vector2(cx + s * 0.48, cy - s * 0.3),
				Vector2(cx + s * 0.5, cy - s * 0.05),
			]), wood_dark)
			# Gold bands
			draw_line(Vector2(cx - s * 0.5, cy - s * 0.05), Vector2(cx + s * 0.5, cy - s * 0.05), gold_col, 2.5)
			draw_line(Vector2(cx - s * 0.5, cy + s * 0.5), Vector2(cx + s * 0.5, cy + s * 0.5), gold_col, 2.0)
			# Gold latch (center)
			draw_rect(Rect2(cx - s * 0.08, cy - s * 0.12, s * 0.16, s * 0.2), gold_col)
			draw_circle(Vector2(cx, cy + s * 0.02), s * 0.06, Color(0.95, 0.75, 0.2))
			# Glow from opening
			draw_circle(Vector2(cx, cy - s * 0.15), s * 0.3, Color(1.0, 0.85, 0.3, 0.08 + sin(_time * 2.5) * 0.04))
			# Corner reinforcements
			for ccx in [cx - s * 0.48, cx + s * 0.42]:
				draw_rect(Rect2(ccx, cy - s * 0.03, s * 0.06, s * 0.52), gold_col.darkened(0.3))
		"emp_packs":
			# Silhouette of character group / book bundle
			var sil_col = Color(0.55, 0.35, 0.15, 0.7)
			var sil_hi = Color(0.7, 0.5, 0.2, 0.5)
			# Three book shapes (stacked at angle)
			# Book 1 (left, leaning)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.4, cy + s * 0.45),
				Vector2(cx - s * 0.5, cy - s * 0.25),
				Vector2(cx - s * 0.3, cy - s * 0.3),
				Vector2(cx - s * 0.2, cy + s * 0.4),
			]), sil_col)
			draw_line(Vector2(cx - s * 0.48, cy - s * 0.2), Vector2(cx - s * 0.22, cy + s * 0.38), Color(0.85, 0.65, 0.1, 0.3), 1.0)
			# Book 2 (center, upright)
			draw_rect(Rect2(cx - s * 0.15, cy - s * 0.4, s * 0.3, s * 0.85), Color(0.45, 0.25, 0.1, 0.75))
			draw_rect(Rect2(cx - s * 0.12, cy - s * 0.35, s * 0.24, s * 0.08), Color(0.85, 0.65, 0.1, 0.4))
			# Book 3 (right, leaning opposite)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + s * 0.2, cy + s * 0.45),
				Vector2(cx + s * 0.3, cy - s * 0.3),
				Vector2(cx + s * 0.5, cy - s * 0.25),
				Vector2(cx + s * 0.4, cy + s * 0.45),
			]), Color(0.5, 0.28, 0.12, 0.7))
			draw_line(Vector2(cx + s * 0.32, cy - s * 0.25), Vector2(cx + s * 0.42, cy + s * 0.4), Color(0.85, 0.65, 0.1, 0.3), 1.0)
			# Character silhouettes peeking above books
			draw_circle(Vector2(cx - s * 0.1, cy - s * 0.52), s * 0.12, Color(0.3, 0.2, 0.1, 0.5))
			draw_circle(Vector2(cx + s * 0.15, cy - s * 0.48), s * 0.1, Color(0.3, 0.2, 0.1, 0.45))
			# Ribbon bookmark
			draw_line(Vector2(cx, cy - s * 0.4), Vector2(cx - s * 0.05, cy + s * 0.55), Color(0.7, 0.15, 0.15, 0.5), 2.0)
		"emp_stars":
			# Cluster of stars with sparkle
			var star_col = Color(0.95, 0.8, 0.2, 0.85)
			var star_glow = Color(1.0, 0.9, 0.4, 0.12)
			# Central glow
			draw_circle(Vector2(cx, cy), s * 0.5, star_glow)
			# Draw 5 stars of varying sizes
			var star_positions = [
				{"pos": Vector2(cx, cy - s * 0.2), "r": s * 0.28},
				{"pos": Vector2(cx - s * 0.35, cy + s * 0.15), "r": s * 0.18},
				{"pos": Vector2(cx + s * 0.35, cy + s * 0.1), "r": s * 0.2},
				{"pos": Vector2(cx - s * 0.15, cy + s * 0.4), "r": s * 0.14},
				{"pos": Vector2(cx + s * 0.2, cy + s * 0.38), "r": s * 0.12},
			]
			for sd in star_positions:
				var sp_center = sd["pos"]
				var sr = sd["r"]
				# 5-point star
				for si in range(5):
					var a1 = -PI / 2.0 + float(si) * TAU / 5.0
					var a2 = -PI / 2.0 + (float(si) + 0.5) * TAU / 5.0
					var p1 = sp_center + Vector2.from_angle(a1) * sr
					var p2 = sp_center + Vector2.from_angle(a2) * sr * 0.4
					var p3 = sp_center + Vector2.from_angle(a1 + TAU / 5.0) * sr
					draw_colored_polygon(PackedVector2Array([sp_center, p1, p2]), star_col)
					draw_colored_polygon(PackedVector2Array([sp_center, p2, p3]), star_col)
			# Cross sparkles on the largest star
			var main_star = star_positions[0]["pos"]
			draw_line(main_star + Vector2(-s * 0.35, 0), main_star + Vector2(s * 0.35, 0), Color(1, 1, 1, 0.3), 1.0)
			draw_line(main_star + Vector2(0, -s * 0.35), main_star + Vector2(0, s * 0.35), Color(1, 1, 1, 0.3), 1.0)
		"emp_trophy":
			# Trophy cup icon
			var trophy_col = Color(0.85, 0.65, 0.1, 0.85)
			# Cup body
			draw_rect(Rect2(cx - s * 0.3, cy - s * 0.3, s * 0.6, s * 0.5), trophy_col)
			# Cup rim
			draw_rect(Rect2(cx - s * 0.35, cy - s * 0.35, s * 0.7, s * 0.08), Color(0.95, 0.78, 0.2, 0.9))
			# Handles
			draw_arc(Vector2(cx - s * 0.35, cy - s * 0.1), s * 0.15, PI * 0.5, PI * 1.5, 8, trophy_col, 3.0)
			draw_arc(Vector2(cx + s * 0.35, cy - s * 0.1), s * 0.15, -PI * 0.5, PI * 0.5, 8, trophy_col, 3.0)
			# Stem
			draw_rect(Rect2(cx - s * 0.06, cy + s * 0.2, s * 0.12, s * 0.2), trophy_col)
			# Base
			draw_rect(Rect2(cx - s * 0.22, cy + s * 0.4, s * 0.44, s * 0.08), trophy_col)
			# Star on cup
			draw_circle(Vector2(cx, cy - s * 0.08), s * 0.1, Color(1.0, 0.9, 0.5, 0.7))

		"emp_powers":
			# Lightning bolt / scroll icon for battle powers
			var pw_col = Color(0.3, 0.7, 0.9, 0.85)
			# Scroll body
			draw_rect(Rect2(cx - s * 0.25, cy - s * 0.3, s * 0.5, s * 0.6), Color(0.85, 0.78, 0.6, 0.8))
			# Scroll top/bottom rolls
			draw_circle(Vector2(cx, cy - s * 0.3), s * 0.08, Color(0.7, 0.6, 0.4, 0.9))
			draw_circle(Vector2(cx, cy + s * 0.3), s * 0.08, Color(0.7, 0.6, 0.4, 0.9))
			# Lightning bolt on scroll
			var bolt_pts = PackedVector2Array([
				Vector2(cx + s * 0.05, cy - s * 0.2),
				Vector2(cx - s * 0.1, cy + s * 0.02),
				Vector2(cx + s * 0.02, cy + s * 0.02),
				Vector2(cx - s * 0.05, cy + s * 0.2),
			])
			for bi in range(bolt_pts.size() - 1):
				draw_line(bolt_pts[bi], bolt_pts[bi + 1], pw_col, 3.0)

func _draw_emporium_sub_panel() -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var font = game_font

	# Navy gradient background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 55.0 + 1), col)

	# Gold double-frame border
	var emp_outer = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.35)
	var emp_gold = Color(0.54, 0.45, 0.20, 0.2)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 3), emp_outer)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 3, panel_w, 3), emp_outer)
	draw_rect(Rect2(panel_x, panel_y, 3, panel_h), emp_outer)
	draw_rect(Rect2(panel_x + panel_w - 3, panel_y, 3, panel_h), emp_outer)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, panel_w - 12, 1), emp_gold)
	draw_rect(Rect2(panel_x + 6, panel_y + panel_h - 7, panel_w - 12, 1), emp_gold)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, 1, panel_h - 12), emp_gold)
	draw_rect(Rect2(panel_x + panel_w - 7, panel_y + 6, 1, panel_h - 12), emp_gold)

	# Category title
	if emporium_sub_category >= 0 and emporium_sub_category < emporium_categories.size():
		var cat = emporium_categories[emporium_sub_category]
		var title_text = cat["name"].to_upper()
		var title_size = 24
		var tw = font.get_string_size(title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size).x
		var tx = panel_x + (panel_w - tw) * 0.5
		_udraw(font, Vector2(tx, panel_y + 36), title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.95, 0.75, 0.2, 0.9))
		# Underline
		var cx = panel_x + panel_w * 0.5
		draw_line(Vector2(cx - 160, panel_y + 44), Vector2(cx + 160, panel_y + 44), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.5)

	# Currency bar
	var bar_y = panel_y + 60.0
	var currencies_text = "Quills: %d    |    Shards: %d    |    Stars: %d    |    Gold: %d" % [player_quills, player_relic_shards, player_storybook_stars, player_gold]
	var cw = font.get_string_size(currencies_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 16).x
	_udraw(font, Vector2(panel_x + (panel_w - cw) * 0.5, bar_y + 14), currencies_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 16, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.7))

	# Chest inventory line
	var chest_text = "Chests:  Bronze: %d  |  Silver: %d  |  Gold: %d" % [treasure_chests_owned["bronze"], treasure_chests_owned["silver"], treasure_chests_owned["gold"]]
	var chest_tw = font.get_string_size(chest_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 15).x
	_udraw(font, Vector2(panel_x + (panel_w - chest_tw) * 0.5, bar_y + 32), chest_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.7))

	# Separator line
	draw_line(Vector2(panel_x + 40, bar_y + 42), Vector2(panel_x + panel_w - 40, bar_y + 42), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.15), 1.0)

	# 3 item cards
	if emporium_sub_category >= 0 and emporium_items.has(emporium_sub_category):
		var items = emporium_items[emporium_sub_category]
		var item_w = 320.0
		var item_h = 130.0
		var gap = 20.0
		var total_w = 3.0 * item_w + 2.0 * gap
		var start_x = panel_x + (panel_w - total_w) * 0.5
		var start_y = panel_y + 130.0

		var max_cols = 3
		var num_rows = ceili(float(items.size()) / max_cols)
		if num_rows > 1:
			item_h = 110.0
		for i in range(items.size()):
			var item = items[i]
			var row_i = i / max_cols
			var col_i = i % max_cols
			var items_in_row = mini(max_cols, items.size() - row_i * max_cols)
			var row_w = float(items_in_row) * item_w + float(items_in_row - 1) * gap
			var row_start_x = panel_x + (panel_w - row_w) * 0.5
			var ix = row_start_x + float(col_i) * (item_w + gap)
			var iy = start_y + float(row_i) * (item_h + 12.0)
			var is_hovered = (i == emporium_sub_hover)

			# Card shadow
			draw_rect(Rect2(ix + 4, iy + 4, item_w, item_h), Color(0.0, 0.0, 0.0, 0.3))
			# Card background
			var bg = menu_bg_card_hover if is_hovered else menu_bg_card
			draw_rect(Rect2(ix, iy, item_w, item_h), bg)
			# Card border — color by item rarity/cost tier (Enhancement #36)
			var rarity_col = Color(0.55, 0.38, 0.08, 0.35)  # Default gold-dim
			if item["cost"] >= 100:
				rarity_col = Color(0.85, 0.65, 0.1, 0.5)  # Gold/rare — expensive items
			elif item["cost"] >= 30:
				rarity_col = Color(0.55, 0.3, 0.7, 0.45)  # Purple/uncommon — mid-range
			else:
				rarity_col = Color(0.3, 0.5, 0.8, 0.4)  # Blue/common — cheap items
			var bdr = Color(rarity_col.r * 1.3, rarity_col.g * 1.3, rarity_col.b * 1.3, 0.7) if is_hovered else rarity_col
			draw_rect(Rect2(ix, iy, item_w, 2), bdr)
			draw_rect(Rect2(ix, iy + item_h - 2, item_w, 2), bdr)
			draw_rect(Rect2(ix, iy, 2, item_h), bdr)
			draw_rect(Rect2(ix + item_w - 2, iy, 2, item_h), bdr)

			# Hover glow
			if is_hovered:
				var ga = 0.06 + sin(_time * 3.5) * 0.03
				draw_rect(Rect2(ix - 2, iy - 2, item_w + 4, item_h + 4), Color(menu_gold.r, menu_gold.g, menu_gold.b, ga))

			# Item name
			var nw = font.get_string_size(item["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 16).x
			_udraw(font, Vector2(ix + (item_w - nw) * 0.5, iy + 28), item["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.9, 0.72, 0.2, 0.95))
			# Item description
			var dw = font.get_string_size(item["desc"], HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x
			_udraw(font, Vector2(ix + (item_w - dw) * 0.5, iy + 50), item["desc"], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.65, 0.55, 0.4, 0.8))
			# Reward line
			var reward_text = "+%d %s" % [item["amount"], item["reward"].capitalize().replace("_", " ")]
			if item["reward"] == "power":
				var pid = item.get("power_id", "")
				var count = owned_powers.get(pid, 0)
				reward_text = "Owned: %d" % count
			var rw = font.get_string_size(reward_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14).x
			_udraw(font, Vector2(ix + (item_w - rw) * 0.5, iy + 78), reward_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.4, 0.85, 0.4, 0.9))
			# Cost line
			var cost_text = "Cost: %d %s" % [item["cost"], item["currency"].capitalize()]
			var ctw = font.get_string_size(cost_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
			# Check affordability for color
			var can_afford = false
			match item["currency"]:
				"quills": can_afford = player_quills >= item["cost"]
				"shards": can_afford = player_relic_shards >= item["cost"]
				"stars": can_afford = player_storybook_stars >= item["cost"]
				"gold": can_afford = player_gold >= item["cost"]
			var cost_col = Color(0.9, 0.8, 0.5, 0.8) if can_afford else Color(0.8, 0.3, 0.2, 0.8)
			_udraw(font, Vector2(ix + (item_w - ctw) * 0.5, iy + 100), cost_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, cost_col)
			# "Owned" checkmark for power items already purchased (Enhancement #37)
			var is_purchased = false
			if item["reward"] == "power":
				var pid = item.get("power_id", "")
				if pid != "" and owned_powers.get(pid, 0) > 0:
					is_purchased = true
			if is_purchased:
				draw_circle(Vector2(ix + item_w - 12, iy + 12), 8, Color(0.2, 0.7, 0.3, 0.7))
				draw_line(Vector2(ix + item_w - 16, iy + 12), Vector2(ix + item_w - 12, iy + 16), Color(1, 1, 1, 0.9), 2.0)
				draw_line(Vector2(ix + item_w - 12, iy + 16), Vector2(ix + item_w - 7, iy + 8), Color(1, 1, 1, 0.9), 2.0)
				# "OWNED" text overlay
				var owned_text = "OWNED"
				var owned_tw = font.get_string_size(owned_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 10).x
				_udraw(font, Vector2(ix + item_w - owned_tw - 22, iy + 16), owned_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(0.3, 0.8, 0.4, 0.7))

			# "BUY" label at bottom
			var buy_text = "[ BUY ]"
			var bw2 = font.get_string_size(buy_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x
			var buy_col = Color(0.85, 0.65, 0.1, 0.8) if is_hovered else Color(0.55, 0.42, 0.2, 0.5)
			_udraw(font, Vector2(ix + (item_w - bw2) * 0.5, iy + item_h - 14), buy_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, buy_col)

	# Purchase confirmation flash overlay (Enhancement #34)
	if _emporium_purchase_flash > 0.0:
		draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(1.0, 0.9, 0.5, _emporium_purchase_flash * 0.2))

	# Open chest buttons (if category is Relic Chests and player has chests)
	if emporium_sub_category == 3:
		var open_y = panel_y + 290.0
		var tier_names = ["Bronze", "Silver", "Gold"]
		var tier_keys = ["bronze", "silver", "gold"]
		var open_total_w = 3.0 * 320.0 + 2.0 * 20.0
		var open_start_x = panel_x + (panel_w - open_total_w) * 0.5
		for ci in range(3):
			var count = treasure_chests_owned[tier_keys[ci]]
			if count > 0:
				var ox = open_start_x + float(ci) * 340.0
				var ow = 320.0
				var oh = 36.0
				draw_rect(Rect2(ox, open_y, ow, oh), Color(0.08, 0.07, 0.18, 0.85))
				draw_rect(Rect2(ox, open_y, ow, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3))
				var ot = "Open %s Chest (%d)" % [tier_names[ci], count]
				var otw = font.get_string_size(ot, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
				_udraw(font, Vector2(ox + (ow - otw) * 0.5, open_y + 24), ot, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.9, 0.75, 0.2, 0.85))

	# Purchase feedback message with visual countdown timer
	if emporium_sub_message != "":
		var msg_col = Color(0.3, 0.85, 0.3, 0.95) if emporium_sub_message == "Purchased!" else Color(0.9, 0.3, 0.2, 0.95)
		var mw = font.get_string_size(emporium_sub_message, HORIZONTAL_ALIGNMENT_LEFT, -1, 18).x
		_udraw(font, Vector2(panel_x + (panel_w - mw) * 0.5, panel_y + panel_h - 80), emporium_sub_message, HORIZONTAL_ALIGNMENT_LEFT, -1, 18, msg_col)
		# Visual countdown bar for confirmation
		if _emporium_confirm_timer > 0.0:
			var cbar_w = 200.0
			var cbar_h = 6.0
			var cbar_x = panel_x + (panel_w - cbar_w) * 0.5
			var cbar_y = panel_y + panel_h - 60
			var fill_ratio = clampf(_emporium_confirm_timer / 3.0, 0.0, 1.0)
			draw_rect(Rect2(cbar_x, cbar_y, cbar_w, cbar_h), Color(0.2, 0.15, 0.1, 0.5))
			draw_rect(Rect2(cbar_x, cbar_y, cbar_w * fill_ratio, cbar_h), Color(0.9, 0.7, 0.2, 0.8))

	# Back button (drawn, detected via click)
	var back_text = "<  BACK"
	var back_x = panel_x + 20.0
	var back_y = panel_y + panel_h - 30.0
	_udraw(font, Vector2(back_x, back_y), back_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7))

func _start_chest_opening(tier: int) -> void:
	chest_opening_active = true
	chest_opening_tier = tier
	chest_opening_phase = 0
	chest_opening_timer = 0.0
	chest_opening_picked = -1
	chest_opening_flip_index = 0
	_generate_chest_cards(tier)
	total_chests_opened += 1
	_check_achievement("chest_collector", 1)
	_save_game()
	queue_redraw()

func _start_victory_chest(difficulty: int, stars: int) -> void:
	victory_chest_active = true
	victory_chest_stars = stars
	victory_trinket_pending = {}
	victory_equip_active = false
	victory_equip_hover = -1
	# Map difficulty to tier colors: Easy=Blue(0), Medium=Purple(1), Hard=Gold(2)
	chest_opening_active = true
	chest_opening_tier = mini(difficulty, 2)
	chest_opening_phase = 0
	chest_opening_timer = 0.0
	chest_opening_picked = -1
	chest_opening_flip_index = 0
	_generate_victory_cards(difficulty, stars)
	total_chests_opened += 1
	_check_achievement("chest_collector", 1)
	# Hide all tower nodes so they don't render over the chest overlay
	for tower in get_tree().get_nodes_in_group("towers"):
		tower.visible = false
	# Hide HUD buttons
	start_button.visible = false
	speed_button.visible = false
	return_button.visible = false
	queue_redraw()

func _generate_victory_cards(difficulty: int, stars: int) -> void:
	chest_opening_cards.clear()
	var loot_bonus = 1.0 + _get_knowledge_bonus("chest_loot")
	var chapter = levels[current_level]["chapter"] if current_level >= 0 and current_level < levels.size() else 0
	var chapter_mult = 1.0 + chapter * 0.5
	var prog_chapter = current_level / 3  # World index for drop rate scaling
	var level_char = levels[current_level]["character"] if current_level >= 0 and current_level < levels.size() else -1
	var highest_lv = _get_highest_completed_level()
	# Currency pools by difficulty (harmonized with chest loot values)
	var currency_pools = [
		[{"type": "shards", "min": 2, "max": 8}, {"type": "quills", "min": 1, "max": 2}, {"type": "gold", "min": 8, "max": 25}],
		[{"type": "shards", "min": 5, "max": 15}, {"type": "quills", "min": 2, "max": 4}, {"type": "gold", "min": 18, "max": 50}, {"type": "stars", "min": 1, "max": 2}],
		[{"type": "shards", "min": 10, "max": 30}, {"type": "quills", "min": 4, "max": 8}, {"type": "gold", "min": 30, "max": 90}, {"type": "stars", "min": 1, "max": 3}],
	]
	var pool = currency_pools[mini(difficulty, 2)]
	# Difficulty-exclusive gear tier + act gating + mythic/forbidden chances
	var trinket_rarity = ["tattered", "bound", "gilded"][difficulty]
	var tier_unlocked = true
	if difficulty == 1 and highest_lv < 12:
		tier_unlocked = false  # Bound requires Act 1 complete
	elif difficulty == 2 and highest_lv < 24:
		tier_unlocked = false  # Gilded requires Act 2 complete
	# Mythic/Forbidden upgrade chance on hard difficulty
	if difficulty == 2 and tier_unlocked:
		var upgrade_roll = randf()
		if upgrade_roll < 0.02:  # 2% forbidden
			trinket_rarity = "forbidden"
		elif upgrade_roll < 0.10:  # 8% mythic
			trinket_rarity = "mythic"
		# BATTD2: Pity Timer — guaranteed mythic after 30 drops, forbidden after 100
		_drops_since_mythic += 1
		_drops_since_forbidden += 1
		if trinket_rarity == "mythic" or trinket_rarity == "forbidden":
			_drops_since_mythic = 0
		if trinket_rarity == "forbidden":
			_drops_since_forbidden = 0
		if _drops_since_forbidden >= PITY_FORBIDDEN:
			trinket_rarity = "forbidden"
			_drops_since_forbidden = 0
			_drops_since_mythic = 0
		elif _drops_since_mythic >= PITY_MYTHIC:
			trinket_rarity = "mythic"
			_drops_since_mythic = 0
	# Drop rate: low base + scales with chapter progression
	var trinket_chance = [0.08, 0.12, 0.18][difficulty]
	trinket_chance += [0.01, 0.015, 0.02][difficulty] * prog_chapter
	if stars >= 3:
		trinket_chance += 0.05
	# Generate 3 cards
	for i in range(3):
		if i == 2 and tier_unlocked and randf() < trinket_chance:
			var chosen = _pick_weighted_relic(trinket_rarity, level_char)
			if not chosen.is_empty():
				chest_opening_cards.append({
					"type": "trinket", "amount": 1, "name": chosen["name"],
					"trinket_id": chosen["id"], "trinket_rarity": trinket_rarity,
					"desc": chosen["desc"]
				})
				continue
		# Currency card
		var entry = pool[randi() % pool.size()]
		var amount = randi_range(entry["min"], entry["max"])
		amount = int(float(amount) * loot_bonus * chapter_mult)
		amount = maxi(amount, 1)
		if stars >= 3:
			amount = int(float(amount) * 1.3)
		var card_name = ""
		match entry["type"]:
			"shards": card_name = "Relic Shards"
			"quills": card_name = "Enchanted Quills"
			"gold": card_name = "Gold Sovereigns"
			"stars": card_name = "Storybook Stars"
		# Small chance for battle power on Medium/Hard
		if difficulty >= 1 and randf() < 0.15 and battle_power_definitions.size() > 0:
			var bp = battle_power_definitions[randi() % battle_power_definitions.size()]
			var bp_count = 1 if difficulty == 1 else 2
			chest_opening_cards.append({"type": "power", "amount": bp_count, "name": bp["name"], "power_id": bp["id"]})
		else:
			chest_opening_cards.append({"type": entry["type"], "amount": amount, "name": card_name})

func _generate_chest_cards(tier: int) -> void:
	chest_opening_cards.clear()
	# Loot pools by tier: Bronze, Silver, Gold
	var currency_ranges = [
		[{"type": "shards", "min": 5, "max": 15}, {"type": "quills", "min": 1, "max": 3}, {"type": "gold", "min": 20, "max": 60}],
		[{"type": "shards", "min": 15, "max": 40}, {"type": "quills", "min": 3, "max": 8}, {"type": "gold", "min": 50, "max": 150}, {"type": "stars", "min": 1, "max": 1}],
		[{"type": "shards", "min": 30, "max": 80}, {"type": "quills", "min": 8, "max": 20}, {"type": "gold", "min": 100, "max": 300}, {"type": "stars", "min": 1, "max": 3}],
	]
	var pool = currency_ranges[mini(tier, 2)]
	var loot_bonus = 1.0 + _get_knowledge_bonus("chest_loot")
	for i in range(3):
		var entry = pool[randi() % pool.size()]
		var amount = randi_range(entry["min"], entry["max"])
		amount = int(float(amount) * loot_bonus)
		amount = maxi(amount, 1)
		var card_name = ""
		match entry["type"]:
			"shards": card_name = "Relic Shards"
			"quills": card_name = "Enchanted Quills"
			"gold": card_name = "Gold Sovereigns"
			"stars": card_name = "Storybook Stars"
		# Small chance to replace with a battle power (Silver/Gold chests only)
		if tier >= 1 and randf() < 0.2 and battle_power_definitions.size() > 0:
			var bp = battle_power_definitions[randi() % battle_power_definitions.size()]
			var bp_count = 1 if tier == 1 else 2
			chest_opening_cards.append({"type": "power", "amount": bp_count, "name": bp["name"], "power_id": bp["id"]})
		else:
			chest_opening_cards.append({"type": entry["type"], "amount": amount, "name": card_name})

func _on_chest_overlay_clicked(mouse_pos: Vector2) -> void:
	# Victory equip overlay intercepts all clicks when active
	if victory_equip_active:
		_on_victory_equip_clicked(mouse_pos)
		return
	# Phase 0 = click to open the chest
	if chest_opening_phase == 0:
		chest_opening_phase = 1
		chest_opening_timer = 0.0
		queue_redraw()
		return
	if chest_opening_phase < 5:
		return  # Still animating (phases 1-4)
	if chest_opening_phase == 6:
		chest_opening_active = false
		# Restore tower visibility
		for tower in get_tree().get_nodes_in_group("towers"):
			tower.visible = true
		if victory_chest_active:
			victory_chest_active = false
			return_button.visible = true
			_queue_post_victory_dialog()
			_save_game()
		queue_redraw()
		return
	# Phase 5 = pick a card
	var cx = 640.0
	var card_w = 170.0
	var card_h = 240.0
	var card_gap = 40.0
	var total = 3.0 * card_w + 2.0 * card_gap
	var start_x = cx - total * 0.5
	var card_y = 220.0
	for i in range(3):
		var card_x = start_x + float(i) * (card_w + card_gap)
		if mouse_pos.x >= card_x and mouse_pos.x <= card_x + card_w and mouse_pos.y >= card_y and mouse_pos.y <= card_y + card_h:
			chest_opening_picked = i
			var card = chest_opening_cards[i]
			# Trinket card — show character equip overlay
			if card.get("type") == "trinket":
				victory_trinket_pending = card
				# Add to owned immediately
				var tid = card.get("trinket_id", "")
				if tid != "":
					owned_bindings[tid] = owned_bindings.get(tid, 0) + 1
					_mark_binding_discovered(tid)
					_add_recent_item(card.get("name", "Trinket"), card.get("trinket_rarity", "tattered"))
				victory_equip_active = true
				victory_equip_hover = -1
				queue_redraw()
				return
			# Grant currency/power reward immediately
			match card["type"]:
				"shards": player_relic_shards += card["amount"]
				"quills": player_quills += card["amount"]
				"gold": player_gold += card["amount"]
				"stars": player_storybook_stars += card["amount"]
				"power":
					var pid = card.get("power_id", "")
					if pid != "":
						owned_powers[pid] = owned_powers.get(pid, 0) + card["amount"]
			chest_opening_phase = 6
			chest_opening_timer = 0.0
			_save_game()
			queue_redraw()
			return

func _on_victory_equip_clicked(mouse_pos: Vector2) -> void:
	# Character selection overlay for equipping a trinket
	var panel_x = 240.0
	var panel_y = 120.0
	var panel_w = 800.0
	var col_w = 115.0
	var col_gap = 10.0
	var row_h = 80.0
	var grid_x = panel_x + 30.0
	var grid_y = panel_y + 90.0
	# 11 characters in 2 rows (6 + 5)
	var tower_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom", "scrooge",
		"sherlock", "tarzan", "dracula", "merlin", "frankenstein"]
	for idx in range(tower_names.size()):
		var row = idx / 6
		var col = idx % 6
		var cx = grid_x + float(col) * (col_w + col_gap)
		var cy = grid_y + float(row) * (row_h + 15.0)
		if mouse_pos.x >= cx and mouse_pos.x <= cx + col_w and mouse_pos.y >= cy and mouse_pos.y <= cy + row_h:
			var tower_type_str = tower_names[idx]
			var slots = _get_binding_slots(tower_type_str)
			if slots <= 0:
				return  # No slots available
			var current = equipped_bindings.get(tower_type_str, [])
			if current.size() >= slots:
				return  # All slots full
			var tid = victory_trinket_pending.get("trinket_id", "")
			if tid != "":
				if not equipped_bindings.has(tower_type_str):
					equipped_bindings[tower_type_str] = []
				equipped_bindings[tower_type_str].append(tid)
				# Apply meta buffs to any placed tower of this type
				for tower in get_tree().get_nodes_in_group("towers"):
					if tower.get("tower_type") != null:
						var tname = _tower_type_to_name(tower.tower_type)
						if tname == tower_type_str:
							_apply_meta_buffs(tower, tower_type_str)
			victory_equip_active = false
			victory_trinket_pending = {}
			chest_opening_phase = 6
			chest_opening_timer = 0.0
			_save_game()
			queue_redraw()
			return
	# "Skip" button at bottom — equip later
	var skip_x = panel_x + (panel_w - 200.0) * 0.5
	var skip_y = panel_y + 310.0
	if mouse_pos.x >= skip_x and mouse_pos.x <= skip_x + 200.0 and mouse_pos.y >= skip_y and mouse_pos.y <= skip_y + 40.0:
		victory_equip_active = false
		victory_trinket_pending = {}
		chest_opening_phase = 6
		chest_opening_timer = 0.0
		_save_game()
		queue_redraw()

func _draw_chest_opening() -> void:
	# Full-screen OPAQUE dark overlay — completely hides everything behind
	draw_rect(Rect2(0, 0, 1280, 720), Color(0.02, 0.01, 0.05, 1.0))
	var font = game_font
	var cx = 640.0
	# Victory chests use difficulty colors; emporium chests use classic tier colors
	var tier_names = ["Apprentice", "Journeyman", "Master"]
	var tier_colors = [Color(0.3, 0.5, 0.85), Color(0.6, 0.3, 0.75), Color(0.85, 0.65, 0.1)]
	if not victory_chest_active:
		tier_names = ["Bronze", "Silver", "Gold"]
		tier_colors = [Color(0.72, 0.50, 0.25), Color(0.75, 0.75, 0.80), Color(0.85, 0.65, 0.1)]
	var tier_col = tier_colors[mini(chest_opening_tier, 2)]
	var glow_col = Color(tier_col.r * 1.2, tier_col.g * 1.2, tier_col.b * 1.0)

	if chest_opening_phase == 0 or chest_opening_phase == 1:
		# === GLOWING TREASURE CHEST ===
		var chest_cy = 300.0
		var shake = 0.0
		if chest_opening_phase == 1:
			shake = sin(chest_opening_timer * 30.0) * (3.0 + chest_opening_timer * 8.0)
		var chest_cx = cx + shake
		var bw = 200.0
		var bh = 120.0
		var pulse = (sin(_time * 2.5) + 1.0) * 0.5

		# Multiple layered glow rings behind chest (bright and dramatic)
		for gi in range(5):
			var gr = 160.0 - float(gi) * 22.0 + pulse * 12.0
			var ga = 0.04 + float(gi) * 0.02 + pulse * 0.02
			draw_circle(Vector2(cx, chest_cy + 20), gr, Color(glow_col.r, glow_col.g, glow_col.b, ga))
		# Outer golden haze
		draw_circle(Vector2(cx, chest_cy + 20), 200.0 + pulse * 20.0, Color(1.0, 0.9, 0.5, 0.03))

		# Floating sparkle particles
		for p in range(16):
			var angle = float(p) * TAU / 16.0 + _time * 0.4
			var dist = 100.0 + sin(_time * 1.5 + float(p) * 2.1) * 40.0
			var px = cx + cos(angle) * dist
			var py = chest_cy + 20.0 + sin(angle) * dist * 0.5
			var sp = (sin(_time * 3.0 + float(p) * 1.3) + 1.0) * 0.5
			var sz = 1.5 + sp * 2.5
			draw_circle(Vector2(px, py), sz, Color(1.0, 0.95, 0.7, sp * 0.5))

		# === Chest shadow on ground ===
		draw_colored_polygon(PackedVector2Array([
			Vector2(chest_cx - bw * 0.6, chest_cy + bh + 6),
			Vector2(chest_cx + bw * 0.6, chest_cy + bh + 6),
			Vector2(chest_cx + bw * 0.45, chest_cy + bh + 18),
			Vector2(chest_cx - bw * 0.45, chest_cy + bh + 18)
		]), Color(0.0, 0.0, 0.0, 0.35))

		# === Chest body ===
		# Dark base
		draw_rect(Rect2(chest_cx - bw * 0.5 - 5, chest_cy - 3, bw + 10, bh + 6), Color(tier_col.r * 0.25, tier_col.g * 0.25, tier_col.b * 0.25))
		# Main body (gradient effect with multiple rects)
		for gi in range(6):
			var t = float(gi) / 5.0
			var yy = chest_cy + t * bh
			var hh = bh / 5.0
			var shade = lerp(0.9, 0.55, t)
			draw_rect(Rect2(chest_cx - bw * 0.5, yy, bw, hh), Color(tier_col.r * shade, tier_col.g * shade, tier_col.b * shade))
		# Horizontal metal bands
		for band_y in [chest_cy + bh * 0.0, chest_cy + bh * 0.45, chest_cy + bh * 0.95]:
			draw_rect(Rect2(chest_cx - bw * 0.54, band_y, bw * 1.08, 5), Color(tier_col.r * 0.35, tier_col.g * 0.35, tier_col.b * 0.35, 0.9))
			draw_rect(Rect2(chest_cx - bw * 0.54, band_y + 1, bw * 1.08, 1), Color(1.0, 0.95, 0.7, 0.15))
		# Vertical center strip
		draw_rect(Rect2(chest_cx - 5, chest_cy, 10, bh), Color(tier_col.r * 0.4, tier_col.g * 0.4, tier_col.b * 0.4, 0.7))
		# Lid (beveled trapezoid)
		draw_colored_polygon(PackedVector2Array([
			Vector2(chest_cx - bw * 0.56, chest_cy), Vector2(chest_cx + bw * 0.56, chest_cy),
			Vector2(chest_cx + bw * 0.46, chest_cy - 45), Vector2(chest_cx - bw * 0.46, chest_cy - 45)
		]), Color(tier_col.r * 0.8, tier_col.g * 0.8, tier_col.b * 0.8))
		# Lid highlight
		draw_colored_polygon(PackedVector2Array([
			Vector2(chest_cx - bw * 0.44, chest_cy - 42), Vector2(chest_cx + bw * 0.44, chest_cy - 42),
			Vector2(chest_cx + bw * 0.40, chest_cy - 30), Vector2(chest_cx - bw * 0.40, chest_cy - 30)
		]), Color(1.0, 1.0, 1.0, 0.08))
		# Golden clasp/lock with glow
		var lock_glow = 0.5 + pulse * 0.5
		draw_circle(Vector2(chest_cx, chest_cy + 10), 18 + pulse * 3, Color(1.0, 0.85, 0.3, 0.15 * lock_glow))
		draw_rect(Rect2(chest_cx - 16, chest_cy - 8, 32, 28), Color(0.90, 0.70, 0.15, 0.95))
		draw_rect(Rect2(chest_cx - 14, chest_cy - 6, 28, 24), Color(1.0, 0.82, 0.25, 0.9))
		draw_circle(Vector2(chest_cx, chest_cy + 8), 8, Color(1.0, 0.90, 0.4, 0.95))
		draw_circle(Vector2(chest_cx, chest_cy + 8), 4, Color(0.35, 0.25, 0.05))
		# Corner rivets with gold gleam
		for corner in [Vector2(-bw*0.48, 4), Vector2(bw*0.48, 4), Vector2(-bw*0.48, bh-4), Vector2(bw*0.48, bh-4)]:
			draw_circle(Vector2(chest_cx + corner.x, chest_cy + corner.y), 5, Color(0.95, 0.75, 0.2, 0.8))
			draw_circle(Vector2(chest_cx + corner.x - 1, chest_cy + corner.y - 1), 2, Color(1.0, 1.0, 0.8, 0.4))

		# === VICTORY text (centered above chest) ===
		if victory_chest_active:
			var vic_text = "VICTORY!"
			var vic_w = font.get_string_size(vic_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 52).x
			# Glow behind text
			draw_circle(Vector2(cx, 125), 80.0, Color(1.0, 0.85, 0.2, 0.08 + pulse * 0.06))
			# Text shadow
			_udraw(font, Vector2(cx - vic_w * 0.5 + 2, 132), vic_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 52, Color(0.0, 0.0, 0.0, 0.7))
			# Text with pulsing gold — large
			var text_bright = 0.85 + pulse * 0.15
			_udraw(font, Vector2(cx - vic_w * 0.5, 130), vic_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 52, Color(text_bright, text_bright * 0.85, 0.2, 0.95))
		# Star display — large, animated victory stars
		if victory_chest_active:
			var star_y = 158.0
			for si in range(3):
				var sx = cx - 60.0 + float(si) * 60.0
				var is_earned = si < victory_chest_stars
				var star_col = Color(1.0, 0.85, 0.15, 0.95) if is_earned else Color(0.3, 0.25, 0.2, 0.35)
				var star_size = 22.0
				# Earned stars glow and pulse
				if is_earned:
					var star_pulse = sin(_time * 2.5 + float(si) * 0.8) * 0.15
					star_size += star_pulse * 4.0
					# Glow halo
					draw_circle(Vector2(sx, star_y), star_size + 8.0, Color(1.0, 0.85, 0.2, 0.15 + star_pulse))
				var star_pts = PackedVector2Array()
				for sp in range(10):
					var sa = float(sp) * TAU / 10.0 - PI / 2.0
					var sr = star_size if sp % 2 == 0 else star_size * 0.45
					star_pts.append(Vector2(sx, star_y) + Vector2(cos(sa), sin(sa)) * sr)
				draw_colored_polygon(star_pts, star_col)
				# White highlight on earned stars
				if is_earned:
					draw_circle(Vector2(sx - 3, star_y - 4), 4.0, Color(1, 1, 1, 0.3))

		# Chest tier name
		var title = "%s Chest" % tier_names[mini(chest_opening_tier, 2)]
		var tw = font.get_string_size(title, HORIZONTAL_ALIGNMENT_CENTER, -1, 20).x
		_udraw(font, Vector2(cx - tw * 0.5, chest_cy + bh + 35), title, HORIZONTAL_ALIGNMENT_LEFT, -1, 20, Color(tier_col.r, tier_col.g, tier_col.b, 0.8))

		# "Tap to Open" prompt (phase 0 only, pulsing)
		if chest_opening_phase == 0:
			var tap_alpha = 0.5 + sin(_time * 3.0) * 0.3
			var tap_text = _get_action_text() + " to Open"
			var tap_w = font.get_string_size(tap_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 18).x
			_udraw(font, Vector2(cx - tap_w * 0.5, chest_cy + bh + 60), tap_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 18, Color(1.0, 0.9, 0.6, tap_alpha))

		# Rising sparkle particles
		for p in range(12):
			var px = cx + sin(_time * 1.1 + float(p) * 2.0) * 130.0
			var py = chest_cy + bh - fmod(_time * 35.0 + float(p) * 45.0, 200.0)
			var pa = clampf(1.0 - (chest_cy + bh - py) / 200.0, 0.0, 0.7)
			var ps = 1.5 + sin(_time * 4.0 + float(p)) * 1.0
			draw_circle(Vector2(px, py), ps, Color(1.0, 0.9, 0.6, pa * 0.5))

	elif chest_opening_phase == 2:
		# === LIGHT BURST when chest opens ===
		var progress = clampf(chest_opening_timer / 0.8, 0.0, 1.0)
		# Radial light rays (more dramatic)
		for r in range(24):
			var angle = float(r) * TAU / 24.0 + _time * 0.3
			var ray_len = 350.0 * progress
			var ray_w = 2.0 + sin(float(r) * 1.5) * 1.5
			var ray_end = Vector2(cx, 310) + Vector2.from_angle(angle) * ray_len
			draw_line(Vector2(cx, 310), ray_end, Color(glow_col.r, glow_col.g, glow_col.b, 0.2 * progress), ray_w)
		# Bright center glows (layered)
		draw_circle(Vector2(cx, 310), 120.0 * progress, Color(1.0, 0.95, 0.8, 0.15 * progress))
		draw_circle(Vector2(cx, 310), 70.0 * progress, Color(1.0, 0.95, 0.85, 0.25 * progress))
		draw_circle(Vector2(cx, 310), 35.0 * progress, Color(1.0, 1.0, 0.9, 0.45 * progress))
		draw_circle(Vector2(cx, 310), 12.0 * progress, Color(1.0, 1.0, 1.0, 0.7 * progress))

	elif chest_opening_phase >= 3 and chest_opening_phase <= 5:
		# === CARDS PHASE (slide, flip, pick) — BRIGHT & EXCITING ===
		var card_w = 170.0
		var card_h = 240.0
		var card_gap = 40.0
		var total_cw = 3.0 * card_w + 2.0 * card_gap
		var start_x = cx - total_cw * 0.5
		var card_y = 220.0
		var pulse = (sin(_time * 2.5) + 1.0) * 0.5

		# Dramatic radial glow behind the entire card area
		for gi in range(6):
			var gr = 380.0 - float(gi) * 50.0 + pulse * 15.0
			draw_circle(Vector2(cx, card_y + card_h * 0.5), gr, Color(glow_col.r, glow_col.g, glow_col.b, 0.02 + float(gi) * 0.008))

		# Ambient floating sparkles across the screen
		for sp in range(20):
			var spx = cx + sin(_time * 0.7 + float(sp) * 1.7) * 500.0
			var spy = 360.0 + cos(_time * 0.9 + float(sp) * 2.3) * 250.0
			var spa = (sin(_time * 3.5 + float(sp) * 1.1) + 1.0) * 0.25
			var sps = 1.0 + sin(_time * 4.0 + float(sp) * 0.8) * 1.0
			draw_circle(Vector2(spx, spy), sps, Color(1.0, 0.95, 0.7, spa))

		for i in range(3):
			var card_x = start_x + float(i) * (card_w + card_gap)
			var ccx = card_x + card_w * 0.5
			var ccy_base = card_y + card_h * 0.5
			# Slide-up animation (phase 3)
			var slide_progress = 1.0
			if chest_opening_phase == 3:
				var per_card_delay = float(i) * 0.2
				slide_progress = clampf((chest_opening_timer - per_card_delay) / 0.4, 0.0, 1.0)
				slide_progress = 1.0 - (1.0 - slide_progress) * (1.0 - slide_progress)
			var actual_y = card_y + (350.0 * (1.0 - slide_progress))
			var alpha = slide_progress
			var card_center = Vector2(ccx, actual_y + card_h * 0.5)

			var is_picked = (chest_opening_picked == i)
			var is_revealed = chest_opening_phase >= 5 or (chest_opening_phase == 4 and i <= chest_opening_flip_index) or is_picked

			# === BRIGHT GLOW HALO behind each card ===
			var halo_pulse = (sin(_time * 3.0 + float(i) * 2.1) + 1.0) * 0.5
			for hi in range(4):
				var hr = 140.0 - float(hi) * 25.0 + halo_pulse * 10.0
				var ha = alpha * (0.04 + float(hi) * 0.015 + halo_pulse * 0.01)
				draw_circle(card_center, hr, Color(glow_col.r, glow_col.g, glow_col.b, ha))

			if not is_revealed:
				# === Face-down card (ornate glowing back) ===
				# Deep shadow
				draw_rect(Rect2(card_x + 5, actual_y + 7, card_w, card_h), Color(0.0, 0.0, 0.0, alpha * 0.6))
				# Outer glow border (bright, pulsing)
				for bi in range(5):
					var bdr_a = alpha * (0.4 - float(bi) * 0.06 + halo_pulse * 0.08)
					draw_rect(Rect2(card_x - float(bi) - 1, actual_y - float(bi) - 1, card_w + float(bi) * 2 + 2, card_h + float(bi) * 2 + 2), Color(tier_col.r, tier_col.g, tier_col.b, bdr_a), false, 2.0)
				# Card back (rich dark)
				draw_rect(Rect2(card_x, actual_y, card_w, card_h), Color(0.06, 0.04, 0.12, alpha))
				# Inner gradient fill
				for gi in range(8):
					var gt = float(gi) / 7.0
					var gy = actual_y + gt * card_h
					var gh = card_h / 7.0
					var shade = 0.08 + sin(gt * PI) * 0.06
					draw_rect(Rect2(card_x + 3, gy, card_w - 6, gh), Color(tier_col.r * shade, tier_col.g * shade, tier_col.b * shade, alpha * 0.8))
				# Bright ornate border lines
				draw_rect(Rect2(card_x, actual_y, card_w, 3), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.8))
				draw_rect(Rect2(card_x, actual_y + card_h - 3, card_w, 3), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.8))
				draw_rect(Rect2(card_x, actual_y, 3, card_h), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.8))
				draw_rect(Rect2(card_x + card_w - 3, actual_y, 3, card_h), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.8))
				# Inner frame highlight
				draw_rect(Rect2(card_x + 6, actual_y + 6, card_w - 12, card_h - 12), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.25), false, 1.0)
				# Diamond pattern (brighter)
				var dcx = card_x + card_w * 0.5
				var dcy = actual_y + card_h * 0.5
				draw_colored_polygon(PackedVector2Array([
					Vector2(dcx, dcy - 50), Vector2(dcx + 40, dcy),
					Vector2(dcx, dcy + 50), Vector2(dcx - 40, dcy)
				]), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.18))
				draw_colored_polygon(PackedVector2Array([
					Vector2(dcx, dcy - 30), Vector2(dcx + 24, dcy),
					Vector2(dcx, dcy + 30), Vector2(dcx - 24, dcy)
				]), Color(tier_col.r * 1.3, tier_col.g * 1.3, tier_col.b * 1.3, alpha * 0.12))
				# Bright pulsing question mark
				var q_pulse = (sin(_time * 2.5 + float(i) * 1.2) + 1.0) * 0.5
				var qw = font.get_string_size("?", HORIZONTAL_ALIGNMENT_CENTER, -1, 48).x
				draw_circle(Vector2(dcx, dcy), 25.0 + q_pulse * 8.0, Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.12))
				_udraw(font, Vector2(card_x + (card_w - qw) * 0.5, actual_y + card_h * 0.5 + 18), "?", HORIZONTAL_ALIGNMENT_LEFT, -1, 48, Color(tier_col.r * 1.5, tier_col.g * 1.5, tier_col.b * 1.5, alpha * (0.5 + q_pulse * 0.3)))
				# Corner sparkles
				for ci in range(4):
					var corner_x = card_x + (card_w if ci % 2 == 1 else 0.0)
					var corner_y = actual_y + (card_h if ci >= 2 else 0.0)
					var cs = (sin(_time * 5.0 + float(ci) * 1.5 + float(i) * 2.0) + 1.0) * 0.5
					draw_circle(Vector2(corner_x, corner_y), 3.0 + cs * 2.0, Color(1.0, 0.95, 0.7, alpha * cs * 0.5))
			else:
				# === Face-up card (BRIGHT revealed reward) ===
				# Deep shadow
				draw_rect(Rect2(card_x + 5, actual_y + 7, card_w, card_h), Color(0.0, 0.0, 0.0, alpha * 0.6))
				# Determine card color
				var card_col = glow_col
				if i < chest_opening_cards.size():
					var card = chest_opening_cards[i]
					var is_trinket = card.get("type") == "trinket"
					if is_trinket:
						var rarity = card.get("trinket_rarity", "tattered")
						card_col = RARITY_COLORS.get(rarity, Color(0.6, 0.6, 0.65))
					else:
						var icon_cols = {"shards": Color(0.7, 0.35, 0.85), "quills": Color(0.35, 0.7, 1.0), "gold": Color(1.0, 0.8, 0.15), "stars": Color(1.0, 0.9, 0.25), "power": Color(1.0, 0.4, 0.25)}
						card_col = icon_cols.get(card.get("type", "gold"), Color(1.0, 0.8, 0.15))

				# Bright outer glow (multiple layers, very visible)
				for bi in range(7):
					var bdr_a = alpha * (0.5 - float(bi) * 0.055 + halo_pulse * 0.06)
					draw_rect(Rect2(card_x - float(bi) - 1, actual_y - float(bi) - 1, card_w + float(bi) * 2 + 2, card_h + float(bi) * 2 + 2), Color(card_col.r, card_col.g, card_col.b, bdr_a), false, 2.5)
				# Card background (subtle gradient)
				draw_rect(Rect2(card_x, actual_y, card_w, card_h), Color(0.04, 0.03, 0.08, alpha))
				for gi in range(6):
					var gt = float(gi) / 5.0
					var gy = actual_y + gt * card_h
					var gh = card_h / 5.0
					var shade = 0.05 + sin(gt * PI) * 0.04
					draw_rect(Rect2(card_x, gy, card_w, gh), Color(card_col.r * shade, card_col.g * shade, card_col.b * shade, alpha * 0.6))
				# Bright border
				draw_rect(Rect2(card_x, actual_y, card_w, card_h), Color(card_col.r, card_col.g, card_col.b, alpha * 0.7), false, 2.0)

				if i < chest_opening_cards.size():
					var card = chest_opening_cards[i]
					var is_trinket = card.get("type") == "trinket"
					if is_trinket:
						var rarity = card.get("trinket_rarity", "tattered")
						var rarity_col = RARITY_COLORS.get(rarity, Color(0.6, 0.6, 0.65))
						# Bright center glow
						draw_circle(card_center, 70, Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.15))
						draw_circle(card_center, 40, Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.1))
						# Gem icon (larger, brighter)
						var gcx = card_x + card_w * 0.5
						var gcy = actual_y + card_h * 0.33
						# Gem glow halo
						draw_circle(Vector2(gcx, gcy), 35 + halo_pulse * 5, Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.2))
						# Gem shape
						draw_colored_polygon(PackedVector2Array([
							Vector2(gcx, gcy - 32), Vector2(gcx + 26, gcy - 12),
							Vector2(gcx + 20, gcy + 24), Vector2(gcx - 20, gcy + 24), Vector2(gcx - 26, gcy - 12)
						]), Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.85))
						# Gem inner highlight
						draw_colored_polygon(PackedVector2Array([
							Vector2(gcx, gcy - 22), Vector2(gcx + 16, gcy - 8),
							Vector2(gcx + 12, gcy + 14), Vector2(gcx - 12, gcy + 14), Vector2(gcx - 16, gcy - 8)
						]), Color(minf(rarity_col.r * 1.5, 1.0), minf(rarity_col.g * 1.5, 1.0), minf(rarity_col.b * 1.5, 1.0), alpha * 0.45))
						# Gem sparkles (multiple, animated)
						for si in range(5):
							var sa = _time * 4.0 + float(si) * 1.3 + float(i) * 2.0
							var ss = (sin(sa) + 1.0) * 0.5
							var sx = gcx + cos(sa * 0.7) * 18.0
							var sy = gcy + sin(sa * 0.5) * 14.0
							draw_circle(Vector2(sx, sy), 1.5 + ss * 2.0, Color(1.0, 1.0, 1.0, alpha * ss * 0.7))
						# Rarity badge (brighter)
						var badge = rarity.to_upper() + " RELIC"
						var badge_w = font.get_string_size(badge, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
						draw_rect(Rect2(card_x + (card_w - badge_w - 16) * 0.5, actual_y + 10, badge_w + 16, 22), Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.45))
						_udraw(font, Vector2(card_x + (card_w - badge_w) * 0.5, actual_y + 28), badge, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(1.0, 1.0, 1.0, alpha * 0.95))
						# Name (bright white-gold)
						_udraw(font, Vector2(card_x + card_w * 0.5, actual_y + card_h * 0.66), card["name"], HORIZONTAL_ALIGNMENT_CENTER, int(card_w - 16), 16, Color(1.0, 0.95, 0.7, alpha))
						# Description
						_udraw(font, Vector2(card_x + card_w * 0.5, actual_y + card_h * 0.78), card.get("desc", ""), HORIZONTAL_ALIGNMENT_CENTER, int(card_w - 12), 14, Color(0.85, 0.8, 0.65, alpha * 0.9))
					else:
						# === Currency/power card (BRIGHT) ===
						var icon_cols = {"shards": Color(0.7, 0.35, 0.85), "quills": Color(0.35, 0.7, 1.0), "gold": Color(1.0, 0.8, 0.15), "stars": Color(1.0, 0.9, 0.25), "power": Color(1.0, 0.4, 0.25)}
						var icon_col = icon_cols.get(card.get("type", "gold"), Color(1.0, 0.8, 0.15))
						# Center glow
						draw_circle(card_center, 60, Color(icon_col.r, icon_col.g, icon_col.b, alpha * 0.15))
						# Large currency circle icon
						var icx = card_x + card_w * 0.5
						var icy = actual_y + card_h * 0.35
						draw_circle(Vector2(icx, icy), 30 + halo_pulse * 3, Color(icon_col.r, icon_col.g, icon_col.b, alpha * 0.2))
						draw_circle(Vector2(icx, icy), 22, Color(icon_col.r, icon_col.g, icon_col.b, alpha * 0.6))
						draw_circle(Vector2(icx, icy), 16, Color(icon_col.r * 1.3, icon_col.g * 1.3, icon_col.b * 1.3, alpha * 0.35))
						# Currency name (bright)
						_udraw(font, Vector2(card_x + card_w * 0.5, actual_y + card_h * 0.58), card["name"], HORIZONTAL_ALIGNMENT_CENTER, int(card_w - 12), 14, Color(1.0, 0.95, 0.7, alpha))
						# Amount (large, bright green)
						var amt_text = "x%d" % card["amount"]
						var aw = font.get_string_size(amt_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 36).x
						# Amount glow
						draw_circle(Vector2(icx, actual_y + card_h * 0.74), 25, Color(0.3, 1.0, 0.3, alpha * 0.08))
						_udraw(font, Vector2(card_x + (card_w - aw) * 0.5, actual_y + card_h * 0.74 + 12), amt_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 36, Color(0.5, 1.0, 0.5, alpha))
						# Type label
						var type_label = card.get("type", "").to_upper()
						_udraw(font, Vector2(card_x + card_w * 0.5, actual_y + card_h * 0.9), type_label, HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(icon_col.r, icon_col.g, icon_col.b, alpha * 0.7))

				# Picked card — bright golden highlight
				if is_picked:
					for bi in range(6):
						var pick_a = 0.35 - float(bi) * 0.05 + halo_pulse * 0.05
						draw_rect(Rect2(card_x - float(bi) * 2 - 2, actual_y - float(bi) * 2 - 2, card_w + float(bi) * 4 + 4, card_h + float(bi) * 4 + 4), Color(1.0, 0.9, 0.3, pick_a), false, 2.5)

				# Shimmer sparkles on each card edge
				for si in range(6):
					var edge_t = fmod(_time * 2.0 + float(si) * 0.5 + float(i) * 1.0, 4.0)
					var ex = card_x
					var ey = actual_y
					if edge_t < 1.0:
						ex = card_x + edge_t * card_w
						ey = actual_y
					elif edge_t < 2.0:
						ex = card_x + card_w
						ey = actual_y + (edge_t - 1.0) * card_h
					elif edge_t < 3.0:
						ex = card_x + card_w - (edge_t - 2.0) * card_w
						ey = actual_y + card_h
					else:
						ex = card_x
						ey = actual_y + card_h - (edge_t - 3.0) * card_h
					var shimmer_a = (sin(_time * 6.0 + float(si) * 2.0) + 1.0) * 0.3
					draw_circle(Vector2(ex, ey), 2.5, Color(1.0, 1.0, 0.9, alpha * shimmer_a))

		# "Choose Your Reward!" instruction (bigger, brighter, pulsing)
		if chest_opening_phase == 5 and chest_opening_picked < 0:
			var inst = "Choose Your Reward!"
			var iw = font.get_string_size(inst, HORIZONTAL_ALIGNMENT_CENTER, -1, 28).x
			var inst_pulse = 0.7 + sin(_time * 3.0) * 0.3
			# Text glow
			draw_circle(Vector2(cx, 180), 80, Color(1.0, 0.9, 0.4, 0.04))
			_udraw(font, Vector2(cx - iw * 0.5 + 2, 192), inst, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(0.0, 0.0, 0.0, 0.4))
			_udraw(font, Vector2(cx - iw * 0.5, 190), inst, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(1.0, 0.95, 0.5, inst_pulse))

	if chest_opening_phase == 6:
		# === RESULT DISPLAY (bright & celebratory) ===
		var res_pulse = (sin(_time * 3.0) + 1.0) * 0.5
		# Radial celebration glow
		for gi in range(5):
			var gr = 200.0 - float(gi) * 30.0 + res_pulse * 10.0
			draw_circle(Vector2(cx, 330), gr, Color(glow_col.r, glow_col.g, glow_col.b, 0.02 + float(gi) * 0.01))
		# Celebration sparkles
		for sp in range(15):
			var spx = cx + sin(_time * 1.2 + float(sp) * 1.5) * 250.0
			var spy = 330.0 + cos(_time * 0.8 + float(sp) * 2.0) * 120.0
			var spa = (sin(_time * 4.0 + float(sp) * 1.3) + 1.0) * 0.3
			draw_circle(Vector2(spx, spy), 1.5 + spa * 1.5, Color(1.0, 0.95, 0.7, spa))
		if chest_opening_picked >= 0 and chest_opening_picked < chest_opening_cards.size():
			var card = chest_opening_cards[chest_opening_picked]
			var is_trinket = card.get("type") == "trinket"
			var res_col = Color(0.7, 0.35, 0.9) if is_trinket else Color(0.5, 1.0, 0.45)
			# Bright glow behind result
			draw_circle(Vector2(cx, 330), 100, Color(res_col.r, res_col.g, res_col.b, 0.1))
			draw_circle(Vector2(cx, 330), 50, Color(res_col.r, res_col.g, res_col.b, 0.06))
			if is_trinket:
				var result = "Gear Acquired!"
				var rw = font.get_string_size(result, HORIZONTAL_ALIGNMENT_CENTER, -1, 32).x
				_udraw(font, Vector2(cx - rw * 0.5 + 2, 302), result, HORIZONTAL_ALIGNMENT_LEFT, -1, 32, Color(0.0, 0.0, 0.0, 0.5))
				_udraw(font, Vector2(cx - rw * 0.5, 300), result, HORIZONTAL_ALIGNMENT_LEFT, -1, 32, Color(1.0, 0.9, 0.35, 0.95))
				var nw = font.get_string_size(card["name"], HORIZONTAL_ALIGNMENT_CENTER, -1, 22).x
				_udraw(font, Vector2(cx - nw * 0.5, 340), card["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 22, Color(1.0, 0.95, 0.7, 0.95))
				var desc = card.get("desc", "")
				var dw = font.get_string_size(desc, HORIZONTAL_ALIGNMENT_CENTER, -1, 16).x
				_udraw(font, Vector2(cx - dw * 0.5, 370), desc, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.8, 0.6, 0.85))
			else:
				var result = "You received: %s x%d" % [card["name"], card["amount"]]
				var rw = font.get_string_size(result, HORIZONTAL_ALIGNMENT_CENTER, -1, 28).x
				_udraw(font, Vector2(cx - rw * 0.5 + 2, 332), result, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(0.0, 0.0, 0.0, 0.5))
				_udraw(font, Vector2(cx - rw * 0.5, 330), result, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(0.5, 1.0, 0.5, 0.95))
		var close_alpha = 0.5 + sin(_time * 2.0) * 0.3
		var close_text = _get_action_text() + " anywhere to continue"
		var clw = font.get_string_size(close_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 16).x
		_udraw(font, Vector2(cx - clw * 0.5, 430), close_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.9, 0.8, 0.5, close_alpha))

	# Victory equip overlay (character selection for relic)
	if victory_equip_active:
		_draw_victory_equip_overlay()

func _draw_victory_equip_overlay() -> void:
	# Darken behind
	draw_rect(Rect2(0, 0, 1280, 720), Color(0.0, 0.0, 0.0, 0.7))
	var font = game_font
	var panel_x = 240.0
	var panel_y = 120.0
	var panel_w = 800.0
	var panel_h = 380.0
	# Panel background
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(0.06, 0.04, 0.1, 0.95))
	# Border
	for edge in [Rect2(panel_x, panel_y, panel_w, 2), Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2),
		Rect2(panel_x, panel_y, 2, panel_h), Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h)]:
		draw_rect(edge, Color(0.6, 0.3, 0.75, 0.5))
	# Title
	var title = "Equip Gear: %s" % victory_trinket_pending.get("name", "")
	var tw = font.get_string_size(title, HORIZONTAL_ALIGNMENT_CENTER, -1, 20).x
	_udraw(font, Vector2(panel_x + (panel_w - tw) * 0.5, panel_y + 30), title, HORIZONTAL_ALIGNMENT_CENTER, -1, 20, Color(0.9, 0.75, 0.3, 0.95))
	# Subtitle
	var sub = "Choose a character to equip this gear on:"
	var sw = font.get_string_size(sub, HORIZONTAL_ALIGNMENT_CENTER, -1, 13).x
	_udraw(font, Vector2(panel_x + (panel_w - sw) * 0.5, panel_y + 55), sub, HORIZONTAL_ALIGNMENT_CENTER, -1, 16, Color(0.7, 0.6, 0.5, 0.7))
	# Relic desc
	var desc = victory_trinket_pending.get("desc", "")
	var dw = font.get_string_size(desc, HORIZONTAL_ALIGNMENT_CENTER, -1, 12).x
	_udraw(font, Vector2(panel_x + (panel_w - dw) * 0.5, panel_y + 78), desc, HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(0.6, 0.5, 0.7, 0.7))
	# Character grid (2 rows: 6 + 5)
	var tower_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom", "scrooge",
		"sherlock", "tarzan", "dracula", "merlin", "frankenstein"]
	var display_names = ["Robin Hood", "Alice", "Wicked Witch", "Peter Pan", "Phantom", "Scrooge",
		"Sherlock", "Tarzan", "Dracula", "Merlin", "Frankenstein"]
	var col_w = 115.0
	var col_gap = 10.0
	var row_h = 80.0
	var grid_x = panel_x + 30.0
	var grid_y = panel_y + 90.0
	var mouse_pos = get_viewport().get_mouse_position()
	for idx in range(tower_names.size()):
		var row = idx / 6
		var col = idx % 6
		var bx = grid_x + float(col) * (col_w + col_gap)
		var by = grid_y + float(row) * (row_h + 15.0)
		var slots = _get_binding_slots(tower_names[idx])
		var current = equipped_bindings.get(tower_names[idx], [])
		var has_room = slots > 0 and current.size() < slots
		var is_hover = mouse_pos.x >= bx and mouse_pos.x <= bx + col_w and mouse_pos.y >= by and mouse_pos.y <= by + row_h
		# Background
		var bg_col = Color(0.12, 0.08, 0.18, 0.8)
		if is_hover and has_room:
			bg_col = Color(0.2, 0.15, 0.3, 0.9)
		elif not has_room:
			bg_col = Color(0.08, 0.06, 0.1, 0.5)
		draw_rect(Rect2(bx, by, col_w, row_h), bg_col)
		if is_hover and has_room:
			draw_rect(Rect2(bx, by, col_w, row_h), Color(0.6, 0.3, 0.75, 0.4), false, 1.5)
		# Mini portrait
		_draw_story_portrait(bx + 5, by + 5, 40.0, tower_names[idx])
		# Name
		_udraw(font, Vector2(bx + 48, by + 22), display_names[idx], HORIZONTAL_ALIGNMENT_LEFT, col_w - 52, 15, Color(0.85, 0.75, 0.4, 0.9 if has_room else 0.4))
		# Slot info
		var slot_text = "%d/%d slots" % [current.size(), slots]
		if slots == 0:
			slot_text = "Lv5 to unlock"
		var slot_col = Color(0.5, 0.7, 0.4, 0.7) if has_room else Color(0.5, 0.35, 0.3, 0.5)
		_udraw(font, Vector2(bx + 48, by + 40), slot_text, HORIZONTAL_ALIGNMENT_LEFT, col_w - 52, 14, slot_col)
		# Level
		var level = survivor_progress.get(tower_names[idx], {}).get("level", 1)
		_udraw(font, Vector2(bx + 48, by + 55), "Lv.%d" % level, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.5, 0.45, 0.4, 0.5))
	# Skip / equip later button
	var skip_x = panel_x + (panel_w - 200.0) * 0.5
	var skip_y = panel_y + 310.0
	var skip_hover = mouse_pos.x >= skip_x and mouse_pos.x <= skip_x + 200.0 and mouse_pos.y >= skip_y and mouse_pos.y <= skip_y + 40.0
	draw_rect(Rect2(skip_x, skip_y, 200, 40), Color(0.15, 0.1, 0.08, 0.9 if skip_hover else 0.7))
	draw_rect(Rect2(skip_x, skip_y, 200, 40), Color(0.5, 0.4, 0.3, 0.5 if skip_hover else 0.3), false, 1.0)
	var skip_t = "Equip Later"
	var stw = font.get_string_size(skip_t, HORIZONTAL_ALIGNMENT_CENTER, -1, 14).x
	_udraw(font, Vector2(skip_x + (200 - stw) * 0.5, skip_y + 26), skip_t, HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.7, 0.6, 0.5, 0.85))

func _draw_closed_book() -> void:
	# === STORYBOOK KNOWLEDGE TREE ===
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var font = game_font

	# Navy gradient background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 55.0 + 1), col)

	# Gold double-frame border
	var border_outer = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.35)
	var border_inner = Color(0.54, 0.45, 0.20, 0.2)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 3), border_outer)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 3, panel_w, 3), border_outer)
	draw_rect(Rect2(panel_x, panel_y, 3, panel_h), border_outer)
	draw_rect(Rect2(panel_x + panel_w - 3, panel_y, 3, panel_h), border_outer)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, panel_w - 12, 1), border_inner)
	draw_rect(Rect2(panel_x + 6, panel_y + panel_h - 7, panel_w - 12, 1), border_inner)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, 1, panel_h - 12), border_inner)
	draw_rect(Rect2(panel_x + panel_w - 7, panel_y + 6, 1, panel_h - 12), border_inner)

	# Title
	var title_text = "STORYBOOK KNOWLEDGE"
	var title_size = 24
	var tw = font.get_string_size(title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size).x
	_udraw(font, Vector2(panel_x + (panel_w - tw) * 0.5, panel_y + 34), title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.95, 0.75, 0.2, 0.9))
	# Title underline
	var cx = panel_x + panel_w * 0.5
	draw_line(Vector2(cx - 160, panel_y + 42), Vector2(cx + 160, panel_y + 42), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.5)

	# Knowledge Ink counter
	var ink_text = "Knowledge Ink: %d" % knowledge_ink
	var ink_w = font.get_string_size(ink_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14).x
	_udraw(font, Vector2(panel_x + panel_w - ink_w - 30, panel_y + 20), ink_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.6, 0.45, 0.8, 0.85))

	# === Total completion percentage header (Enhancement #46 style for knowledge) ===
	var total_nodes = 0
	var unlocked_nodes = 0
	for kb in knowledge_branches:
		total_nodes += kb["nodes"].size()
	for kk in knowledge_tree:
		if knowledge_tree[kk]:
			unlocked_nodes += 1
	var knowledge_ratio = float(unlocked_nodes) / float(max(1, total_nodes))
	# Progress bar under title
	draw_rect(Rect2(panel_x + 40, panel_y + 46, panel_w - 80, 4), Color(0.1, 0.1, 0.15, 0.4))
	draw_rect(Rect2(panel_x + 40, panel_y + 46, (panel_w - 80) * knowledge_ratio, 4), Color(0.6, 0.45, 0.8, 0.6))
	_udraw(font, Vector2(panel_x + 40, panel_y + 58), "%d / %d NODES  (%d%%)" % [unlocked_nodes, total_nodes, int(knowledge_ratio * 100)], HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(0.6, 0.5, 0.7, 0.5))

	# 5 branches side by side (compact layout)
	var num_branches = knowledge_branches.size()
	var branch_w = 210.0
	var branch_gap = 14.0
	var total_bw = float(num_branches) * branch_w + float(num_branches - 1) * branch_gap
	var branch_start_x = panel_x + (panel_w - total_bw) * 0.5
	var branch_start_y = panel_y + 62.0
	var node_radius = 16.0
	var node_spacing_y = 52.0

	for bi in range(knowledge_branches.size()):
		var branch = knowledge_branches[bi]
		var bx = branch_start_x + float(bi) * (branch_w + branch_gap)
		var bcol = branch["color"]

		# === Branch divider ornament (Enhancement #38) — between branches ===
		if bi > 0:
			var div_x = bx - branch_gap * 0.5
			# Vertical divider line
			draw_line(Vector2(div_x, branch_start_y + 8), Vector2(div_x, branch_start_y + float(branch["nodes"].size()) * node_spacing_y + 70), Color(0.54, 0.45, 0.20, 0.12), 1.0)
			# Diamond ornament at top of divider
			var div_dy = branch_start_y + 12
			draw_colored_polygon(PackedVector2Array([Vector2(div_x, div_dy - 4), Vector2(div_x + 3, div_dy), Vector2(div_x, div_dy + 4), Vector2(div_x - 3, div_dy)]), Color(0.54, 0.45, 0.20, 0.25))
			# Diamond ornament at bottom of divider
			var div_by = branch_start_y + float(branch["nodes"].size()) * node_spacing_y + 66
			draw_colored_polygon(PackedVector2Array([Vector2(div_x, div_by - 4), Vector2(div_x + 3, div_by), Vector2(div_x, div_by + 4), Vector2(div_x - 3, div_by)]), Color(0.54, 0.45, 0.20, 0.25))

		# Branch header
		var bname = branch["name"]
		var bdesc = "(%s)" % branch["desc"]
		var bnw = font.get_string_size(bname, HORIZONTAL_ALIGNMENT_LEFT, -1, 15).x
		_udraw(font, Vector2(bx + (branch_w - bnw) * 0.5, branch_start_y + 14), bname, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(bcol.r, bcol.g, bcol.b, 0.9))
		var bdw = font.get_string_size(bdesc, HORIZONTAL_ALIGNMENT_LEFT, -1, 14).x
		_udraw(font, Vector2(bx + (branch_w - bdw) * 0.5, branch_start_y + 26), bdesc, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(bcol.r, bcol.g, bcol.b, 0.5))

		# === Character portrait beside branch header (Enhancement #40) ===
		var portrait_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom"]
		if bi < portrait_names.size():
			_draw_story_portrait(bx + 6, branch_start_y + 4, 18.0, portrait_names[bi])

		# === Branch completion progress bar (Enhancement #42) ===
		var branch_unlocked = 0
		for bni in range(branch["nodes"].size()):
			if knowledge_tree.get("%d_%d" % [bi, bni], false):
				branch_unlocked += 1
		var branch_ratio = float(branch_unlocked) / float(max(1, branch["nodes"].size()))
		draw_rect(Rect2(bx, branch_start_y + 32, branch_w, 3), Color(0.1, 0.1, 0.15, 0.3))
		draw_rect(Rect2(bx, branch_start_y + 32, branch_w * branch_ratio, 3), Color(bcol.r, bcol.g, bcol.b, 0.5))

		# Nodes (vertical chain)
		var node_cx = bx + branch_w * 0.5
		for ni in range(branch["nodes"].size()):
			var node = branch["nodes"][ni]
			var node_key = "%d_%d" % [bi, ni]
			var is_unlocked = knowledge_tree.get(node_key, false)
			var can_unlock = not is_unlocked and knowledge_ink >= node["cost"]
			if ni > 0:
				can_unlock = can_unlock and knowledge_tree.get("%d_%d" % [bi, ni - 1], false)
			var node_cy = branch_start_y + 60.0 + float(ni) * node_spacing_y
			var is_hovered = (chronicles_hover_branch == bi and chronicles_hover_node == ni)

			# Connection line to previous node
			if ni > 0:
				var prev_y = branch_start_y + 60.0 + float(ni - 1) * node_spacing_y
				var line_col = Color(bcol.r, bcol.g, bcol.b, 0.5) if knowledge_tree.get("%d_%d" % [bi, ni - 1], false) else Color(0.3, 0.3, 0.3, 0.2)
				draw_line(Vector2(node_cx, prev_y + node_radius), Vector2(node_cx, node_cy - node_radius), line_col, 2.0)

			# Node circle
			if is_unlocked:
				# Gold filled (unlocked)
				draw_circle(Vector2(node_cx, node_cy), node_radius, Color(bcol.r * 0.3, bcol.g * 0.3, bcol.b * 0.3, 0.8))
				draw_circle(Vector2(node_cx, node_cy), node_radius - 2, Color(bcol.r, bcol.g, bcol.b, 0.6))
				draw_arc(Vector2(node_cx, node_cy), node_radius, 0, TAU, 24, Color(0.85, 0.65, 0.1, 0.7), 1.5)
				# Checkmark (scaled for smaller radius)
				draw_line(Vector2(node_cx - 5, node_cy), Vector2(node_cx - 1, node_cy + 4), Color(1, 1, 1, 0.8), 2.0)
				draw_line(Vector2(node_cx - 1, node_cy + 4), Vector2(node_cx + 6, node_cy - 4), Color(1, 1, 1, 0.8), 2.0)
			elif can_unlock:
				# Pulsing available
				var pulse = 0.4 + sin(_time * 3.0) * 0.15
				draw_circle(Vector2(node_cx, node_cy), node_radius + 2, Color(bcol.r, bcol.g, bcol.b, pulse * 0.3))
				draw_circle(Vector2(node_cx, node_cy), node_radius, Color(0.08, 0.06, 0.15, 0.9))
				draw_arc(Vector2(node_cx, node_cy), node_radius, 0, TAU, 24, Color(bcol.r, bcol.g, bcol.b, pulse), 1.5)
				# Cost text inside
				var cost_str = "%d" % node["cost"]
				var csw = font.get_string_size(cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
				_udraw(font, Vector2(node_cx - csw * 0.5, node_cy + 4), cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(bcol.r, bcol.g, bcol.b, pulse + 0.3))
			else:
				# Grey locked
				draw_circle(Vector2(node_cx, node_cy), node_radius, Color(0.06, 0.05, 0.10, 0.8))
				draw_arc(Vector2(node_cx, node_cy), node_radius, 0, TAU, 24, Color(0.3, 0.25, 0.2, 0.3), 1.5)
				# Lock icon
				draw_rect(Rect2(node_cx - 5, node_cy - 1, 10, 8), Color(0.3, 0.25, 0.2, 0.5))
				draw_arc(Vector2(node_cx, node_cy - 2), 5, PI, TAU, 8, Color(0.3, 0.25, 0.2, 0.5), 2.0)

			# Hover highlight
			if is_hovered:
				draw_arc(Vector2(node_cx, node_cy), node_radius + 4, 0, TAU, 24, Color(1, 1, 1, 0.3), 1.5)

			# === Read/unread indicator dot (Enhancement #41) ===
			var ind_x = node_cx - node_radius - 8
			if is_unlocked:
				# Bright solid dot — "read"/unlocked
				draw_circle(Vector2(ind_x, node_cy), 3, Color(0.4, 0.8, 0.3, 0.8))
			elif can_unlock:
				# Pulsing dim dot — available to unlock
				var dot_pulse = 0.4 + sin(_time * 3.5 + float(bi * 10 + ni)) * 0.3
				draw_circle(Vector2(ind_x, node_cy), 3, Color(bcol.r, bcol.g, bcol.b, dot_pulse))
			else:
				# Dim grey dot — locked
				draw_circle(Vector2(ind_x, node_cy), 2, Color(0.3, 0.3, 0.3, 0.25))

			# Node name and desc (to the right)
			var text_x = node_cx + node_radius + 8
			var name_col = Color(0.9, 0.8, 0.5, 0.9) if is_unlocked else (Color(bcol.r, bcol.g, bcol.b, 0.7) if can_unlock else Color(0.5, 0.45, 0.4, 0.5))
			_udraw(font, Vector2(text_x, node_cy - 1), node["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, name_col)
			_udraw(font, Vector2(text_x, node_cy + 11), node["desc"], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(name_col.r, name_col.g, name_col.b, name_col.a * 0.7))

	# === Content fade masks at top/bottom edges (Enhancement #39) ===
	var bg_base = menu_bg_section
	for fi in range(6):
		var fa = 0.7 - float(fi) * 0.12
		draw_rect(Rect2(panel_x + 3, panel_y + 60 + float(fi) * 4, panel_w - 6, 4), Color(bg_base.r, bg_base.g, bg_base.b, fa))
	for fi in range(6):
		var fa = 0.7 - float(fi) * 0.12
		draw_rect(Rect2(panel_x + 3, panel_y + panel_h - 10 - float(fi) * 4, panel_w - 6, 4), Color(menu_bg_dark.r, menu_bg_dark.g, menu_bg_dark.b, fa))

	# === Vertical scroll/completion bar on right side (Enhancement #42) ===
	var scrollbar_x = panel_x + panel_w - 12
	var scrollbar_top = panel_y + 60
	var scrollbar_h = panel_h - 80
	draw_rect(Rect2(scrollbar_x, scrollbar_top, 4, scrollbar_h), Color(0.15, 0.12, 0.25, 0.3))
	var scroll_fill = knowledge_ratio * scrollbar_h
	draw_rect(Rect2(scrollbar_x, scrollbar_top, 4, scroll_fill), Color(0.6, 0.45, 0.8, 0.5))
	# Thumb indicator
	draw_rect(Rect2(scrollbar_x - 1, scrollbar_top + scroll_fill - 2, 6, 4), Color(0.8, 0.65, 0.2, 0.6))

func _update_knowledge_hover() -> void:
	var mouse_pos = get_viewport().get_mouse_position()
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var num_branches = knowledge_branches.size()
	var branch_w = 210.0
	var branch_gap = 14.0
	var total_bw = float(num_branches) * branch_w + float(num_branches - 1) * branch_gap
	var branch_start_x = panel_x + (panel_w - total_bw) * 0.5
	var branch_start_y = panel_y + 62.0
	var node_radius = 16.0
	var node_spacing_y = 52.0
	chronicles_hover_branch = -1
	chronicles_hover_node = -1
	for bi in range(knowledge_branches.size()):
		var bx = branch_start_x + float(bi) * (branch_w + branch_gap)
		var node_cx = bx + branch_w * 0.5
		for ni in range(knowledge_branches[bi]["nodes"].size()):
			var node_cy = branch_start_y + 60.0 + float(ni) * node_spacing_y
			if mouse_pos.distance_to(Vector2(node_cx, node_cy)) <= node_radius + 4:
				chronicles_hover_branch = bi
				chronicles_hover_node = ni
				return

func _on_knowledge_tree_clicked(mouse_pos: Vector2) -> void:
	if chronicles_hover_branch < 0 or chronicles_hover_node < 0:
		return
	var bi = chronicles_hover_branch
	var ni = chronicles_hover_node
	var node_key = "%d_%d" % [bi, ni]
	if knowledge_tree.get(node_key, false):
		return  # Already unlocked
	var node = knowledge_branches[bi]["nodes"][ni]
	if knowledge_ink < node["cost"]:
		return  # Can't afford
	# Check prerequisite (previous node in chain must be unlocked)
	if ni > 0 and not knowledge_tree.get("%d_%d" % [bi, ni - 1], false):
		return
	knowledge_ink -= node["cost"]
	knowledge_tree[node_key] = true
	total_knowledge_nodes += 1
	_check_achievement("knowledge_scholar", 1)
	_save_game()
	queue_redraw()

func _draw_daily_reward() -> void:
	# Full-screen dark overlay
	draw_rect(Rect2(0, 0, 1280, 720), Color(0.0, 0.0, 0.02, 0.88))
	var font = game_font
	var cx = 640.0

	# Modal panel
	var modal_w = 700.0
	var modal_h = 380.0
	var modal_x = cx - modal_w * 0.5
	var modal_y = 170.0

	# Panel background
	for i in range(38):
		var t = float(i) / 37.0
		var col = Color(0.08, 0.06, 0.16).lerp(Color(0.05, 0.04, 0.12), t)
		draw_rect(Rect2(modal_x, modal_y + t * modal_h, modal_w, modal_h / 37.0 + 1), col)

	# Gold border
	draw_rect(Rect2(modal_x, modal_y, modal_w, 3), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.5))
	draw_rect(Rect2(modal_x, modal_y + modal_h - 3, modal_w, 3), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.5))
	draw_rect(Rect2(modal_x, modal_y, 3, modal_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.5))
	draw_rect(Rect2(modal_x + modal_w - 3, modal_y, 3, modal_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.5))

	# Title
	var title = "DAILY REWARDS"
	var title_size = 22
	var ttw = font.get_string_size(title, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size).x
	_udraw(font, Vector2(cx - ttw * 0.5, modal_y + 32), title, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.95, 0.75, 0.2, 0.9))
	draw_line(Vector2(cx - 120, modal_y + 40), Vector2(cx + 120, modal_y + 40), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.5)

	# Streak
	var streak_text = "Streak: Day %d" % (daily_streak % 7 + 1)
	var stw = font.get_string_size(streak_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
	_udraw(font, Vector2(cx - stw * 0.5, modal_y + 58), streak_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.6))

	# 7 day cards: row of 4 + row of 3
	var card_w = 130.0
	var card_h = 100.0
	var card_gap = 16.0
	var current_day = daily_streak % 7

	for d in range(7):
		var row = 0 if d < 4 else 1
		var col = d if d < 4 else (d - 4)
		var cards_in_row = 4 if row == 0 else 3
		var row_w = float(cards_in_row) * card_w + float(cards_in_row - 1) * card_gap
		var row_x = cx - row_w * 0.5
		var dx = row_x + float(col) * (card_w + card_gap)
		var dy = modal_y + 75.0 + float(row) * (card_h + 14.0)
		var reward = daily_rewards_schedule[d]
		var is_today = (d == current_day)
		var is_claimed = d < current_day or daily_reward_claimed_today

		# Card background
		var bg_col = Color(0.12, 0.08, 0.22, 0.9) if is_today else Color(0.06, 0.05, 0.14, 0.8)
		if d < current_day:
			bg_col = Color(0.04, 0.10, 0.08, 0.7)  # Completed (green tint)
		draw_rect(Rect2(dx, dy, card_w, card_h), bg_col)

		# Card border
		var bdr = Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7) if is_today else Color(0.3, 0.25, 0.45, 0.3)
		if d < current_day:
			bdr = Color(0.3, 0.6, 0.3, 0.4)
		draw_rect(Rect2(dx, dy, card_w, 2), bdr)
		draw_rect(Rect2(dx, dy + card_h - 2, card_w, 2), bdr)
		draw_rect(Rect2(dx, dy, 2, card_h), bdr)
		draw_rect(Rect2(dx + card_w - 2, dy, 2, card_h), bdr)

		# Today glow
		if is_today and not daily_reward_claimed_today:
			var ga = 0.05 + sin(_time * 3.0) * 0.03
			draw_rect(Rect2(dx - 2, dy - 2, card_w + 4, card_h + 4), Color(menu_gold.r, menu_gold.g, menu_gold.b, ga))

		# Day label
		var day_label = "Day %d" % (d + 1)
		var dlw = font.get_string_size(day_label, HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x
		_udraw(font, Vector2(dx + (card_w - dlw) * 0.5, dy + 18), day_label, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.8))

		# Reward name
		var rname = reward["name"]
		if rname.length() > 16:
			rname = rname.substr(0, 14) + ".."
		var rnw = font.get_string_size(rname, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
		_udraw(font, Vector2(dx + (card_w - rnw) * 0.5, dy + 50), rname, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.9, 0.75, 0.3, 0.85))

		# Amount
		var amt_text = "x%d" % reward["amount"] if reward["type"] != "gold_chest" else "Chest!"
		var aw = font.get_string_size(amt_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16).x
		_udraw(font, Vector2(dx + (card_w - aw) * 0.5, dy + 72), amt_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.4, 0.85, 0.4, 0.9))

		# Claimed checkmark
		if d < current_day:
			draw_line(Vector2(dx + card_w - 22, dy + card_h - 18), Vector2(dx + card_w - 16, dy + card_h - 10), Color(0.3, 0.8, 0.3, 0.7), 2.0)
			draw_line(Vector2(dx + card_w - 16, dy + card_h - 10), Vector2(dx + card_w - 8, dy + card_h - 22), Color(0.3, 0.8, 0.3, 0.7), 2.0)

	# Claim button (only if not yet claimed today)
	if not daily_reward_claimed_today:
		var btn_w = 200.0
		var btn_h = 40.0
		var btn_x = cx - btn_w * 0.5
		var btn_y = modal_y + modal_h - 60.0
		var btn_col = Color(0.54, 0.45, 0.20, 0.8 + sin(_time * 2.5) * 0.1)
		draw_rect(Rect2(btn_x, btn_y, btn_w, btn_h), btn_col)
		draw_rect(Rect2(btn_x, btn_y, btn_w, 2), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.5))
		var claim_text = "CLAIM REWARD"
		var claim_tw = font.get_string_size(claim_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16).x
		_udraw(font, Vector2(btn_x + (btn_w - claim_tw) * 0.5, btn_y + 27), claim_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.04, 0.04, 0.10, 0.95))
	else:
		var done_text = "Reward claimed! Come back tomorrow."
		var done_w = font.get_string_size(done_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14).x
		_udraw(font, Vector2(cx - done_w * 0.5, modal_y + modal_h - 40), done_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.4, 0.8, 0.4, 0.7))

	# Close button (X in top-right)
	var close_x = modal_x + modal_w - 30
	var close_y = modal_y + 10
	_udraw(font, Vector2(close_x, close_y + 16), "X", HORIZONTAL_ALIGNMENT_LEFT, -1, 18, Color(menu_text.r, menu_text.g, menu_text.b, 0.7))

func _on_daily_reward_clicked(mouse_pos: Vector2) -> void:
	var cx = 640.0
	var modal_w = 700.0
	var modal_h = 380.0
	var modal_x = cx - modal_w * 0.5
	var modal_y = 170.0

	# Close button
	var close_x = modal_x + modal_w - 35
	var close_y = modal_y + 5
	if mouse_pos.x >= close_x and mouse_pos.x <= close_x + 30 and mouse_pos.y >= close_y and mouse_pos.y <= close_y + 25:
		daily_reward_open = false
		queue_redraw()
		return

	# Claim button
	if not daily_reward_claimed_today:
		var btn_w = 200.0
		var btn_h = 40.0
		var btn_x = cx - btn_w * 0.5
		var btn_y = modal_y + modal_h - 60.0
		if mouse_pos.x >= btn_x and mouse_pos.x <= btn_x + btn_w and mouse_pos.y >= btn_y and mouse_pos.y <= btn_y + btn_h:
			_claim_daily_reward()
			return

	# Click outside modal to close
	if mouse_pos.x < modal_x or mouse_pos.x > modal_x + modal_w or mouse_pos.y < modal_y or mouse_pos.y > modal_y + modal_h:
		daily_reward_open = false
		queue_redraw()

func _draw_survivor_grid() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 38.0
	var panel_w = 1140.0
	var panel_h = 570.0

	# Panel background gradient
	for row in range(58):
		var t = float(row) / 57.0
		var bg_col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 57.0 + 1), bg_col)

	# Accent border with inner glow
	var border_col = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.3)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), border_col)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), border_col)
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), border_col)
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), border_col)

	# === "SURVIVORS" title banner ===
	var title_y = panel_y + 6.0
	var title_text = "SURVIVORS"
	var title_w = font.get_string_size(title_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 22).x
	var title_cx = panel_x + panel_w * 0.5
	# Title background bar
	draw_rect(Rect2(title_cx - title_w * 0.5 - 40, title_y, title_w + 80, 28), Color(0.03, 0.03, 0.08, 0.8))
	draw_rect(Rect2(title_cx - title_w * 0.5 - 40, title_y + 27, title_w + 80, 2), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3))
	# Title text with shadow
	_udraw(font, Vector2(title_cx - title_w * 0.5 + 1, title_y + 21), title_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 22, Color(0, 0, 0, 0.5))
	_udraw(font, Vector2(title_cx - title_w * 0.5, title_y + 20), title_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 22, menu_gold)
	# Decorative lines beside title
	draw_line(Vector2(title_cx - title_w * 0.5 - 80, title_y + 14), Vector2(title_cx - title_w * 0.5 - 44, title_y + 14), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.0)
	draw_line(Vector2(title_cx + title_w * 0.5 + 44, title_y + 14), Vector2(title_cx + title_w * 0.5 + 80, title_y + 14), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.0)

	# === PARTY count badge (top-right) ===
	var unlocked_count = 0
	for st in survivor_types:
		if _is_character_unlocked(st):
			unlocked_count += 1
	var party_text = "PARTY: %d/%d" % [unlocked_count, survivor_types.size()]
	var party_w = font.get_string_size(party_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
	draw_rect(Rect2(panel_x + panel_w - party_w - 30, title_y + 4, party_w + 20, 20), Color(menu_accent_purple.r, menu_accent_purple.g, menu_accent_purple.b, 0.6))
	draw_rect(Rect2(panel_x + panel_w - party_w - 30, title_y + 4, party_w + 20, 20), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.25), false, 1.0)
	_udraw(font, Vector2(panel_x + panel_w - party_w - 20, title_y + 18), party_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, menu_gold_light)

	var card_colors_grid = [
		Color(0.29, 0.55, 0.25),  # Robin Hood
		Color(0.44, 0.66, 0.86),  # Alice
		Color(0.48, 0.25, 0.63),  # Wicked Witch
		Color(0.90, 0.49, 0.13),  # Peter Pan
		Color(0.75, 0.22, 0.17),  # Phantom
		Color(0.79, 0.66, 0.30),  # Scrooge
		Color(0.20, 0.35, 0.55),  # Sherlock
		Color(0.30, 0.50, 0.20),  # Tarzan
		Color(0.50, 0.10, 0.15),  # Dracula
		Color(0.25, 0.20, 0.55),  # Merlin
		Color(0.35, 0.40, 0.30),  # Frankenstein
		Color(0.12, 0.08, 0.18),  # Shadow Author
	]

	# BATTD-style grid: 2 rows of cards with large character portraits
	# Row 1: 6 cards, Row 2: 5 cards (centered)
	var card_w = 170.0
	var card_h = 230.0
	var gap_x = 12.0
	var gap_y = 12.0
	var grid_start_y = panel_y + 42.0

	for i in range(survivor_types.size()):
		var row_i: int
		var col_i: int
		var cards_in_row: int
		if i < 6:
			row_i = 0
			col_i = i
			cards_in_row = 6
		else:
			row_i = 1
			col_i = i - 6
			cards_in_row = survivor_types.size() - 6
		var row_w = float(cards_in_row) * card_w + float(cards_in_row - 1) * gap_x
		var row_x = panel_x + (panel_w - row_w) * 0.5
		var cx = row_x + float(col_i) * (card_w + gap_x)
		var cy = grid_start_y + float(row_i) * (card_h + gap_y)

		var tower_type = survivor_types[i]
		var info = tower_info[tower_type]
		var accent = card_colors_grid[mini(i, card_colors_grid.size() - 1)]
		var unlocked = _is_character_unlocked(tower_type)
		var is_hovered = (world_map_hover_index == i)
		var speaker_name = _tower_type_to_name(tower_type)

		# === Enhancement 1: Card hover scale-up ===
		var draw_cx = cx
		var draw_cy = cy
		var draw_cw = card_w
		var draw_ch = card_h
		if is_hovered and unlocked:
			draw_cx -= 4.0
			draw_cy -= 4.0
			draw_cw += 8.0
			draw_ch += 8.0

		# === Card shadow ===
		draw_rect(Rect2(draw_cx + 3, draw_cy + 3, draw_cw, draw_ch), Color(0.0, 0.0, 0.0, 0.4))

		# === Card background — gradient with character accent ===
		draw_rect(Rect2(draw_cx, draw_cy, draw_cw, draw_ch), Color(0.05, 0.05, 0.12))
		# Accent gradient at top
		for gi in range(int(draw_ch * 0.4)):
			var gt = float(gi) / (draw_ch * 0.4)
			draw_rect(Rect2(draw_cx, draw_cy + float(gi), draw_cw, 1), Color(accent.r, accent.g, accent.b, 0.08 * (1.0 - gt)))

		# === Character portrait (large, centered) ===
		var portrait_cx = draw_cx + draw_cw * 0.5
		var portrait_cy = draw_cy + draw_ch * 0.42
		# Enhancement 2: Character breathing animation
		var breath_offset = sin(_time * 2.0 + float(i) * 0.7) * 2.0 if unlocked else 0.0
		if unlocked:
			# Character accent glow
			draw_circle(Vector2(portrait_cx, portrait_cy + 10 + breath_offset), 55.0, Color(accent.r, accent.g, accent.b, 0.06))
			# Draw full character portrait using story portrait system
			_draw_story_portrait(portrait_cx, portrait_cy + 30 + breath_offset, 130.0, speaker_name)
		else:
			# Dark silhouette placeholder
			draw_circle(Vector2(portrait_cx, portrait_cy), 35.0, Color(0.08, 0.08, 0.15, 0.5))
			_udraw(font, Vector2(portrait_cx - 5, portrait_cy + 5), "?", HORIZONTAL_ALIGNMENT_CENTER, -1, 30, Color(0.3, 0.3, 0.4, 0.5))

		# === Level badge (top-left corner circle) ===
		if unlocked:
			var progress = survivor_progress.get(tower_type, {"level": 1})
			var lvl = progress.get("level", 1)
			var badge_cx = draw_cx + 20.0
			var badge_cy = draw_cy + 20.0
			# Badge circle: dark background + accent ring
			draw_circle(Vector2(badge_cx, badge_cy), 16, Color(0.02, 0.02, 0.06, 0.9))
			draw_circle(Vector2(badge_cx, badge_cy), 14, Color(accent.r, accent.g, accent.b, 0.6))
			draw_circle(Vector2(badge_cx, badge_cy), 11, Color(0.03, 0.03, 0.08))
			# Level number
			var lvl_str = str(lvl)
			var lvl_w = font.get_string_size(lvl_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
			_udraw(font, Vector2(badge_cx - lvl_w * 0.5, badge_cy + 5), lvl_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color.WHITE)

		# === Enhancement 6: Role icon badge (top-center) ===
		if unlocked:
			var role = "DPS"
			match i:
				1: role = "SUP"  # Alice - support
				2: role = "AOE"  # Witch - AoE
				5: role = "SUP"  # Scrooge - support
				6: role = "BUF"  # Sherlock - buffer
				9: role = "BUF"  # Merlin - buffer
				_: role = "DPS"
			var role_x = draw_cx + draw_cw * 0.5
			var role_y = draw_cy + 8.0
			draw_rect(Rect2(role_x - 12, role_y, 24, 12), Color(0.02, 0.02, 0.06, 0.8))
			_udraw(font, Vector2(role_x - 10, role_y + 10), role, HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(accent.r, accent.g, accent.b, 0.7))

		# === Star rating (top-right) ===
		var stars_earned = 0
		# Map survivor index to their arc's level indices
		var char_level_map = {
			0: [16, 17, 18], 1: [19, 20, 21], 2: [22, 23, 24],
			3: [25, 26, 27], 4: [28, 29, 30], 5: [31, 32, 33],
			6: [1, 2, 3], 7: [7, 8, 9], 8: [10, 11, 12],
			9: [4, 5, 6], 10: [13, 14, 15], 11: [34, 35, 36]
		}
		if char_level_map.has(i):
			for lvl_idx in char_level_map[i]:
				stars_earned += level_stars.get(lvl_idx, 0)
		if unlocked:
			var star_x = draw_cx + draw_cw - 18.0
			var star_y = draw_cy + 16.0
			# Star badge circle
			draw_circle(Vector2(star_x, star_y), 13, Color(0.02, 0.02, 0.06, 0.8))
			draw_circle(Vector2(star_x, star_y), 11, Color(0.85, 0.65, 0.1, 0.7))
			draw_circle(Vector2(star_x, star_y), 9, Color(0.03, 0.03, 0.08))
			# Star icon
			var sp = Vector2(star_x, star_y)
			var sr = 6.0
			var star_pts = PackedVector2Array()
			for si in range(10):
				var sa = -PI * 0.5 + float(si) * TAU / 10.0
				var sd = sr if si % 2 == 0 else sr * 0.45
				star_pts.append(sp + Vector2(cos(sa) * sd, sin(sa) * sd))
			draw_colored_polygon(star_pts, Color(1.0, 0.85, 0.2, 0.9))

		# === Enhancement 8: Star progress bar ===
		if unlocked and stars_earned > 0:
			var max_stars = 9  # 3 levels x 3 stars each
			var star_fill = clampf(float(stars_earned) / float(max_stars), 0.0, 1.0)
			var sbar_x = draw_cx + draw_cw - 30.0
			var sbar_y = draw_cy + 30.0
			draw_rect(Rect2(sbar_x, sbar_y, 20, 3), Color(0.15, 0.15, 0.2, 0.5))
			draw_rect(Rect2(sbar_x, sbar_y, 20 * star_fill, 3), Color(1.0, 0.85, 0.2, 0.7))

		# === Equipped gear count badge ===
		if unlocked:
			var eq_count = equipped_bindings.get(tower_type, []).size()
			var eq_max = _get_binding_slots(tower_type)
			if eq_max > 0:
				var eq_str = "%d/%d" % [eq_count, eq_max]
				var eq_w = font.get_string_size(eq_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x + 8
				var eq_x = draw_cx + 6.0
				var eq_y = draw_cy + 36.0
				draw_rect(Rect2(eq_x, eq_y, eq_w, 13), Color(0.02, 0.02, 0.06, 0.8))
				draw_rect(Rect2(eq_x, eq_y, eq_w, 13), Color(0.7, 0.35, 0.9, 0.3), false, 1.0)
				_udraw(font, Vector2(eq_x + 4, eq_y + 10), eq_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.7, 0.35, 0.9, 0.8))

		# === Enhancement 7: Total damage dealt on card ===
		if unlocked:
			var total_dmg = 0.0
			for key in session_damage:
				if key == tower_type:
					total_dmg = session_damage[key]
			# Check lifetime damage from survivor_progress
			var sp2 = survivor_progress.get(tower_type, {})
			var lifetime_dmg = sp2.get("total_damage", 0.0)
			if lifetime_dmg > 0:
				var dmg_str = ""
				if lifetime_dmg >= 1000000:
					dmg_str = "%.1fM" % (lifetime_dmg / 1000000.0)
				elif lifetime_dmg >= 1000:
					dmg_str = "%.1fK" % (lifetime_dmg / 1000.0)
				else:
					dmg_str = str(int(lifetime_dmg))
				var dmg_w = font.get_string_size(dmg_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x
				_udraw(font, Vector2(draw_cx + draw_cw - dmg_w - 8, draw_cy + draw_ch - 46), dmg_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.7, 0.7, 0.7, 0.5))

		# === Character name plate (bottom) ===
		var name_plate_y = draw_cy + draw_ch - 38.0
		draw_rect(Rect2(draw_cx, name_plate_y, draw_cw, 38), Color(0.03, 0.03, 0.08, 0.85))
		draw_rect(Rect2(draw_cx, name_plate_y, draw_cw, 1), Color(accent.r, accent.g, accent.b, 0.3))
		var name_str: String = info["name"]
		var name_w = font.get_string_size(name_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
		# Name with shadow
		_udraw(font, Vector2(draw_cx + (draw_cw - name_w) * 0.5 + 1, name_plate_y + 16), name_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.5))
		_udraw(font, Vector2(draw_cx + (draw_cw - name_w) * 0.5, name_plate_y + 15), name_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_parchment if unlocked else Color(0.4, 0.38, 0.45))
		# Novel subtitle
		var novel_str = character_novels[i] if i < character_novels.size() else ""
		if novel_str.length() > 22:
			novel_str = novel_str.substr(0, 20) + ".."
		var novel_w = font.get_string_size(novel_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x
		_udraw(font, Vector2(draw_cx + (draw_cw - novel_w) * 0.5, name_plate_y + 30), novel_str, HORIZONTAL_ALIGNMENT_LEFT, int(draw_cw - 8), 14, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.6) if unlocked else Color(0.3, 0.28, 0.35, 0.5))

		# === Enhancement 3: XP progress bar under name ===
		if unlocked:
			var progress_data = survivor_progress.get(tower_type, {"level": 1})
			var xp_lvl = progress_data.get("level", 1)
			var xp_ratio = clampf(float(xp_lvl) / 9.0, 0.0, 1.0)  # max level ~9
			var bar_y = draw_cy + draw_ch - 6.0
			var bar_x = draw_cx + 8.0
			var bar_w = draw_cw - 16.0
			draw_rect(Rect2(bar_x, bar_y, bar_w, 3), Color(0.1, 0.1, 0.15, 0.6))
			draw_rect(Rect2(bar_x, bar_y, bar_w * xp_ratio, 3), Color(accent.r, accent.g, accent.b, 0.7))

		# === Enhancement 4: Stat preview mini-bars on hover ===
		if is_hovered and unlocked:
			var stat_x = draw_cx + 8.0
			var stat_y = draw_cy + draw_ch - 32.0
			var stat_w = 50.0
			var stat_names = ["DMG", "SPD", "RNG"]
			var stat_values = [info.get("damage", 25) / 55.0, info.get("fire_rate", 0.5) / 1.0, info.get("range", 160) / 200.0]
			var stat_colors = [Color(0.9, 0.3, 0.2), Color(0.3, 0.8, 0.4), Color(0.3, 0.5, 0.9)]
			for si in range(3):
				var sy = stat_y + float(si) * 12.0
				_udraw(font, Vector2(stat_x, sy + 6), stat_names[si], HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.7, 0.7, 0.7, 0.7))
				draw_rect(Rect2(stat_x + 22, sy + 1, stat_w, 4), Color(0.15, 0.15, 0.2, 0.5))
				draw_rect(Rect2(stat_x + 22, sy + 1, stat_w * clampf(stat_values[si], 0.0, 1.0), 4), stat_colors[si])

		# === Card border frame ===
		var bdr_col: Color
		if not unlocked:
			bdr_col = Color(0.25, 0.25, 0.35, 0.4)
		elif is_hovered:
			bdr_col = Color(accent.r, accent.g, accent.b, 0.8)
		else:
			bdr_col = Color(accent.r, accent.g, accent.b, 0.4)
		# Outer border (thick frame like BATTD)
		draw_rect(Rect2(draw_cx, draw_cy, draw_cw, 3), bdr_col)
		draw_rect(Rect2(draw_cx, draw_cy + draw_ch - 3, draw_cw, 3), bdr_col)
		draw_rect(Rect2(draw_cx, draw_cy, 3, draw_ch), bdr_col)
		draw_rect(Rect2(draw_cx + draw_cw - 3, draw_cy, 3, draw_ch), bdr_col)

		# === Enhancement 5: Tier border glow ===
		if unlocked:
			var tier_data = survivor_progress.get(tower_type, {"level": 1})
			var tier = tier_data.get("level", 1)
			var tier_col = Color(0.6, 0.4, 0.2, 0.15)  # bronze
			if tier >= 7:
				tier_col = Color(0.4, 0.8, 1.0, 0.2)  # diamond
			elif tier >= 5:
				tier_col = Color(0.85, 0.7, 0.2, 0.2)  # gold
			elif tier >= 3:
				tier_col = Color(0.7, 0.72, 0.78, 0.18)  # silver
			draw_rect(Rect2(draw_cx - 2, draw_cy - 2, draw_cw + 4, draw_ch + 4), tier_col)

		# === Locked overlay ===
		if not unlocked:
			draw_rect(Rect2(draw_cx + 3, draw_cy + 3, draw_cw - 6, draw_ch - 6), Color(0.0, 0.0, 0.02, 0.6))
			# Padlock
			var lock_cx = draw_cx + draw_cw * 0.5
			var lock_cy = draw_cy + draw_ch * 0.4
			draw_rect(Rect2(lock_cx - 14, lock_cy, 28, 22), Color(0.3, 0.25, 0.40, 0.7))
			draw_arc(Vector2(lock_cx, lock_cy), 11, PI, TAU, 12, Color(0.35, 0.30, 0.45, 0.7), 3.0)
			draw_circle(Vector2(lock_cx, lock_cy + 10), 3, Color(0.04, 0.04, 0.10))
			draw_rect(Rect2(lock_cx - 1.5, lock_cy + 11, 3, 5), Color(0.04, 0.04, 0.10))

		# === Hover glow ===
		if unlocked and is_hovered:
			var glow_a = 0.10 + 0.05 * sin(_time * 3.0)
			draw_rect(Rect2(draw_cx + 3, draw_cy + 3, draw_cw - 6, draw_ch - 6), Color(accent.r, accent.g, accent.b, glow_a))
			# Bright border on hover
			draw_rect(Rect2(draw_cx, draw_cy, draw_cw, 3), Color(accent.r, accent.g, accent.b, 0.9))
			draw_rect(Rect2(draw_cx, draw_cy + draw_ch - 3, draw_cw, 3), Color(accent.r, accent.g, accent.b, 0.9))
			draw_rect(Rect2(draw_cx, draw_cy, 3, draw_ch), Color(accent.r, accent.g, accent.b, 0.9))
			draw_rect(Rect2(draw_cx + draw_cw - 3, draw_cy, 3, draw_ch), Color(accent.r, accent.g, accent.b, 0.9))

		# === Enhancement 9: Character-themed particles on hovered card ===
		if unlocked and is_hovered:
			for pi in range(4):
				var pa = _time * 1.5 + float(pi) * 1.6 + float(i) * 0.5
				var py_off = sin(pa) * (draw_ch * 0.3)
				var px_off = cos(pa * 0.7) * (draw_cw * 0.3)
				var pp = Vector2(draw_cx + draw_cw * 0.5 + px_off, draw_cy + draw_ch * 0.4 + py_off)
				var p_alpha = 0.2 + sin(_time * 3.0 + float(pi)) * 0.1
				draw_circle(pp, 2.0, Color(accent.r, accent.g, accent.b, p_alpha))

func _draw_new_character_portrait(idx: int, center: Vector2, col: Color) -> void:
	var cx = center.x
	var cy = center.y
	var head_y = cy - 20
	var body_y = cy - 8
	# Head
	draw_circle(Vector2(cx, head_y), 8, Color(0.85, 0.72, 0.55, 0.8))
	# Eyes
	draw_circle(Vector2(cx - 3, head_y - 1), 1.5, Color(0.1, 0.1, 0.1, 0.7))
	draw_circle(Vector2(cx + 3, head_y - 1), 1.5, Color(0.1, 0.1, 0.1, 0.7))
	# Body
	draw_colored_polygon(PackedVector2Array([Vector2(cx - 8, body_y), Vector2(cx + 8, body_y), Vector2(cx + 12, body_y + 22), Vector2(cx - 12, body_y + 22)]), Color(col.r, col.g, col.b, 0.7))
	match idx:
		6:  # Sherlock - deerstalker hat + pipe
			draw_rect(Rect2(cx - 8, head_y - 10, 16, 6), Color(0.35, 0.25, 0.15, 0.7))
			draw_rect(Rect2(cx - 10, head_y - 5, 20, 3), Color(0.35, 0.25, 0.15, 0.6))
			# Pipe
			draw_line(Vector2(cx + 5, head_y + 4), Vector2(cx + 15, head_y + 2), Color(0.4, 0.3, 0.15, 0.6), 2.0)
			draw_rect(Rect2(cx + 13, head_y - 4, 5, 6), Color(0.4, 0.3, 0.15, 0.6))
		7:  # Tarzan - wild hair + loincloth
			for hi in range(5):
				var hx = cx - 6 + hi * 3
				var hy = head_y - 8 - (hi % 2) * 3
				draw_line(Vector2(hx, hy), Vector2(hx + 1, head_y - 3), Color(0.35, 0.25, 0.1, 0.6), 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 6, body_y + 16), Vector2(cx + 6, body_y + 16), Vector2(cx + 4, body_y + 24), Vector2(cx - 4, body_y + 24)]), Color(0.5, 0.35, 0.15, 0.6))
		8:  # Dracula - high collar cape
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 12, body_y - 4), Vector2(cx + 12, body_y - 4), Vector2(cx + 20, body_y + 25), Vector2(cx - 20, body_y + 25)]), Color(0.15, 0.02, 0.02, 0.6))
			# High collar
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 6, head_y + 4), Vector2(cx - 10, head_y - 2), Vector2(cx - 8, body_y)]), Color(0.15, 0.02, 0.02, 0.7))
			draw_colored_polygon(PackedVector2Array([Vector2(cx + 6, head_y + 4), Vector2(cx + 10, head_y - 2), Vector2(cx + 8, body_y)]), Color(0.15, 0.02, 0.02, 0.7))
			# Fangs
			draw_line(Vector2(cx - 2, head_y + 4), Vector2(cx - 2, head_y + 7), Color(0.9, 0.9, 0.9, 0.5), 1.0)
			draw_line(Vector2(cx + 2, head_y + 4), Vector2(cx + 2, head_y + 7), Color(0.9, 0.9, 0.9, 0.5), 1.0)
		9:  # Merlin - wizard hat + staff
			draw_colored_polygon(PackedVector2Array([Vector2(cx, head_y - 22), Vector2(cx - 10, head_y - 6), Vector2(cx + 10, head_y - 6)]), Color(0.15, 0.10, 0.40, 0.7))
			draw_rect(Rect2(cx - 12, head_y - 7, 24, 3), Color(0.15, 0.10, 0.40, 0.6))
			# Staff
			draw_line(Vector2(cx + 15, body_y - 5), Vector2(cx + 15, body_y + 24), Color(0.5, 0.35, 0.15, 0.6), 2.0)
			draw_circle(Vector2(cx + 15, body_y - 5), 4, Color(0.4, 0.3, 0.8, 0.5))
		10:  # Frankenstein - flat top head + bolts
			draw_rect(Rect2(cx - 8, head_y - 10, 16, 4), Color(0.3, 0.35, 0.25, 0.7))
			# Neck bolts
			draw_circle(Vector2(cx - 10, head_y + 4), 2, Color(0.5, 0.5, 0.5, 0.6))
			draw_circle(Vector2(cx + 10, head_y + 4), 2, Color(0.5, 0.5, 0.5, 0.6))
			# Stitches on forehead
			draw_line(Vector2(cx - 4, head_y - 5), Vector2(cx + 4, head_y - 5), Color(0.2, 0.2, 0.2, 0.5), 1.0)
			draw_line(Vector2(cx - 2, head_y - 7), Vector2(cx - 2, head_y - 3), Color(0.2, 0.2, 0.2, 0.5), 1.0)
			draw_line(Vector2(cx + 2, head_y - 7), Vector2(cx + 2, head_y - 3), Color(0.2, 0.2, 0.2, 0.5), 1.0)

func _draw_zone_character(idx: int, center: Vector2, col: Color, pulse: float) -> void:
	var cx = center.x
	var cy = center.y + pulse
	var head_y = cy - 20
	var body_y = cy - 8

	# Head
	draw_circle(Vector2(cx, head_y), 8, Color(0.85, 0.72, 0.55, 0.8))
	# Eyes
	draw_circle(Vector2(cx - 3, head_y - 1), 1.5, Color(0.1, 0.1, 0.1, 0.7))
	draw_circle(Vector2(cx + 3, head_y - 1), 1.5, Color(0.1, 0.1, 0.1, 0.7))
	# Body (trapezoid)
	draw_colored_polygon(PackedVector2Array([Vector2(cx - 8, body_y), Vector2(cx + 8, body_y), Vector2(cx + 12, body_y + 22), Vector2(cx - 12, body_y + 22)]), Color(col.r, col.g, col.b, 0.7))

	match idx:
		0:  # Robin Hood - hat + bow
			draw_colored_polygon(PackedVector2Array([Vector2(cx, head_y - 16), Vector2(cx - 10, head_y - 6), Vector2(cx + 6, head_y - 6)]), Color(0.2, 0.4, 0.1, 0.7))
			draw_line(Vector2(cx + 2, head_y - 14), Vector2(cx + 8, head_y - 20), Color(0.8, 0.2, 0.1, 0.5), 1.5)
			draw_arc(Vector2(cx + 20, cy + pulse), 10, -PI * 0.4, PI * 0.4, 12, Color(0.5, 0.35, 0.15, 0.6), 2.0)
		1:  # Alice - hair + cards
			draw_rect(Rect2(cx - 9, head_y - 6, 18, 4), Color(0.9, 0.8, 0.4, 0.6))
			draw_rect(Rect2(cx - 10, head_y - 2, 3, 16), Color(0.9, 0.8, 0.4, 0.5))
			draw_rect(Rect2(cx + 7, head_y - 2, 3, 16), Color(0.9, 0.8, 0.4, 0.5))
			draw_rect(Rect2(cx - 9, head_y - 7, 18, 2), Color(0.3, 0.5, 0.8, 0.6))
			draw_rect(Rect2(cx + 14, body_y + 2, 8, 12), Color(0.9, 0.87, 0.8, 0.5))
			draw_circle(Vector2(cx + 18, body_y + 8), 2, Color(0.8, 0.15, 0.2, 0.5))
		2:  # Wicked Witch - pointy hat + broom
			draw_colored_polygon(PackedVector2Array([Vector2(cx, head_y - 22), Vector2(cx - 10, head_y - 6), Vector2(cx + 10, head_y - 6)]), Color(0.1, 0.1, 0.1, 0.7))
			draw_rect(Rect2(cx - 12, head_y - 7, 24, 3), Color(0.1, 0.1, 0.1, 0.6))
			draw_line(Vector2(cx - 15, body_y + 5), Vector2(cx - 25, body_y + 25), Color(0.5, 0.35, 0.15, 0.6), 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 28, body_y + 22), Vector2(cx - 22, body_y + 22), Vector2(cx - 25, body_y + 32)]), Color(0.4, 0.3, 0.1, 0.5))
			draw_circle(Vector2(cx, head_y), 8, Color(0.3, 0.6, 0.2, 0.15))
		3:  # Peter Pan - cap + dagger
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 8, head_y - 6), Vector2(cx + 8, head_y - 6), Vector2(cx + 12, head_y - 12)]), Color(0.2, 0.5, 0.15, 0.7))
			draw_line(Vector2(cx + 10, head_y - 12), Vector2(cx + 16, head_y - 20), Color(0.9, 0.3, 0.1, 0.5), 1.5)
			draw_line(Vector2(cx + 14, body_y + 4), Vector2(cx + 22, body_y - 2), Color(0.7, 0.72, 0.75, 0.6), 2.0)
			draw_line(Vector2(cx + 13, body_y + 5), Vector2(cx + 16, body_y + 3), Color(0.5, 0.35, 0.15, 0.6), 2.0)
		4:  # Phantom - cape + mask
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 10, body_y - 2), Vector2(cx + 10, body_y - 2), Vector2(cx + 18, body_y + 25), Vector2(cx - 18, body_y + 25)]), Color(0.1, 0.08, 0.08, 0.6))
			draw_arc(Vector2(cx, head_y), 8, PI + 0.2, TAU - 0.2, 12, Color(0.9, 0.88, 0.82, 0.6), 2.5)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 8, body_y), Vector2(cx + 8, body_y), Vector2(cx + 10, body_y + 20), Vector2(cx - 10, body_y + 20)]), Color(col.r, col.g, col.b, 0.7))
		5:  # Scrooge - top hat + cane
			draw_rect(Rect2(cx - 8, head_y - 18, 16, 14), Color(0.1, 0.1, 0.1, 0.7))
			draw_rect(Rect2(cx - 11, head_y - 5, 22, 3), Color(0.1, 0.1, 0.1, 0.6))
			draw_line(Vector2(cx + 14, body_y + 2), Vector2(cx + 14, body_y + 24), Color(0.4, 0.3, 0.15, 0.6), 2.0)
			draw_arc(Vector2(cx + 14, body_y + 2), 4, PI, TAU, 8, Color(0.4, 0.3, 0.15, 0.6), 2.0)

func _update_world_map_hover() -> void:
	var mouse_pos = get_viewport().get_mouse_position()
	world_map_hover_index = -1
	var panel_x = 70.0
	var panel_w = 1140.0
	var card_w = 170.0
	var card_h = 230.0
	var gap_x = 12.0
	var gap_y = 12.0
	var grid_start_y = 38.0 + 42.0
	for i in range(survivor_types.size()):
		var row_i: int
		var col_i: int
		var cards_in_row: int
		if i < 6:
			row_i = 0
			col_i = i
			cards_in_row = 6
		else:
			row_i = 1
			col_i = i - 6
			cards_in_row = survivor_types.size() - 6
		var row_w = float(cards_in_row) * card_w + float(cards_in_row - 1) * gap_x
		var row_x = panel_x + (panel_w - row_w) * 0.5
		var cx = row_x + float(col_i) * (card_w + gap_x)
		var cy = grid_start_y + float(row_i) * (card_h + gap_y)
		if Rect2(cx, cy, card_w, card_h).has_point(mouse_pos):
			world_map_hover_index = i
			break

func _draw_relic_icon(center: Vector2, icon_key: String, sz: float, accent: Color) -> void:
	var cx = center.x
	var cy = center.y
	var s = sz * 0.5
	match icon_key:
		"green_cloak":
			# Cloak shape - triangular drape
			var cloak_col = Color(0.2, 0.55, 0.15, 0.8)
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy - s * 0.8), Vector2(cx + s * 0.7, cy + s * 0.8), Vector2(cx - s * 0.7, cy + s * 0.8)]), cloak_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.3, cy - s * 0.6), Vector2(cx + s * 0.3, cy - s * 0.6), Vector2(cx + s * 0.15, cy - s * 0.35), Vector2(cx - s * 0.15, cy - s * 0.35)]), Color(0.15, 0.45, 0.1, 0.9))
			# Clasp
			draw_circle(Vector2(cx, cy - s * 0.45), s * 0.12, Color(0.85, 0.65, 0.1))
		"silver_arrow":
			# Arrow pointing right
			var arr_col = Color(0.8, 0.82, 0.85, 0.9)
			draw_line(Vector2(cx - s * 0.8, cy), Vector2(cx + s * 0.5, cy), arr_col, 2.0)
			# Arrowhead
			draw_colored_polygon(PackedVector2Array([Vector2(cx + s * 0.8, cy), Vector2(cx + s * 0.4, cy - s * 0.25), Vector2(cx + s * 0.4, cy + s * 0.25)]), arr_col)
			# Fletching
			draw_line(Vector2(cx - s * 0.8, cy), Vector2(cx - s * 0.6, cy - s * 0.2), Color(0.6, 0.5, 0.4), 1.5)
			draw_line(Vector2(cx - s * 0.8, cy), Vector2(cx - s * 0.6, cy + s * 0.2), Color(0.6, 0.5, 0.4), 1.5)
		"longbow":
			# Curved bow
			var bow_col = Color(0.55, 0.35, 0.15, 0.9)
			draw_arc(Vector2(cx + s * 0.3, cy), s * 0.75, PI * 0.6, PI * 1.4, 12, bow_col, 2.5)
			# String
			draw_line(Vector2(cx + s * 0.3 - s * 0.75 * cos(PI * 0.6), cy - s * 0.75 * sin(PI * 0.6)), Vector2(cx + s * 0.3 - s * 0.75 * cos(PI * 1.4), cy - s * 0.75 * sin(PI * 1.4)), Color(0.7, 0.65, 0.55), 1.0)
		"flask":
			# Bottle shape
			var flask_col = Color(0.5, 0.35, 0.15, 0.7)
			# Neck
			draw_rect(Rect2(cx - s * 0.12, cy - s * 0.7, s * 0.24, s * 0.35), flask_col)
			# Body
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.12, cy - s * 0.35), Vector2(cx + s * 0.12, cy - s * 0.35), Vector2(cx + s * 0.35, cy - s * 0.05), Vector2(cx + s * 0.35, cy + s * 0.65), Vector2(cx - s * 0.35, cy + s * 0.65), Vector2(cx - s * 0.35, cy - s * 0.05)]), flask_col)
			# Liquid
			draw_rect(Rect2(cx - s * 0.3, cy + s * 0.15, s * 0.6, s * 0.45), Color(0.8, 0.6, 0.1, 0.6))
			# Cork
			draw_rect(Rect2(cx - s * 0.15, cy - s * 0.75, s * 0.3, s * 0.1), Color(0.6, 0.45, 0.2))
		"horn":
			# Curved horn
			var horn_col = Color(0.7, 0.55, 0.25, 0.85)
			draw_arc(Vector2(cx, cy + s * 0.3), s * 0.7, PI * 1.2, PI * 1.9, 10, horn_col, 3.5)
			# Bell end
			draw_circle(Vector2(cx + s * 0.55, cy - s * 0.15), s * 0.2, horn_col)
			draw_circle(Vector2(cx + s * 0.55, cy - s * 0.15), s * 0.12, Color(0.3, 0.2, 0.1, 0.5))
			# Mouthpiece
			draw_circle(Vector2(cx - s * 0.45, cy + s * 0.35), s * 0.08, horn_col)
		"gold_crown":
			# Crown
			var crown_col = Color(0.9, 0.7, 0.1, 0.9)
			# Base band
			draw_rect(Rect2(cx - s * 0.55, cy + s * 0.1, s * 1.1, s * 0.35), crown_col)
			# Three points
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.55, cy + s * 0.1), Vector2(cx - s * 0.35, cy - s * 0.5), Vector2(cx - s * 0.15, cy + s * 0.1)]), crown_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.2, cy + s * 0.1), Vector2(cx, cy - s * 0.65), Vector2(cx + s * 0.2, cy + s * 0.1)]), crown_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx + s * 0.15, cy + s * 0.1), Vector2(cx + s * 0.35, cy - s * 0.5), Vector2(cx + s * 0.55, cy + s * 0.1)]), crown_col)
			# Gems
			draw_circle(Vector2(cx, cy + s * 0.25), s * 0.1, Color(0.8, 0.1, 0.1, 0.8))
			draw_circle(Vector2(cx - s * 0.3, cy + s * 0.25), s * 0.07, Color(0.1, 0.4, 0.8, 0.8))
			draw_circle(Vector2(cx + s * 0.3, cy + s * 0.25), s * 0.07, Color(0.1, 0.8, 0.3, 0.8))
		"drink_me":
			# Small bottle with label
			var bottle_col = Color(0.3, 0.5, 0.8, 0.7)
			draw_rect(Rect2(cx - s * 0.1, cy - s * 0.65, s * 0.2, s * 0.3), bottle_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.1, cy - s * 0.35), Vector2(cx + s * 0.1, cy - s * 0.35), Vector2(cx + s * 0.3, cy - s * 0.1), Vector2(cx + s * 0.3, cy + s * 0.65), Vector2(cx - s * 0.3, cy + s * 0.65), Vector2(cx - s * 0.3, cy - s * 0.1)]), bottle_col)
			# Liquid shimmer
			draw_rect(Rect2(cx - s * 0.25, cy + s * 0.2, s * 0.5, s * 0.4), Color(0.4, 0.2, 0.7, 0.5))
			# Label tag
			draw_rect(Rect2(cx - s * 0.18, cy - s * 0.05, s * 0.36, s * 0.18), Color(0.9, 0.85, 0.7, 0.8))
			# Cork
			draw_rect(Rect2(cx - s * 0.12, cy - s * 0.72, s * 0.24, s * 0.1), Color(0.6, 0.45, 0.2))
		"eat_me_cake":
			# Frosted cake
			var cake_col = Color(0.75, 0.55, 0.3, 0.85)
			# Base
			draw_rect(Rect2(cx - s * 0.45, cy + s * 0.1, s * 0.9, s * 0.45), cake_col)
			# Frosting top
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.5, cy + s * 0.1), Vector2(cx + s * 0.5, cy + s * 0.1), Vector2(cx + s * 0.45, cy - s * 0.15), Vector2(cx - s * 0.45, cy - s * 0.15)]), Color(0.95, 0.85, 0.9, 0.9))
			# Cherry on top
			draw_circle(Vector2(cx, cy - s * 0.3), s * 0.12, Color(0.9, 0.15, 0.15, 0.9))
			# Drip frosting
			draw_rect(Rect2(cx - s * 0.15, cy + s * 0.1, s * 0.08, s * 0.15), Color(0.95, 0.85, 0.9, 0.7))
			draw_rect(Rect2(cx + s * 0.12, cy + s * 0.1, s * 0.08, s * 0.2), Color(0.95, 0.85, 0.9, 0.7))
		"vorpal_sword":
			# Jagged blade
			var blade_col = Color(0.75, 0.8, 0.85, 0.9)
			# Blade
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.05, cy + s * 0.5), Vector2(cx + s * 0.05, cy + s * 0.5), Vector2(cx + s * 0.08, cy - s * 0.1), Vector2(cx + s * 0.15, cy - s * 0.25), Vector2(cx + s * 0.05, cy - s * 0.4), Vector2(cx + s * 0.1, cy - s * 0.6), Vector2(cx, cy - s * 0.8), Vector2(cx - s * 0.1, cy - s * 0.6), Vector2(cx - s * 0.05, cy - s * 0.4), Vector2(cx - s * 0.15, cy - s * 0.25), Vector2(cx - s * 0.08, cy - s * 0.1)]), blade_col)
			# Guard
			draw_rect(Rect2(cx - s * 0.25, cy + s * 0.45, s * 0.5, s * 0.08), Color(0.85, 0.65, 0.1, 0.8))
			# Handle
			draw_rect(Rect2(cx - s * 0.06, cy + s * 0.53, s * 0.12, s * 0.25), Color(0.5, 0.3, 0.15, 0.9))
		"heart_scepter":
			# Scepter with heart top
			var scepter_col = Color(0.85, 0.65, 0.1, 0.9)
			# Shaft
			draw_rect(Rect2(cx - s * 0.06, cy - s * 0.15, s * 0.12, s * 0.85), scepter_col)
			# Heart
			var hx = cx
			var hy = cy - s * 0.4
			draw_circle(Vector2(hx - s * 0.12, hy - s * 0.06), s * 0.15, Color(0.9, 0.1, 0.2, 0.9))
			draw_circle(Vector2(hx + s * 0.12, hy - s * 0.06), s * 0.15, Color(0.9, 0.1, 0.2, 0.9))
			draw_colored_polygon(PackedVector2Array([Vector2(hx - s * 0.26, hy), Vector2(hx, hy + s * 0.3), Vector2(hx + s * 0.26, hy)]), Color(0.9, 0.1, 0.2, 0.9))
		"pocket_watch":
			# Pocket watch
			var watch_col = Color(0.85, 0.7, 0.3, 0.85)
			draw_circle(Vector2(cx, cy + s * 0.05), s * 0.55, watch_col)
			draw_circle(Vector2(cx, cy + s * 0.05), s * 0.45, Color(0.95, 0.92, 0.85, 0.9))
			# Clock hands
			draw_line(Vector2(cx, cy + s * 0.05), Vector2(cx, cy - s * 0.2), Color(0.2, 0.15, 0.1), 1.5)
			draw_line(Vector2(cx, cy + s * 0.05), Vector2(cx + s * 0.15, cy + s * 0.15), Color(0.2, 0.15, 0.1), 1.5)
			# Ring at top
			draw_arc(Vector2(cx, cy - s * 0.55), s * 0.12, 0, TAU, 8, watch_col, 2.0)
			# Chain hint
			draw_line(Vector2(cx, cy - s * 0.67), Vector2(cx + s * 0.3, cy - s * 0.75), watch_col, 1.5)
		"cheshire_grin":
			# Floating grin
			var grin_col = Color(0.9, 0.4, 0.8, 0.8)
			draw_arc(Vector2(cx, cy), s * 0.5, 0.15, PI - 0.15, 12, grin_col, 2.5)
			# Teeth
			for ti in range(5):
				var tx = cx - s * 0.35 + float(ti) * s * 0.175
				draw_rect(Rect2(tx, cy - s * 0.04, s * 0.12, s * 0.12), Color(0.95, 0.95, 0.9, 0.8))
			# Eyes (floating above)
			draw_circle(Vector2(cx - s * 0.25, cy - s * 0.35), s * 0.1, grin_col)
			draw_circle(Vector2(cx + s * 0.25, cy - s * 0.35), s * 0.1, grin_col)
			draw_circle(Vector2(cx - s * 0.25, cy - s * 0.35), s * 0.04, Color(0.1, 0.1, 0.1))
			draw_circle(Vector2(cx + s * 0.25, cy - s * 0.35), s * 0.04, Color(0.1, 0.1, 0.1))
		"ruby_slippers":
			# Red shoes
			var shoe_col = Color(0.85, 0.1, 0.15, 0.9)
			# Left shoe
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.6, cy + s * 0.1), Vector2(cx - s * 0.1, cy + s * 0.1), Vector2(cx - s * 0.1, cy + s * 0.4), Vector2(cx - s * 0.7, cy + s * 0.4), Vector2(cx - s * 0.75, cy + s * 0.25)]), shoe_col)
			# Right shoe
			draw_colored_polygon(PackedVector2Array([Vector2(cx + s * 0.1, cy + s * 0.1), Vector2(cx + s * 0.6, cy + s * 0.1), Vector2(cx + s * 0.75, cy + s * 0.25), Vector2(cx + s * 0.7, cy + s * 0.4), Vector2(cx + s * 0.1, cy + s * 0.4)]), shoe_col)
			# Sparkles
			draw_circle(Vector2(cx - s * 0.4, cy + s * 0.2), s * 0.05, Color(1.0, 0.8, 0.8, 0.9))
			draw_circle(Vector2(cx + s * 0.4, cy + s * 0.2), s * 0.05, Color(1.0, 0.8, 0.8, 0.9))
			draw_circle(Vector2(cx - s * 0.25, cy + s * 0.15), s * 0.03, Color(1.0, 1.0, 0.9, 0.7))
			draw_circle(Vector2(cx + s * 0.5, cy + s * 0.3), s * 0.03, Color(1.0, 1.0, 0.9, 0.7))
			# Heels
			draw_rect(Rect2(cx - s * 0.15, cy + s * 0.4, s * 0.08, s * 0.2), shoe_col)
			draw_rect(Rect2(cx + s * 0.55, cy + s * 0.4, s * 0.08, s * 0.2), shoe_col)
		"crystal_ball":
			# Glass orb on stand
			var orb_col = Color(0.6, 0.7, 0.9, 0.5)
			draw_circle(Vector2(cx, cy - s * 0.1), s * 0.45, orb_col)
			draw_arc(Vector2(cx, cy - s * 0.1), s * 0.45, 0, TAU, 16, Color(0.7, 0.8, 1.0, 0.6), 1.5)
			# Inner glow
			draw_circle(Vector2(cx - s * 0.1, cy - s * 0.2), s * 0.12, Color(0.8, 0.9, 1.0, 0.4))
			# Stand
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.2, cy + s * 0.3), Vector2(cx + s * 0.2, cy + s * 0.3), Vector2(cx + s * 0.35, cy + s * 0.6), Vector2(cx - s * 0.35, cy + s * 0.6)]), Color(0.5, 0.4, 0.2, 0.8))
		"monkey_fez":
			# Red fez hat
			var fez_col = Color(0.8, 0.15, 0.1, 0.9)
			# Main body
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.35, cy + s * 0.3), Vector2(cx + s * 0.35, cy + s * 0.3), Vector2(cx + s * 0.25, cy - s * 0.35), Vector2(cx - s * 0.25, cy - s * 0.35)]), fez_col)
			# Flat top
			draw_rect(Rect2(cx - s * 0.28, cy - s * 0.4, s * 0.56, s * 0.08), fez_col)
			# Tassel
			draw_line(Vector2(cx + s * 0.15, cy - s * 0.4), Vector2(cx + s * 0.45, cy - s * 0.15), Color(0.85, 0.7, 0.1), 1.5)
			draw_circle(Vector2(cx + s * 0.45, cy - s * 0.15), s * 0.06, Color(0.85, 0.7, 0.1))
			# Brim
			draw_rect(Rect2(cx - s * 0.4, cy + s * 0.28, s * 0.8, s * 0.06), Color(0.6, 0.1, 0.08, 0.9))
		"poppy_dust":
			# Red flowers
			var poppy_col = Color(0.9, 0.15, 0.1, 0.8)
			# Three poppies
			for pi in range(3):
				var px = cx - s * 0.35 + float(pi) * s * 0.35
				var py = cy - s * 0.1 + sin(float(pi) * 1.5) * s * 0.15
				for petal in range(5):
					var angle = float(petal) * TAU / 5.0
					var ppx = px + cos(angle) * s * 0.15
					var ppy = py + sin(angle) * s * 0.15
					draw_circle(Vector2(ppx, ppy), s * 0.1, poppy_col)
				draw_circle(Vector2(px, py), s * 0.06, Color(0.15, 0.1, 0.05))
			# Dust particles
			draw_circle(Vector2(cx + s * 0.3, cy - s * 0.4), s * 0.04, Color(1.0, 0.8, 0.3, 0.5))
			draw_circle(Vector2(cx - s * 0.2, cy - s * 0.5), s * 0.03, Color(1.0, 0.8, 0.3, 0.4))
		"golden_cap":
			# Gold cap
			var cap_col = Color(0.9, 0.75, 0.15, 0.9)
			# Dome
			draw_arc(Vector2(cx, cy + s * 0.1), s * 0.45, PI, TAU, 12, cap_col, 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.45, cy + s * 0.1), Vector2(cx + s * 0.45, cy + s * 0.1), Vector2(cx + s * 0.3, cy - s * 0.3), Vector2(cx, cy - s * 0.45), Vector2(cx - s * 0.3, cy - s * 0.3)]), cap_col)
			# Brim
			draw_rect(Rect2(cx - s * 0.55, cy + s * 0.08, s * 1.1, s * 0.1), Color(0.85, 0.65, 0.1, 0.9))
			# Center jewel
			draw_circle(Vector2(cx, cy - s * 0.1), s * 0.1, Color(0.6, 0.1, 0.5, 0.9))
			# Rune marks
			draw_line(Vector2(cx - s * 0.2, cy + s * 0.0), Vector2(cx - s * 0.1, cy - s * 0.15), Color(0.5, 0.1, 0.4, 0.5), 1.0)
			draw_line(Vector2(cx + s * 0.1, cy - s * 0.15), Vector2(cx + s * 0.2, cy + s * 0.0), Color(0.5, 0.1, 0.4, 0.5), 1.0)
		"hourglass":
			# Hourglass
			var glass_col = Color(0.7, 0.6, 0.4, 0.8)
			# Top triangle
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.4, cy - s * 0.7), Vector2(cx + s * 0.4, cy - s * 0.7), Vector2(cx, cy)]), Color(0.85, 0.75, 0.55, 0.5))
			# Bottom triangle
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy), Vector2(cx + s * 0.4, cy + s * 0.7), Vector2(cx - s * 0.4, cy + s * 0.7)]), Color(0.85, 0.75, 0.55, 0.5))
			# Sand (bottom fill)
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy + s * 0.2), Vector2(cx + s * 0.3, cy + s * 0.7), Vector2(cx - s * 0.3, cy + s * 0.7)]), Color(0.9, 0.75, 0.3, 0.7))
			# Frame bars
			draw_rect(Rect2(cx - s * 0.45, cy - s * 0.75, s * 0.9, s * 0.08), glass_col)
			draw_rect(Rect2(cx - s * 0.45, cy + s * 0.67, s * 0.9, s * 0.08), glass_col)
		"fairy_vial":
			# Glowing vial
			var vial_col = Color(0.4, 0.8, 0.5, 0.6)
			# Bottle body
			draw_rect(Rect2(cx - s * 0.08, cy - s * 0.6, s * 0.16, s * 0.25), Color(0.6, 0.7, 0.65, 0.6))
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.08, cy - s * 0.35), Vector2(cx + s * 0.08, cy - s * 0.35), Vector2(cx + s * 0.25, cy - s * 0.1), Vector2(cx + s * 0.25, cy + s * 0.6), Vector2(cx - s * 0.25, cy + s * 0.6), Vector2(cx - s * 0.25, cy - s * 0.1)]), vial_col)
			# Glow
			draw_circle(Vector2(cx, cy + s * 0.1), s * 0.3, Color(0.5, 1.0, 0.6, 0.2))
			# Sparkles
			draw_circle(Vector2(cx - s * 0.08, cy), s * 0.04, Color(1.0, 1.0, 0.7, 0.8))
			draw_circle(Vector2(cx + s * 0.1, cy + s * 0.25), s * 0.03, Color(1.0, 1.0, 0.7, 0.7))
			draw_circle(Vector2(cx, cy + s * 0.4), s * 0.035, Color(1.0, 1.0, 0.7, 0.6))
		"iron_hook":
			# Captain Hook's hook
			var hook_col = Color(0.6, 0.62, 0.65, 0.9)
			# Shaft
			draw_rect(Rect2(cx - s * 0.07, cy - s * 0.7, s * 0.14, s * 0.6), hook_col)
			# Curved hook
			draw_arc(Vector2(cx, cy + s * 0.1), s * 0.3, PI * 0.0, PI * 1.3, 10, hook_col, 3.0)
			# Point
			var hook_end_x = cx + s * 0.3 * cos(PI * 1.3)
			var hook_end_y = cy + s * 0.1 + s * 0.3 * sin(PI * 1.3)
			draw_circle(Vector2(hook_end_x, hook_end_y), s * 0.05, hook_col)
			# Guard ring
			draw_arc(Vector2(cx, cy - s * 0.15), s * 0.15, 0, TAU, 8, Color(0.85, 0.65, 0.1, 0.6), 2.0)
		"star_map":
			# Star map / scroll with stars
			var map_col = Color(0.75, 0.7, 0.55, 0.8)
			# Scroll body
			draw_rect(Rect2(cx - s * 0.5, cy - s * 0.45, s * 1.0, s * 0.9), Color(0.15, 0.1, 0.25, 0.8))
			# Scroll rolls
			draw_circle(Vector2(cx - s * 0.5, cy - s * 0.45), s * 0.08, map_col)
			draw_circle(Vector2(cx + s * 0.5, cy - s * 0.45), s * 0.08, map_col)
			draw_circle(Vector2(cx - s * 0.5, cy + s * 0.45), s * 0.08, map_col)
			draw_circle(Vector2(cx + s * 0.5, cy + s * 0.45), s * 0.08, map_col)
			# Stars on map
			var star_positions = [Vector2(-0.2, -0.2), Vector2(0.25, -0.1), Vector2(0.0, 0.15), Vector2(-0.3, 0.1), Vector2(0.3, 0.25)]
			for sp in star_positions:
				draw_circle(Vector2(cx + sp.x * s, cy + sp.y * s), s * 0.06, Color(1.0, 0.9, 0.4, 0.8))
			# Constellation lines
			draw_line(Vector2(cx - s * 0.2, cy - s * 0.2), Vector2(cx + s * 0.25, cy - s * 0.1), Color(0.7, 0.7, 0.9, 0.3), 1.0)
			draw_line(Vector2(cx + s * 0.25, cy - s * 0.1), Vector2(cx, cy + s * 0.15), Color(0.7, 0.7, 0.9, 0.3), 1.0)
		"croc_tooth":
			# Large fang
			var tooth_col = Color(0.9, 0.88, 0.8, 0.9)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.2, cy - s * 0.65), Vector2(cx + s * 0.2, cy - s * 0.65), Vector2(cx + s * 0.12, cy + s * 0.15), Vector2(cx, cy + s * 0.7), Vector2(cx - s * 0.12, cy + s * 0.15)]), tooth_col)
			# Root ridges
			draw_line(Vector2(cx - s * 0.12, cy - s * 0.5), Vector2(cx - s * 0.06, cy - s * 0.1), Color(0.7, 0.65, 0.55, 0.4), 1.0)
			draw_line(Vector2(cx + s * 0.12, cy - s * 0.5), Vector2(cx + s * 0.06, cy - s * 0.1), Color(0.7, 0.65, 0.55, 0.4), 1.0)
			# Blood hint
			draw_circle(Vector2(cx, cy + s * 0.55), s * 0.06, Color(0.7, 0.1, 0.1, 0.4))
		"thimble":
			# Silver thimble
			var thimble_col = Color(0.75, 0.78, 0.82, 0.85)
			# Dome top
			draw_arc(Vector2(cx, cy - s * 0.15), s * 0.3, PI, TAU, 10, thimble_col, 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.3, cy - s * 0.15), Vector2(cx + s * 0.3, cy - s * 0.15), Vector2(cx + s * 0.15, cy - s * 0.4), Vector2(cx, cy - s * 0.48), Vector2(cx - s * 0.15, cy - s * 0.4)]), thimble_col)
			# Cylinder body
			draw_rect(Rect2(cx - s * 0.3, cy - s * 0.15, s * 0.6, s * 0.65), thimble_col)
			# Dimple dots
			for row in range(3):
				for col in range(4):
					var dx = cx - s * 0.2 + float(col) * s * 0.13
					var dy = cy - s * 0.35 + float(row) * s * 0.12
					draw_circle(Vector2(dx, dy), s * 0.03, Color(0.6, 0.62, 0.65, 0.6))
			# Bottom rim
			draw_rect(Rect2(cx - s * 0.33, cy + s * 0.45, s * 0.66, s * 0.06), Color(0.65, 0.68, 0.72, 0.9))
		"shadow_thread":
			# Dark thread / wispy shadow
			var thread_col = Color(0.2, 0.15, 0.3, 0.8)
			# Wavy thread lines
			for ti in range(5):
				var ty_off = -s * 0.6 + float(ti) * s * 0.3
				var pts: Array[Vector2] = []
				for seg in range(8):
					var tx_seg = cx - s * 0.5 + float(seg) * s * 0.14
					var ty_seg = cy + ty_off + sin(float(seg) * 1.2 + float(ti)) * s * 0.1
					pts.append(Vector2(tx_seg, ty_seg))
				for seg in range(pts.size() - 1):
					draw_line(pts[seg], pts[seg + 1], thread_col, 1.5 + float(ti) * 0.3)
			# Needle
			draw_line(Vector2(cx + s * 0.3, cy - s * 0.7), Vector2(cx + s * 0.5, cy - s * 0.3), Color(0.7, 0.7, 0.75, 0.7), 1.5)
			draw_circle(Vector2(cx + s * 0.5, cy - s * 0.3), s * 0.04, Color(0.7, 0.7, 0.75, 0.7))
		"red_rose":
			# Red rose
			var rose_col = Color(0.85, 0.1, 0.15, 0.9)
			# Petals (overlapping circles)
			draw_circle(Vector2(cx, cy - s * 0.25), s * 0.2, rose_col)
			draw_circle(Vector2(cx - s * 0.15, cy - s * 0.1), s * 0.18, rose_col)
			draw_circle(Vector2(cx + s * 0.15, cy - s * 0.1), s * 0.18, rose_col)
			draw_circle(Vector2(cx - s * 0.08, cy + s * 0.05), s * 0.15, rose_col)
			draw_circle(Vector2(cx + s * 0.08, cy + s * 0.05), s * 0.15, rose_col)
			# Center
			draw_circle(Vector2(cx, cy - s * 0.08), s * 0.08, Color(0.6, 0.05, 0.1))
			# Stem
			draw_line(Vector2(cx, cy + s * 0.12), Vector2(cx - s * 0.05, cy + s * 0.7), Color(0.2, 0.5, 0.15), 2.0)
			# Leaf
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.05, cy + s * 0.4), Vector2(cx - s * 0.3, cy + s * 0.3), Vector2(cx - s * 0.05, cy + s * 0.5)]), Color(0.2, 0.5, 0.15, 0.8))
		"punjab_lasso":
			# Coiled rope / lasso
			var rope_col = Color(0.6, 0.5, 0.3, 0.85)
			# Coils
			draw_arc(Vector2(cx, cy - s * 0.1), s * 0.4, 0, TAU, 12, rope_col, 2.5)
			draw_arc(Vector2(cx, cy - s * 0.1), s * 0.28, 0.3, TAU + 0.3, 10, rope_col, 2.0)
			draw_arc(Vector2(cx, cy - s * 0.1), s * 0.16, 0.6, TAU + 0.6, 8, rope_col, 1.5)
			# Hanging end
			draw_line(Vector2(cx + s * 0.4, cy - s * 0.1), Vector2(cx + s * 0.3, cy + s * 0.5), rope_col, 2.0)
			# Knot
			draw_circle(Vector2(cx + s * 0.3, cy + s * 0.5), s * 0.08, rope_col)
		"opera_score":
			# Sheet music
			var paper_col = Color(0.9, 0.85, 0.7, 0.85)
			# Paper
			draw_rect(Rect2(cx - s * 0.45, cy - s * 0.6, s * 0.9, s * 1.2), paper_col)
			# Staff lines
			for li in range(5):
				var ly = cy - s * 0.35 + float(li) * s * 0.15
				draw_line(Vector2(cx - s * 0.38, ly), Vector2(cx + s * 0.38, ly), Color(0.3, 0.25, 0.2, 0.5), 1.0)
			# Music notes
			draw_circle(Vector2(cx - s * 0.2, cy - s * 0.2), s * 0.06, Color(0.2, 0.15, 0.1, 0.8))
			draw_line(Vector2(cx - s * 0.14, cy - s * 0.2), Vector2(cx - s * 0.14, cy - s * 0.5), Color(0.2, 0.15, 0.1, 0.8), 1.0)
			draw_circle(Vector2(cx + s * 0.05, cy - s * 0.05), s * 0.06, Color(0.2, 0.15, 0.1, 0.8))
			draw_line(Vector2(cx + s * 0.11, cy - s * 0.05), Vector2(cx + s * 0.11, cy - s * 0.4), Color(0.2, 0.15, 0.1, 0.8), 1.0)
			draw_circle(Vector2(cx + s * 0.25, cy + s * 0.1), s * 0.06, Color(0.2, 0.15, 0.1, 0.8))
			draw_line(Vector2(cx + s * 0.31, cy + s * 0.1), Vector2(cx + s * 0.31, cy - s * 0.2), Color(0.2, 0.15, 0.1, 0.8), 1.0)
		"chandelier_chain":
			# Chain links
			var chain_col = Color(0.7, 0.65, 0.5, 0.85)
			# Vertical chain of oval links
			for li in range(4):
				var ly = cy - s * 0.55 + float(li) * s * 0.3
				draw_arc(Vector2(cx, ly), s * 0.12, 0, TAU, 8, chain_col, 2.0)
			# Horizontal connector at bottom
			draw_line(Vector2(cx - s * 0.35, cy + s * 0.45), Vector2(cx + s * 0.35, cy + s * 0.45), chain_col, 2.0)
			# Small chandelier shape at bottom
			draw_line(Vector2(cx - s * 0.35, cy + s * 0.45), Vector2(cx - s * 0.25, cy + s * 0.65), chain_col, 1.5)
			draw_line(Vector2(cx + s * 0.35, cy + s * 0.45), Vector2(cx + s * 0.25, cy + s * 0.65), chain_col, 1.5)
			draw_line(Vector2(cx, cy + s * 0.45), Vector2(cx, cy + s * 0.7), chain_col, 1.5)
			# Candle flames
			draw_circle(Vector2(cx - s * 0.25, cy + s * 0.6), s * 0.05, Color(1.0, 0.8, 0.2, 0.7))
			draw_circle(Vector2(cx + s * 0.25, cy + s * 0.6), s * 0.05, Color(1.0, 0.8, 0.2, 0.7))
		"gondola_key":
			# Ornate key
			var key_col = Color(0.75, 0.6, 0.25, 0.9)
			# Bow (circular top)
			draw_arc(Vector2(cx - s * 0.15, cy - s * 0.35), s * 0.25, 0, TAU, 10, key_col, 2.5)
			draw_circle(Vector2(cx - s * 0.15, cy - s * 0.35), s * 0.15, Color(0.08, 0.05, 0.03))
			# Shaft
			draw_rect(Rect2(cx - s * 0.05, cy - s * 0.15, s * 0.1, s * 0.8), key_col)
			# Bit (teeth at bottom)
			draw_rect(Rect2(cx + s * 0.05, cy + s * 0.45, s * 0.2, s * 0.06), key_col)
			draw_rect(Rect2(cx + s * 0.05, cy + s * 0.55, s * 0.15, s * 0.06), key_col)
		"hand_mirror":
			# Hand mirror
			var mirror_col = Color(0.75, 0.6, 0.25, 0.9)
			# Mirror face (oval)
			draw_circle(Vector2(cx, cy - s * 0.2), s * 0.38, mirror_col)
			draw_circle(Vector2(cx, cy - s * 0.2), s * 0.3, Color(0.75, 0.82, 0.9, 0.7))
			# Reflection shine
			draw_circle(Vector2(cx - s * 0.1, cy - s * 0.3), s * 0.08, Color(1.0, 1.0, 1.0, 0.3))
			# Handle
			draw_rect(Rect2(cx - s * 0.08, cy + s * 0.15, s * 0.16, s * 0.55), mirror_col)
			# Handle end
			draw_circle(Vector2(cx, cy + s * 0.7), s * 0.1, mirror_col)
		"heavy_chains":
			# Heavy chains
			var chains_col = Color(0.55, 0.5, 0.45, 0.85)
			# Multiple chain links in a pile
			for ci in range(3):
				var chain_cx = cx - s * 0.25 + float(ci) * s * 0.25
				for li in range(3):
					var chain_cy = cy - s * 0.3 + float(li) * s * 0.25
					draw_arc(Vector2(chain_cx, chain_cy), s * 0.1, 0, TAU, 6, chains_col, 2.5)
			# Padlock at center
			draw_rect(Rect2(cx - s * 0.12, cy + s * 0.2, s * 0.24, s * 0.25), Color(0.5, 0.45, 0.35, 0.9))
			draw_arc(Vector2(cx, cy + s * 0.2), s * 0.1, PI, TAU, 6, chains_col, 2.0)
		"ghost_lantern":
			# Glowing lantern
			var lantern_col = Color(0.6, 0.55, 0.35, 0.85)
			# Handle
			draw_arc(Vector2(cx, cy - s * 0.45), s * 0.15, PI, TAU, 8, lantern_col, 2.0)
			# Body frame
			draw_rect(Rect2(cx - s * 0.25, cy - s * 0.35, s * 0.5, s * 0.7), Color(0.0, 0.0, 0.0, 0.3))
			draw_rect(Rect2(cx - s * 0.25, cy - s * 0.35, s * 0.5, 2), lantern_col)
			draw_rect(Rect2(cx - s * 0.25, cy + s * 0.35 - 2, s * 0.5, 2), lantern_col)
			draw_rect(Rect2(cx - s * 0.25, cy - s * 0.35, 2, s * 0.7), lantern_col)
			draw_rect(Rect2(cx + s * 0.25 - 2, cy - s * 0.35, 2, s * 0.7), lantern_col)
			# Glow inside
			draw_circle(Vector2(cx, cy), s * 0.18, Color(0.5, 0.9, 0.6, 0.3))
			draw_circle(Vector2(cx, cy), s * 0.1, Color(0.6, 1.0, 0.7, 0.4))
			# Base
			draw_rect(Rect2(cx - s * 0.3, cy + s * 0.35, s * 0.6, s * 0.12), lantern_col)
		"brass_key":
			# Brass key (simpler than gondola key)
			var bkey_col = Color(0.8, 0.65, 0.2, 0.9)
			# Bow (diamond shape)
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy - s * 0.6), Vector2(cx + s * 0.2, cy - s * 0.35), Vector2(cx, cy - s * 0.1), Vector2(cx - s * 0.2, cy - s * 0.35)]), bkey_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy - s * 0.5), Vector2(cx + s * 0.1, cy - s * 0.35), Vector2(cx, cy - s * 0.2), Vector2(cx - s * 0.1, cy - s * 0.35)]), Color(0.08, 0.05, 0.03))
			# Shaft
			draw_rect(Rect2(cx - s * 0.05, cy - s * 0.15, s * 0.1, s * 0.75), bkey_col)
			# Teeth
			draw_rect(Rect2(cx + s * 0.05, cy + s * 0.35, s * 0.15, s * 0.06), bkey_col)
			draw_rect(Rect2(cx + s * 0.05, cy + s * 0.48, s * 0.12, s * 0.06), bkey_col)
		"xmas_pudding":
			# Steaming pudding
			var pudding_col = Color(0.45, 0.25, 0.1, 0.9)
			# Bowl
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.45, cy - s * 0.05), Vector2(cx + s * 0.45, cy - s * 0.05), Vector2(cx + s * 0.35, cy + s * 0.55), Vector2(cx - s * 0.35, cy + s * 0.55)]), pudding_col)
			# Pudding dome
			draw_arc(Vector2(cx, cy - s * 0.05), s * 0.45, PI, TAU, 10, pudding_col, 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.45, cy - s * 0.05), Vector2(cx + s * 0.45, cy - s * 0.05), Vector2(cx + s * 0.3, cy - s * 0.35), Vector2(cx, cy - s * 0.45), Vector2(cx - s * 0.3, cy - s * 0.35)]), pudding_col)
			# White sauce drip
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.35, cy - s * 0.25), Vector2(cx + s * 0.35, cy - s * 0.25), Vector2(cx + s * 0.3, cy - s * 0.05), Vector2(cx + s * 0.15, cy + s * 0.1), Vector2(cx, cy - s * 0.05), Vector2(cx - s * 0.2, cy + s * 0.15), Vector2(cx - s * 0.3, cy - s * 0.05)]), Color(0.95, 0.92, 0.85, 0.8))
			# Holly on top
			draw_circle(Vector2(cx - s * 0.05, cy - s * 0.35), s * 0.06, Color(0.85, 0.1, 0.1, 0.9))
			draw_circle(Vector2(cx + s * 0.08, cy - s * 0.38), s * 0.06, Color(0.85, 0.1, 0.1, 0.9))
			# Steam wisps
			draw_arc(Vector2(cx - s * 0.15, cy - s * 0.55), s * 0.1, PI * 0.8, PI * 1.8, 6, Color(0.8, 0.8, 0.8, 0.3), 1.0)
			draw_arc(Vector2(cx + s * 0.1, cy - s * 0.6), s * 0.08, PI * 0.7, PI * 1.7, 6, Color(0.8, 0.8, 0.8, 0.25), 1.0)
		"fiddle":
			# Violin/fiddle
			var fiddle_col = Color(0.6, 0.35, 0.12, 0.9)
			# Body (figure-8)
			draw_circle(Vector2(cx, cy + s * 0.15), s * 0.3, fiddle_col)
			draw_circle(Vector2(cx, cy - s * 0.2), s * 0.22, fiddle_col)
			# Waist
			draw_rect(Rect2(cx - s * 0.12, cy - s * 0.1, s * 0.24, s * 0.15), Color(0.08, 0.05, 0.03))
			draw_rect(Rect2(cx - s * 0.15, cy - s * 0.05, s * 0.3, s * 0.08), fiddle_col)
			# Neck
			draw_rect(Rect2(cx - s * 0.05, cy - s * 0.55, s * 0.1, s * 0.35), fiddle_col)
			# Scroll
			draw_arc(Vector2(cx, cy - s * 0.58), s * 0.08, PI * 0.5, PI * 2.0, 6, fiddle_col, 2.0)
			# Strings
			for si_str in range(4):
				var sx_str = cx - s * 0.09 + float(si_str) * s * 0.06
				draw_line(Vector2(sx_str, cy - s * 0.4), Vector2(sx_str, cy + s * 0.35), Color(0.8, 0.75, 0.6, 0.5), 0.8)
			# F-holes
			draw_line(Vector2(cx - s * 0.1, cy + s * 0.0), Vector2(cx - s * 0.1, cy + s * 0.2), Color(0.08, 0.05, 0.03, 0.6), 1.0)
			draw_line(Vector2(cx + s * 0.1, cy + s * 0.0), Vector2(cx + s * 0.1, cy + s * 0.2), Color(0.08, 0.05, 0.03, 0.6), 1.0)
			# Bow (diagonal)
			draw_line(Vector2(cx + s * 0.4, cy - s * 0.6), Vector2(cx - s * 0.3, cy + s * 0.5), Color(0.55, 0.35, 0.15, 0.5), 1.0)
		"church_bell":
			# Church bell
			var bell_col = Color(0.8, 0.65, 0.2, 0.85)
			# Bell body
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.15, cy - s * 0.55), Vector2(cx + s * 0.15, cy - s * 0.55), Vector2(cx + s * 0.2, cy - s * 0.3), Vector2(cx + s * 0.15, cy + s * 0.1), Vector2(cx + s * 0.4, cy + s * 0.35), Vector2(cx + s * 0.45, cy + s * 0.45), Vector2(cx - s * 0.45, cy + s * 0.45), Vector2(cx - s * 0.4, cy + s * 0.35), Vector2(cx - s * 0.15, cy + s * 0.1), Vector2(cx - s * 0.2, cy - s * 0.3)]), bell_col)
			# Clapper
			draw_line(Vector2(cx, cy - s * 0.2), Vector2(cx, cy + s * 0.3), Color(0.5, 0.4, 0.15), 1.5)
			draw_circle(Vector2(cx, cy + s * 0.32), s * 0.07, Color(0.5, 0.4, 0.15))
			# Top mount
			draw_rect(Rect2(cx - s * 0.1, cy - s * 0.65, s * 0.2, s * 0.12), Color(0.5, 0.4, 0.2))
			draw_arc(Vector2(cx, cy - s * 0.65), s * 0.12, PI, TAU, 6, Color(0.5, 0.4, 0.2), 2.0)
		_:
			# Fallback: diamond icon
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy - s * 0.5), Vector2(cx + s * 0.35, cy), Vector2(cx, cy + s * 0.5), Vector2(cx - s * 0.35, cy)]), Color(accent.r, accent.g, accent.b, 0.4))

const HERO_ROLE_NAMES: Dictionary = {
	TowerType.ROBIN_HOOD: "Marksman", TowerType.ALICE: "Controller",
	TowerType.WICKED_WITCH: "Summoner", TowerType.PETER_PAN: "Assassin",
	TowerType.PHANTOM: "Artillery", TowerType.SCROOGE: "Economist",
	TowerType.SHERLOCK: "Support", TowerType.TARZAN: "Brawler",
	TowerType.DRACULA: "Drain Tank", TowerType.MERLIN: "Wizard",
	TowerType.FRANKENSTEIN: "Juggernaut",
}

func _get_levelup_cost(level: int) -> int:
	# Accelerating cost curve: early levels cheap, later levels require commitment
	return 5 + level * 3 + int(float(level * level) * 0.5)

func _get_level_rewards(level: int) -> Array:
	var rewards: Array = []
	rewards.append("+2% DMG, +1.5% RNG, +1% SPD")
	if level == 2:
		rewards.append("Weapon Unlocked")
	if level == 3:
		rewards.append("Sidekick Slot #1")
	if level == 4:
		rewards.append("+Relic Slot (3 total)")
	if level == 5:
		rewards.append("+5% DMG Milestone")
		rewards.append("Sidekick Slot #2")
		rewards.append("Tome Binding Slot")
	if level == 7:
		rewards.append("+Relic Slot (4 total)")
	if level == 8:
		rewards.append("Sidekick Slot #3")
	if level == 10:
		rewards.append("+Relic Slot (5 total)")
		rewards.append("Tome Binding Slot #2")
	if level == 15:
		rewards.append("+10% DMG/RNG/SPD Milestone")
	return rewards

func _draw_ability_icon(center: Vector2, tier: int, accent: Color) -> void:
	match tier:
		0:  # Quill icon for T1
			draw_line(center + Vector2(-5, 6), center + Vector2(5, -6), Color(accent.r, accent.g, accent.b, 0.9), 2.0)
			draw_line(center + Vector2(4, -6), center + Vector2(6, -8), Color(accent.r, accent.g, accent.b, 0.7), 1.5)
			draw_line(center + Vector2(-5, 6), center + Vector2(-6, 8), Color(accent.r, accent.g, accent.b, 0.5), 1.0)
		1:  # Sword icon for T2
			draw_line(center + Vector2(0, -8), center + Vector2(0, 7), Color(0.8, 0.82, 0.85, 0.9), 2.5)
			draw_line(center + Vector2(-5, -2), center + Vector2(5, -2), Color(0.7, 0.55, 0.2, 0.9), 2.0)
			draw_circle(center + Vector2(0, -8), 2, Color(0.85, 0.65, 0.1, 0.8))
		2:  # Star icon for T3
			var star_pts = PackedVector2Array()
			for si in range(10):
				var sa = -PI * 0.5 + float(si) * TAU / 10.0
				var sd = 7.0 if si % 2 == 0 else 3.0
				star_pts.append(center + Vector2(cos(sa) * sd, sin(sa) * sd))
			draw_colored_polygon(star_pts, Color(accent.r, accent.g, accent.b, 0.8))
		3:  # Crown icon for T4
			var crown_pts = PackedVector2Array()
			crown_pts.append(center + Vector2(-8, 4))
			crown_pts.append(center + Vector2(-6, -4))
			crown_pts.append(center + Vector2(-2, 0))
			crown_pts.append(center + Vector2(0, -6))
			crown_pts.append(center + Vector2(2, 0))
			crown_pts.append(center + Vector2(6, -4))
			crown_pts.append(center + Vector2(8, 4))
			draw_colored_polygon(crown_pts, Color(0.85, 0.65, 0.1, 0.85))
			draw_rect(Rect2(center.x - 8, center.y + 4, 16, 3), Color(0.85, 0.65, 0.1, 0.85))

func _draw_survivor_detail() -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var panel_x = 70.0
	var panel_y = 38.0
	var panel_w = 1140.0
	var panel_h = 570.0
	var tower_type = survivor_types[survivor_detail_index]
	var info = tower_info[tower_type]
	var progress = survivor_progress.get(tower_type, {"level": 1, "xp": 0.0, "xp_next": float(HERO_XP_TABLE[0]), "gear_unlocked": false, "sidekicks_unlocked": [false, false, false], "relics_unlocked": [false, false, false, false, false, false]})
	var speaker_name = _tower_type_to_name(tower_type)
	var font = game_font
	var char_level = progress.get("level", 1)
	var card_colors = [
		Color(0.29, 0.55, 0.25), Color(0.44, 0.66, 0.86), Color(0.48, 0.25, 0.63),
		Color(0.90, 0.49, 0.13), Color(0.75, 0.22, 0.17), Color(0.79, 0.66, 0.30),
		Color(0.20, 0.35, 0.55), Color(0.30, 0.50, 0.20), Color(0.50, 0.10, 0.15),
		Color(0.25, 0.20, 0.55), Color(0.35, 0.40, 0.30), Color(0.12, 0.08, 0.18),
	]
	var accent = card_colors[mini(survivor_detail_index, card_colors.size() - 1)]

	# === Panel background gradient ===
	for i in range(58):
		var t = float(i) / 57.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 57.0 + 1), col)
	draw_circle(Vector2(panel_x + 200, panel_y + 280), 180, Color(accent.r, accent.g, accent.b, 0.03))
	# Outer border
	var bdr = Color(accent.r, accent.g, accent.b, 0.5)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 3), bdr)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 3, panel_w, 3), bdr)
	draw_rect(Rect2(panel_x, panel_y, 3, panel_h), bdr)
	draw_rect(Rect2(panel_x + panel_w - 3, panel_y, 3, panel_h), bdr)
	draw_rect(Rect2(panel_x + 3, panel_y + 3, panel_w - 6, panel_h - 6), Color(accent.r, accent.g, accent.b, 0.06), false, 1.0)

	# === TOP BAR ===
	var top_y = panel_y + 8.0
	_udraw(font, Vector2(panel_x + 20, top_y + 16), "< SURVIVORS", HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7))
	var char_name = info["name"].to_upper()
	var name_w = font.get_string_size(char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 26).x
	var name_cx = panel_x + panel_w * 0.5
	_udraw(font, Vector2(name_cx - name_w * 0.5 + 1, top_y + 21), char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 26, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(name_cx - name_w * 0.5, top_y + 20), char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 26, menu_parchment)
	# "IN PARTY" badge
	var party_text = "IN PARTY"
	var party_tw = font.get_string_size(party_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
	var party_bx = panel_x + panel_w - party_tw - 40
	draw_rect(Rect2(party_bx, top_y + 4, party_tw + 20, 22), Color(accent.r, accent.g, accent.b, 0.5))
	draw_rect(Rect2(party_bx, top_y + 4, party_tw + 20, 22), Color(accent.r, accent.g, accent.b, 0.7), false, 1.0)
	_udraw(font, Vector2(party_bx + 10, top_y + 18), party_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color.WHITE)
	draw_rect(Rect2(panel_x + 10, top_y + 30, panel_w - 20, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))

	var content_y = top_y + 38.0

	# ================================================================
	# LEFT SIDE: Portrait + XP + Stats + Abilities (BATTD style)
	# ================================================================
	var left_x = panel_x + 20.0
	var port_x = left_x
	var port_y = content_y
	var port_w = 240.0
	var port_h = 250.0
	# Portrait background
	draw_rect(Rect2(port_x, port_y, port_w, port_h), Color(0.03, 0.02, 0.07))
	for gi in range(25):
		var gt = float(gi) / 24.0
		draw_rect(Rect2(port_x, port_y + float(gi), port_w, 1), Color(accent.r, accent.g, accent.b, 0.08 * (1.0 - gt)))
	draw_circle(Vector2(port_x + port_w * 0.5, port_y + port_h * 0.55), 70.0, Color(accent.r, accent.g, accent.b, 0.06))
	_draw_story_portrait(port_x + port_w * 0.5, port_y + port_h * 0.45, 200.0, speaker_name)
	# Portrait frame
	draw_rect(Rect2(port_x, port_y, port_w, 3), Color(accent.r, accent.g, accent.b, 0.6))
	draw_rect(Rect2(port_x, port_y + port_h - 3, port_w, 3), Color(accent.r, accent.g, accent.b, 0.6))
	draw_rect(Rect2(port_x, port_y, 3, port_h), Color(accent.r, accent.g, accent.b, 0.6))
	draw_rect(Rect2(port_x + port_w - 3, port_y, 3, port_h), Color(accent.r, accent.g, accent.b, 0.6))
	draw_rect(Rect2(port_x + 3, port_y + 3, port_w - 6, port_h - 6), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.12), false, 1.0)
	# Level badge star (BATTD style — gold star with level number)
	var badge_cx = port_x + port_w - 20.0
	var badge_cy = port_y + 20.0
	var star_r = 18.0
	var star_pts = PackedVector2Array()
	for si in range(10):
		var sa = -PI * 0.5 + float(si) * TAU / 10.0
		var sd = star_r if si % 2 == 0 else star_r * 0.45
		star_pts.append(Vector2(badge_cx + cos(sa) * sd, badge_cy + sin(sa) * sd))
	draw_colored_polygon(star_pts, Color(0.85, 0.65, 0.1, 0.95))
	draw_circle(Vector2(badge_cx, badge_cy), 10, Color(0.04, 0.03, 0.08))
	var lvl_str = str(char_level)
	var lvl_w = font.get_string_size(lvl_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
	_udraw(font, Vector2(badge_cx - lvl_w * 0.5, badge_cy + 5), lvl_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color.WHITE)
	# Info icon (bottom-left) — highlights on hover
	var info_icon_hover = (detail_hover_type == "info_icon")
	draw_circle(Vector2(port_x + 22, port_y + port_h - 22), 12, Color(0.2, 0.4, 0.8, 0.85 if info_icon_hover else 0.6))
	if info_icon_hover:
		draw_arc(Vector2(port_x + 22, port_y + port_h - 22), 13, 0, TAU, 16, Color(0.4, 0.7, 1.0, 0.6), 1.5)
	_udraw(font, Vector2(port_x + 18, port_y + port_h - 17), "i", HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color.WHITE)

	# --- Right of portrait: NEXT REWARDS roadmap ---
	var info_x = port_x + port_w + 14.0
	var info_y = port_y + 6.0
	_udraw(font, Vector2(info_x, info_y + 12), "NEXT REWARDS", HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7))
	draw_rect(Rect2(info_x, info_y + 16, 80, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.2))
	var roadmap_y = info_y + 24.0
	var rewards_shown = 0
	var check_level = char_level + 1
	while rewards_shown < 3 and check_level <= MAX_SURVIVOR_LEVEL:
		var rewards = _get_level_rewards(check_level)
		if rewards.size() > 1:  # Has special rewards beyond the base stat line
			# Level number badge
			var badge_str = "LV.%d" % check_level
			_udraw(font, Vector2(info_x, roadmap_y + 9), badge_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1, 0.8))
			var reward_x = info_x + 36.0
			for ri in range(1, mini(rewards.size(), 3)):  # Skip index 0 (base stats)
				_udraw(font, Vector2(reward_x, roadmap_y + 9), rewards[ri], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.7))
				roadmap_y += 12.0
			rewards_shown += 1
		check_level += 1
	if char_level >= MAX_SURVIVOR_LEVEL:
		_udraw(font, Vector2(info_x, roadmap_y + 9), "All rewards unlocked!", HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1, 0.6))

	# --- XP bar (below portrait) ---
	var xp_y = port_y + port_h + 6.0
	var xp_w = port_w
	var xp_h = 20.0
	var xp_ratio = clamp(progress["xp"] / max(progress["xp_next"], 1.0), 0.0, 1.0)
	draw_rect(Rect2(port_x, xp_y, xp_w, xp_h), Color(0.03, 0.03, 0.08))
	draw_rect(Rect2(port_x, xp_y, xp_w, xp_h), Color(accent.r, accent.g, accent.b, 0.2), false, 1.0)
	if xp_ratio > 0:
		draw_rect(Rect2(port_x + 2, xp_y + 2, (xp_w - 4) * xp_ratio, xp_h - 4), Color(0.85, 0.65, 0.1, 0.8))
		draw_rect(Rect2(port_x + 2, xp_y + 2, (xp_w - 4) * xp_ratio, (xp_h - 4) * 0.35), Color(1, 1, 1, 0.15))
	var xp_text = "%d/%d" % [int(progress["xp"]), int(progress["xp_next"])]
	if char_level >= MAX_SURVIVOR_LEVEL:
		xp_text = "MAX LEVEL"
	var xp_tw = font.get_string_size(xp_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
	_udraw(font, Vector2(port_x + (xp_w - xp_tw) * 0.5, xp_y + 15), xp_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color.WHITE)

	# --- LEVEL UP button (below XP bar) ---
	var levelup_btn_y = xp_y + xp_h
	var levelup_btn_h = 22.0
	if char_level >= MAX_SURVIVOR_LEVEL:
		# MAX LEVEL badge
		draw_rect(Rect2(port_x, levelup_btn_y, xp_w, levelup_btn_h), Color(0.85, 0.65, 0.1, 0.15))
		draw_rect(Rect2(port_x, levelup_btn_y, xp_w, levelup_btn_h), Color(0.85, 0.65, 0.1, 0.3), false, 1.0)
		var max_str = "MAX LEVEL REACHED"
		var max_w = font.get_string_size(max_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 10).x
		_udraw(font, Vector2(port_x + (xp_w - max_w) * 0.5, levelup_btn_y + 15), max_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1, 0.7))
	else:
		var lvup_cost = _get_levelup_cost(char_level)
		var can_afford = player_quills >= lvup_cost
		var is_lvup_hover = (detail_hover_type == "levelup")
		# Button background
		var btn_bg = Color(0.85, 0.65, 0.1, 0.25 if is_lvup_hover else 0.12) if can_afford else Color(0.3, 0.3, 0.3, 0.15)
		var btn_border = Color(0.85, 0.65, 0.1, 0.7 if is_lvup_hover else 0.4) if can_afford else Color(0.4, 0.4, 0.4, 0.3)
		draw_rect(Rect2(port_x, levelup_btn_y, xp_w, levelup_btn_h), btn_bg)
		draw_rect(Rect2(port_x, levelup_btn_y, xp_w, levelup_btn_h), btn_border, false, 1.5)
		if is_lvup_hover and can_afford:
			draw_rect(Rect2(port_x + 1, levelup_btn_y + 1, xp_w - 2, (levelup_btn_h - 2) * 0.4), Color(1, 1, 1, 0.06))
		var lvup_str = "LEVEL UP  —  %d Quills" % lvup_cost
		var lvup_tw = font.get_string_size(lvup_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 10).x
		var lvup_col = Color(0.85, 0.65, 0.1, 0.9) if can_afford else Color(0.5, 0.48, 0.55, 0.6)
		_udraw(font, Vector2(port_x + (xp_w - lvup_tw) * 0.5, levelup_btn_y + 15), lvup_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, lvup_col)

	# --- Stat bonus pills ---
	var stat_y = xp_y + xp_h + levelup_btn_h + 4.0
	var lvl_b = _get_level_bonuses(tower_type)
	var rel_b = _get_relic_bonuses(tower_type)
	var total_dmg = lvl_b.get("damage", 0.0) + rel_b.get("damage", 0.0) + _get_knowledge_bonus("damage")
	var total_rng = lvl_b.get("range", 0.0) + rel_b.get("range", 0.0) + _get_knowledge_bonus("range")
	var total_spd = lvl_b.get("attack_speed", 0.0) + rel_b.get("attack_speed", 0.0) + _get_knowledge_bonus("attack_speed")
	var pill_x = port_x
	var pill_labels = ["+%d%% DMG" % int(total_dmg * 100), "+%d%% RNG" % int(total_rng * 100), "+%d%% SPD" % int(total_spd * 100)]
	var pill_colors = [Color(0.9, 0.3, 0.2), Color(0.3, 0.7, 0.9), Color(0.3, 0.9, 0.4)]
	for pi in range(3):
		var pw = font.get_string_size(pill_labels[pi], HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x + 12
		draw_rect(Rect2(pill_x, stat_y, pw, 16), Color(pill_colors[pi].r, pill_colors[pi].g, pill_colors[pi].b, 0.12))
		draw_rect(Rect2(pill_x, stat_y, pw, 16), Color(pill_colors[pi].r, pill_colors[pi].g, pill_colors[pi].b, 0.25), false, 1.0)
		_udraw(font, Vector2(pill_x + 6, stat_y + 11), pill_labels[pi], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(pill_colors[pi].r, pill_colors[pi].g, pill_colors[pi].b, 0.9))
		pill_x += pw + 6.0

	# Novel title (below stat pills on the left side)
	var novel_str = character_novels[survivor_detail_index] if survivor_detail_index < character_novels.size() else ""
	_udraw(font, Vector2(port_x, stat_y + 22), novel_str, HORIZONTAL_ALIGNMENT_LEFT, int(port_w + 60), 14, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.5))

	# ================================================================
	# RIGHT SIDE: Weapon + Sidekicks + Relics (BATTD layout)
	# ================================================================
	var right_x = panel_x + 310.0
	var right_w = panel_w - 330.0
	var slot_size = 72.0

	# --- WEAPON section ---
	var weap_y = content_y
	_udraw(font, Vector2(right_x + 1, weap_y + 15), "WEAPON", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(right_x, weap_y + 14), "WEAPON", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_gold)
	var gear_data = survivor_gear.get(tower_type, {"name": "Unknown", "desc": ""})
	var gear_unlocked = progress.get("gear_unlocked", false)
	var gear_sy = weap_y + 32.0
	var gear_hover = (detail_hover_type == "weapon" and detail_hover_index == 0)
	# Weapon slot
	draw_rect(Rect2(right_x, gear_sy, slot_size, slot_size), Color(0.04, 0.04, 0.10))
	var gear_bdr_col = Color(accent.r, accent.g, accent.b, 0.7 if gear_hover else 0.4) if gear_unlocked else Color(0.3, 0.28, 0.40, 0.3)
	draw_rect(Rect2(right_x, gear_sy, slot_size, slot_size), gear_bdr_col, false, 2.5)
	if gear_unlocked:
		draw_circle(Vector2(right_x + slot_size * 0.5, gear_sy + slot_size * 0.5), 24, Color(accent.r, accent.g, accent.b, 0.2))
		draw_arc(Vector2(right_x + slot_size * 0.5, gear_sy + slot_size * 0.5), 20, 0, TAU, 16, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.35), 2.0)
		# Simple weapon icon (sword)
		var wc = Vector2(right_x + slot_size * 0.5, gear_sy + slot_size * 0.5)
		draw_line(wc + Vector2(0, -18), wc + Vector2(0, 14), Color(0.8, 0.82, 0.85, 0.8), 3.0)
		draw_line(wc + Vector2(-9, -5), wc + Vector2(9, -5), Color(0.7, 0.55, 0.2, 0.8), 2.5)
		draw_circle(wc + Vector2(0, -18), 3, Color(0.85, 0.65, 0.1, 0.7))
	else:
		# Locked: padlock
		var lk = Vector2(right_x + slot_size * 0.5, gear_sy + slot_size * 0.4)
		draw_rect(Rect2(lk.x - 12, lk.y + 2, 24, 18), Color(0.35, 0.30, 0.45, 0.6))
		draw_arc(Vector2(lk.x, lk.y + 2), 9, PI, TAU, 12, Color(0.4, 0.35, 0.50, 0.6), 2.5)
		draw_circle(Vector2(lk.x, lk.y + 11), 3, Color(0.04, 0.04, 0.10))
	# Weapon name + type badge below slot
	var weap_name = gear_data["name"] if gear_unlocked else "LV.2"
	var weap_nw = font.get_string_size(weap_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
	_udraw(font, Vector2(right_x + (slot_size - weap_nw) * 0.5, gear_sy + slot_size + 14), weap_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, menu_parchment if gear_unlocked else Color(0.5, 0.48, 0.55, 0.6))
	if gear_unlocked and gear_data.has("type"):
		var wtype = gear_data["type"]
		var type_col = Color(0.5, 0.7, 0.9, 0.7)
		var type_w = font.get_string_size(wtype, HORIZONTAL_ALIGNMENT_LEFT, -1, 10).x + 10
		var type_x = right_x + (slot_size - type_w) * 0.5
		draw_rect(Rect2(type_x, gear_sy + slot_size + 18, type_w, 14), Color(0.1, 0.15, 0.25, 0.6))
		draw_rect(Rect2(type_x, gear_sy + slot_size + 18, type_w, 14), Color(type_col.r, type_col.g, type_col.b, 0.3), false, 1.0)
		_udraw(font, Vector2(type_x + 5, gear_sy + slot_size + 30), wtype, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, type_col)

	# --- SIDEKICKS section (right of weapon) ---
	var sk_x = right_x + slot_size + 50.0
	var sk_y = content_y
	var sk_data = survivor_sidekicks.get(tower_type, [])
	var sk_max = _get_ally_slots(tower_type)
	var sk_unlocked_arr = progress.get("sidekicks_unlocked", [false, false, false])
	while sk_unlocked_arr.size() < sk_max:
		sk_unlocked_arr.append(false)
	var sk_count = 0
	for su in sk_unlocked_arr:
		if su:
			sk_count += 1
	_udraw(font, Vector2(sk_x + 1, sk_y + 15), "ALLIES (%d/%d)" % [sk_count, sk_max], HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(sk_x, sk_y + 14), "ALLIES (%d/%d)" % [sk_count, sk_max], HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_gold)
	var sk_slot_y = sk_y + 32.0
	var sk_levels = [3, 5, 8, 10]
	for si in range(sk_max):
		var sx = sk_x + float(si) * (slot_size + 14.0)
		var sy = sk_slot_y
		var sk_unlocked = sk_unlocked_arr[si] if si < sk_unlocked_arr.size() else false
		var sk_hover = (detail_hover_type == "sidekick" and detail_hover_index == si)
		draw_rect(Rect2(sx, sy, slot_size, slot_size), Color(0.04, 0.04, 0.10))
		var sk_bdr = Color(accent.r, accent.g, accent.b, 0.7 if sk_hover else 0.4) if sk_unlocked else Color(0.3, 0.28, 0.40, 0.3)
		draw_rect(Rect2(sx, sy, slot_size, slot_size), sk_bdr, false, 2.5)
		if sk_unlocked and si < sk_data.size():
			# Sidekick portrait silhouette
			var sc = Vector2(sx + slot_size * 0.5, sy + slot_size * 0.4)
			draw_circle(sc + Vector2(0, -8), 14, Color(accent.r, accent.g, accent.b, 0.3))
			draw_rect(Rect2(sc.x - 10, sc.y + 2, 20, 18), Color(accent.r, accent.g, accent.b, 0.2))
			# Name below
			var sk_name = sk_data[si]["name"]
			if sk_name.length() > 10:
				sk_name = sk_name.substr(0, 9) + ".."
			var snw = font.get_string_size(sk_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x
			_udraw(font, Vector2(sx + (slot_size - snw) * 0.5, sy + slot_size + 12), sk_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.8))
		else:
			if si == 0 or (si > 0 and sk_unlocked_arr[si - 1] if si - 1 < sk_unlocked_arr.size() else false):
				# Next unlockable — show "+" icon
				draw_rect(Rect2(sx + 32, sy + 24, 8, 24), Color(accent.r, accent.g, accent.b, 0.3))
				draw_rect(Rect2(sx + 24, sy + 32, 24, 8), Color(accent.r, accent.g, accent.b, 0.3))
			else:
				# Locked — padlock icon
				var lk = Vector2(sx + slot_size * 0.5, sy + slot_size * 0.4)
				draw_rect(Rect2(lk.x - 10, lk.y + 2, 20, 16), Color(0.35, 0.30, 0.45, 0.5))
				draw_arc(Vector2(lk.x, lk.y + 2), 8, PI, TAU, 10, Color(0.4, 0.35, 0.50, 0.5), 2.5)
				draw_circle(Vector2(lk.x, lk.y + 10), 2.5, Color(0.04, 0.04, 0.10))
			# Level requirement star (bottom-right of slot)
			_draw_detail_level_star(Vector2(sx + slot_size - 2, sy + slot_size - 2), sk_levels[si], font)
	# Sidekick description
	_udraw(font, Vector2(sk_x, sk_slot_y + slot_size + 24), "Sidekicks: Call in extra characters", HORIZONTAL_ALIGNMENT_LEFT, 400, 14, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.5))

	# --- RELICS section (full width of right side, below weapon+sidekicks) ---
	var rel_y = gear_sy + slot_size + 44.0
	var char_relics = survivor_relics.get(tower_type, [])
	var rel_unlocked_arr = progress.get("relics_unlocked", [false, false, false, false, false, false])
	var rel_count = 0
	for ru in rel_unlocked_arr:
		if ru:
			rel_count += 1
	var max_rel_slots = _get_relic_slots(char_level)
	_udraw(font, Vector2(right_x + 1, rel_y + 15), "RELICS (%d/%d)" % [rel_count, char_relics.size()], HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(right_x, rel_y + 14), "RELICS (%d/%d)" % [rel_count, char_relics.size()], HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_gold)
	var relic_slot_y = rel_y + 24.0
	var relic_slot_size = 72.0
	var relic_gap = 12.0
	var relic_earn_levels = [2, 4, 6, 8, 10, 12]
	var relic_purchasable = [false, true, false, true, false, true]
	var relic_costs = [0, 100, 0, 250, 0, 500]
	# 2 rows of 3 relics
	for ri in range(mini(char_relics.size(), 6)):
		var r_row = ri / 3
		var r_col = ri % 3
		var rx = right_x + float(r_col) * (relic_slot_size + relic_gap)
		var ry = relic_slot_y + float(r_row) * (relic_slot_size + 24.0)
		var is_unlocked = rel_unlocked_arr[ri] if ri < rel_unlocked_arr.size() else false
		var is_rel_hover = (detail_hover_type == "relic" and detail_hover_index == ri)
		var relic_data = char_relics[ri] if ri < char_relics.size() else {}
		# Slot bg
		draw_rect(Rect2(rx, ry, relic_slot_size, relic_slot_size), Color(0.04, 0.04, 0.10))
		if is_unlocked:
			var eq_list = equipped_relics.get(tower_type, [])
			var is_equipped = ri in eq_list
			# Equipped = gold border, owned = accent border
			var relic_bdr = Color(0.85, 0.65, 0.1, 0.8 if is_rel_hover else 0.6) if is_equipped else Color(accent.r, accent.g, accent.b, 0.7 if is_rel_hover else 0.4)
			draw_rect(Rect2(rx, ry, relic_slot_size, relic_slot_size), relic_bdr, false, 2.5)
			# Relic icon
			if not relic_data.is_empty():
				_draw_relic_icon(Vector2(rx + relic_slot_size * 0.5, ry + relic_slot_size * 0.4), relic_data.get("icon", ""), relic_slot_size * 0.55, accent)
			# Equipped corner triangle
			if is_equipped:
				draw_colored_polygon(PackedVector2Array([Vector2(rx, ry), Vector2(rx + 18, ry), Vector2(rx, ry + 18)]), Color(0.85, 0.65, 0.1, 0.8))
			# Relic name below
			var rn = relic_data.get("name", "")
			if rn.length() > 11:
				rn = rn.substr(0, 10) + ".."
			var rnw = font.get_string_size(rn, HORIZONTAL_ALIGNMENT_LEFT, -1, 8).x
			_udraw(font, Vector2(rx + (relic_slot_size - rnw) * 0.5, ry + relic_slot_size + 12), rn, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, menu_parchment)
		elif relic_purchasable[ri] and char_level >= relic_earn_levels[ri]:
			# Purchasable with gold — cyan border like BATTD "+" slots
			draw_rect(Rect2(rx, ry, relic_slot_size, relic_slot_size), Color(accent.r, accent.g, accent.b, 0.4 if is_rel_hover else 0.2), false, 2.0)
			# Plus icon
			draw_rect(Rect2(rx + 32, ry + 24, 8, 24), Color(accent.r, accent.g, accent.b, 0.4))
			draw_rect(Rect2(rx + 24, ry + 32, 24, 8), Color(accent.r, accent.g, accent.b, 0.4))
			# Cost label
			var cost_str = "%d GOLD" % relic_costs[ri]
			var cost_w = font.get_string_size(cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 8).x
			_udraw(font, Vector2(rx + (relic_slot_size - cost_w) * 0.5, ry + relic_slot_size + 12), cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1, 0.7))
		else:
			# Locked — gray with padlock
			draw_rect(Rect2(rx, ry, relic_slot_size, relic_slot_size), Color(0.2, 0.18, 0.30, 0.2), false, 1.5)
			var lk = Vector2(rx + relic_slot_size * 0.5, ry + relic_slot_size * 0.38)
			draw_rect(Rect2(lk.x - 12, lk.y + 2, 24, 18), Color(0.35, 0.30, 0.45, 0.55))
			draw_arc(Vector2(lk.x, lk.y + 2), 9, PI, TAU, 12, Color(0.4, 0.35, 0.50, 0.55), 2.5)
			draw_circle(Vector2(lk.x, lk.y + 11), 3, Color(0.04, 0.04, 0.10))
			# Level requirement star
			_draw_detail_level_star(Vector2(rx + relic_slot_size - 2, ry + relic_slot_size - 2), relic_earn_levels[ri], font)
	# Relics description
	var relic_desc_y = relic_slot_y + 2.0 * (relic_slot_size + 24.0) + 4.0
	_udraw(font, Vector2(right_x, relic_desc_y), "Relics: Add extra attacks, damage, or effects", HORIZONTAL_ALIGNMENT_LEFT, 500, 15, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.5))

	# --- ABILITIES section (to the right of relics) ---
	var abil_x = right_x + 270.0
	var abil_y = rel_y
	var abil_w = 520.0
	var abil_data = survivor_detail_abilities
	_udraw(font, Vector2(abil_x + 1, abil_y + 15), "ABILITIES", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(abil_x, abil_y + 14), "ABILITIES", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_gold)
	draw_rect(Rect2(abil_x, abil_y + 19, 100, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3))
	var abil_entry_y = abil_y + 30.0
	var abil_entry_h = 48.0
	for ai in range(mini(abil_data.size(), 4)):
		var ay = abil_entry_y + float(ai) * abil_entry_h
		var is_abil_hover = (detail_hover_type == "ability" and detail_hover_index == ai)
		# Hover highlight bar
		if is_abil_hover:
			draw_rect(Rect2(abil_x - 4, ay - 2, abil_w, abil_entry_h - 4), Color(accent.r, accent.g, accent.b, 0.08))
		# Small icon circle
		var icon_cx = abil_x + 16.0
		var icon_cy = ay + 14.0
		draw_circle(Vector2(icon_cx, icon_cy), 14.0, Color(0.04, 0.04, 0.10))
		var ring_alpha = 0.8 if is_abil_hover else 0.5
		draw_arc(Vector2(icon_cx, icon_cy), 13.0, 0, TAU, 16, Color(0.85, 0.65, 0.1, ring_alpha), 2.0)
		_draw_ability_icon(Vector2(icon_cx, icon_cy), ai, accent)
		# Tier number
		var tier_str = "%d." % (ai + 1)
		_udraw(font, Vector2(abil_x + 36, ay + 12), tier_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.65, 0.1, 0.9))
		# Ability name
		var a_name = abil_data[ai].get("name", "Tier %d" % (ai + 1))
		_udraw(font, Vector2(abil_x + 52, ay + 12), a_name, HORIZONTAL_ALIGNMENT_LEFT, int(abil_w - 120), 16, menu_gold)
		# Cost (right-aligned)
		var cost_str = "%dG" % abil_data[ai].get("cost", 0)
		var cost_w = font.get_string_size(cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
		_udraw(font, Vector2(abil_x + abil_w - cost_w - 10, ay + 12), cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.85, 0.65, 0.1, 0.7))
		# Description
		var a_desc = abil_data[ai].get("desc", "")
		_udraw(font, Vector2(abil_x + 36, ay + 28), a_desc, HORIZONTAL_ALIGNMENT_LEFT, int(abil_w - 50), 15, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.95))

	# --- Tome Bindings section (below relics, if player has slots) ---
	var bind_slots = _get_binding_slots(tower_type)
	if bind_slots > 0:
		var eq_bindings = equipped_bindings.get(tower_type, [])
		var rarity_colors = RARITY_COLORS
		var tome_y = relic_desc_y + 18.0
		_udraw(font, Vector2(right_x + 1, tome_y + 13), "TOME BINDINGS (%d/%d)" % [eq_bindings.size(), bind_slots], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0, 0, 0, 0.4))
		_udraw(font, Vector2(right_x, tome_y + 12), "TOME BINDINGS (%d/%d)" % [eq_bindings.size(), bind_slots], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7))
		# Set bonus indicator
		var tower_names_sb = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom", "scrooge", "sherlock", "tarzan", "dracula", "merlin", "frankenstein", "scheherazade"]
		var cn = tower_names_sb[tower_type] if tower_type >= 0 and tower_type < tower_names_sb.size() else ""
		var cgc = 0
		for eqb in eq_bindings:
			var bd = _find_binding(eqb)
			if bd.get("character", "") == cn:
				cgc += 1
		if cgc >= 3:
			var sb_str = "SET BONUS x%d (+%d%% ALL)" % [cgc, cgc * 5]
			_udraw(font, Vector2(right_x + 200, tome_y + 12), sb_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(1.0, 0.85, 0.2, 0.8))
		var tome_slot_y = tome_y + 22.0
		var tome_slot_size = 44.0
		for tsi in range(bind_slots):
			var tx = right_x + float(tsi) * (tome_slot_size + 8)
			var ty = tome_slot_y
			draw_rect(Rect2(tx, ty, tome_slot_size, tome_slot_size), Color(0.04, 0.04, 0.10))
			if tsi < eq_bindings.size():
				var binding = _find_binding(eq_bindings[tsi])
				if not binding.is_empty():
					var rc = RARITY_COLORS.get(binding.get("rarity", "tattered"), Color(0.6, 0.6, 0.65))
					draw_rect(Rect2(tx, ty, tome_slot_size, tome_slot_size), Color(rc.r, rc.g, rc.b, 0.4), false, 1.5)
					draw_circle(Vector2(tx + tome_slot_size * 0.5, ty + tome_slot_size * 0.4), 12, Color(rc.r, rc.g, rc.b, 0.25))
					# Rarity initial badge
					var rar = binding.get("rarity", "tattered")
					var rar_letter = rar.substr(0, 1).to_upper()
					_udraw(font, Vector2(tx + 2, ty + 10), rar_letter, HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(rc.r, rc.g, rc.b, 0.7))
			else:
				draw_rect(Rect2(tx, ty, tome_slot_size, tome_slot_size), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.15), false, 1.0)
				draw_rect(Rect2(tx + 18, ty + 12, 8, 20), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))
				draw_rect(Rect2(tx + 12, ty + 18, 20, 8), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))
		# Owned bindings list (scrollable)
		var browse_y = tome_slot_y + tome_slot_size + 6.0
		var browse_bottom = panel_y + panel_h - 20.0
		var bcol = 0
		var brow = 0
		var card_w = 200.0
		var card_h = 36.0
		for b in TOME_BINDINGS:
			var count = owned_bindings.get(b["id"], 0)
			if count <= 0:
				continue
			var bx = right_x + float(bcol) * (card_w + 8)
			var by = browse_y + float(brow) * (card_h + 3) - detail_binding_scroll
			bcol += 1
			if bcol >= 3:
				bcol = 0
				brow += 1
			# Clip to visible area
			if by + card_h < browse_y or by > browse_bottom:
				continue
			var is_eq = b["id"] in eq_bindings
			var rc = RARITY_COLORS.get(b.get("rarity", "tattered"), Color(0.6, 0.6, 0.65))
			var bg_c = Color(0.10, 0.08, 0.22, 0.8) if is_eq else Color(0.05, 0.05, 0.14, 0.7)
			draw_rect(Rect2(bx, by, card_w, card_h), bg_c)
			draw_rect(Rect2(bx, by, card_w, card_h), Color(rc.r, rc.g, rc.b, 0.3 if is_eq else 0.15), false, 1.0)
			# Rarity stripe
			draw_rect(Rect2(bx, by, 3, card_h), Color(rc.r, rc.g, rc.b, 0.6))
			_udraw(font, Vector2(bx + 6, by + 12), b["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 40), 14, menu_parchment)
			_udraw(font, Vector2(bx + 6, by + 26), b["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 12), 12, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.6))
			var count_label = "EQ" if is_eq else ("x%d" % count)
			_udraw(font, Vector2(bx + card_w - 28, by + 12), count_label, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.3, 0.8, 0.3) if is_eq else Color(0.55, 0.52, 0.50))
		# Scroll indicator for bindings list
		var browse_vis_h = browse_bottom - browse_y
		var total_binding_h = float(brow + 1) * (card_h + 3)
		if total_binding_h > browse_vis_h:
			_draw_scroll_indicator(right_x + 618, browse_y, browse_vis_h, detail_binding_scroll, total_binding_h, browse_vis_h)

	# === TOOLTIP (drawn last, on top) ===
	if detail_hover_type != "" and detail_hover_index >= 0:
		var tt_title = ""
		var tt_lines: Array = []
		match detail_hover_type:
			"ability":
				if detail_hover_index < abil_data.size():
					var ad = abil_data[detail_hover_index]
					tt_title = ad.get("name", "Tier %d" % (detail_hover_index + 1))
					tt_lines.append(ad.get("desc", ""))
					tt_lines.append("In-game cost: %d gold" % ad.get("cost", 0))
			"weapon":
				tt_title = gear_data["name"]
				tt_lines.append(gear_data["desc"])
				if not gear_unlocked:
					tt_lines.append("Unlocks at Level 2")
			"sidekick":
				if detail_hover_index < sk_data.size():
					tt_title = sk_data[detail_hover_index]["name"]
					tt_lines.append(sk_data[detail_hover_index]["desc"])
					var sk_u = sk_unlocked_arr[detail_hover_index] if detail_hover_index < sk_unlocked_arr.size() else false
					if not sk_u:
						tt_lines.append("Unlocks at Level %d" % sk_levels[detail_hover_index])
			"relic":
				if detail_hover_index < char_relics.size():
					var rd = char_relics[detail_hover_index]
					tt_title = rd["name"]
					tt_lines.append(rd["desc"])
					var r_unlocked = rel_unlocked_arr[detail_hover_index] if detail_hover_index < rel_unlocked_arr.size() else false
					if r_unlocked:
						var eq_list = equipped_relics.get(tower_type, [])
						if detail_hover_index in eq_list:
							tt_lines.append("EQUIPPED - %s to unequip" % _get_action_text())
						elif eq_list.size() < max_rel_slots:
							tt_lines.append("%s to equip" % _get_action_text())
						else:
							tt_lines.append("Equip slots full (%d/%d)" % [eq_list.size(), max_rel_slots])
					elif relic_purchasable[detail_hover_index] and char_level >= relic_earn_levels[detail_hover_index]:
						tt_lines.append("%s to buy for %d gold" % [_get_action_text(), relic_costs[detail_hover_index]])
					else:
						tt_lines.append("Unlocks at Level %d" % relic_earn_levels[detail_hover_index])
		if tt_title != "":
			var mouse_pos = get_viewport().get_mouse_position()
			var tt_w = font.get_string_size(tt_title, HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x + 24
			for tl in tt_lines:
				tt_w = max(tt_w, font.get_string_size(tl, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x + 24)
			tt_w = clampf(tt_w, 160, 340)
			var tt_h = 22.0 + float(tt_lines.size()) * 14.0
			var tt_x = clampf(mouse_pos.x + 14, panel_x, panel_x + panel_w - tt_w - 4)
			var tt_y_pos = mouse_pos.y - tt_h - 10
			if tt_y_pos < panel_y:
				tt_y_pos = mouse_pos.y + 22
			draw_rect(Rect2(tt_x - 1, tt_y_pos - 1, tt_w + 2, tt_h + 2), Color(0, 0, 0, 0.6))
			draw_rect(Rect2(tt_x, tt_y_pos, tt_w, tt_h), Color(0.04, 0.03, 0.10, 0.95))
			draw_rect(Rect2(tt_x, tt_y_pos, tt_w, tt_h), Color(accent.r, accent.g, accent.b, 0.5), false, 1.5)
			_udraw(font, Vector2(tt_x + 8, tt_y_pos + 14), tt_title, HORIZONTAL_ALIGNMENT_LEFT, int(tt_w - 16), 15, menu_gold)
			for tli in range(tt_lines.size()):
				_udraw(font, Vector2(tt_x + 8, tt_y_pos + 28 + tli * 14), tt_lines[tli], HORIZONTAL_ALIGNMENT_LEFT, int(tt_w - 16), 14, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.85))

	# === INFO OVERLAY (drawn on top of everything when open) ===
	if detail_info_overlay_open:
		_draw_detail_info_overlay(panel_x, panel_y, panel_w, panel_h, tower_type, accent, font, char_level, progress)

func _draw_detail_info_overlay(panel_x: float, panel_y: float, panel_w: float, panel_h: float, tower_type, accent: Color, font: Font, char_level: int, progress: Dictionary) -> void:
	# Semi-transparent backdrop
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(0, 0, 0, 0.6))
	# Overlay panel (centered)
	var ov_w = 700.0
	var ov_h = 400.0
	var ov_x = panel_x + (panel_w - ov_w) * 0.5
	var ov_y = panel_y + (panel_h - ov_h) * 0.5
	# Panel background
	for i in range(40):
		var t = float(i) / 39.0
		var col = Color(0.06, 0.04, 0.12).lerp(Color(0.03, 0.02, 0.08), t)
		draw_rect(Rect2(ov_x, ov_y + t * ov_h, ov_w, ov_h / 39.0 + 1), col)
	# Border
	draw_rect(Rect2(ov_x, ov_y, ov_w, ov_h), Color(accent.r, accent.g, accent.b, 0.6), false, 2.0)
	draw_rect(Rect2(ov_x + 2, ov_y + 2, ov_w - 4, ov_h - 4), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.15), false, 1.0)
	# Close button (X)
	var close_x = ov_x + ov_w - 16.0
	var close_y = ov_y + 16.0
	draw_circle(Vector2(close_x, close_y), 12, Color(0.6, 0.2, 0.2, 0.6))
	_udraw(font, Vector2(close_x - 5, close_y + 5), "X", HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color.WHITE)
	# === Content ===
	var cx = ov_x + 20.0
	var cy = ov_y + 16.0
	# Character name
	var char_name = tower_info[tower_type]["name"].to_upper()
	_udraw(font, Vector2(cx, cy + 14), char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 18, menu_parchment)
	# Role badge
	var role = HERO_ROLE_NAMES.get(tower_type, "Hero")
	var role_w = font.get_string_size(role, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x + 16
	var role_x = cx + font.get_string_size(char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 18).x + 14
	draw_rect(Rect2(role_x, cy, role_w, 20), Color(accent.r, accent.g, accent.b, 0.3))
	draw_rect(Rect2(role_x, cy, role_w, 20), Color(accent.r, accent.g, accent.b, 0.5), false, 1.0)
	_udraw(font, Vector2(role_x + 8, cy + 14), role, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(accent.r, accent.g, accent.b, 0.9))
	draw_rect(Rect2(cx, cy + 22, ov_w - 40, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))
	cy += 32.0
	# Character description
	var desc = survivor_descriptions.get(tower_type, "A legendary hero.")
	var desc_lines = desc.split("\n")
	for dl in desc_lines:
		_udraw(font, Vector2(cx, cy + 11), dl, HORIZONTAL_ALIGNMENT_LEFT, int(ov_w - 40), 14, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.8))
		cy += 14.0
	cy += 8.0
	# === Two columns: left = Stats, right = Synergies ===
	var col_w = (ov_w - 60.0) * 0.5
	var left_cx = cx
	var right_cx = cx + col_w + 20.0
	# --- LEFT COLUMN: Combat Stats ---
	_udraw(font, Vector2(left_cx, cy + 12), "COMBAT STATS", HORIZONTAL_ALIGNMENT_LEFT, -1, 15, menu_gold)
	draw_rect(Rect2(left_cx, cy + 16, 100, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.25))
	cy += 24.0
	var stat_left_y = cy
	var total_dmg = progress.get("total_damage", 0.0)
	var est_kills = int(total_dmg / 25.0)  # Rough estimate
	_udraw(font, Vector2(left_cx, stat_left_y + 11), "Total Damage: %s" % _format_number(total_dmg), HORIZONTAL_ALIGNMENT_LEFT, int(col_w), 14, menu_parchment)
	stat_left_y += 16.0
	_udraw(font, Vector2(left_cx, stat_left_y + 11), "Est. Enemies Defeated: %s" % _format_number(float(est_kills)), HORIZONTAL_ALIGNMENT_LEFT, int(col_w), 14, menu_parchment)
	stat_left_y += 16.0
	_udraw(font, Vector2(left_cx, stat_left_y + 11), "Level: %d / %d" % [char_level, MAX_SURVIVOR_LEVEL], HORIZONTAL_ALIGNMENT_LEFT, int(col_w), 14, menu_parchment)
	stat_left_y += 16.0
	# Golden Shields display with upgrade button
	var gs_level = _get_golden_shield_level(tower_type)
	_draw_golden_shield_indicator(Vector2(left_cx + 8, stat_left_y + 6), gs_level, font)
	_udraw(font, Vector2(left_cx + 26, stat_left_y + 11), "Golden Shields: %d / %d" % [gs_level, MAX_GOLDEN_SHIELD], HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 26), 14, Color(0.85, 0.7, 0.2))
	if gs_level < MAX_GOLDEN_SHIELD:
		var gs_cost = GOLDEN_SHIELD_COSTS[gs_level]
		var can_upgrade_gs = player_relic_shards >= gs_cost
		var gs_btn_x = left_cx + col_w - 90.0
		var gs_btn_y = stat_left_y - 2.0
		_gs_upgrade_btn_rect = Rect2(gs_btn_x, gs_btn_y, 86, 18)
		var gs_hover = (detail_hover_type == "golden_shield")
		var gs_bg = Color(0.2, 0.15, 0.05, 0.8) if (can_upgrade_gs and gs_hover) else Color(0.12, 0.08, 0.04, 0.7) if can_upgrade_gs else Color(0.08, 0.06, 0.08, 0.5)
		draw_rect(Rect2(gs_btn_x, gs_btn_y, 86, 18), gs_bg)
		draw_rect(Rect2(gs_btn_x, gs_btn_y, 86, 18), Color(0.85, 0.65, 0.1, 0.5) if can_upgrade_gs else Color(0.3, 0.25, 0.2, 0.3), false, 1.0)
		var gs_text = "UPGRADE %dS" % gs_cost
		_udraw(font, Vector2(gs_btn_x + 43, gs_btn_y + 13), gs_text, HORIZONTAL_ALIGNMENT_CENTER, 82, 14, Color(0.85, 0.7, 0.2) if can_upgrade_gs else Color(0.4, 0.35, 0.3))
	else:
		_udraw(font, Vector2(left_cx + col_w - 60, stat_left_y + 11), "MAXED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.85, 0.7, 0.2, 0.6))
	stat_left_y += 16.0
	_udraw(font, Vector2(left_cx, stat_left_y + 11), "Slots: %d Gear | %d Sidekick | %d Binding" % [_get_gear_slot_count(tower_type), _get_sidekick_slot_count(tower_type), _get_binding_slot_count(tower_type)], HORIZONTAL_ALIGNMENT_LEFT, int(col_w), 14, menu_text)
	stat_left_y += 20.0
	# Level Bonus Breakdown
	_udraw(font, Vector2(left_cx, stat_left_y + 12), "BONUS BREAKDOWN", HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.8))
	draw_rect(Rect2(left_cx, stat_left_y + 16, 100, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.2))
	stat_left_y += 24.0
	var lvl_b = _get_level_bonuses(tower_type)
	var rel_b = _get_relic_bonuses(tower_type)
	var kb_dmg = _get_knowledge_bonus("damage")
	var kb_rng = _get_knowledge_bonus("range")
	var kb_spd = _get_knowledge_bonus("attack_speed")
	var star_b = _get_level_stat_boosts(tower_type)
	var gear_b = _get_binding_bonuses(tower_type)
	var bonus_lines = [
		["Level DMG", lvl_b.get("damage", 0.0)], ["Level RNG", lvl_b.get("range", 0.0)], ["Level SPD", lvl_b.get("attack_speed", 0.0)],
		["Star DMG", star_b.get("damage", 0.0)], ["Star RNG", star_b.get("range", 0.0)], ["Star SPD", star_b.get("attack_speed", 0.0)],
		["Gear DMG", gear_b.get("damage", 0.0)], ["Gear RNG", gear_b.get("range", 0.0)], ["Gear SPD", gear_b.get("attack_speed", 0.0)],
		["Knowledge DMG", kb_dmg], ["Knowledge RNG", kb_rng], ["Knowledge SPD", kb_spd],
	]
	for bl in bonus_lines:
		if bl[1] > 0:
			_udraw(font, Vector2(left_cx + 6, stat_left_y + 10), "%s: +%d%%" % [bl[0], int(bl[1] * 100)], HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 10), 14, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.7))
			stat_left_y += 13.0
	# --- RIGHT COLUMN: Synergies ---
	var syn_y = cy
	_udraw(font, Vector2(right_cx, syn_y + 12), "SYNERGIES", HORIZONTAL_ALIGNMENT_LEFT, -1, 15, menu_gold)
	draw_rect(Rect2(right_cx, syn_y + 16, 80, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.25))
	syn_y += 24.0
	var syn_count = 0
	for syn in synergy_definitions:
		if syn["tower_a"] == tower_type or syn["tower_b"] == tower_type:
			# Synergy card
			draw_rect(Rect2(right_cx, syn_y, col_w, 36), Color(accent.r, accent.g, accent.b, 0.06))
			draw_rect(Rect2(right_cx, syn_y, col_w, 36), Color(accent.r, accent.g, accent.b, 0.15), false, 1.0)
			_udraw(font, Vector2(right_cx + 6, syn_y + 13), syn["name"], HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 12), 14, Color(0.85, 0.65, 0.1, 0.9))
			_udraw(font, Vector2(right_cx + 6, syn_y + 27), syn["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 12), 14, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.7))
			# Partner name
			var partner = syn["tower_b"] if syn["tower_a"] == tower_type else syn["tower_a"]
			var partner_name = tower_info[partner]["name"]
			var pnw = font.get_string_size("+ " + partner_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 8).x
			_udraw(font, Vector2(right_cx + col_w - pnw - 6, syn_y + 13), "+ " + partner_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.6))
			syn_y += 42.0
			syn_count += 1
	if syn_count == 0:
		_udraw(font, Vector2(right_cx + 6, syn_y + 11), "No synergies discovered", HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 12), 14, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.5))

func _format_number(value: float) -> String:
	if value >= 1000000:
		return "%.1fM" % (value / 1000000.0)
	elif value >= 1000:
		return "%.1fK" % (value / 1000.0)
	return str(int(value))

func _format_gold(amount: int) -> String:
	if amount < 1000:
		return str(amount)
	var s = str(amount)
	var result = ""
	var count = 0
	for i in range(s.length() - 1, -1, -1):
		if count > 0 and count % 3 == 0:
			result = "," + result
		result = s[i] + result
		count += 1
	return result

func _draw_detail_level_star(center: Vector2, req_level: int, font: Font) -> void:
	var sr = 10.0
	var spts = PackedVector2Array()
	for si in range(10):
		var sa = -PI * 0.5 + float(si) * TAU / 10.0
		var sd = sr if si % 2 == 0 else sr * 0.4
		spts.append(Vector2(center.x + cos(sa) * sd, center.y + sin(sa) * sd))
	draw_colored_polygon(spts, Color(0.85, 0.65, 0.1, 0.85))
	var ls = str(req_level)
	var lw = font.get_string_size(ls, HORIZONTAL_ALIGNMENT_LEFT, -1, 8).x
	_udraw(font, Vector2(center.x - lw * 0.5, center.y + 3), ls, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.03, 0.03, 0.08))

# Story map node positions — 18 levels in a winding path
var story_map_selected_node: int = -1
var story_map_scroll_y: float = 0.0
var story_map_active_arc: int = -1
var menu_side_panel: String = ""  # "", "deals", "quests", "arena", "odyssey", "endless"

func _get_story_map_node_positions() -> Array:
	# Two-column book spread layout:
	# Left page: Act I (arcs 0-5, levels 0-15)
	# Right page: Act II (arcs 6-11, levels 16-33)
	# Bottom center: Act III / Shadow Author (levels 34-36)
	var nodes: Array = []
	var row_h = 56.0
	var start_y = 95.0
	var lx = [200.0, 310.0, 420.0]  # Left column L→R
	var lx_rev = [420.0, 310.0, 200.0]  # Left column R→L
	var rx = [810.0, 920.0, 1030.0]  # Right column L→R
	var rx_rev = [1030.0, 920.0, 810.0]  # Right column R→L
	# Level 0: Prologue — centered in left column
	nodes.append(Vector2(310.0, start_y))
	# Levels 1-15: Left column arcs 1-5 (Sherlock → Frankenstein)
	for r in range(5):
		var y = start_y + float(r + 1) * row_h
		var xs = lx if r % 2 == 0 else lx_rev
		nodes.append(Vector2(xs[0], y))
		nodes.append(Vector2(xs[1], y))
		nodes.append(Vector2(xs[2], y))
	# Levels 16-33: Right column arcs 6-11 (Robin Hood → Scrooge)
	for r in range(6):
		var y = start_y + float(r) * row_h
		var xs = rx if r % 2 == 0 else rx_rev
		nodes.append(Vector2(xs[0], y))
		nodes.append(Vector2(xs[1], y))
		nodes.append(Vector2(xs[2], y))
	# Levels 34-36: Shadow Author — centered bottom
	var shadow_y = start_y + 6.0 * row_h + 18.0
	nodes.append(Vector2(460.0, shadow_y))
	nodes.append(Vector2(640.0, shadow_y))
	nodes.append(Vector2(820.0, shadow_y))
	return nodes

var chapters_hover_level: int = -1
var chapters_diff_popup_level: int = -1  # Level index for difficulty picker popup (-1 = closed)

func _draw_story_map() -> void:
	var font = game_font
	var list_x = 40.0
	var list_y = 36.0
	var list_w = 1200.0
	var list_h = 610.0
	var row_h = 82.0
	var header_h = 32.0
	var arc_gap = 6.0

	# --- Background panel ---
	draw_rect(Rect2(list_x, list_y, list_w, list_h), Color(0.05, 0.04, 0.08, 0.95))
	draw_rect(Rect2(list_x, list_y, list_w, 2), Color(0.54, 0.45, 0.20, 0.4))
	draw_rect(Rect2(list_x, list_y + list_h - 2, list_w, 2), Color(0.54, 0.45, 0.20, 0.25))

	# --- Title bar ---
	draw_rect(Rect2(list_x, list_y, list_w, 36), Color(0.08, 0.06, 0.12, 0.9))
	_udraw(font, Vector2(list_x + list_w * 0.35, list_y + 25), "THE TOME OF SHADOWS", HORIZONTAL_ALIGNMENT_CENTER, list_w - 40, 16, Color(0.85, 0.70, 0.28))
	# Level progress indicator
	var num_completed = completed_levels.size()
	var num_total = levels.size()
	var progress_text = "%d/%d Levels" % [num_completed, num_total]
	_udraw(font, Vector2(list_x + list_w - 160, list_y + 25), progress_text, HORIZONTAL_ALIGNMENT_RIGHT, 150, 15, Color(0.7, 0.65, 0.5, 0.8))
	# Mini progress bar
	var pb_x = list_x + list_w - 155
	var pb_w = 105.0
	draw_rect(Rect2(pb_x, list_y + 28, pb_w, 4), Color(0.2, 0.18, 0.25, 0.6))
	var pb_fill = pb_w * clampf(float(num_completed) / float(maxi(num_total, 1)), 0.0, 1.0)
	draw_rect(Rect2(pb_x, list_y + 28, pb_fill, 4), Color(0.85, 0.70, 0.28, 0.8))
	draw_rect(Rect2(list_x, list_y + 36, list_w, 1), Color(0.54, 0.45, 0.20, 0.3))

	var content_top = list_y + 40.0
	var content_h = list_h - 40.0

	# --- Calculate total content height ---
	var total_h = 0.0
	for arc in arc_data:
		total_h += header_h + arc_gap
		total_h += float(arc["levels"].size()) * row_h
	total_h += 10.0  # Bottom padding
	var max_scroll = maxf(0.0, total_h - content_h)
	story_map_scroll_y = clampf(story_map_scroll_y, 0.0, max_scroll)

	# --- Clip region (draw only within visible area) ---
	var scroll_y = story_map_scroll_y
	var cursor_y = content_top - scroll_y
	var mouse_pos = get_viewport().get_mouse_position()

	# Enhancement 18: Find first uncompleted level for NEXT indicator
	var first_uncompleted_level = -1
	for _fli in range(levels.size()):
		if _fli not in completed_levels and _is_level_unlocked(_fli):
			first_uncompleted_level = _fli
			break

	# Track previous row center for connecting lines (Enhancement 17)
	var prev_row_center = Vector2.ZERO
	var prev_row_visible = false

	var arc_color_map = {
		"Prologue": Color(0.45, 0.30, 0.55),
		"Sherlock Holmes": Color(0.50, 0.50, 0.62),
		"Merlin": Color(0.30, 0.50, 0.72),
		"Tarzan": Color(0.25, 0.60, 0.25),
		"Dracula": Color(0.65, 0.18, 0.22),
		"Frankenstein": Color(0.42, 0.52, 0.32),
		"Robin Hood": Color(0.32, 0.58, 0.28),
		"Alice": Color(0.46, 0.68, 0.88),
		"Wicked Witch": Color(0.52, 0.28, 0.66),
		"Peter Pan": Color(0.92, 0.52, 0.16),
		"Phantom": Color(0.78, 0.25, 0.20),
		"Scrooge": Color(0.82, 0.68, 0.32),
		"Shadow Author": Color(0.25, 0.10, 0.30),
	}

	for ai in range(arc_data.size()):
		var arc = arc_data[ai]
		var arc_name = arc["name"]
		var arc_col = arc_color_map.get(arc_name, Color(0.5, 0.5, 0.5))
		var arc_levels = arc["levels"]

		# Reset path line tracking for new arc
		prev_row_visible = false

		# --- Arc completion ---
		var arc_done = 0
		var arc_total = arc_levels.size()
		for lvl_idx in arc_levels:
			if lvl_idx in completed_levels:
				arc_done += 1
		var arc_pct = 0
		if arc_total > 0:
			arc_pct = int(float(arc_done) / float(arc_total) * 100.0)

		# --- Arc header ---
		if cursor_y + header_h > content_top and cursor_y < content_top + content_h:
			var hy = maxf(cursor_y, content_top)
			draw_rect(Rect2(list_x + 4, hy, list_w - 8, header_h), Color(arc_col.r * 0.3, arc_col.g * 0.3, arc_col.b * 0.3, 0.8))
			draw_rect(Rect2(list_x + 4, hy, 4, header_h), Color(arc_col.r, arc_col.g, arc_col.b, 0.8))
			_udraw(font, Vector2(list_x + 18, hy + 22), arc_name.to_upper(), HORIZONTAL_ALIGNMENT_LEFT, 180, 14, Color(0.92, 0.78, 0.28))
			if arc_done == arc_total:
				_udraw(font, Vector2(list_x + list_w - 20, hy + 22), "COMPLETE", HORIZONTAL_ALIGNMENT_RIGHT, 200, 15, Color(0.45, 0.80, 0.30))
			else:
				_udraw(font, Vector2(list_x + list_w - 20, hy + 22), "%d%% Complete" % arc_pct, HORIZONTAL_ALIGNMENT_RIGHT, 200, 15, Color(0.60, 0.52, 0.38))
			# Enhancement 14: Chapter progress bar
			var cpb_x = list_x + 200.0
			var cpb_w = list_w - 420.0
			var cpb_y = hy + 26.0
			draw_rect(Rect2(cpb_x, cpb_y, cpb_w, 3), Color(0.2, 0.18, 0.15, 0.5))
			var cpb_fill = cpb_w * clampf(float(arc_done) / float(maxi(arc_total, 1)), 0.0, 1.0)
			var cpb_col = Color(0.45, 0.80, 0.30, 0.8) if arc_done == arc_total else Color(arc_col.r, arc_col.g, arc_col.b, 0.7)
			draw_rect(Rect2(cpb_x, cpb_y, cpb_fill, 3), cpb_col)
			# Glowing tip on progress bar
			if cpb_fill > 0 and arc_done < arc_total:
				var tip_glow = 0.4 + sin(_time * 3.0) * 0.2
				draw_circle(Vector2(cpb_x + cpb_fill, cpb_y + 1.5), 3.0, Color(arc_col.r, arc_col.g, arc_col.b, tip_glow))
		cursor_y += header_h + arc_gap

		# --- Level rows ---
		for li in range(arc_levels.size()):
			var lvl_idx = arc_levels[li]
			if lvl_idx >= levels.size():
				prev_row_visible = false
				cursor_y += row_h
				continue
			var level = levels[lvl_idx]
			var is_unlocked = _is_level_unlocked(lvl_idx)
			var is_complete = lvl_idx in completed_levels
			var stars = level_stars.get(lvl_idx, 0)
			var is_boss = (li == arc_levels.size() - 1) and arc_levels.size() >= 3

			# Skip rows outside visible area
			if cursor_y + row_h < content_top or cursor_y > content_top + content_h:
				prev_row_center = Vector2(list_x + 30.0, cursor_y + row_h * 0.5)
				prev_row_visible = false
				cursor_y += row_h
				continue

			var ry = cursor_y
			var rx = list_x + 8.0
			var rw = list_w - 16.0
			var row_center = Vector2(rx + 30.0, ry + row_h * 0.5)

			# Enhancement 17: Connected path lines between levels
			if li > 0 and prev_row_visible:
				var line_col = Color(arc_col.r, arc_col.g, arc_col.b, 0.25)
				draw_line(prev_row_center, row_center, line_col, 1.0)
				# Small dot at connection point
				draw_circle(row_center, 2.0, Color(arc_col.r, arc_col.g, arc_col.b, 0.35))
			prev_row_center = row_center
			prev_row_visible = true

			# --- Row background ---
			var is_hovered = Rect2(rx, maxf(ry, content_top), rw, row_h).has_point(mouse_pos) and ry >= content_top
			# Enhancement 20: Chapter theme accent colors — tint row bg with arc color
			var tint_r = arc_col.r * 0.06
			var tint_g = arc_col.g * 0.06
			var tint_b = arc_col.b * 0.06
			var row_bg = Color(0.10 + tint_r, 0.08 + tint_g, 0.06 + tint_b, 0.5) if not is_hovered else Color(0.15 + tint_r, 0.12 + tint_g, 0.08 + tint_b, 0.7)
			if not is_unlocked:
				row_bg = Color(0.06, 0.05, 0.04, 0.4)
			draw_rect(Rect2(rx, ry, rw, row_h - 2), row_bg)
			# Left accent bar
			var accent_col = arc_col if is_unlocked else Color(0.3, 0.25, 0.2, 0.3)
			draw_rect(Rect2(rx, ry, 3, row_h - 2), accent_col)

			# Enhancement 16: Boss level red border
			if is_boss and is_unlocked:
				var boss_pulse = 0.3 + sin(_time * 2.5) * 0.1
				draw_rect(Rect2(rx, ry, rw, row_h - 2), Color(0.8, 0.15, 0.1, boss_pulse), false, 2.0)
				# Red corner accents
				draw_rect(Rect2(rx, ry, 12, 2), Color(0.9, 0.2, 0.1, 0.6))
				draw_rect(Rect2(rx, ry, 2, 12), Color(0.9, 0.2, 0.1, 0.6))
				draw_rect(Rect2(rx + rw - 12, ry, 12, 2), Color(0.9, 0.2, 0.1, 0.6))
				draw_rect(Rect2(rx + rw - 2, ry, 2, 12), Color(0.9, 0.2, 0.1, 0.6))
				# "BOSS" label in top-right corner
				_udraw(font, Vector2(rx + rw - 45, ry + 12), "BOSS", HORIZONTAL_ALIGNMENT_RIGHT, 40, 14, Color(0.9, 0.25, 0.15, 0.7))

			# Enhancement 18: NEXT pulse on recommended level
			if lvl_idx == first_uncompleted_level:
				var next_pulse_a = 0.15 + sin(_time * 4.0) * 0.1
				draw_rect(Rect2(rx, ry, rw, row_h - 2), Color(0.3, 0.8, 0.3, next_pulse_a))
				# Pulsing "NEXT" badge
				var next_badge_x = rx + rw - 100.0
				var next_badge_y = ry + 56.0
				var next_text_a = 0.7 + sin(_time * 4.0) * 0.3
				var next_scale = 1.0 + sin(_time * 3.0) * 0.05
				draw_rect(Rect2(next_badge_x, next_badge_y, 80.0 * next_scale, 16), Color(0.2, 0.6, 0.15, next_text_a * 0.5))
				_udraw(font, Vector2(next_badge_x + 40.0 * next_scale, next_badge_y + 12), ">> NEXT <<", HORIZONTAL_ALIGNMENT_CENTER, 78, 14, Color(0.4, 1.0, 0.4, next_text_a))

			# --- Mini map thumbnail (70x52) ---
			var thumb_x = rx + 12.0
			var thumb_y = ry + 8.0
			var thumb_w = 70.0
			var thumb_h = 52.0
			var sky = level["sky_color"] if is_unlocked else Color(0.15, 0.12, 0.10)
			var gnd = level["ground_color"] if is_unlocked else Color(0.10, 0.08, 0.06)
			draw_rect(Rect2(thumb_x, thumb_y, thumb_w, thumb_h * 0.5), sky)
			draw_rect(Rect2(thumb_x, thumb_y + thumb_h * 0.5, thumb_w, thumb_h * 0.5), gnd)
			# Terrain detail dots (subtle background)
			for ti in range(5):
				var tx = thumb_x + float(ti) * 16.0 + 4.0
				var ty = thumb_y + thumb_h * 0.48 + sin(float(ti + lvl_idx) * 1.3) * 4.0
				draw_circle(Vector2(tx, ty), 3.0, Color(gnd.r * 1.2, gnd.g * 1.2, gnd.b * 1.2, 0.25))
			# Path preview in thumbnail
			if _path_thumbnail_cache.has(lvl_idx) and is_unlocked:
				var pts = _path_thumbnail_cache[lvl_idx]
				if pts.size() >= 2:
					var min_p = Vector2(1e9, 1e9)
					var max_p = Vector2(-1e9, -1e9)
					for p in pts:
						min_p.x = minf(min_p.x, p.x)
						min_p.y = minf(min_p.y, p.y)
						max_p.x = maxf(max_p.x, p.x)
						max_p.y = maxf(max_p.y, p.y)
					var range_p = max_p - min_p
					if range_p.x < 1: range_p.x = 1
					if range_p.y < 1: range_p.y = 1
					var margin = 4.0
					var draw_w = thumb_w - margin * 2
					var draw_h = thumb_h - margin * 2
					var scaled: PackedVector2Array = PackedVector2Array()
					for p in pts:
						var nx = thumb_x + margin + ((p.x - min_p.x) / range_p.x) * draw_w
						var ny = thumb_y + margin + ((p.y - min_p.y) / range_p.y) * draw_h
						scaled.append(Vector2(nx, ny))
					var path_col = Color(0.85, 0.75, 0.45, 0.7)
					for pi in range(scaled.size() - 1):
						draw_line(scaled[pi], scaled[pi + 1], path_col, 1.5)
					draw_circle(scaled[0], 2.5, Color(0.3, 0.8, 0.3, 0.8))
					draw_circle(scaled[scaled.size() - 1], 2.5, Color(0.8, 0.2, 0.2, 0.8))
			draw_rect(Rect2(thumb_x, thumb_y, thumb_w, thumb_h), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
			# Level number badge
			draw_circle(Vector2(thumb_x + 12, thumb_y + 12), 10, Color(0.0, 0.0, 0.0, 0.6))
			_udraw(font, Vector2(thumb_x + 12, thumb_y + 16), str(lvl_idx + 1), HORIZONTAL_ALIGNMENT_CENTER, 20, 14, Color(0.90, 0.82, 0.55))

			# --- Text info ---
			var text_x = thumb_x + thumb_w + 14.0
			var name_col = Color(0.92, 0.80, 0.35) if is_unlocked else Color(0.45, 0.38, 0.28, 0.6)
			var sub_col = Color(0.70, 0.60, 0.42) if is_unlocked else Color(0.35, 0.30, 0.22, 0.5)
			var stat_col = Color(0.55, 0.70, 0.45) if is_unlocked else Color(0.30, 0.28, 0.22, 0.4)
			_udraw(font, Vector2(text_x, ry + 22), level["name"], HORIZONTAL_ALIGNMENT_LEFT, 440, 14, name_col)
			_udraw(font, Vector2(text_x, ry + 38), level["subtitle"], HORIZONTAL_ALIGNMENT_LEFT, 440, 14, sub_col)

			# Enhancement 22: Best wave indicator
			var wave_info = "Waves: %d  |  Gold: %d  |  Lives: %d" % [level["waves"], level["gold"], level["lives"]]
			var best_w = level_best_wave.get(lvl_idx, 0)
			if best_w > 0:
				wave_info += "  |  Best: W%d" % best_w
			_udraw(font, Vector2(text_x, ry + 54), wave_info, HORIZONTAL_ALIGNMENT_LEFT, 440, 14, stat_col)

			# Enhancement 21: Reward preview icons on level cards
			var level_rewards = _get_level_rewards(lvl_idx)
			if level_rewards.size() > 0 and is_unlocked:
				var reward_icon_x = text_x
				var reward_icon_y = ry + 68.0
				# Show up to 3 small reward hint icons
				var reward_count = mini(level_rewards.size(), 3)
				for ri in range(reward_count):
					var rix = reward_icon_x + float(ri) * 18.0
					var reward_text = level_rewards[ri]
					if "DMG" in reward_text or "SPD" in reward_text or "RNG" in reward_text:
						# Stat boost — small up-arrow icon
						draw_line(Vector2(rix + 4, reward_icon_y + 2), Vector2(rix + 4, reward_icon_y - 4), Color(0.4, 0.8, 0.3, 0.6), 1.5)
						draw_line(Vector2(rix + 1, reward_icon_y - 1), Vector2(rix + 4, reward_icon_y - 4), Color(0.4, 0.8, 0.3, 0.6), 1.5)
						draw_line(Vector2(rix + 7, reward_icon_y - 1), Vector2(rix + 4, reward_icon_y - 4), Color(0.4, 0.8, 0.3, 0.6), 1.5)
					elif "Weapon" in reward_text or "Slot" in reward_text:
						# Unlock — small star icon
						_draw_mini_star(Vector2(rix + 4, reward_icon_y - 1), 4.0, Color(0.85, 0.70, 0.28, 0.7))
					elif "Relic" in reward_text:
						# Relic — small diamond
						var dc = Color(0.7, 0.3, 0.9, 0.6)
						draw_line(Vector2(rix + 4, reward_icon_y - 5), Vector2(rix + 8, reward_icon_y - 1), dc, 1.5)
						draw_line(Vector2(rix + 8, reward_icon_y - 1), Vector2(rix + 4, reward_icon_y + 3), dc, 1.5)
						draw_line(Vector2(rix + 4, reward_icon_y + 3), Vector2(rix, reward_icon_y - 1), dc, 1.5)
						draw_line(Vector2(rix, reward_icon_y - 1), Vector2(rix + 4, reward_icon_y - 5), dc, 1.5)
					elif "Binding" in reward_text or "Tome" in reward_text:
						# Binding — small book icon
						draw_rect(Rect2(rix + 1, reward_icon_y - 4, 6, 8), Color(0.6, 0.4, 0.2, 0.5))
						draw_line(Vector2(rix + 4, reward_icon_y - 4), Vector2(rix + 4, reward_icon_y + 4), Color(0.85, 0.70, 0.28, 0.4), 1.0)
					else:
						# Generic reward — small circle
						draw_circle(Vector2(rix + 4, reward_icon_y - 1), 3.0, Color(0.85, 0.70, 0.28, 0.4))
				if reward_count > 0:
					_udraw(font, Vector2(reward_icon_x + float(reward_count) * 18.0 + 4, reward_icon_y + 3), "%d rewards" % level_rewards.size(), HORIZONTAL_ALIGNMENT_LEFT, 100, 14, Color(0.6, 0.55, 0.40, 0.5))

			# --- Difficulty medals (BTD6-style shields) ---
			var medal_x = rx + rw - 240.0
			var medal_colors = [Color(0.45, 0.72, 0.35), Color(0.82, 0.72, 0.22), Color(0.90, 0.45, 0.15)]
			var medal_labels = ["E", "M", "H"]
			var medals = level_difficulty_medals.get(lvl_idx, [false, false, false])
			var diff_stars_arr = level_difficulty_stars.get(lvl_idx, [0, 0, 0])
			for di in range(3):
				var mx = medal_x + float(di) * 44.0
				var my = ry + 14.0
				var mw = 38.0
				var mh = 48.0
				var earned = medals[di]
				if earned:
					# Filled shield with difficulty color
					var mc = medal_colors[di]
					_draw_shield(Vector2(mx + mw * 0.5, my + mh * 0.5), 16.0, mc, true)
					# Enhancement 15: Star glow behind earned stars
					var ds = diff_stars_arr[di]
					for dsi in range(3):
						var sx = mx + mw * 0.5 - 8.0 + float(dsi) * 8.0
						var sy = my + mh * 0.5 + 8.0
						if dsi < ds:
							# Golden glow behind earned star
							var star_glow_a = 0.15 + sin(_time * 2.5 + float(dsi) * 0.5) * 0.08
							draw_circle(Vector2(sx, sy), 6.0, Color(1.0, 0.85, 0.2, star_glow_a))
							_draw_mini_star(Vector2(sx, sy), 3.5, Color(1, 0.95, 0.7, 0.95))
						else:
							_draw_mini_star(Vector2(sx, sy), 3.0, Color(0.5, 0.4, 0.3, 0.25))
				else:
					# Gray outline shield (unearned)
					_draw_shield(Vector2(mx + mw * 0.5, my + mh * 0.5), 16.0, Color(0.3, 0.25, 0.2, 0.3), false)
				# Difficulty letter below shield
				var lbl_col = medal_colors[di] if earned else Color(0.35, 0.30, 0.22, 0.4)
				_udraw(font, Vector2(mx + mw * 0.5, my + mh - 2), medal_labels[di], HORIZONTAL_ALIGNMENT_CENTER, 20, 14, lbl_col)

			# Enhancement 13: Level difficulty medals (Easy/Med/Hard dots)
			var dot_base_x = medal_x
			var dot_y = ry + row_h - 10.0
			for di in range(3):
				var dot_x = dot_base_x + float(di) * 44.0 + 19.0
				var dot_col = [Color(0.3, 0.8, 0.3), Color(0.85, 0.7, 0.2), Color(0.9, 0.2, 0.15)][di]
				if medals[di]:
					draw_circle(Vector2(dot_x, dot_y), 3.0, dot_col)
				else:
					draw_arc(Vector2(dot_x, dot_y), 3.0, 0, TAU, 8, Color(dot_col.r, dot_col.g, dot_col.b, 0.2), 1.0)

			# --- GO / PLAY button or LOCKED ---
			var btn_x = rx + rw - 100.0
			var btn_y2 = ry + 14.0
			var btn_w2 = 80.0
			var btn_h2 = 38.0
			if is_unlocked:
				var btn_hover = Rect2(btn_x, btn_y2, btn_w2, btn_h2).has_point(mouse_pos) and ry >= content_top
				var btn_pulse = 0.85 + sin(_time * 3.0) * 0.15 if not is_complete else 0.7
				var btn_col = Color(0.20, 0.58, 0.15, btn_pulse) if not btn_hover else Color(0.25, 0.68, 0.18, 1.0)
				if is_complete:
					btn_col = Color(0.15, 0.40, 0.12, 0.6) if not btn_hover else Color(0.20, 0.50, 0.15, 0.8)
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, btn_h2), btn_col)
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, 2), Color(0.4, 0.8, 0.3, 0.3))
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, btn_h2), Color(0.54, 0.45, 0.20, 0.4), false, 1.0)
				_udraw(font, Vector2(btn_x + btn_w2 * 0.5, btn_y2 + 25), "GO", HORIZONTAL_ALIGNMENT_CENTER, btn_w2 - 8, 14, Color(1, 1, 1, 0.95))
			else:
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, btn_h2), Color(0.12, 0.10, 0.08, 0.5))
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, btn_h2), Color(0.3, 0.25, 0.18, 0.3), false, 1.0)
				# Lock icon
				var lc = Vector2(btn_x + btn_w2 * 0.5, btn_y2 + btn_h2 * 0.5)
				draw_rect(Rect2(lc.x - 5, lc.y - 1, 10, 9), Color(0.40, 0.32, 0.20, 0.5))
				draw_arc(Vector2(lc.x, lc.y - 3), 5.0, PI, TAU, 10, Color(0.40, 0.32, 0.20, 0.5), 1.5)
				# Enhancement 19: Locked level requirement text
				if lvl_idx > 0:
					var req_lvl = lvl_idx - 1
					var req_name = levels[req_lvl]["name"] if req_lvl < levels.size() else "Level %d" % req_lvl
					_udraw(font, Vector2(btn_x + btn_w2 * 0.5, btn_y2 + btn_h2 + 10), "Complete:", HORIZONTAL_ALIGNMENT_CENTER, btn_w2 + 20, 14, Color(0.5, 0.38, 0.25, 0.5))
					_udraw(font, Vector2(btn_x + btn_w2 * 0.5, btn_y2 + btn_h2 + 22), req_name, HORIZONTAL_ALIGNMENT_CENTER, btn_w2 + 40, 14, Color(0.65, 0.50, 0.30, 0.6))

			# --- Bottom separator ---
			draw_line(Vector2(rx + 8, ry + row_h - 2), Vector2(rx + rw - 8, ry + row_h - 2), Color(0.54, 0.45, 0.20, 0.08), 1.0)

			cursor_y += row_h

	# --- Scroll bar ---
	if max_scroll > 0:
		var bar_x = list_x + list_w - 8
		var bar_h_vis = content_h * (content_h / total_h)
		var bar_y_pos = content_top + (scroll_y / max_scroll) * (content_h - bar_h_vis)
		draw_rect(Rect2(bar_x, content_top, 4, content_h), Color(0.2, 0.15, 0.10, 0.15))
		draw_rect(Rect2(bar_x, bar_y_pos, 4, bar_h_vis), Color(0.54, 0.45, 0.20, 0.35))

func _on_story_map_clicked(mouse_pos: Vector2) -> void:
	# Handle difficulty popup clicks first
	if chapters_diff_popup_level >= 0:
		_on_diff_popup_clicked(mouse_pos)
		return

	var list_x = 40.0
	var list_y = 36.0
	var list_w = 1200.0
	var list_h = 610.0
	var row_h = 82.0
	var header_h = 32.0
	var arc_gap = 6.0
	var content_top = list_y + 40.0
	var content_h = list_h - 40.0
	var scroll_y = story_map_scroll_y

	# Only process clicks within the list area
	if not Rect2(list_x, content_top, list_w, content_h).has_point(mouse_pos):
		return

	var cursor_y = content_top - scroll_y
	for ai in range(arc_data.size()):
		var arc = arc_data[ai]
		cursor_y += header_h + arc_gap
		for li in range(arc["levels"].size()):
			var lvl_idx = arc["levels"][li]
			if lvl_idx >= levels.size():
				cursor_y += row_h
				continue
			var ry = cursor_y
			var rx = list_x + 8.0
			var rw = list_w - 16.0

			if ry + row_h >= content_top and ry <= content_top + content_h:
				# Check GO button click — opens difficulty popup
				var btn_x = rx + rw - 100.0
				var btn_y2 = ry + 14.0
				var btn_w2 = 80.0
				var btn_h2 = 38.0
				if Rect2(btn_x, btn_y2, btn_w2, btn_h2).has_point(mouse_pos):
					if _is_level_unlocked(lvl_idx):
						chapters_diff_popup_level = lvl_idx
						queue_redraw()
						return

			cursor_y += row_h

func _on_diff_popup_clicked(mouse_pos: Vector2) -> void:
	# Difficulty popup: centered overlay with 4 difficulty buttons
	var popup_w = 440.0
	var popup_h = 220.0
	var popup_x = 640.0 - popup_w * 0.5
	var popup_y = 310.0 - popup_h * 0.5
	# Click outside popup closes it
	if not Rect2(popup_x, popup_y, popup_w, popup_h).has_point(mouse_pos):
		chapters_diff_popup_level = -1
		queue_redraw()
		return
	# Check difficulty button clicks
	var btn_w = 90.0
	var btn_h = 80.0
	var btn_y = popup_y + 80.0
	var spacing = 10.0
	var total_btn_w = 4.0 * btn_w + 3.0 * spacing
	var btn_start_x = popup_x + (popup_w - total_btn_w) * 0.5
	for di in range(4):
		var bx = btn_start_x + float(di) * (btn_w + spacing)
		if Rect2(bx, btn_y, btn_w, btn_h).has_point(mouse_pos):
			selected_difficulty = di
			var lvl = chapters_diff_popup_level
			chapters_diff_popup_level = -1
			_on_level_selected(lvl)
			return

func _draw_diff_popup() -> void:
	if chapters_diff_popup_level < 0:
		return
	var font = game_font
	var lvl_idx = chapters_diff_popup_level
	var level = levels[lvl_idx] if lvl_idx < levels.size() else null
	if level == null:
		chapters_diff_popup_level = -1
		return
	var mouse_pos = get_viewport().get_mouse_position()

	# Dim background
	draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.6))

	# Popup panel
	var popup_w = 440.0
	var popup_h = 220.0
	var popup_x = 640.0 - popup_w * 0.5
	var popup_y = 310.0 - popup_h * 0.5
	# Background gradient
	for gi in range(22):
		var t = float(gi) / 21.0
		var col = Color(0.08, 0.06, 0.12).lerp(Color(0.04, 0.03, 0.07), t)
		draw_rect(Rect2(popup_x, popup_y + t * popup_h, popup_w, popup_h / 21.0 + 1), col)
	# Gold border
	var bp = 0.6 + sin(_time * 2.0) * 0.15
	draw_rect(Rect2(popup_x, popup_y, popup_w, popup_h), Color(0.85, 0.70, 0.28, bp), false, 2.0)
	# Inner border
	draw_rect(Rect2(popup_x + 3, popup_y + 3, popup_w - 6, popup_h - 6), Color(0.85, 0.70, 0.28, bp * 0.2), false, 1.0)

	# Title
	_udraw(font, Vector2(popup_x + popup_w * 0.5, popup_y + 24), level["name"], HORIZONTAL_ALIGNMENT_CENTER, int(popup_w - 20), 15, Color(0.92, 0.80, 0.35))
	_udraw(font, Vector2(popup_x + popup_w * 0.5, popup_y + 46), "Select Difficulty", HORIZONTAL_ALIGNMENT_CENTER, int(popup_w - 20), 14, Color(0.65, 0.55, 0.40))
	draw_rect(Rect2(popup_x + 15, popup_y + 55, popup_w - 30, 1), Color(0.85, 0.70, 0.28, 0.3))

	# 4 difficulty buttons
	var diff_names = ["EASY", "MEDIUM", "HARD", "PURE"]
	var diff_colors = [Color(0.35, 0.72, 0.30), Color(0.82, 0.72, 0.18), Color(0.90, 0.35, 0.15), Color(0.75, 0.15, 0.15)]
	var diff_waves = ["20 waves", "30 waves", "40 waves", "40 waves"]
	var diff_lives_text = ["100 lives", "50 lives", "20 lives", "1 life"]
	var medals = level_difficulty_medals.get(lvl_idx, [false, false, false, false])
	var diff_stars_arr = level_difficulty_stars.get(lvl_idx, [0, 0, 0, 0])

	var btn_w = 90.0
	var btn_h = 80.0
	var btn_y = popup_y + 80.0
	var spacing = 10.0
	var total_btn_w = 4.0 * btn_w + 3.0 * spacing
	var btn_start_x = popup_x + (popup_w - total_btn_w) * 0.5

	for di in range(4):
		var bx = btn_start_x + float(di) * (btn_w + spacing)
		var dc = diff_colors[di]
		var is_hovered = Rect2(bx, btn_y, btn_w, btn_h).has_point(mouse_pos)
		var earned = medals[di]

		# Button background
		var bg_alpha = 0.7 if is_hovered else 0.4
		draw_rect(Rect2(bx, btn_y, btn_w, btn_h), Color(dc.r * 0.15, dc.g * 0.15, dc.b * 0.15, bg_alpha))
		# Border (glowing if earned)
		var border_a = 0.9 if is_hovered else (0.6 if earned else 0.3)
		draw_rect(Rect2(bx, btn_y, btn_w, btn_h), Color(dc.r, dc.g, dc.b, border_a), false, 2.0 if earned else 1.0)
		# Top accent
		draw_rect(Rect2(bx, btn_y, btn_w, 2), Color(dc.r, dc.g, dc.b, 0.5))

		# Shield icon at top of button
		var shield_cx = bx + btn_w * 0.5
		var shield_cy = btn_y + 20.0
		if earned:
			_draw_shield(Vector2(shield_cx, shield_cy), 12.0, dc, true)
			# Checkmark inside shield
			draw_line(Vector2(shield_cx - 4, shield_cy - 1), Vector2(shield_cx - 1, shield_cy + 3), Color(1, 1, 1, 0.9), 2.0)
			draw_line(Vector2(shield_cx - 1, shield_cy + 3), Vector2(shield_cx + 5, shield_cy - 4), Color(1, 1, 1, 0.9), 2.0)
		else:
			_draw_shield(Vector2(shield_cx, shield_cy), 12.0, Color(dc.r, dc.g, dc.b, 0.3), false)

		# Difficulty name
		_udraw(font, Vector2(bx + btn_w * 0.5, btn_y + 42), diff_names[di], HORIZONTAL_ALIGNMENT_CENTER, int(btn_w - 4), 14, Color(dc.r, dc.g, dc.b, 0.95))
		# Wave/lives info
		_udraw(font, Vector2(bx + btn_w * 0.5, btn_y + 56), diff_waves[di], HORIZONTAL_ALIGNMENT_CENTER, int(btn_w - 4), 14, Color(0.6, 0.55, 0.45, 0.7))
		_udraw(font, Vector2(bx + btn_w * 0.5, btn_y + 68), diff_lives_text[di], HORIZONTAL_ALIGNMENT_CENTER, int(btn_w - 4), 14, Color(0.6, 0.55, 0.45, 0.7))

		# Stars below button if earned
		if earned:
			var ds = diff_stars_arr[di]
			for dsi in range(3):
				var sx = bx + btn_w * 0.5 - 12.0 + float(dsi) * 12.0
				var sy = btn_y + btn_h + 10.0
				if dsi < ds:
					_draw_mini_star(Vector2(sx, sy), 5.0, Color(1, 0.88, 0.32, 0.9))
				else:
					_draw_mini_star(Vector2(sx, sy), 4.5, Color(0.35, 0.28, 0.18, 0.3))

	# Close hint
	_udraw(font, Vector2(popup_x + popup_w * 0.5, popup_y + popup_h - 12), "Click outside to cancel", HORIZONTAL_ALIGNMENT_CENTER, int(popup_w - 20), 14, Color(0.5, 0.45, 0.35, 0.5))

func _draw_chapters_badges() -> void:
	var font = game_font
	var mouse_pos = get_viewport().get_mouse_position()
	# 5 floating animated badge circles along the right edge of the chapter view
	var badges = [
		{"id": "deals", "label": "DEALS", "col": Color(0.85, 0.70, 0.28)},
		{"id": "quests", "label": "QUESTS", "col": Color(0.4, 0.8, 0.3)},
		{"id": "arena", "label": "ARENA", "col": Color(0.7, 0.3, 0.9)},
		{"id": "odyssey", "label": "ODYSSEY", "col": Color(0.82, 0.62, 0.92)},
		{"id": "endless", "label": "ENDLESS", "col": Color(0.52, 0.62, 0.92)},
	]
	var badge_x = 1222.0
	var badge_start_y = 85.0
	var badge_spacing = 68.0
	var badge_r = 24.0

	for i in range(badges.size()):
		var badge = badges[i]
		var tc = badge["col"]
		var bob = sin(_time * 1.5 + float(i) * 1.2) * 2.5
		var cx = badge_x
		var cy = badge_start_y + float(i) * badge_spacing + bob
		var is_hovered = mouse_pos.distance_to(Vector2(cx, cy)) < badge_r + 5
		var pulse = 0.12 + sin(_time * 3.0 + float(i) * 0.8) * 0.08

		# Outer glow halo
		var glow_r = badge_r + 8 + sin(_time * 2.0 + float(i)) * 3.0
		draw_circle(Vector2(cx, cy), glow_r, Color(tc.r, tc.g, tc.b, pulse * (1.8 if is_hovered else 1.0)))
		# Dark background circle
		draw_circle(Vector2(cx, cy), badge_r, Color(0.05, 0.03, 0.07, 0.93))
		# Inner gradient shine
		draw_circle(Vector2(cx, cy - 3), badge_r * 0.6, Color(tc.r * 0.15, tc.g * 0.15, tc.b * 0.15, 0.3))
		# Animated border ring
		var border_a = 0.85 if is_hovered else 0.45
		draw_arc(Vector2(cx, cy), badge_r, 0, TAU, 32, Color(tc.r, tc.g, tc.b, border_a), 2.5)
		if is_hovered:
			draw_arc(Vector2(cx, cy), badge_r + 3, 0, TAU, 32, Color(tc.r, tc.g, tc.b, 0.2), 1.0)

		# Per-badge procedural icon
		var ic = Color(tc.r, tc.g, tc.b, 0.9)
		if i == 0:  # DEALS — coin with dollar sign
			draw_circle(Vector2(cx, cy), 10, Color(tc.r, tc.g, tc.b, 0.35))
			draw_arc(Vector2(cx, cy), 10, 0, TAU, 16, Color(tc.r, tc.g, tc.b, 0.5), 1.5)
			_udraw(font, Vector2(cx, cy + 5), "$", HORIZONTAL_ALIGNMENT_CENTER, -1, 16, ic)
		elif i == 1:  # QUESTS — scroll with lines
			draw_rect(Rect2(cx - 7, cy - 10, 14, 20), Color(tc.r, tc.g, tc.b, 0.3))
			draw_arc(Vector2(cx, cy - 10), 7, PI, TAU, 8, ic, 1.5)
			draw_arc(Vector2(cx, cy + 10), 7, 0, PI, 8, ic, 1.5)
			for li in range(3):
				var ly = cy - 4.0 + float(li) * 5.0
				draw_line(Vector2(cx - 5, ly), Vector2(cx + 5, ly), Color(tc.r, tc.g, tc.b, 0.6), 1.0)
		elif i == 2:  # ARENA — crossed swords
			draw_line(Vector2(cx - 9, cy + 9), Vector2(cx + 9, cy - 9), ic, 2.5)
			draw_line(Vector2(cx + 9, cy + 9), Vector2(cx - 9, cy - 9), ic, 2.5)
			draw_circle(Vector2(cx, cy), 3.5, Color(tc.r, tc.g, tc.b, 0.5))
		elif i == 3:  # ODYSSEY — compass rose
			for si in range(4):
				var sa = float(si) * TAU / 4.0 - PI * 0.25
				var tip = Vector2(cx + cos(sa) * 10, cy + sin(sa) * 10)
				draw_line(Vector2(cx, cy), tip, ic, 1.5)
				draw_circle(tip, 1.5, ic)
			draw_circle(Vector2(cx, cy), 3, Color(tc.r, tc.g, tc.b, 0.6))
		elif i == 4:  # ENDLESS — infinity symbol
			draw_arc(Vector2(cx - 5, cy), 6, -PI * 0.75, PI * 0.75, 12, ic, 2.0)
			draw_arc(Vector2(cx + 5, cy), 6, PI * 0.25, PI * 1.75, 12, ic, 2.0)

		# Label below badge
		var lbl_a = 0.85 if is_hovered else 0.5
		_udraw(font, Vector2(cx, cy + badge_r + 13), badge["label"], HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(tc.r, tc.g, tc.b, lbl_a))

		# Orbiting sparkles on hover
		if is_hovered:
			for si in range(3):
				var sa = _time * 3.0 + float(si) * TAU / 3.0
				var sp = Vector2(cx + cos(sa) * (badge_r + 5), cy + sin(sa) * (badge_r + 5))
				draw_circle(sp, 1.5, Color(tc.r, tc.g, tc.b, 0.45 + sin(_time * 4.0 + float(si)) * 0.2))

		# Notification dot (red pulsing) for actionable items
		var show_dot = false
		if i == 0:  # Deals — any unpurchased
			for di in range(daily_deals_purchased.size()):
				if not daily_deals_purchased[di]:
					show_dot = true
					break
		elif i == 1:  # Quests — any completed but unclaimed
			for q in active_quests:
				if q.get("completed", false) and not q.get("claimed", false):
					show_dot = true
					break
		if show_dot:
			var dot_pos = Vector2(cx + badge_r * 0.55, cy - badge_r * 0.55)
			draw_circle(dot_pos, 6, Color(0.85, 0.15, 0.1, 0.9))
			draw_circle(dot_pos, 3.5, Color(1.0, 0.35, 0.25, 0.6 + sin(_time * 5.0) * 0.3))

func _draw_chapters_overlay() -> void:
	if menu_side_panel == "":
		return
	var font = game_font
	# Dark dimming overlay behind the panel
	draw_rect(Rect2(0, 0, 1280, 620), Color(0, 0, 0, 0.65))
	# Panel dimensions (centered)
	var panel_x = 250.0
	var panel_y = 55.0
	var panel_w = 780.0
	var panel_h = 520.0
	var content_y = panel_y + 52.0
	var content_h = panel_h - 60.0
	# Panel theme color
	var color_map = {"deals": Color(0.85, 0.70, 0.28), "quests": Color(0.4, 0.8, 0.3), "arena": Color(0.7, 0.3, 0.9), "odyssey": Color(0.82, 0.62, 0.92), "endless": Color(0.52, 0.62, 0.92)}
	var tc = color_map.get(menu_side_panel, menu_gold)
	# Panel background with subtle gradient
	for gi in range(52):
		var t = float(gi) / 51.0
		var col = Color(0.06, 0.04, 0.08).lerp(Color(0.03, 0.02, 0.05), t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 51.0 + 1), col)
	# Animated glowing gold border
	var bp = 0.5 + sin(_time * 2.0) * 0.15
	var bc = Color(tc.r, tc.g, tc.b, bp)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), bc)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), bc)
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), bc)
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), bc)
	# Second inner border (double-line effect)
	draw_rect(Rect2(panel_x + 4, panel_y + 4, panel_w - 8, 1), Color(tc.r, tc.g, tc.b, bp * 0.3))
	draw_rect(Rect2(panel_x + 4, panel_y + panel_h - 5, panel_w - 8, 1), Color(tc.r, tc.g, tc.b, bp * 0.3))
	draw_rect(Rect2(panel_x + 4, panel_y + 4, 1, panel_h - 8), Color(tc.r, tc.g, tc.b, bp * 0.3))
	draw_rect(Rect2(panel_x + panel_w - 5, panel_y + 4, 1, panel_h - 8), Color(tc.r, tc.g, tc.b, bp * 0.3))
	# Corner flourish decorations
	var corners = [Vector2(panel_x, panel_y), Vector2(panel_x + panel_w, panel_y), Vector2(panel_x, panel_y + panel_h), Vector2(panel_x + panel_w, panel_y + panel_h)]
	for ci in range(4):
		var cp = corners[ci]
		var dxf = 1.0 if ci % 2 == 0 else -1.0
		var dyf = 1.0 if ci < 2 else -1.0
		draw_line(cp, cp + Vector2(dxf * 25, 0), Color(tc.r, tc.g, tc.b, 0.5), 2.0)
		draw_line(cp, cp + Vector2(0, dyf * 25), Color(tc.r, tc.g, tc.b, 0.5), 2.0)
		# Small decorative curl
		draw_arc(cp + Vector2(dxf * 12, dyf * 12), 8, 0, TAU * 0.5, 8, Color(tc.r, tc.g, tc.b, 0.15), 1.0)
	# Title bar with glow
	draw_rect(Rect2(panel_x + 2, panel_y + 2, panel_w - 4, 48), Color(tc.r * 0.08, tc.g * 0.08, tc.b * 0.08, 0.6))
	var title_map = {"deals": "DAILY DEALS", "quests": "DAILY QUESTS", "arena": "SHADOW ARENA", "odyssey": "ODYSSEY MODE", "endless": "THE ETERNAL CHAPTER"}
	var title = title_map.get(menu_side_panel, "")
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 34), title, HORIZONTAL_ALIGNMENT_CENTER, int(panel_w - 100), 20, tc)
	# Title underline with glow
	draw_rect(Rect2(panel_x + 20, panel_y + 50, panel_w - 40, 1), Color(tc.r, tc.g, tc.b, 0.4))
	# Subtle glow beneath title line
	draw_rect(Rect2(panel_x + 40, panel_y + 51, panel_w - 80, 2), Color(tc.r, tc.g, tc.b, 0.08))
	# Close button (X) — top right
	var close_x = panel_x + panel_w - 42.0
	var close_y = panel_y + 10.0
	var mouse_pos = get_viewport().get_mouse_position()
	var close_hov = Rect2(close_x, close_y, 30, 30).has_point(mouse_pos)
	draw_rect(Rect2(close_x, close_y, 30, 30), Color(0.6, 0.1, 0.1, 0.55 if close_hov else 0.2))
	draw_rect(Rect2(close_x, close_y, 30, 30), Color(0.9, 0.3, 0.3, 0.5 if close_hov else 0.2), false, 1.0)
	var xc = Color(0.95, 0.35, 0.3, 0.95 if close_hov else 0.6)
	draw_line(Vector2(close_x + 8, close_y + 8), Vector2(close_x + 22, close_y + 22), xc, 2.5)
	draw_line(Vector2(close_x + 22, close_y + 8), Vector2(close_x + 8, close_y + 22), xc, 2.5)
	# Draw the selected panel content (reuses existing sidebar draw functions)
	if menu_side_panel == "deals":
		_draw_daily_deals_sidebar(panel_x, content_y, panel_w, content_h)
	elif menu_side_panel == "quests":
		_draw_quest_panel_sidebar(panel_x, content_y, panel_w, content_h)
	elif menu_side_panel == "arena":
		_draw_shadow_arena_sidebar(panel_x, content_y, panel_w, content_h)
	elif menu_side_panel == "odyssey":
		_draw_odyssey_sidebar(panel_x, content_y, panel_w, content_h)
	elif menu_side_panel == "endless":
		_draw_endless_sidebar(panel_x, content_y, panel_w, content_h)

func _on_chapters_sidebar_clicked(mouse_pos: Vector2) -> void:
	# Overlay panel coordinates (must match _draw_chapters_overlay)
	var panel_x = 250.0
	var panel_y = 55.0
	var panel_w = 780.0
	var panel_h = 520.0
	var content_y = panel_y + 52.0

	if menu_side_panel != "":
		# --- Overlay is open: handle close + content clicks ---
		# Close button
		var close_x = panel_x + panel_w - 42.0
		var close_y_btn = panel_y + 10.0
		if Rect2(close_x, close_y_btn, 30, 30).has_point(mouse_pos):
			menu_side_panel = ""
			queue_redraw()
			return
		# Click outside panel closes it
		if not Rect2(panel_x, panel_y, panel_w, panel_h).has_point(mouse_pos):
			menu_side_panel = ""
			queue_redraw()
			return
		# Content-specific clicks
		if menu_side_panel == "deals":
			_on_overlay_deals_clicked(mouse_pos, panel_x, content_y, panel_w)
		elif menu_side_panel == "arena":
			_on_overlay_arena_clicked(mouse_pos, panel_x, content_y, panel_w)
		elif menu_side_panel == "odyssey":
			if not odyssey_completed_this_week:
				if Rect2(panel_x + panel_w * 0.5 - 60, content_y + 120, 120, 40).has_point(mouse_pos):
					menu_side_panel = ""
					_start_odyssey()
		elif menu_side_panel == "endless":
			if Rect2(panel_x + panel_w * 0.5 - 60, content_y + 145, 120, 40).has_point(mouse_pos):
				menu_side_panel = ""
				_start_endless_mode()
		return

	# --- No overlay: check badge clicks ---
	var badge_x = 1222.0
	var badge_start_y = 85.0
	var badge_spacing = 68.0
	var badge_r = 28.0  # Click radius slightly larger than visual
	var badge_ids = ["deals", "quests", "arena", "odyssey", "endless"]

	for i in range(badge_ids.size()):
		# Use fixed Y for click detection (no bob) so badges are easy to tap on mobile
		var cy = badge_start_y + float(i) * badge_spacing
		if mouse_pos.distance_to(Vector2(badge_x, cy)) < badge_r:
			menu_side_panel = badge_ids[i]
			queue_redraw()
			return

func _on_overlay_deals_clicked(mouse_pos: Vector2, px: float, py: float, pw: float) -> void:
	for i in range(min(3, daily_deals.size())):
		if daily_deals_purchased[i]:
			continue
		var deal = daily_deals[i]
		var ix = px + 10
		var iy = py + 42 + float(i) * 58.0
		var iw = pw - 20
		if mouse_pos.x >= ix + iw - 100 and mouse_pos.x <= ix + iw - 12 and mouse_pos.y >= iy + 8 and mouse_pos.y <= iy + 42:
			if _deal_confirm_index != i:
				_deal_confirm_index = i
				_deal_confirm_timer = 3.0
				queue_redraw()
				return
			_deal_confirm_index = -1
			_deal_confirm_timer = 0.0
			var cost = deal.get("cost", 0)
			var cost_type = deal.get("cost_type", "")
			var can_afford = false
			match cost_type:
				"quills": can_afford = player_quills >= cost
				"shards": can_afford = player_relic_shards >= cost
				"stars": can_afford = player_storybook_stars >= cost
				"gold": can_afford = player_gold >= cost
			if not can_afford:
				return
			match cost_type:
				"quills": player_quills -= cost
				"shards": player_relic_shards -= cost
				"stars": player_storybook_stars -= cost
				"gold": player_gold -= cost
			match deal.get("type", ""):
				"binding":
					var b = deal.get("item", {})
					if b.has("id"):
						owned_bindings[b["id"]] = owned_bindings.get(b["id"], 0) + 1
						_mark_binding_discovered(b["id"])
						_add_recent_item(b.get("name", "Binding"), b.get("rarity", "tattered"))
				"power":
					var pid = deal.get("power_id", "")
					var amt = deal.get("amount", 1)
					if pid != "":
						owned_powers[pid] = owned_powers.get(pid, 0) + amt
				"currency":
					var ctype = deal.get("currency_type", "")
					var camt = deal.get("amount", 0)
					match ctype:
						"quills": player_quills += camt
						"shards": player_relic_shards += camt
						"stars": player_storybook_stars += camt
						"gold": player_gold += camt
						"ink": knowledge_ink += camt
			daily_deals_purchased[i] = true
			total_emporium_purchases += 1
			_save_game()
			queue_redraw()
			return

func _on_overlay_arena_clicked(mouse_pos: Vector2, px: float, py: float, pw: float) -> void:
	var shop_items = _get_arena_shop_items()
	# Coords must match _draw_shadow_arena_sidebar: info_y=py+260, shop_y=info_y+44=py+304
	var shop_y = py + 304.0
	# Enter button
	var enter_y = shop_y + 16.0 + float(shop_items.size()) * 42.0 + 10.0
	if Rect2(px + pw * 0.5 - 60, enter_y, 120, 36).has_point(mouse_pos):
		menu_side_panel = ""
		_start_shadow_arena()
		return
	# Crystal shop item clicks
	for si in range(shop_items.size()):
		var item = shop_items[si]
		var iy = shop_y + 16.0 + float(si) * 42.0
		if mouse_pos.x >= px + 8 and mouse_pos.x <= px + pw - 8 and mouse_pos.y >= iy and mouse_pos.y <= iy + 36:
			if _arena_confirm_index != si:
				_arena_confirm_index = si
				_arena_confirm_timer = 3.0
				queue_redraw()
				return
			_arena_confirm_index = -1
			_arena_confirm_timer = 0.0
			if arena_crystals >= item["cost"]:
				arena_crystals -= item["cost"]
				match item["type"]:
					"shards": player_relic_shards += item["amount"]
					"quills": player_quills += item["amount"]
					"stars": player_storybook_stars += item["amount"]
					"gold": player_gold += item["amount"]
					"ink": knowledge_ink += item["amount"]
				queue_redraw()
			break

# --- Sidebar panel draw functions (repositioned versions) ---

func _draw_daily_deals_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 18), "DAILY DEALS", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.85, 0.70, 0.28))
	_udraw(font, Vector2(px + pw * 0.5, py + 36), "Refreshes at midnight", HORIZONTAL_ALIGNMENT_CENTER, -1, 12, menu_text_muted)
	for i in range(min(3, daily_deals.size())):
		var deal = daily_deals[i]
		var ix = px + 10
		var iy = py + 42 + float(i) * 58.0
		var iw = pw - 20
		var ih = 52.0
		var purchased = daily_deals_purchased[i] if i < daily_deals_purchased.size() else false
		var bg_col = Color(0.05, 0.15, 0.05, 0.6) if purchased else Color(0.08, 0.06, 0.12, 0.7)
		draw_rect(Rect2(ix, iy, iw, ih), bg_col)
		draw_rect(Rect2(ix, iy, iw, ih), Color(0.4, 0.35, 0.2, 0.3), false, 1.0)
		_udraw(font, Vector2(ix + 10, iy + 18), deal.get("name", "Deal"), HORIZONTAL_ALIGNMENT_LEFT, int(iw - 120), 15, Color(0.85, 0.75, 0.5))
		_udraw(font, Vector2(ix + 10, iy + 36), deal.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(iw - 120), 14, menu_text_muted)
		if purchased:
			_udraw(font, Vector2(ix + iw - 60, iy + 28), "SOLD", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.4, 0.7, 0.3))
		else:
			var cost_str = "%d %s" % [deal.get("cost", 0), deal.get("cost_type", "").capitalize()]
			draw_rect(Rect2(ix + iw - 100, iy + 8, 88, 34), Color(0.15, 0.12, 0.08, 0.8))
			_udraw(font, Vector2(ix + iw - 56, iy + 30), cost_str, HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.85, 0.70, 0.28))

func _draw_quest_panel_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 18), "DAILY QUESTS", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.4, 0.8, 0.3))
	_udraw(font, Vector2(px + pw * 0.5, py + 34), "Complete for rewards!", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, menu_text_muted)
	for i in range(min(3, active_quests.size())):
		var q = active_quests[i]
		var iy = py + 44 + float(i) * 58.0
		var completed = q.get("completed", false)
		var bg = Color(0.05, 0.12, 0.05, 0.6) if completed else Color(0.06, 0.06, 0.08, 0.6)
		draw_rect(Rect2(px + 8, iy, pw - 16, 50), bg)
		draw_rect(Rect2(px + 8, iy, pw - 16, 50), Color(0.3, 0.6, 0.3, 0.25), false, 1.0)
		_udraw(font, Vector2(px + 16, iy + 16), q.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 150), 14, Color(0.8, 0.75, 0.6))
		# Progress bar
		var pct = float(q.get("progress", 0)) / float(max(1, q.get("target", 1)))
		var bar_w = 100.0
		draw_rect(Rect2(px + pw - 120, iy + 6, bar_w, 12), Color(0.15, 0.15, 0.15))
		draw_rect(Rect2(px + pw - 120, iy + 6, bar_w * pct, 12), Color(0.3, 0.8, 0.3) if not completed else Color(0.2, 0.6, 0.2))
		_udraw(font, Vector2(px + pw - 70, iy + 16), "%d/%d" % [q.get("progress", 0), q.get("target", 1)], HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.8, 0.8, 0.8))
		# Reward
		var reward_str = "+%d %s" % [q.get("reward_amount", 0), q.get("reward_type", "").capitalize()]
		if completed:
			_udraw(font, Vector2(px + pw - 70, iy + 40), "DONE!", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.4, 0.8, 0.3))
		else:
			_udraw(font, Vector2(px + pw - 70, iy + 40), reward_str, HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.85, 0.70, 0.28))

func _draw_shadow_arena_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 18), "SHADOW ARENA", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.7, 0.3, 0.9))
	_udraw(font, Vector2(px + pw * 0.5, py + 38), "Weekly competitive challenge", HORIZONTAL_ALIGNMENT_CENTER, -1, 12, menu_text_muted)
	# Modifiers
	var mod_str = ""
	for m in shadow_arena_modifiers:
		mod_str += m.replace("_", " ").capitalize() + "  "
	_udraw(font, Vector2(px + pw * 0.5, py + 54), "Modifiers: " + mod_str, HORIZONTAL_ALIGNMENT_CENTER, int(pw - 20), 14, Color(0.8, 0.5, 0.3))
	# Leaderboard
	_udraw(font, Vector2(px + 15, py + 74), "LEADERBOARD", HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.85, 0.70, 0.28))
	for i in range(min(8, arena_leaderboard.size())):
		var entry = arena_leaderboard[i]
		var ey = py + 90 + float(i) * 20.0
		var name_col = Color(0.9, 0.8, 0.3) if entry["name"] == "YOU" else menu_text
		_udraw(font, Vector2(px + 15, ey), "#%d  %s" % [i + 1, entry["name"]], HORIZONTAL_ALIGNMENT_LEFT, int(pw * 0.6), 14, name_col)
		_udraw(font, Vector2(px + pw - 15, ey), "Wave %d" % entry["score"], HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, menu_text_muted)
	# Your best + crystals
	var info_y = py + 260
	_udraw(font, Vector2(px + 15, info_y), "Your Best: Wave %d" % shadow_arena_high_score, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.7, 0.7, 0.9))
	_udraw(font, Vector2(px + 15, info_y + 18), "Arena Crystals: %d" % arena_crystals, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.6, 0.3, 0.9))
	# Crystal Shop
	var shop_y = info_y + 44
	_udraw(font, Vector2(px + pw * 0.5, shop_y), "CRYSTAL SHOP", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.6, 0.3, 0.9))
	var shop_items = _get_arena_shop_items()
	for si in range(shop_items.size()):
		var item = shop_items[si]
		var iy = shop_y + 16 + float(si) * 42.0
		var can_buy = arena_crystals >= item["cost"]
		var item_col = Color(0.9, 0.85, 1.0) if can_buy else Color(0.5, 0.4, 0.5)
		var is_confirming = (_arena_confirm_index == si and _arena_confirm_timer > 0.0)
		draw_rect(Rect2(px + 8, iy, pw - 16, 36), Color(0.25, 0.12, 0.35, 0.8) if is_confirming else Color(0.15, 0.08, 0.2, 0.6))
		if is_confirming:
			draw_rect(Rect2(px + 8, iy, pw - 16, 36), Color(0.7, 0.3, 0.9, 0.6), false, 2.0)
		_udraw(font, Vector2(px + 14, iy + 14), item["name"], HORIZONTAL_ALIGNMENT_LEFT, int(pw - 100), 14, item_col)
		_udraw(font, Vector2(px + 14, iy + 28), item["desc"] if not is_confirming else "Tap again to confirm", HORIZONTAL_ALIGNMENT_LEFT, int(pw - 100), 14, Color(1.0, 0.8, 0.3) if is_confirming else Color(0.5, 0.45, 0.55))
		_udraw(font, Vector2(px + pw - 20, iy + 20), "%d" % item["cost"], HORIZONTAL_ALIGNMENT_RIGHT, -1, 15, Color(0.6, 0.3, 0.9) if can_buy else Color(0.4, 0.3, 0.4))
	# Enter button
	var enter_y = shop_y + 16 + float(shop_items.size()) * 42.0 + 10
	draw_rect(Rect2(px + pw * 0.5 - 60, enter_y, 120, 36), Color(0.30, 0.15, 0.50, 0.75))
	draw_rect(Rect2(px + pw * 0.5 - 60, enter_y, 120, 2), Color(0.5, 0.3, 0.7, 0.5))
	_udraw(font, Vector2(px + pw * 0.5, enter_y + 24), "ENTER", HORIZONTAL_ALIGNMENT_CENTER, 108, 14, Color(0.88, 0.78, 0.98))

func _draw_odyssey_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 20), "ODYSSEY MODE", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 15, Color(0.82, 0.62, 0.92))
	draw_rect(Rect2(px + 10, py + 30, pw - 20, 1), Color(0.5, 0.3, 0.7, 0.3))
	if odyssey_completed_this_week:
		_udraw(font, Vector2(px + pw * 0.5, py + 55), "Completed this week!", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 15, Color(0.5, 0.8, 0.3))
		_udraw(font, Vector2(px + pw * 0.5, py + 75), "Resets Monday", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 14, Color(0.4, 0.6, 0.3))
	else:
		var map_names = ""
		for mi in range(odyssey_maps.size()):
			if mi > 0: map_names += " > "
			if odyssey_maps[mi] < levels.size():
				map_names += levels[odyssey_maps[mi]]["name"]
		_udraw(font, Vector2(px + pw * 0.5, py + 55), "Journey through:", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 14, Color(0.6, 0.5, 0.7))
		_udraw(font, Vector2(px + pw * 0.5, py + 75), map_names, HORIZONTAL_ALIGNMENT_CENTER, int(pw - 30), 14, Color(0.7, 0.6, 0.5))
		_udraw(font, Vector2(px + pw * 0.5, py + 100), "Trophies: %d | Reward: 10-30" % trophy_currency, HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 14, Color(0.85, 0.70, 0.28))
		# Start button
		draw_rect(Rect2(px + pw * 0.5 - 60, py + 120, 120, 40), Color(0.30, 0.15, 0.50, 0.75))
		draw_rect(Rect2(px + pw * 0.5 - 60, py + 120, 120, 2), Color(0.6, 0.3, 0.8, 0.6))
		_udraw(font, Vector2(px + pw * 0.5, py + 146), "START", HORIZONTAL_ALIGNMENT_CENTER, 108, 14, Color(0.88, 0.78, 0.98))

func _draw_endless_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 20), "THE ETERNAL CHAPTER", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 15, Color(0.52, 0.62, 0.92))
	draw_rect(Rect2(px + 10, py + 30, pw - 20, 1), Color(0.3, 0.4, 0.7, 0.3))
	_udraw(font, Vector2(px + pw * 0.5, py + 55), "Infinite scaling waves.", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 15, Color(0.6, 0.6, 0.75))
	_udraw(font, Vector2(px + pw * 0.5, py + 73), "How far can you go?", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 15, Color(0.6, 0.6, 0.75))
	if endless_high_wave > 0:
		_udraw(font, Vector2(px + pw * 0.5, py + 100), "Best: Wave %d" % endless_high_wave, HORIZONTAL_ALIGNMENT_CENTER, -1, 16, Color(0.85, 0.70, 0.28))
	_udraw(font, Vector2(px + pw * 0.5, py + 125), "Hard difficulty | Random themes", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 14, Color(0.45, 0.45, 0.55))
	# Start button
	draw_rect(Rect2(px + pw * 0.5 - 60, py + 145, 120, 40), Color(0.15, 0.20, 0.48, 0.75))
	draw_rect(Rect2(px + pw * 0.5 - 60, py + 145, 120, 2), Color(0.3, 0.4, 0.7, 0.6))
	_udraw(font, Vector2(px + pw * 0.5, py + 171), "START", HORIZONTAL_ALIGNMENT_CENTER, 108, 14, Color(0.72, 0.82, 0.98))

func _draw_mini_star(center: Vector2, size: float, color: Color) -> void:
	var pts = PackedVector2Array()
	for i in range(10):
		var angle = -PI / 2.0 + float(i) * TAU / 10.0
		var r = size if i % 2 == 0 else size * 0.4
		pts.append(center + Vector2.from_angle(angle) * r)
	draw_colored_polygon(pts, color)

func _draw_shield(center: Vector2, size: float, color: Color, filled: bool) -> void:
	# Shield/badge shape: rounded top, pointed bottom
	var pts = PackedVector2Array()
	# Top arc (left to right)
	for i in range(9):
		var angle = PI + float(i) * PI / 8.0
		pts.append(center + Vector2(cos(angle) * size * 0.8, sin(angle) * size * 0.6 - size * 0.15))
	# Bottom point
	pts.append(center + Vector2(0, size * 0.95))
	# Close back up (right side going to bottom point is implicit)
	# Reverse right side
	if filled:
		draw_colored_polygon(pts, color)
		# Highlight on top-left
		var highlight_pts = PackedVector2Array()
		for i in range(5):
			var angle = PI + float(i) * PI / 8.0
			var hs = size * 0.65
			highlight_pts.append(center + Vector2(cos(angle) * hs * 0.8, sin(angle) * hs * 0.6 - size * 0.15))
		highlight_pts.append(center + Vector2(0, size * 0.3))
		draw_colored_polygon(highlight_pts, Color(1, 1, 1, 0.12))
		# Border
		for i in range(pts.size()):
			var next_i = (i + 1) % pts.size()
			draw_line(pts[i], pts[next_i], Color(color.r * 1.3, color.g * 1.3, color.b * 1.3, 0.6), 1.5)
	else:
		# Just outline
		for i in range(pts.size()):
			var next_i = (i + 1) % pts.size()
			draw_line(pts[i], pts[next_i], color, 1.0)

func _draw_open_book() -> void:
	# === Open book (two-page spread) ===
	var bx = 70.0
	var by = 45.0
	var pw = 560.0  # page width
	var ph = 555.0  # page height
	var spine_x = bx + pw + 10  # spine center

	# Book shadow
	draw_rect(Rect2(bx - 5 + 8, by - 5 + 8, pw * 2 + 30, ph + 10), Color(0.02, 0.02, 0.06, 0.35))

	# Left page (aged cream paper)
	for i in range(55):
		var t = float(i) / 54.0
		var col = Color(0.88, 0.82, 0.70).lerp(Color(0.85, 0.78, 0.65), t)
		var grain = sin(float(i) * 2.3) * 0.01
		col.r += grain
		col.g += grain
		draw_rect(Rect2(bx, by + t * ph, pw, ph / 54.0 + 1), col)

	# Right page
	for i in range(55):
		var t = float(i) / 54.0
		var col = Color(0.86, 0.80, 0.68).lerp(Color(0.83, 0.76, 0.63), t)
		var grain = sin(float(i) * 2.7 + 1.0) * 0.01
		col.r += grain
		col.g += grain
		draw_rect(Rect2(spine_x + 10, by + t * ph, pw, ph / 54.0 + 1), col)

	# Spine (leather center with gold bands)
	draw_rect(Rect2(spine_x - 5, by - 8, 20, ph + 16), Color(0.22, 0.10, 0.04))
	for i in range(5):
		var sy = by + 60.0 + float(i) * 100.0
		# All gold bands
		draw_line(Vector2(spine_x - 5, sy), Vector2(spine_x + 15, sy), Color(0.54, 0.45, 0.20, 0.35), 2.0)
		# Embossed diamond shapes on spine
		var diamond_cx = spine_x + 5.0
		var diamond_cy = sy + 50.0
		draw_colored_polygon(PackedVector2Array([Vector2(diamond_cx, diamond_cy - 6), Vector2(diamond_cx + 4, diamond_cy), Vector2(diamond_cx, diamond_cy + 6), Vector2(diamond_cx - 4, diamond_cy)]), Color(0.54, 0.45, 0.20, 0.2))
	# Spine shadow gradient
	for i in range(15):
		var t = float(i) / 14.0
		draw_line(Vector2(spine_x + 15 + t * 8, by), Vector2(spine_x + 15 + t * 8, by + ph), Color(0.0, 0.0, 0.0, 0.06 * (1.0 - t)), 1.0)
		draw_line(Vector2(spine_x - 5 - t * 8, by), Vector2(spine_x - 5 - t * 8, by + ph), Color(0.0, 0.0, 0.0, 0.06 * (1.0 - t)), 1.0)

	# Page borders — gold outer frame (3px) + gold inner frame (1px) — left page
	var outer_border = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.3)
	var gold_border = Color(0.54, 0.45, 0.20, 0.2)
	# Left page outer gold border (3px)
	draw_rect(Rect2(bx + 8, by + 8, pw - 16, 3), outer_border)
	draw_rect(Rect2(bx + 8, by + ph - 11, pw - 16, 3), outer_border)
	draw_rect(Rect2(bx + 8, by + 8, 3, ph - 16), outer_border)
	draw_rect(Rect2(bx + pw - 11, by + 8, 3, ph - 16), outer_border)
	# Left page inner gold border (1px)
	draw_rect(Rect2(bx + 14, by + 14, pw - 28, 1), gold_border)
	draw_rect(Rect2(bx + 14, by + ph - 15, pw - 28, 1), gold_border)
	draw_rect(Rect2(bx + 14, by + 14, 1, ph - 28), gold_border)
	draw_rect(Rect2(bx + pw - 15, by + 14, 1, ph - 28), gold_border)

	# Right page double border
	var rx = spine_x + 10
	draw_rect(Rect2(rx + 8, by + 8, pw - 16, 3), outer_border)
	draw_rect(Rect2(rx + 8, by + ph - 11, pw - 16, 3), outer_border)
	draw_rect(Rect2(rx + 8, by + 8, 3, ph - 16), outer_border)
	draw_rect(Rect2(rx + pw - 11, by + 8, 3, ph - 16), outer_border)
	draw_rect(Rect2(rx + 14, by + 14, pw - 28, 1), gold_border)
	draw_rect(Rect2(rx + 14, by + ph - 15, pw - 28, 1), gold_border)
	draw_rect(Rect2(rx + 14, by + 14, 1, ph - 28), gold_border)
	draw_rect(Rect2(rx + pw - 15, by + 14, 1, ph - 28), gold_border)

	# Page edge glow — subtle gold line along outer page edges
	draw_rect(Rect2(bx, by, pw, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08))
	draw_rect(Rect2(bx, by + ph - 1, pw, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08))
	draw_rect(Rect2(bx, by, 1, ph), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08))
	draw_rect(Rect2(rx + pw - 1, by, 1, ph), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08))

	# L-bracket corner ornaments (left page — gold only)
	for corner in [Vector2(bx + 18, by + 18), Vector2(bx + pw - 18, by + 18), Vector2(bx + 18, by + ph - 18), Vector2(bx + pw - 18, by + ph - 18)]:
		var dx_sign = 1.0 if corner.x < bx + pw * 0.5 else -1.0
		var dy_sign = 1.0 if corner.y < by + ph * 0.5 else -1.0
		draw_line(corner, corner + Vector2(12 * dx_sign, 0), Color(0.54, 0.45, 0.20, 0.25), 1.0)
		draw_line(corner, corner + Vector2(0, 12 * dy_sign), Color(0.54, 0.45, 0.20, 0.25), 1.0)
		draw_line(corner + Vector2(12 * dx_sign, 0), corner + Vector2(12 * dx_sign, 4 * dy_sign), Color(0.54, 0.45, 0.20, 0.2), 1.0)
		draw_line(corner + Vector2(0, 12 * dy_sign), corner + Vector2(4 * dx_sign, 12 * dy_sign), Color(0.54, 0.45, 0.20, 0.2), 1.0)
		draw_circle(corner, 5, Color(0.54, 0.45, 0.20, 0.2))
		draw_circle(corner, 3.5, Color(0.54, 0.45, 0.20, 0.15))
		draw_circle(corner, 2, Color(0.54, 0.45, 0.20, 0.25))

	# L-bracket corner ornaments (right page — gold only)
	for corner in [Vector2(rx + 18, by + 18), Vector2(rx + pw - 18, by + 18), Vector2(rx + 18, by + ph - 18), Vector2(rx + pw - 18, by + ph - 18)]:
		var dx_sign2 = 1.0 if corner.x < rx + pw * 0.5 else -1.0
		var dy_sign2 = 1.0 if corner.y < by + ph * 0.5 else -1.0
		draw_line(corner, corner + Vector2(12 * dx_sign2, 0), Color(0.54, 0.45, 0.20, 0.25), 1.0)
		draw_line(corner, corner + Vector2(0, 12 * dy_sign2), Color(0.54, 0.45, 0.20, 0.25), 1.0)
		draw_line(corner + Vector2(12 * dx_sign2, 0), corner + Vector2(12 * dx_sign2, 4 * dy_sign2), Color(0.54, 0.45, 0.20, 0.2), 1.0)
		draw_line(corner + Vector2(0, 12 * dy_sign2), corner + Vector2(4 * dx_sign2, 12 * dy_sign2), Color(0.54, 0.45, 0.20, 0.2), 1.0)
		draw_circle(corner, 5, Color(0.54, 0.45, 0.20, 0.2))
		draw_circle(corner, 3.5, Color(0.54, 0.45, 0.20, 0.15))
		draw_circle(corner, 2, Color(0.54, 0.45, 0.20, 0.25))

	# Ink blot decorations (right page corners)
	draw_circle(Vector2(rx + pw - 40, by + ph - 40), 6.0, Color(0.2, 0.15, 0.1, 0.06))
	draw_circle(Vector2(rx + pw - 35, by + ph - 45), 4.0, Color(0.2, 0.15, 0.1, 0.04))

	# Left page: character preview area (tower preview is placed by menu system)
	if menu_current_view == "chapters":
		var char_idx = menu_character_index
		# Character-themed decorative motif on left page
		var motif_y = by + 160.0
		var motif_x = bx + pw * 0.5
		# Draw a simple emblem/crest area
		draw_circle(Vector2(motif_x, motif_y + 80), 60, Color(0.54, 0.45, 0.20, 0.04))
		draw_arc(Vector2(motif_x, motif_y + 80), 55, 0, TAU, 48, Color(0.54, 0.45, 0.20, 0.12), 1.5)
		draw_arc(Vector2(motif_x, motif_y + 80), 45, 0, TAU, 48, Color(0.54, 0.45, 0.20, 0.08), 1.0)

		# Character emblem icons (simple procedural)
		match char_idx:
			0:  # Robin Hood - bow and arrow
				draw_arc(Vector2(motif_x, motif_y + 80), 25, 1.0, 5.3, 32, Color(0.4, 0.25, 0.08, 0.35), 2.5)
				draw_line(Vector2(motif_x - 20, motif_y + 60), Vector2(motif_x + 20, motif_y + 100), Color(0.4, 0.25, 0.08, 0.3), 1.5)
				draw_colored_polygon(PackedVector2Array([Vector2(motif_x + 18, motif_y + 96), Vector2(motif_x + 24, motif_y + 100), Vector2(motif_x + 20, motif_y + 104)]), Color(0.4, 0.25, 0.08, 0.3))
			1:  # Alice - playing card (heart)
				draw_rect(Rect2(motif_x - 18, motif_y + 58, 36, 44), Color(0.9, 0.87, 0.8, 0.3))
				draw_rect(Rect2(motif_x - 16, motif_y + 60, 32, 40), Color(0.95, 0.92, 0.88, 0.2))
				# Heart shape
				draw_circle(Vector2(motif_x - 6, motif_y + 73), 6, Color(0.8, 0.15, 0.15, 0.3))
				draw_circle(Vector2(motif_x + 6, motif_y + 73), 6, Color(0.8, 0.15, 0.15, 0.3))
				draw_colored_polygon(PackedVector2Array([Vector2(motif_x - 11, motif_y + 76), Vector2(motif_x + 11, motif_y + 76), Vector2(motif_x, motif_y + 92)]), Color(0.8, 0.15, 0.15, 0.3))
			2:  # Oz - emerald
				draw_colored_polygon(PackedVector2Array([Vector2(motif_x, motif_y + 58), Vector2(motif_x + 18, motif_y + 72), Vector2(motif_x + 14, motif_y + 95), Vector2(motif_x - 14, motif_y + 95), Vector2(motif_x - 18, motif_y + 72)]), Color(0.15, 0.6, 0.2, 0.3))
				draw_circle(Vector2(motif_x, motif_y + 78), 8, Color(0.3, 0.8, 0.4, 0.15))
			3:  # Peter Pan - star
				for s in range(5):
					var a1 = -PI / 2.0 + float(s) * TAU / 5.0
					var a2 = -PI / 2.0 + (float(s) + 0.5) * TAU / 5.0
					draw_line(Vector2(motif_x, motif_y + 80) + Vector2.from_angle(a1) * 22, Vector2(motif_x, motif_y + 80) + Vector2.from_angle(a2) * 10, Color(0.65, 0.55, 0.1, 0.3), 2.0)
					draw_line(Vector2(motif_x, motif_y + 80) + Vector2.from_angle(a2) * 10, Vector2(motif_x, motif_y + 80) + Vector2.from_angle(a1 + TAU / 5.0) * 22, Color(0.65, 0.55, 0.1, 0.3), 2.0)
			4:  # Phantom - mask
				draw_arc(Vector2(motif_x, motif_y + 72), 18, PI + 0.3, TAU - 0.3, 32, Color(0.9, 0.88, 0.82, 0.35), 3.0)
				draw_circle(Vector2(motif_x - 7, motif_y + 70), 4, Color(0.1, 0.08, 0.06, 0.3))
				draw_circle(Vector2(motif_x + 7, motif_y + 70), 4, Color(0.1, 0.08, 0.06, 0.3))
				draw_line(Vector2(motif_x, motif_y + 55), Vector2(motif_x, motif_y + 62), Color(0.9, 0.88, 0.82, 0.25), 2.0)
			5:  # Scrooge - coin
				draw_circle(Vector2(motif_x, motif_y + 80), 18, Color(0.75, 0.6, 0.1, 0.3))
				draw_circle(Vector2(motif_x, motif_y + 80), 15, Color(0.85, 0.7, 0.15, 0.2))
				draw_circle(Vector2(motif_x, motif_y + 80), 6, Color(0.54, 0.45, 0.20, 0.15))

		# Decorative line under character quote
		draw_line(Vector2(bx + 80, by + ph - 100), Vector2(bx + pw - 80, by + ph - 100), Color(0.54, 0.45, 0.20, 0.1), 1.0)

	# Right page: chapter separator lines (between the 3 cards)
	if menu_current_view == "chapters":
		for i in range(2):
			var sep_y = by + 190.0 + float(i) * 165.0
			draw_line(Vector2(rx + 30, sep_y), Vector2(rx + pw - 30, sep_y), Color(0.5, 0.4, 0.25, 0.15), 1.0)
			# Decorative diamond at center of separator
			var sep_cx = rx + pw * 0.5
			draw_colored_polygon(PackedVector2Array([Vector2(sep_cx, sep_y - 4), Vector2(sep_cx + 4, sep_y), Vector2(sep_cx, sep_y + 4), Vector2(sep_cx - 4, sep_y)]), Color(0.54, 0.45, 0.20, 0.15))
			# Small gold dots at ends of separator
			draw_circle(Vector2(rx + 30, sep_y), 2.0, Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))
			draw_circle(Vector2(rx + pw - 30, sep_y), 2.0, Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))

	# Page tab bookmarks on right edge (character quick nav) — enhanced gothic
	var tab_colors = [Color(0.29, 0.55, 0.25), Color(0.44, 0.66, 0.86), Color(0.48, 0.25, 0.63), Color(0.90, 0.49, 0.13), Color(0.75, 0.22, 0.17), Color(0.79, 0.66, 0.30)]
	if menu_current_view == "chapters":
		for i in range(6):
			var tab_y = by + 30.0 + float(i) * 80.0
			var tab_x = rx + pw - 5
			var is_active = (i == menu_character_index)
			var tab_w = 24.0 if is_active else 16.0
			var tab_alpha = (0.7 + sin(_time * 2.0) * 0.15) if is_active else 0.25
			var tab_h = 50.0
			var tc = Color(tab_colors[i].r, tab_colors[i].g, tab_colors[i].b, tab_alpha)
			# Glow effect behind active tab
			if is_active:
				draw_circle(Vector2(tab_x + tab_w * 0.5, tab_y + tab_h * 0.5), 30.0, Color(tab_colors[i].r, tab_colors[i].g, tab_colors[i].b, 0.08))
			# Tab rectangle
			draw_rect(Rect2(tab_x, tab_y, tab_w, tab_h), tc)
			# Gothic pointed bottom edge (triangle)
			draw_colored_polygon(PackedVector2Array([Vector2(tab_x, tab_y + tab_h), Vector2(tab_x + tab_w, tab_y + tab_h), Vector2(tab_x + tab_w * 0.5, tab_y + tab_h + 8)]), tc)
			# Thin gold border on inner edge
			draw_line(Vector2(tab_x, tab_y), Vector2(tab_x, tab_y + tab_h), Color(0.54, 0.45, 0.20, 0.3), 1.0)

# ============================================================
# GAME LOOP
# ============================================================

func get_cached_enemies() -> Array:
	return _cached_enemies

func _process(delta: float) -> void:
	_time += delta
	# Cache enemy list once per frame for performance
	if game_state == GameState.PLAYING:
		_cached_enemies = get_tree().get_nodes_in_group("enemies")
	# Input debounce cooldown
	if _input_cooldown > 0.0:
		_input_cooldown -= delta
	# Story dialog typewriter
	_process_story_typewriter(delta)
	# Layered music volume/tempo update
	_update_layered_music(delta)
	_update_levelup_fanfare(delta)
	# Musical beat clock (140 BPM)
	_music_beat_accum += delta
	while _music_beat_accum >= MUSIC_BEAT_INTERVAL:
		_music_beat_accum -= MUSIC_BEAT_INTERVAL
		music_beat_index += 1
	# Ability popup freeze
	if _ability_popup_freeze > 0.0:
		_ability_popup_freeze -= delta
		_ability_popup_timer -= delta
		if _ability_popup_timer <= 0.0:
			_ability_popup_timer = 0.0
		queue_redraw()
		return
	if _ability_popup_timer > 0.0:
		_ability_popup_timer -= delta
	# Synergy banner timer
	if synergy_banner_timer > 0.0:
		synergy_banner_timer -= delta
	# Achievement popup timer
	if achievement_popup_timer > 0.0:
		achievement_popup_timer -= delta
	if game_state != GameState.PLAYING:
		# Chest opening animation (phase 0=idle/click to open, 1=shake, 2=burst, 3=slide, 4=flip, 5=pick, 6=done)
		if chest_opening_active:
			chest_opening_timer += delta
			# Phase 0: idle, waiting for click (no auto-advance)
			if chest_opening_phase == 1 and chest_opening_timer >= 1.2:
				chest_opening_phase = 2
				chest_opening_timer = 0.0
			elif chest_opening_phase == 2 and chest_opening_timer >= 0.8:
				chest_opening_phase = 3
				chest_opening_timer = 0.0
			elif chest_opening_phase == 3 and chest_opening_timer >= 1.0:
				chest_opening_phase = 4
				chest_opening_timer = 0.0
				chest_opening_flip_index = 0
			elif chest_opening_phase == 4:
				var flip_speed = 0.3
				if chest_opening_timer >= flip_speed:
					chest_opening_timer = 0.0
					chest_opening_flip_index += 1
					if chest_opening_flip_index >= 3:
						chest_opening_phase = 5
						chest_opening_timer = 0.0
						# Award base chest loot (guaranteed rewards)
						_award_chest_loot()
		# Emporium sub-panel message timer
		if emporium_sub_message_timer > 0.0:
			emporium_sub_message_timer -= delta
			if emporium_sub_message_timer <= 0.0:
				emporium_sub_message = ""
		if _emporium_confirm_timer > 0.0:
			_emporium_confirm_timer -= delta
			if _emporium_confirm_timer <= 0.0:
				_emporium_confirm_index = -1
		if _deal_confirm_timer > 0.0:
			_deal_confirm_timer -= delta
			if _deal_confirm_timer <= 0.0:
				_deal_confirm_index = -1
		if _arena_confirm_timer > 0.0:
			_arena_confirm_timer -= delta
			if _arena_confirm_timer <= 0.0:
				_arena_confirm_index = -1
		# Purchase flash decay
		if _emporium_purchase_flash > 0.0:
			_emporium_purchase_flash = maxf(_emporium_purchase_flash - delta * 2.0, 0.0)
		# View transition overlay decay
		if _menu_transition_alpha > 0.0:
			_menu_transition_alpha = maxf(_menu_transition_alpha - delta * 3.0, 0.0)
		# Hover updates
		if not chest_opening_active and not daily_reward_open:
			if survivor_detail_open:
				_update_detail_hover()
			elif menu_current_view == "survivors":
				_update_world_map_hover()
			elif menu_current_view == "relics":
				_update_relics_tab_hover()
			elif menu_current_view == "emporium":
				_update_emporium_hover()
			elif menu_current_view == "chronicles":
				_update_knowledge_hover()
		queue_redraw()
		return
	ghost_position = get_global_mouse_position()
	_update_branch_hover(get_viewport().get_mouse_position())
	_update_spawn_debuffs()
	# Battle power timed effects
	if active_power_effects.has("ink_freeze"):
		active_power_effects["ink_freeze"] -= delta
		if active_power_effects["ink_freeze"] <= 0.0:
			active_power_effects.erase("ink_freeze")
			for enemy in get_tree().get_nodes_in_group("enemies"):
				if is_instance_valid(enemy):
					enemy.set("speed_multiplier", 1.0)
	if active_power_effects.has("enchanted_towers"):
		active_power_effects["enchanted_towers"] -= delta
		if active_power_effects["enchanted_towers"] <= 0.0:
			active_power_effects.erase("enchanted_towers")
			power_enchanted_timer = 0.0
			for tower in get_tree().get_nodes_in_group("towers"):
				if "power_damage_mult" in tower:
					tower.power_damage_mult = 1.0
		else:
			power_enchanted_timer = active_power_effects["enchanted_towers"]
			for tower in get_tree().get_nodes_in_group("towers"):
				if "power_damage_mult" in tower:
					tower.power_damage_mult = 1.5
	# Odyssey transition
	if odyssey_transition_active:
		odyssey_transition_timer -= delta
		if odyssey_transition_timer <= 0.0:
			odyssey_transition_active = false
			_start_odyssey_map(odyssey_current_map)
	# Boss rescue animation
	_process_boss_rescue(delta)
	if is_wave_active:
		_handle_spawning(delta)
		_check_wave_complete()
	elif wave_auto_timer > 0.0:
		wave_auto_timer -= delta
		start_button.text = "  NEXT IN %.0fs  " % maxf(wave_auto_timer, 0.0)
		if wave_auto_timer <= 0.0:
			wave_auto_timer = -1.0
			_start_next_wave()
	# Fighting voice-over catchphrases (every 20-30s during combat)
	if placed_tower_positions.size() > 0:
		_fighting_quote_timer -= delta
		# Shadow Author taunts in his domain (levels 34-36) on separate timer
		if current_level >= 34 and shadow_author_fight_clips.size() > 0:
			shadow_author_taunt_timer -= delta
			if shadow_author_taunt_timer <= 0.0 and not catchphrase_player.playing:
				_play_shadow_author_taunt()
				shadow_author_taunt_timer = randf_range(25.0, 40.0)
		if _fighting_quote_timer <= 0.0 and not catchphrase_player.playing:
			_play_random_fighting_quote()
			_fighting_quote_timer = randf_range(20.0, 30.0)
	# Combo timer countdown
	# BATTD2: Wave Blessing timer
	if _blessing_active:
		_blessing_timer -= delta
		if _blessing_timer <= 0.0:
			_blessing_active = false
			_blessing_type = ""
	# BATTD2: Overcharge timer
	if _overcharge_timer > 0.0:
		_overcharge_timer -= delta
		if _overcharge_timer <= 0.0:
			_overcharged_tower = null
	# BATTD2: Enemy Intel timer
	if _intel_timer > 0.0:
		_intel_timer -= delta
		if _intel_timer <= 0.0:
			_intel_target = null
	# BATTD2: Path Events (random environmental damage)
	if is_wave_active and not game_paused:
		_path_event_cooldown -= delta
		if _path_event_cooldown <= 0.0:
			_path_event_cooldown = PATH_EVENT_INTERVAL
			_spawn_path_event()
	# BATTD2: Update path event timers
	var pe_i = _path_events.size() - 1
	while pe_i >= 0:
		_path_events[pe_i]["timer"] -= delta
		if _path_events[pe_i]["timer"] <= 0.0:
			_path_events.remove_at(pe_i)
		pe_i -= 1
	# BATTD2: Check character bonds
	if is_wave_active:
		_check_character_bonds()
	# BATTD2: Process path traps
	if is_wave_active and _path_traps.size() > 0:
		_process_path_traps()
	# BATTD: Income breakdown timer
	if _income_display_timer > 0.0:
		_income_display_timer -= delta
	# BATTD: Crit streak timer
	if _crit_streak_timer > 0.0:
		_crit_streak_timer -= delta
		if _crit_streak_timer <= 0.0:
			_crit_streak = 0
	# BATTD: Placement streak timer
	if _placement_streak_timer > 0.0:
		_placement_streak_timer -= delta
		if _placement_streak_timer <= 0.0:
			_placement_streak_count = 0
	if combo_timer > 0.0:
		combo_timer -= delta
		if combo_timer <= 0.0:
			combo_count = 0
	# Undo tower timer countdown
	if not undo_tower_data.is_empty():
		undo_tower_data["timer"] = undo_tower_data.get("timer", 0.0) - delta
		if undo_tower_data["timer"] <= 0.0:
			undo_tower_data.clear()
			undo_button.visible = false
	# Wave preview timer
	if wave_preview_active:
		wave_preview_timer -= delta
		if wave_preview_timer <= 0.0:
			wave_preview_active = false
	# Update floating texts
	var ft_i = _floating_texts.size() - 1
	while ft_i >= 0:
		var ft = _floating_texts[ft_i]
		ft["timer"] -= delta
		ft["vel_y"] *= 0.96  # decelerate
		ft["pos"].y += ft["vel_y"] * delta
		if ft["timer"] <= 0.0:
			_floating_texts.remove_at(ft_i)
		ft_i -= 1
	# Update gold flash
	if _insufficient_gold_flash > 0.0:
		_insufficient_gold_flash -= delta * 3.0
	# Update boss alert
	if _boss_alert_timer > 0.0:
		_boss_alert_timer -= delta
	# Update wave clear popup
	if _wave_clear_timer > 0.0:
		_wave_clear_timer -= delta
	# Update screen shake
	if _screen_shake_timer > 0.0:
		_screen_shake_timer -= delta
		var shake_strength = _screen_shake_intensity * (_screen_shake_timer / 0.5)
		_screen_shake_offset = Vector2(randf_range(-shake_strength, shake_strength), randf_range(-shake_strength, shake_strength))
	else:
		_screen_shake_offset = Vector2.ZERO
	# Update ink splatters
	var sp_i = _ink_splatters.size() - 1
	while sp_i >= 0:
		var sp = _ink_splatters[sp_i]
		sp["timer"] -= delta
		sp["vel"] *= 0.92  # friction
		sp["pos"] += sp["vel"] * delta
		if sp["timer"] <= 0.0:
			_ink_splatters.remove_at(sp_i)
		sp_i -= 1
	# Update death flash
	if _death_flash_timer > 0.0:
		_death_flash_timer -= delta
	# Update AoE impacts
	var aoe_i = _aoe_impacts.size() - 1
	while aoe_i >= 0:
		_aoe_impacts[aoe_i]["timer"] -= delta
		if _aoe_impacts[aoe_i]["timer"] <= 0.0:
			_aoe_impacts.remove_at(aoe_i)
		aoe_i -= 1
	# Update crit flashes
	var crit_i = _crit_flashes.size() - 1
	while crit_i >= 0:
		_crit_flashes[crit_i]["timer"] -= delta
		if _crit_flashes[crit_i]["timer"] <= 0.0:
			_crit_flashes.remove_at(crit_i)
		crit_i -= 1
	# Update build effects
	var be_i = _build_effects.size() - 1
	while be_i >= 0:
		_build_effects[be_i]["timer"] -= delta
		if _build_effects[be_i]["timer"] <= 0.0:
			_build_effects.remove_at(be_i)
		be_i -= 1
	# Update victory burst
	if _victory_burst_timer > 0.0:
		_victory_burst_timer -= delta
		for vp in _victory_particles:
			vp["pos"] += vp["vel"] * delta
			vp["vel"].y += 80.0 * delta  # gravity
			vp["timer"] -= delta
	# Update defeat timer
	if _defeat_timer > 0.0:
		_defeat_timer -= delta
	# Update spawn portal intensity
	if _spawn_portal_intensity > 0.0:
		_spawn_portal_intensity = maxf(_spawn_portal_intensity - delta * 2.0, 0.0)
	# Update environmental particles
	for ep in _env_particles:
		ep["x"] += ep["dx"] * delta
		ep["y"] += sin(_time * ep["freq"] + ep["phase"]) * 0.3
		if ep["x"] > 1300.0:
			ep["x"] = -20.0
		elif ep["x"] < -20.0:
			ep["x"] = 1300.0
		if ep["y"] > 740.0:
			ep["y"] = -10.0
		elif ep["y"] < -10.0:
			ep["y"] = 740.0
	# Update wave banner
	if _wave_banner_timer > 0.0:
		_wave_banner_timer -= delta
	# Update gold pickups
	var gp_i = _gold_pickups.size() - 1
	while gp_i >= 0:
		var gp = _gold_pickups[gp_i]
		gp["timer"] -= delta
		var t = 1.0 - clampf(gp["timer"] / gp["max_timer"], 0.0, 1.0)
		gp["pos"] = gp["start"].lerp(gp["end"], t) + Vector2(0, -sin(t * PI) * 40.0)
		if gp["timer"] <= 0.0:
			_gold_pickups.remove_at(gp_i)
			_gold_pickup_flash = 0.3
		gp_i -= 1
	if _gold_pickup_flash > 0.0:
		_gold_pickup_flash -= delta
	queue_redraw()

func _handle_spawning(delta: float) -> void:
	if enemies_to_spawn <= 0:
		return
	spawn_timer -= delta
	if spawn_timer <= 0.0:
		_spawn_enemy()
		spawn_timer = spawn_interval

func _spawn_enemy() -> void:
	_spawn_portal_intensity = 1.0
	var enemy = enemy_scene.instantiate()
	enemy.add_to_group("enemies")

	# Set enemy theme and tier
	if endless_mode:
		enemy.enemy_theme = randi() % 13
	else:
		enemy.enemy_theme = levels[current_level].get("enemy_theme", levels[current_level]["character"]) if current_level >= 0 and current_level < levels.size() else 0
	var wave_progress = float(wave) / float(max(1, total_waves))
	if endless_mode:
		var w = wave
		if w < 10:
			enemy.enemy_tier = 0
		elif w < 25:
			enemy.enemy_tier = 1
		elif w < 50:
			enemy.enemy_tier = 2
		else:
			enemy.enemy_tier = 3
	elif wave_progress <= 0.25:
		enemy.enemy_tier = 0
	elif wave_progress <= 0.5:
		enemy.enemy_tier = 1
	elif wave_progress <= 0.75:
		enemy.enemy_tier = 2
	else:
		enemy.enemy_tier = 3

	# Endless mode scaling — sub-exponential to stay playable at high waves
	if endless_mode:
		var w = wave
		# Health: polynomial+log scaling instead of pure exponential
		# wave 10: ~750, wave 25: ~3.75k, wave 50: ~22.5k, wave 100: ~137k
		var base_hp = (80.0 + w * 30.0 + pow(w, 2.2) * 2.0) * 1.25
		if w > 20:
			base_hp *= 1.0 + log(float(w - 19)) * 0.5
		enemy.max_health = base_hp
		enemy.speed = minf(80.0 + w * 2.0, 260.0)  # Cap speed to keep game playable
		# Gold scales with health so economy stays viable
		enemy.gold_reward = 5 + w / 2 + int(base_hp / 200.0)
		# Boss every 10 waves
		if w > 0 and w % 10 == 0:
			enemy.boss_scale = 1.8 + float(w) / 50.0
			enemy.max_health *= 4.0
			enemy.speed *= 0.65
			enemy.gold_reward += 15 + w / 5
		enemy.health = enemy.max_health
		# Apply endless mutations
		if endless_mutation == "Speed Surge":
			enemy.speed *= 1.5
		elif endless_mutation == "Shield Wall":
			enemy.max_health *= 1.6
			enemy.health = enemy.max_health
		elif endless_mutation == "Regen Wave":
			if enemy.has_method("set_meta"):
				enemy.set_meta("regen_rate", enemy.max_health * 0.02)
		elif endless_mutation == "Swarm":
			enemy.max_health *= 0.5
			enemy.health = enemy.max_health
			enemy.speed *= 1.2
		elif endless_mutation == "Gold Drought":
			enemy.gold_reward = maxi(1, enemy.gold_reward / 2)
		_apply_enemy_modifiers(enemy, w, enemy.boss_scale > 1.0)
		enemy_path.add_child(enemy)
		enemies_to_spawn -= 1
		enemies_alive += 1
		return

	# Boss Rush mode — spawn single powerful boss per wave
	if boss_rush_mode:
		var br_mult = 3.0 + float(wave) * 1.7  # 3x -> 20x scaling
		enemy.max_health = (500.0 + wave * 200.0) * br_mult
		enemy.health = enemy.max_health
		enemy.speed = clampf(50.0 + wave * 3.0, 50.0, 120.0)
		enemy.gold_reward = 20 + wave * 5
		enemy.boss_scale = 2.0 + float(wave) * 0.2
		enemy.enemy_tier = clampi(wave / 3, 0, 3)
		_apply_enemy_modifiers(enemy, wave, true)
		enemy_path.add_child(enemy)
		enemies_to_spawn -= 1
		enemies_alive += 1
		return

	# Progressive difficulty scaling (supports 20-40 waves)
	# All phases have +25% HP global multiplier applied at end
	var w = wave
	if w <= 5:
		# Phase 1: Gentle introduction — need 2+ towers to handle comfortably
		enemy.max_health = 80.0 + w * 25.0
		enemy.speed = 65.0 + w * 4.0
		enemy.gold_reward = 1 + w / 2
	elif w <= 10:
		# Phase 2: Building pressure — single tower can't keep up
		enemy.max_health = 220.0 + (w - 5) * 55.0
		enemy.speed = 80.0 + (w - 5) * 5.0
		enemy.gold_reward = 3 + (w - 5) / 2
	elif w <= 16:
		# Phase 3: Challenging — need upgrades and synergies
		enemy.max_health = 520.0 + (w - 10) * 85.0
		enemy.speed = 100.0 + (w - 10) * 4.0
		enemy.gold_reward = 4 + (w - 10) / 2
	elif w <= 24:
		# Phase 4: Hard — need tier upgrades to survive
		enemy.max_health = 1050.0 + (w - 16) * 120.0
		enemy.speed = 115.0 + (w - 16) * 4.0
		enemy.gold_reward = 7 + (w - 16) / 2
	elif w <= 32:
		# Phase 5: Very hard — need maxed towers
		enemy.max_health = 2000.0 + (w - 24) * 175.0
		enemy.speed = 130.0 + (w - 24) * 3.0
		enemy.gold_reward = 11 + (w - 24) / 2
	else:
		# Phase 6: Brutal (waves 33-40) — endgame challenge
		enemy.max_health = 3400.0 + (w - 32) * 250.0
		enemy.speed = 145.0 + (w - 32) * 3.0
		enemy.gold_reward = 15 + (w - 32) * 1
	# +25% HP across all phases
	enemy.max_health *= 1.25

	# === MOAB Villain waves ===
	# MOAB at wave 15 (tier 0), 25 (tier 1), 35 (tier 2) on Medium/Hard
	var theme = levels[current_level].get("enemy_theme", 0) if current_level >= 0 and current_level < levels.size() else 0
	if selected_difficulty >= 1 and enemies_to_spawn == _get_wave_enemy_count(w):
		# First enemy of the wave — check if MOAB wave
		if w == 15 and selected_difficulty >= 1:
			_spawn_moab_wave(theme, 0)
		elif w == 25 and selected_difficulty >= 1:
			_spawn_moab_wave(theme, 1)
		elif w == 35 and selected_difficulty >= 1:
			_spawn_moab_wave(theme, 2)

	# === Boss wave modifiers ===
	# Milestone bosses at waves 20, 25, 30, 35 — bigger, tougher, slower
	var is_boss_wave = w in [20, 25, 30, 35]
	var is_final_villain = w >= 39 and selected_difficulty >= 2  # Hard/Pure mode waves 39-40
	var is_last_wave = w == total_waves

	if is_final_villain:
		# Final villain — extremely strong, very large
		enemy.max_health *= 8.0
		enemy.speed *= 0.55
		enemy.gold_reward += 25
		enemy.enemy_tier = 3
		enemy.boss_scale = 2.5
	elif is_boss_wave:
		# Milestone boss — much stronger, larger
		var boss_mult = 1.0 + float(w) / 20.0  # 2.0x at w20, 2.25x at w25, etc.
		enemy.max_health *= 3.5 * boss_mult
		enemy.speed *= 0.65
		enemy.gold_reward += 10 + w / 4
		enemy.boss_scale = 1.8
	elif is_last_wave:
		# Final wave — single named boss villain
		enemy.is_named_boss = true
		enemy.boss_name = BOSS_VILLAIN_NAMES.get(enemy.enemy_theme, "The Villain")
		enemy.enemy_tier = 3
		enemy.boss_scale = 3.5
		enemy.max_health *= 12.0
		enemy.speed *= 0.45
		enemy.gold_reward += 30

	# Assign boss mechanics based on theme
	if is_boss_wave or is_final_villain or is_last_wave:
		match enemy.enemy_theme:
			0, 1, 3:  # Sherwood, Wonderland, Neverland — Summon
				enemy.boss_mechanic = "summon"
			4, 5:  # Opera, Victorian — Shield Pulse
				enemy.boss_mechanic = "shield_pulse"
			2, 6:  # Oz, Shadow — Enrage
				enemy.boss_mechanic = "enrage"
			7, 8, 10:  # Sherlock, Merlin, Dracula — Area Deny
				enemy.boss_mechanic = "area_deny"
			_:
				var mechanics = ["summon", "shield_pulse", "enrage", "area_deny"]
				enemy.boss_mechanic = mechanics[randi() % mechanics.size()]

	# Variety waves (fast rushes and swarms between bosses)
	if not is_boss_wave and not is_final_villain and not is_last_wave:
		var quarter = max(1, int(total_waves * 0.25))
		var half_w = max(1, int(total_waves * 0.5))
		var three_q = max(1, int(total_waves * 0.75))
		if w == quarter:
			enemy.speed *= 1.6
			enemy.max_health *= 0.6
		elif w == half_w:
			enemy.max_health *= 2.0
			enemy.speed *= 0.7
			enemy.gold_reward += 3
		elif w == three_q:
			enemy.max_health *= 0.5
			enemy.speed *= 1.3

	# Difficulty mode multiplier (Easy=0.85, Medium=1.0, Hard=1.2, Pure=1.5)
	var diff_mult = [0.85, 1.0, 1.2, 1.5][mini(selected_difficulty, 3)]
	enemy.max_health *= diff_mult
	enemy.speed *= (0.9 + mini(selected_difficulty, 2) * 0.05)

	# Level difficulty multiplier
	if current_level >= 0 and current_level < levels.size():
		var diff = levels[current_level]["difficulty"]
		enemy.max_health *= diff
		enemy.speed = enemy.speed * (1.0 + (diff - 1.0) * 0.3)

	# Cap enemy speed to prevent unplayable situations
	enemy.speed = minf(enemy.speed, 280.0)

	# Apply spawn debuffs from progressive abilities
	if spawn_hp_reduction > 0.0:
		enemy.max_health *= (1.0 - spawn_hp_reduction)
	# Apply Knowledge Tree enemy debuffs (Dark Passages branch) — disabled in Pure Mode
	if selected_difficulty != PURE_MODE:
		var kt_hp_reduce = _get_knowledge_bonus("enemy_hp_reduce")
		if kt_hp_reduce > 0.0:
			enemy.max_health *= (1.0 - kt_hp_reduce)
		var kt_boss_hp_reduce = _get_knowledge_bonus("boss_hp_reduce")
		if kt_boss_hp_reduce > 0.0 and (is_boss_wave or is_final_villain or is_last_wave):
			enemy.max_health *= (1.0 - kt_boss_hp_reduce)
		var kt_half_hp = _get_knowledge_bonus("enemy_half_hp")
		if kt_half_hp > 0.0 and randf() < kt_half_hp:
			enemy.max_health *= 0.5
	enemy.health = enemy.max_health
	var kt_enemy_slow = _get_knowledge_bonus("enemy_slow")
	if spawn_permanent_slow < 1.0:
		enemy.apply_permanent_slow(spawn_permanent_slow)
	if kt_enemy_slow > 0.0:
		enemy.apply_permanent_slow(1.0 - kt_enemy_slow)
	# Apply cursed passages modifiers
	_apply_enemy_modifiers(enemy, w, is_boss_wave or is_final_villain or is_last_wave)
	enemy_path.add_child(enemy)
	enemies_to_spawn -= 1
	enemies_alive += 1
	if (is_boss_wave or is_final_villain or is_last_wave) and _is_mobile:
		Input.vibrate_handheld(80)

func _get_wave_enemy_count(w: int) -> int:
	if boss_rush_mode:
		return 1  # Boss rush: single boss per wave
	if endless_mode:
		if w > 0 and w % 10 == 0:
			return 3  # Boss waves: fewer enemies
		var count = 6 + w * 2 + w / 3
		if endless_mutation == "Swarm":
			count = int(count * 2)
		return count
	var base = 4 + w * 2
	# Boss waves: fewer but much stronger enemies
	if w in [20, 25, 30, 35]:
		return max(3, base / 3)
	# Final villain waves (Hard 39-40): very few, very strong
	if w >= 39 and selected_difficulty >= 2:
		return 2 if w == 40 else 3
	# Last wave of any difficulty: single named boss villain
	if w == total_waves:
		return 1
	# Variety waves
	var q = max(1, int(total_waves * 0.25))
	var h = max(1, int(total_waves * 0.5))
	var tq = max(1, int(total_waves * 0.75))
	if w == q: return base + 8   # Fast rush — lots of enemies
	if w == h: return base - 4   # Tank wave — fewer enemies
	if w == tq: return base + 12 # Swarm
	return base

func _get_wave_spawn_interval(w: int) -> float:
	# Boss waves spawn slower (dramatic pacing)
	if w in [20, 25, 30, 35] or w == total_waves:
		return 2.0
	if w >= 39 and selected_difficulty >= 2:
		return 3.0  # Final villains — very slow, dramatic
	var progress = float(w) / float(max(1, total_waves))
	if progress <= 0.33:
		return 0.9 - progress * 0.3
	elif progress <= 0.6:
		return 0.78 - (progress - 0.33) * 0.5
	elif progress <= 0.8:
		return 0.6 - (progress - 0.6) * 0.5
	else:
		return max(0.25, 0.48 - (progress - 0.8) * 0.3)

func _get_wave_name(w: int) -> String:
	var q = max(1, int(total_waves * 0.25))
	var h = max(1, int(total_waves * 0.5))
	var tq = max(1, int(total_waves * 0.75))
	var char_idx = levels[current_level].get("enemy_theme", levels[current_level]["character"]) if current_level >= 0 and current_level < levels.size() else 0
	var chap_idx = levels[current_level]["chapter"] if current_level >= 0 and current_level < levels.size() else 0

	# === Boss milestone wave names (override regular names) ===
	var boss_names = {
		0: {  # Robin Hood
			20: "BOSS — The Sheriff's Champion!",
			25: "BOSS — The Black Knight!",
			30: "BOSS — Sir Guy of Gisbourne!",
			35: "BOSS — Prince John's Warlord!",
			39: "FINAL VILLAIN — Prince John Arrives!",
			40: "FINAL VILLAIN — The Crown's Vengeance!",
		},
		1: {  # Alice
			20: "BOSS — The Jabberwock Awakens!",
			25: "BOSS — The Red Queen's Champion!",
			30: "BOSS — The Bandersnatch!",
			35: "BOSS — The Vorpal Beast!",
			39: "FINAL VILLAIN — The Queen of Hearts!",
			40: "FINAL VILLAIN — Off With ALL Their Heads!",
		},
		2: {  # Wicked Witch
			20: "BOSS — The Winkie Warlord!",
			25: "BOSS — The King of the Flying Monkeys!",
			30: "BOSS — The Great and Terrible Oz!",
			35: "BOSS — The Nome King's General!",
			39: "FINAL VILLAIN — The Nome King Rises!",
			40: "FINAL VILLAIN — The Throne of Stone!",
		},
		3: {  # Peter Pan
			20: "BOSS — The Pirate Quartermaster!",
			25: "BOSS — The Crocodile Hunter!",
			30: "BOSS — Blackbeard's Ghost!",
			35: "BOSS — Hook's Right Hand!",
			39: "FINAL VILLAIN — Captain Hook!",
			40: "FINAL VILLAIN — The Jolly Roger's Last Stand!",
		},
		4: {  # Phantom
			20: "BOSS — The Grand Chandelier Falls!",
			25: "BOSS — The Mirror Shade!",
			30: "BOSS — The Opera Gargoyle!",
			35: "BOSS — The Masked Maestro!",
			39: "FINAL VILLAIN — The Phantom Unmasked!",
			40: "FINAL VILLAIN — The Phantom's Requiem!",
		},
		5: {  # Scrooge
			20: "BOSS — Marley's Ghost!",
			25: "BOSS — The Ghost of Christmas Past!",
			30: "BOSS — The Ghost of Christmas Present!",
			35: "BOSS — The Ghost of Christmas Future!",
			39: "FINAL VILLAIN — Death's Shadow!",
			40: "FINAL VILLAIN — Scrooge's Final Reckoning!",
		},
		6: {  # Shadow Entities (Prologue)
			8: "BOSS — The Shadow Sentinel!",
			10: "BOSS — The Ink Lord!",
		},
		7: {  # Sherlock Criminals
			20: "BOSS — The Crime Lord!",
			25: "BOSS — Moriarty's Right Hand!",
			39: "FINAL VILLAIN — Professor Moriarty!",
			40: "FINAL VILLAIN — The Napoleon of Crime!",
		},
		8: {  # Merlin Dark Sorcery
			20: "BOSS — The Dark Enchantress!",
			25: "BOSS — The Black Knight!",
			39: "FINAL VILLAIN — Morgan le Fay!",
			40: "FINAL VILLAIN — The Sorceress Supreme!",
		},
		9: {  # Tarzan Hunters
			20: "BOSS — The Head Poacher!",
			25: "BOSS — The Safari King!",
			39: "FINAL VILLAIN — Clayton!",
			40: "FINAL VILLAIN — The Hunter Becomes the Hunted!",
		},
		10: {  # Dracula Undead
			20: "BOSS — The Vampire Bride!",
			25: "BOSS — The Alpha Wolf!",
			28: "BOSS — The Elder Vampire!",
			39: "FINAL VILLAIN — Count Dracula Awakens!",
			40: "FINAL VILLAIN — The Eternal Night!",
		},
		11: {  # Frankenstein Experiments
			20: "BOSS — The Failed Experiment!",
			25: "BOSS — The Homunculus King!",
			28: "BOSS — Victor's Shadow!",
			39: "FINAL VILLAIN — Igor the Mad!",
			40: "FINAL VILLAIN — The Creator's Revenge!",
		},
		12: {  # Shadow Author
			25: "BOSS — The Ink Colossus!",
			30: "BOSS — The Corrupted Narrator!",
			35: "BOSS — The Eraser!",
			39: "FINAL VILLAIN — The Shadow Author!",
			40: "FINAL VILLAIN — THE END!",
		},
	}
	# Check for boss/final villain waves
	if char_idx in boss_names and w in boss_names[char_idx]:
		if w >= 39 and selected_difficulty < 2:
			pass  # Only show final villain names on Hard
		elif w > total_waves:
			pass  # Don't show boss names beyond the wave count
		else:
			return boss_names[char_idx][w]

	match char_idx:
		0: # Robin Hood
			match chap_idx:
				0: # Ch1 — Tax collectors, early Sherwood
					if w == q: return "FAST RUSH — Swift tax riders!"
					if w == h: return "TANK WAVE — Armored revenue cart!"
					if w == tq: return "SWARM — Tax collector stampede!"
					if w == total_waves: return "BOSS — The Royal Tax Master!"
					var n = ["Tax collectors spotted!", "Revenue patrol incoming", "More tax men approach",
						"Sherwood road toll guards", "Tax wagon escort", "Sheriff's informants",
						"Tax assessor squad", "Coin purse snatchers", "Tithe enforcers march",
						"Ledger-bearing clerks", "Treasury scouts advance", "Royal tax decree!",
						"Debt warrant officers", "Gold cart guardsmen"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Sheriff's soldiers, escalation
					if w == q: return "FAST RUSH — Mounted sheriff's scouts!"
					if w == h: return "TANK WAVE — Armored knights ride forth!"
					if w == tq: return "SWARM — The Sheriff's full garrison!"
					if w == total_waves: return "BOSS — The Sheriff of Nottingham!"
					var n = ["Sheriff's patrol spotted!", "Soldiers from the castle", "Crossbow sentries advance",
						"Nottingham cavalry scouts", "Castle garrison deploys", "Sheriff's archers march",
						"Knight errant vanguard", "Pikemen hold the line", "Sheriff's war hounds",
						"Battering ram escort", "Armored lance brigade", "Castle wall defenders",
						"The Sheriff's elite guard", "Siege tower builders"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Siege of Nottingham, climax
					if w == q: return "FAST RUSH — Siege scouts sprint ahead!"
					if w == h: return "TANK WAVE — Castle siege engines!"
					if w == tq: return "SWARM — All of Nottingham marches!"
					if w == total_waves: return "BOSS — Prince John's Royal Army!"
					var n = ["Siege vanguard approaches!", "Trebuchet operators advance", "Battering ram crews",
						"Castle wall breakers", "Prince John's heralds", "Royal decree enforcers",
						"Flaming arrow brigade", "Fortress sappers tunnel in", "War elephant handlers",
						"Crown loyalist knights", "The Prince's iron guard", "Nottingham's last stand",
						"Throne room defenders", "The final siege wave"]
					return n[(w - 1) % n.size()]
		1: # Alice
			match chap_idx:
				0: # Ch1 — Card scouts, early Wonderland
					if w == q: return "FAST RUSH — Card scouts scramble!"
					if w == h: return "TANK WAVE — Armored ace of spades!"
					if w == tq: return "SWARM — Full deck deployed!"
					if w == total_waves: return "BOSS — The Knave of Hearts!"
					var n = ["Card soldiers spotted!", "Numbered cards march", "Spade patrol incoming",
						"Diamond sentries glitter", "Club enforcers stomp", "Two of hearts scouts",
						"Shuffled patrol advance", "Card painters approach", "Rose garden guards",
						"Croquet ground wardens", "Hedge maze sentries", "Deck reshuffled!",
						"Wild card scouts", "Joker's little helpers"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Mad tea party & chess pieces
					if w == q: return "FAST RUSH — March Hare's stampede!"
					if w == h: return "TANK WAVE — The Jabberwock stirs!"
					if w == tq: return "SWARM — Chess pieces flood the board!"
					if w == total_waves: return "BOSS — The Red Queen!"
					var n = ["Mad tea party crashers!", "Dormouse sleeper agents", "March Hare's militia",
						"Cheshire grin stalkers", "Looking glass scouts", "Chess pawn advance",
						"Rook towers roll forward", "Knight pieces gallop", "Bishop diagonal assault",
						"Tweedledee & Tweedledum", "Bandersnatch sighting!", "Mock turtle brigade",
						"Vorpal blade seekers", "Through the looking glass"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Queen's court, climax
					if w == q: return "FAST RUSH — Queen's swift executioners!"
					if w == h: return "TANK WAVE — Jabberwock unleashed!"
					if w == tq: return "SWARM — The entire court attacks!"
					if w == total_waves: return "BOSS — The Queen of Hearts!"
					var n = ["Royal court assembles!", "Queen's herald sounds", "Executioner's guard",
						"Flamingo cavalry charge", "The Queen's croquet army", "Painting roses red!",
						"Throne room champions", "Crown jewel defenders", "Off with their heads!",
						"Jabberwock's brood descends", "Royal flush assault", "The Queen's ultimatum",
						"Wonderland unravels!", "Final verdict approaches"]
					return n[(w - 1) % n.size()]
		2: # Wicked Witch / Oz
			match chap_idx:
				0: # Ch1 — Winkie guards, early Oz
					if w == q: return "FAST RUSH — Winkie scouts dash!"
					if w == h: return "TANK WAVE — Armored Winkie captain!"
					if w == tq: return "SWARM — Winkie regiment marches!"
					if w == total_waves: return "BOSS — The Winkie General!"
					var n = ["Winkie guards spotted!", "Yellow uniform patrol", "Western frontier scouts",
						"Poppy field lurkers", "Winkie spear carriers", "Emerald road blockers",
						"Yellow brick sentries", "Winkie drum corps", "Witch's errand runners",
						"Tin whistle scouts", "Scarecrow field watchers", "Winkie border patrol",
						"Golden cap seekers", "Oz perimeter guards"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Flying monkeys & the Witch rises
					if w == q: return "FAST RUSH — Flying monkeys swoop!"
					if w == h: return "TANK WAVE — Armored gorilla guard!"
					if w == tq: return "SWARM — Monkey horde darkens the sky!"
					if w == total_waves: return "BOSS — The Wicked Witch of the West!"
					var n = ["Flying monkeys approach!", "Monkey squadron descends", "Winged ambush party",
						"Witch's cauldron brew stirs", "Broom-riding scouts", "Monkey bombardiers",
						"Crystal ball spies", "Enchanted forest walkers", "Tornado debris creatures",
						"Silver shoe seekers", "Witch's shadow minions", "Dark spell weavers",
						"Monkey king's vanguard", "The Witch's cackle echoes"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Nome King & Emerald City siege
					if w == q: return "FAST RUSH — Nome tunnelers burst forth!"
					if w == h: return "TANK WAVE — Rock titan advances!"
					if w == tq: return "SWARM — Underground legion surfaces!"
					if w == total_waves: return "BOSS — The Nome King!"
					var n = ["Nome tunnelers emerge!", "Crystal cave raiders", "Rock soldiers march",
						"Underground sappers dig in", "Gemstone golem patrol", "Emerald City spies",
						"Nome King's heralds", "Quartz shard throwers", "Obsidian knight brigade",
						"Magma core dwellers", "The Nome King stirs!", "Jewel-encrusted sentinels",
						"Earthquake brigade", "The throne room trembles"]
					return n[(w - 1) % n.size()]
		3: # Peter Pan
			match chap_idx:
				0: # Ch1 — Pirate scouts, Neverland shores
					if w == q: return "FAST RUSH — Pirate scouts sprint!"
					if w == h: return "TANK WAVE — Powder keg haulers!"
					if w == tq: return "SWARM — Shore landing party!"
					if w == total_waves: return "BOSS — The Pirate Bosun!"
					var n = ["Pirate deckhands arrive!", "Swabbie patrol incoming", "Buccaneer scouts",
						"Cutlass-wielding mates", "Crow's nest lookouts", "Plank walkers march",
						"Powder monkey brigade", "Rum barrel rollers", "Anchor chain draggers",
						"Dinghy landing crew", "Treasure map hunters", "Skull Rock sentries",
						"Parrot messenger scouts", "Neverland shore patrol"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Pirate officers & jungle dangers
					if w == q: return "FAST RUSH — Jungle ambush runners!"
					if w == h: return "TANK WAVE — Pirate cannon crew!"
					if w == tq: return "SWARM — Lost Boys besieged!"
					if w == total_waves: return "BOSS — The Pirate First Mate!"
					var n = ["Pirate officers advance!", "Boarding party inbound", "Cannon crew approaches",
						"First mate's detachment", "Jungle vine swingers", "Mermaid Lagoon assault",
						"Crocodile handlers march", "Boatswain's brigade", "Musket-bearing pirates",
						"Jungle trap setters", "Tiger Lily's warning!", "Neverland fog creepers",
						"Pirate war drummers", "The jungle closes in"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Captain Hook & the Jolly Roger
					if w == q: return "FAST RUSH — Hook's fastest cutthroats!"
					if w == h: return "TANK WAVE — Ironclad pirate warship!"
					if w == tq: return "SWARM — The entire Jolly Roger crew!"
					if w == total_waves: return "BOSS — Captain Hook!"
					var n = ["Hook sends his vanguard!", "Jolly Roger's finest", "The Black Spot cometh",
						"Hook's elite swordsmen", "Cannonball barrage crew", "All hands on deck!",
						"Pirate armada sails forth", "Hook's personal guard", "Tick-Tock draws near!",
						"Gangplank executioners", "The captain's ultimatum", "Jolly Roger broadside!",
						"Hook's final gambit", "Neverland's darkest hour"]
					return n[(w - 1) % n.size()]
		4: # Phantom
			match chap_idx:
				0: # Ch1 — Stagehands & shadows, opera house
					if w == q: return "FAST RUSH — Shadow dancers dart!"
					if w == h: return "TANK WAVE — Heavy curtain golem!"
					if w == tq: return "SWARM — Backstage mob floods out!"
					if w == total_waves: return "BOSS — The Stage Manager!"
					var n = ["Stagehands scurry forth!", "The orchestra stirs", "Shadows in the wings",
						"Prop room escapees", "Spotlight chasers", "Rats from below the stage",
						"Costume rack lurkers", "Sandbag droppers above", "Makeup room horrors",
						"Backstage frenzy builds", "Rigging rope swingers", "Prompt box whisperers",
						"Curtain pullers advance", "The overture begins"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Labyrinth & mirrors, deeper opera
					if w == q: return "FAST RUSH — Mirror shards scatter!"
					if w == h: return "TANK WAVE — Gargoyle sentinels descend!"
					if w == tq: return "SWARM — Labyrinth spawns endlessly!"
					if w == total_waves: return "BOSS — The Mirror Phantom!"
					var n = ["The masquerade begins!", "Mirror maze madness", "Trapdoor ambush below",
						"Labyrinth of mirrors", "Candelabra ghosts flicker", "Phantom copycats emerge",
						"Gargoyle watchers stir", "Chandelier chain rattlers", "Opera ghost sightings",
						"Box Five awakens!", "Falling curtain shades", "Hall of echoes patrol",
						"Wax figure sentries", "The organ's fury builds"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Underground lair, climax
					if w == q: return "FAST RUSH — Lair bats swarm the exits!"
					if w == h: return "TANK WAVE — The organ colossus!"
					if w == tq: return "SWARM — Underground phantoms pour forth!"
					if w == total_waves: return "BOSS — The Phantom of the Opera!"
					var n = ["Underground lake patrol!", "Christine's nightmare stirs", "Lair entrance guardians",
						"Sewer tunnel crawlers", "Subterranean echo shades", "Candle-lit crypt walkers",
						"The Phantom's music swells", "Torture chamber sentinels", "Lasso-wielding shadows",
						"Pipe organ resonators", "Lake of fire boatmen", "Mask fragment seekers",
						"The final act begins!", "Beneath the opera forever"]
					return n[(w - 1) % n.size()]
		5: # Scrooge
			match chap_idx:
				0: # Ch1 — Street urchins & carolers, London streets
					if w == q: return "FAST RUSH — Pickpocket dash!"
					if w == h: return "TANK WAVE — Workhouse bruiser!"
					if w == tq: return "SWARM — Street mob riots!"
					if w == total_waves: return "BOSS — The Debt Collector General!"
					var n = ["Street urchins scuttle!", "Chimney sweepers march", "Pickpocket gang approaches",
						"Workhouse escapees shamble", "Carolers gone wrong", "Fog-born shadows creep",
						"Lamplighter scouts", "Cobblestone prowlers", "Penny-pincher patrol",
						"Beggar brigade advances", "Newspaper boy ambush", "Coal dust sneakers",
						"Frostbitten vagrants", "London's forgotten ones"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Spirits & ghosts, hauntings
					if w == q: return "FAST RUSH — Spirit wisps scatter!"
					if w == h: return "TANK WAVE — Ghosts of Christmas Past!"
					if w == tq: return "SWARM — Spectral procession floods in!"
					if w == total_waves: return "BOSS — Ghost of Christmas Present!"
					var n = ["Debt collectors approach!", "Chain rattlers march", "Marley's associates",
						"Counting house guards", "Ghostly apparitions drift", "Spirit wisps gather",
						"Ledger keepers advance", "Top hat enforcers", "Spectral procession forms",
						"Frost wraiths howl!", "Candle flame phantoms", "Clock tower bell shades",
						"Memory lane specters", "The spirits converge"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Army of despair, climax
					if w == q: return "FAST RUSH — Despair's swift heralds!"
					if w == h: return "TANK WAVE — Marley's iron chains!"
					if w == tq: return "SWARM — The army of despair marches!"
					if w == total_waves: return "BOSS — Ghost of Christmas Yet to Come!"
					var n = ["Blizzard brigade advances!", "Frozen specters shamble", "Winter wolves howl",
						"Grave diggers march forth", "Tombstone sentinels rise", "The chains grow heavier",
						"Midnight bell tolls!", "Shadow of the future looms", "Despair's vanguard",
						"Headstone inscription crawlers", "Unmarked grave keepers", "The final Christmas Eve",
						"Bells toll midnight!", "Dawn must break"]
					return n[(w - 1) % n.size()]
		6: # Shadow Entities (Prologue)
			if w == q: return "FAST RUSH — Ink wisps scatter!"
			if w == h: return "TANK WAVE — Shadow beast looms!"
			if w == tq: return "SWARM — The ink floods in!"
			if w == total_waves: return "BOSS — The Ink Lord!"
			var n = ["Shadow wisps emerge!", "Ink blots crawl forth", "Dark page fragments",
				"Quill scratch soldiers", "Torn page ghosts", "Ink puddle lurkers",
				"Shadow puppets advance", "Blotted word wraiths", "Spine-crack crawlers",
				"Margin creepers", "Footnote phantoms", "Chapter end shadows",
				"Bookmark sentinels", "The pages darken"]
			return n[(w - 1) % n.size()]
		7: # Sherlock Criminals
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Pickpocket sprint!"
					if w == h: return "TANK WAVE — Armored bruiser!"
					if w == tq: return "SWARM — Street gang swarms!"
					if w == total_waves: return "BOSS — The Crime Boss!"
					var n = ["Street thugs spotted!", "Alley lurkers emerge", "Pickpocket gang approaches",
						"Baker Street irregulars", "Opium den enforcers", "Dockland brawlers",
						"Whitechapel stalkers", "Underground fighters", "Fence operation crew",
						"Black market dealers", "Safecracker squad", "Informant hunters",
						"Scotland Yard imposters", "The fog thickens"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Assassin blades flash!"
					if w == h: return "TANK WAVE — Criminal mastermind's guard!"
					if w == tq: return "SWARM — The underworld mobilizes!"
					if w == total_waves: return "BOSS — Moriarty's Lieutenant!"
					var n = ["Assassins in the fog!", "Garrote wire specialists", "Poison dart blowers",
						"Moriarty's spies advance", "Criminal network agents", "Coded message runners",
						"Disguised operatives", "The web tightens!", "Sniper nest sighters",
						"Explosive experts approach", "Criminal syndicate elite", "Shadow organization",
						"Double agent ambush", "The game is afoot"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Moriarty's fastest!"
					if w == h: return "TANK WAVE — The Professor's machine!"
					if w == tq: return "SWARM — All of London's criminals!"
					if w == total_waves: return "BOSS — Professor Moriarty!"
					var n = ["Reichenbach approaches!", "The falls thunder", "Mathematical assassins",
						"Moriarty's chess pieces", "The final problem begins", "Crime empire remnants",
						"Waterfall mist soldiers", "Cliffside ambushers", "The professor's gambit",
						"Criminal masterwork!", "Deduction vs destruction", "The Napoleon of Crime stirs",
						"Elementary, my dear enemy", "The final deduction"]
					return n[(w - 1) % n.size()]
		8: # Merlin Dark Sorcery
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Squire scouts charge!"
					if w == h: return "TANK WAVE — Corrupted knight!"
					if w == tq: return "SWARM — The dark army forms!"
					if w == total_waves: return "BOSS — The Black Knight!"
					var n = ["Dark squires march!", "Rusted armor clanks", "Corrupted page boys",
						"Shadow lance bearers", "Cursed shield walls", "Enchanted sentries",
						"Round Table traitors", "Morgana's scouts", "Dark spell apprentices",
						"Camelot's fallen", "Cursed banner carriers", "Iron golem guards",
						"Blackened sword knights", "The corruption spreads"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Forest spirits charge!"
					if w == h: return "TANK WAVE — Ancient tree golem!"
					if w == tq: return "SWARM — The enchanted forest rises!"
					if w == total_waves: return "BOSS — The Warlock!"
					var n = ["Enchanted forest stirs!", "Standing stone guardians", "Rune circle warriors",
						"Dark druid summoners", "Celtic curse weavers", "Ancient oak sentinels",
						"Mushroom ring crawlers", "Fairy circle traps!", "Moss golem patrol",
						"Stone circle shamans", "Forest wraith ambush", "Ley line channelers",
						"Crystal shard throwers", "The old magic awakens"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Crystal shards fly!"
					if w == h: return "TANK WAVE — Crystal golem!"
					if w == tq: return "SWARM — The cave erupts!"
					if w == total_waves: return "BOSS — Morgan le Fay!"
					var n = ["Crystal cave defenders!", "Gemstone sentinels", "Cave stalactite warriors",
						"Morgan's enchantresses", "Dark crystal resonators", "Spell-forged knights",
						"The cave pulses!", "Arcane rune soldiers", "Merlin's prison guards",
						"Excalibur seekers", "Holy Grail protectors", "The sorceress stirs!",
						"Final enchantment wave", "Break the crystal prison!"]
					return n[(w - 1) % n.size()]
		9: # Tarzan Hunters
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Poachers sprint!"
					if w == h: return "TANK WAVE — Caged beast hauler!"
					if w == tq: return "SWARM — Hunting party swarms!"
					if w == total_waves: return "BOSS — The Head Poacher!"
					var n = ["Poachers spotted!", "Net-carrying trappers", "Jungle path cutters",
						"Pith helmet scouts", "Trophy hunters advance", "Canopy vine cutters",
						"Animal cage haulers", "Snare wire layers", "Ivory seekers march",
						"Jungle map readers", "Exotic pet catchers", "Tranquilizer dart squad",
						"Campsite builders", "The hunt begins"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Mounted hunters charge!"
					if w == h: return "TANK WAVE — Armored safari vehicle!"
					if w == tq: return "SWARM — The graveyard awakens!"
					if w == total_waves: return "BOSS — The Safari King!"
					var n = ["Big game hunters advance!", "Elephant gun carriers", "Safari jeep scouts",
						"Bone collectors march", "Graveyard dust seekers", "Tusk pry-bar squad",
						"Trophy wall builders", "Taxidermy experts", "Quicksand pathfinders",
						"Jungle ambush unit", "Rhino horn raiders", "The bones rattle!",
						"Ancient burial guardians", "The dead remember"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Mercenary scouts!"
					if w == h: return "TANK WAVE — Fortress siege ram!"
					if w == tq: return "SWARM — Clayton's full army!"
					if w == total_waves: return "BOSS — Clayton!"
					var n = ["Mercenary vanguard!", "Combat gear soldiers", "Machete-wielding scouts",
						"Fortress gate guards", "Watchtower snipers", "Barbed wire layers",
						"Explosive ordinance team", "Clayton's elite guard", "Jungle clearers",
						"Cage key holders", "The fortress trembles!", "Tarzan's rage builds!",
						"Freedom fighters", "Break the chains!"]
					return n[(w - 1) % n.size()]
		10: # Dracula Undead
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Thralls sprint!"
					if w == h: return "TANK WAVE — Dire wolf alpha!"
					if w == tq: return "SWARM — The village is overrun!"
					if w == total_waves: return "BOSS — The Village Elder!"
					var n = ["Thralls shamble forth!", "Pale villagers march", "Hypnotized peasants",
						"Garlic-proof scouts", "Wolfbane carriers", "Night patrol guards",
						"Graveyard shift workers", "Blood offering bearers", "Cross-resistant thralls",
						"Moonlit ambushers", "Fog-shrouded stalkers", "The village bell tolls!",
						"Midnight processioners", "Dawn never comes"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Bat swarm descends!"
					if w == h: return "TANK WAVE — Castle knight rises!"
					if w == tq: return "SWARM — The castle awakens!"
					if w == total_waves: return "BOSS — The Vampire Bride!"
					var n = ["Castle corridor stalkers!", "Armor suit animations", "Bat swarm scouts",
						"Coffin lid pushers", "Dining hall servants", "Bloodstain trail followers",
						"Tower staircase guards", "Chandelier chain swingers", "Portrait eye watchers",
						"Crypt key seekers", "The brides stir!", "Dire wolf pack howls",
						"Castle wall crawlers", "The Count watches"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Blood mist rushers!"
					if w == h: return "TANK WAVE — Ancient vampire!"
					if w == tq: return "SWARM — The crypt erupts!"
					if w == total_waves: return "BOSS — Count Dracula!"
					var n = ["Crypt guardians rise!", "Blood pool swimmers", "Ancient coffin dwellers",
						"Stake-proof elders", "Crimson mist walkers", "Blood chalice bearers",
						"The undead army marches!", "Shadow form shifters", "Nosferatu's children",
						"The crypt pulses red!", "Eternal night soldiers", "Dracula's chains rattle!",
						"Freedom through blood!", "Break the blood seal!"]
					return n[(w - 1) % n.size()]
		11: # Frankenstein Experiments
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Lab rats scatter!"
					if w == h: return "TANK WAVE — Failed experiment!"
					if w == tq: return "SWARM — The lab overflows!"
					if w == total_waves: return "BOSS — The Head Scientist!"
					var n = ["Lab rats scurry!", "Homunculus crawlers", "Beaker-born creatures",
						"Tesla coil sparkers", "Formaldehyde floaters", "Stitch-mark soldiers",
						"Lightning rod channelers", "Electrode head walkers", "Test tube terrors",
						"Galvanic cell chargers", "The lab sparks!", "Surgical tool wielders",
						"Brain jar carriers", "The experiment continues"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Torch runners!"
					if w == h: return "TANK WAVE — Pitchfork mob leader!"
					if w == tq: return "SWARM — The whole village attacks!"
					if w == total_waves: return "BOSS — The Village Magistrate!"
					var n = ["Angry villagers approach!", "Torch-bearing mob", "Pitchfork wielders march",
						"Millstone throwers", "Tavern brawler squad", "Church bell ringers",
						"Holy water throwers", "Wooden stake carriers", "The mob grows louder!",
						"Blacksmith hammer squad", "Hay cart barricaders", "Fire brigade arsonists",
						"Town crier warnings!", "The village burns!"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Ice shard runners!"
					if w == h: return "TANK WAVE — Frost golem!"
					if w == tq: return "SWARM — The arctic army!"
					if w == total_waves: return "BOSS — Igor!"
					var n = ["Arctic wind howlers!", "Frost-bitten soldiers", "Ice pick wielders",
						"Sled dog pack hunters", "Snowblind scouts", "Frozen chain draggers",
						"Igor's assistants march!", "Cryogenic capsule guards", "The ice cracks!",
						"Blizzard born warriors", "Glacier path breakers", "The Monster's chains rattle!",
						"Promethean spark seekers", "Shatter the ice prison!"]
					return n[(w - 1) % n.size()]
		12: # Shadow Author
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Ink soldiers charge!"
					if w == h: return "TANK WAVE — Ink colossus!"
					if w == tq: return "SWARM — The ink realm floods!"
					if w == total_waves: return "BOSS — The Ink Titan!"
					var n = ["Ink soldiers form!", "Dripping word warriors", "Quill-forged knights",
						"Paragraph golems march", "Sentence serpents slither", "Plot hole abominations",
						"Narrative thread weavers", "Exposition crawlers", "Red ink editors",
						"Footnote assassins", "The ink flows faster!", "Manuscript shredders",
						"Prologue phantoms", "The Author writes"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Corrupted heroes sprint!"
					if w == h: return "TANK WAVE — Corrupted champion!"
					if w == tq: return "SWARM — All stories collapse!"
					if w == total_waves: return "BOSS — The Corrupted Narrator!"
					var n = ["Corrupted characters emerge!", "Twisted fairy tales", "Dark adaptations march",
						"Rewritten heroes attack!", "Genre-bent warriors", "Sequel shadow soldiers",
						"Plagiarized phantoms", "Adaptation aberrations", "The pages go blank!",
						"Retcon shock troops", "Unreliable narrators", "Cliffhanger ambushers",
						"Deus ex machina soldiers", "The story unravels!"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Eraser blades sweep!"
					if w == h: return "TANK WAVE — The Eraser!"
					if w == tq: return "SWARM — THE END approaches!"
					if w == total_waves: return "BOSS — THE SHADOW AUTHOR!"
					var n = ["The final chapter begins!", "Every villain returns!", "All stories converge!",
						"The Author's masterwork!", "Ink tsunami approaches!", "Characters dissolve!",
						"The quill strikes!", "Reality rewrites itself!", "THE END is written!",
						"But the heroes resist!", "Stories fight back!", "Every page turns!",
						"The climax crescendos!", "REWRITE THE ENDING!"]
					return n[(w - 1) % n.size()]
	return "Wave %d" % w

func _check_wave_complete() -> void:
	if boss_rescue_active:
		return
	if enemies_to_spawn <= 0 and enemies_alive <= 0:
		is_wave_active = false
		game_paused = false
		start_button.disabled = false
		# Wave clear popup + sound
		_wave_clear_timer = 1.5
		_wave_clear_num = wave
		_play_sfx(_sfx_wave_complete)
		if _is_mobile:
			Input.vibrate_handheld(30)
		if not endless_mode and not shadow_arena_active and wave >= total_waves:
			_victory()
		else:
			# Endless bonus gold every 5 waves — scales with wave number
			if endless_mode and wave > 0 and wave % 5 == 0:
				var endless_bonus = 50 + wave * 3
				add_gold(endless_bonus)
				spawn_floating_text(Vector2(640, 300), "+%dG Endless Bonus!" % endless_bonus, Color(1.0, 0.9, 0.2), 18.0, 1.5)
			start_button.text = "  START WAVE  "
			# BATTD: Wave Rush bonus (fast clear = extra gold)
			var wave_time = _time - _wave_start_time
			_wave_rush_bonus = 0
			if wave_time < WAVE_RUSH_THRESHOLD and wave_time > 0.1:
				_wave_rush_bonus = int((WAVE_RUSH_THRESHOLD - wave_time) * 2.0)
				add_gold(_wave_rush_bonus)
				spawn_floating_text(Vector2(640, 310), "RUSH +%dG (%.1fs)" % [_wave_rush_bonus, wave_time], Color(0.2, 1.0, 0.8), 15.0, 1.2)
			# BATTD: Income breakdown display timer
			_income_display_timer = 3.0
			# Bonus gold between waves — scales with progression
			var bonus = 5 + wave * 2 + int(wave / 10) * 5
			add_gold(bonus)
			spawn_floating_text(Vector2(640, 340), "+%dG Wave Bonus" % bonus, Color(1.0, 0.85, 0.2), 14.0, 1.0)
			_income_breakdown["wave_bonus"] = bonus
			# Knowledge tree: life regen per wave
			var life_regen = int(_get_knowledge_bonus("life_regen"))
			if life_regen > 0:
				lives += life_regen
				spawn_floating_text(Vector2(640, 370), "+%d Lives" % life_regen, Color(0.3, 1.0, 0.4), 13.0, 1.0)
			update_hud()
			# Auto-wave: start countdown timer for next wave
			if auto_wave_enabled:
				wave_auto_timer = auto_wave_delay
				start_button.text = "  NEXT IN %.0fs  " % auto_wave_delay
			info_label.text = "Wave %d cleared! +%dG bonus. Ready for next wave!" % [wave, bonus]
			# BATTD2: Gold Interest (5% on unspent gold between waves)
			if gold_interest_enabled and gold > 0:
				var interest = mini(int(float(gold) * GOLD_INTEREST_RATE), GOLD_INTEREST_CAP)
				if interest > 0:
					add_gold(interest)
					spawn_floating_text(Vector2(640, 380), "+%dG Interest" % interest, Color(0.9, 0.8, 0.3), 13.0, 1.0)
			# BATTD2: Auto-collect map collectibles
			if auto_collect_enabled:
				for mc in _map_collectibles:
					if not mc["collected"]:
						_check_collectible_click(mc["pos"])
			# Show wave preview for next wave
			wave_preview_data = _generate_wave_preview(wave)
			if wave_preview_data.size() > 0:
				wave_preview_active = true
				wave_preview_timer = 3.0
			if _is_mobile:
				Input.vibrate_handheld(50)

func _notification(what: int) -> void:
	if what == NOTIFICATION_WM_GO_BACK_REQUEST:
		_handle_back_button()

func _handle_back_button() -> void:
	if chest_opening_active:
		return
	if daily_reward_open:
		return
	if story_state["active"]:
		_end_story_dialog()
		return
	if game_state == GameState.PLAYING:
		if power_selection_open:
			power_selection_open = false
			queue_redraw()
			return
		if selected_tower_node:
			_deselect_tower()
			return
		if placing_tower:
			_on_cancel_placement()
			return
		_on_restart_pressed()
		return
	if game_state == GameState.MENU:
		if detail_info_overlay_open:
			detail_info_overlay_open = false
			queue_redraw()
			return
		if survivor_detail_open:
			survivor_detail_open = false
			survivor_detail_index = -1
			survivor_grid_container.visible = true
			survivor_detail_container.visible = false
			_remove_detail_preview()
			queue_redraw()
			return
		if emporium_sub_category >= 0 or emporium_sub_open:
			emporium_sub_open = false
			emporium_sub_category = -1
			emporium_sub_hover = -1
			queue_redraw()
			return
		if menu_current_view != "chapters":
			menu_current_view = "chapters"
			_on_nav_pressed("chapters")
			queue_redraw()
			return

func _input(event: InputEvent) -> void:
	# Input debouncing for buttons
	if _input_cooldown > 0:
		return
	# Touch drag scrolling for mobile
	if event is InputEventScreenTouch and game_state == GameState.MENU:
		if event.pressed:
			_touch_scroll_start_y = event.position.y
			_touch_last_y = event.position.y
			_touch_scroll_velocity = 0.0
		else:
			_touch_scroll_start_y = -1.0
		return
	if event is InputEventScreenDrag and game_state == GameState.MENU:
		var delta_y = _touch_last_y - event.position.y
		_touch_last_y = event.position.y
		_touch_scroll_velocity = delta_y
		if menu_current_view == "chapters":
			story_map_scroll_y = maxf(0.0, story_map_scroll_y + delta_y)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "relics":
			relic_scroll_offset = clampf(relic_scroll_offset + delta_y, 0.0, 1200.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "emporium" and emporium_sub_category == 8:
			binding_shop_scroll = clampf(binding_shop_scroll + delta_y, 0.0, 1200.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "survivors" and survivor_detail_open:
			detail_binding_scroll = clampf(detail_binding_scroll + delta_y, 0.0, 600.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
	if event is InputEventScreenDrag and game_state == GameState.PLAYING:
		ghost_position = event.position
		return
	# Scroll wheel handling for scrollable views
	if event is InputEventMouseButton and event.pressed and game_state == GameState.MENU:
		if menu_current_view == "chapters" and (event.button_index == MOUSE_BUTTON_WHEEL_UP or event.button_index == MOUSE_BUTTON_WHEEL_DOWN):
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				story_map_scroll_y = maxf(0.0, story_map_scroll_y - 60.0)
			else:
				story_map_scroll_y = minf(story_map_scroll_y + 60.0, 2000.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "relics" and (event.button_index == MOUSE_BUTTON_WHEEL_UP or event.button_index == MOUSE_BUTTON_WHEEL_DOWN):
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				relic_scroll_offset = maxf(0.0, relic_scroll_offset - 30.0)
			else:
				relic_scroll_offset = minf(relic_scroll_offset + 30.0, 1200.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "emporium" and emporium_sub_category == 8 and (event.button_index == MOUSE_BUTTON_WHEEL_UP or event.button_index == MOUSE_BUTTON_WHEEL_DOWN):
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				binding_shop_scroll = maxf(0.0, binding_shop_scroll - 30.0)
			else:
				binding_shop_scroll = minf(binding_shop_scroll + 30.0, 1200.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "survivors" and survivor_detail_open and (event.button_index == MOUSE_BUTTON_WHEEL_UP or event.button_index == MOUSE_BUTTON_WHEEL_DOWN):
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				detail_binding_scroll = maxf(0.0, detail_binding_scroll - 30.0)
			else:
				detail_binding_scroll = minf(detail_binding_scroll + 30.0, 600.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
	if not (event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT):
		return
	var mouse_pos = get_viewport().get_mouse_position()
	# Overlays must intercept before Control nodes consume the event
	if daily_reward_open:
		_on_daily_reward_clicked(mouse_pos)
		get_viewport().set_input_as_handled()
		return
	if chest_opening_active:
		_on_chest_overlay_clicked(mouse_pos)
		get_viewport().set_input_as_handled()
		return
	if story_state.active:
		_on_story_dialog_clicked(mouse_pos)
		get_viewport().set_input_as_handled()
		return
	# Menu clicks (must be in _input because menu_overlay eats events before _unhandled_input)
	# But let clicks on the nav bar (y >= 620) pass through to buttons
	if game_state == GameState.MENU and mouse_pos.y < 620:
		if menu_current_view == "chapters":
			if chapters_diff_popup_level >= 0:
				_on_diff_popup_clicked(mouse_pos)
				get_viewport().set_input_as_handled()
				return
			_on_chapters_sidebar_clicked(mouse_pos)
			if menu_side_panel == "":
				_on_story_map_clicked(mouse_pos)
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "survivors":
			if survivor_detail_open:
				_on_detail_item_clicked(mouse_pos)
			elif world_map_hover_index >= 0:
				_on_survivor_card_pressed(world_map_hover_index)
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "emporium":
			if emporium_sub_category == 6:
				_on_trophy_store_clicked(mouse_pos)
			elif emporium_sub_category == 8:
				_on_binding_shop_clicked(mouse_pos)
			elif emporium_sub_category == 9:
				_on_salvage_clicked(mouse_pos)
			elif emporium_sub_category == 10:
				_on_chest_crafting_clicked(mouse_pos)
			elif emporium_sub_category == 11:
				_on_instrument_shop_clicked(mouse_pos)
			elif emporium_sub_open:
				_on_emporium_sub_input(mouse_pos)
			elif emporium_hover_index >= 0:
				if emporium_hover_index == 6:
					emporium_sub_category = 6
				elif emporium_hover_index == 8:
					emporium_sub_category = 8
				elif emporium_hover_index == 9:
					emporium_sub_category = 9
				elif emporium_hover_index == 10:
					emporium_sub_category = 10
				elif emporium_hover_index == 11:
					emporium_sub_category = 11
				else:
					_on_emporium_tile_clicked(emporium_hover_index)
			get_viewport().set_input_as_handled()
			queue_redraw()
			return
		elif menu_current_view == "chronicles":
			_on_knowledge_tree_clicked(mouse_pos)
			get_viewport().set_input_as_handled()
			return

func _unhandled_input(event: InputEvent) -> void:
	if game_state != GameState.PLAYING:
		if not (event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT):
			return
		var mouse_pos = get_viewport().get_mouse_position()
		# === Overlays first (chest opening, daily rewards) ===
		if chest_opening_active:
			_on_chest_overlay_clicked(mouse_pos)
			return
		if daily_reward_open:
			_on_daily_reward_clicked(mouse_pos)
			return
		if game_state != GameState.MENU:
			return
		# Handle clicks in survivor detail view (BATTD-style)
		if survivor_detail_open:
			_on_detail_item_clicked(mouse_pos)
		# Handle world map zone clicks
		elif menu_current_view == "survivors" and not survivor_detail_open:
			if world_map_hover_index >= 0:
				_on_survivor_card_pressed(world_map_hover_index)
		# Handle emporium clicks
		elif menu_current_view == "emporium":
			if emporium_sub_category == 6:
				_on_trophy_store_clicked(mouse_pos)
			elif emporium_sub_category == 8:
				_on_binding_shop_clicked(mouse_pos)
			elif emporium_sub_category == 9:
				_on_salvage_clicked(mouse_pos)
			elif emporium_sub_category == 10:
				_on_chest_crafting_clicked(mouse_pos)
			elif emporium_sub_category == 11:
				_on_instrument_shop_clicked(mouse_pos)
			elif emporium_sub_open:
				_on_emporium_sub_input(mouse_pos)
			elif emporium_hover_index >= 0:
				if emporium_hover_index == 6:
					emporium_sub_category = 6
					queue_redraw()
				elif emporium_hover_index == 8:
					emporium_sub_category = 8
					queue_redraw()
				elif emporium_hover_index == 9:
					emporium_sub_category = 9
					queue_redraw()
				elif emporium_hover_index == 10:
					emporium_sub_category = 10
					queue_redraw()
				elif emporium_hover_index == 11:
					emporium_sub_category = 11
					queue_redraw()
				else:
					_on_emporium_tile_clicked(emporium_hover_index)
		# Handle chronicles/knowledge tree clicks
		elif menu_current_view == "chronicles":
			_on_knowledge_tree_clicked(mouse_pos)
		# Handle chapters view — diff popup first, then badges/overlay, then story map
		elif menu_current_view == "chapters":
			if chapters_diff_popup_level >= 0:
				_on_diff_popup_clicked(mouse_pos)
			else:
				_on_chapters_sidebar_clicked(mouse_pos)
				if menu_side_panel == "":
					_on_story_map_clicked(mouse_pos)
		return
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			# Power selection overlay
			if power_selection_open:
				_on_power_selection_clicked(event.position)
				return
			if placing_tower:
				_try_place_tower(event.position)
			elif _handle_branch_panel_click(event.position):
				pass  # Branch panel consumed the click
			elif _handle_instrument_placement_click(event.position):
				pass  # Instrument placement consumed the click
			else:
				# Check storybook page / map collectible clicks first
				if _check_page_click(event.position) or _check_collectible_click(event.position):
					pass
				else:
					var tower = _find_tower_at(event.position)
					if tower:
						_select_tower(tower)
					else:
						_deselect_tower()
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			if _placing_instrument != "":
				_placing_instrument = ""
				_instrument_picker_open = false
				info_label.text = "Instrument placement cancelled."
				queue_redraw()
			elif placing_tower:
				placing_tower = false
				cancel_button.visible = false
				info_label.text = "Placement cancelled."
			else:
				_deselect_tower()
	elif event is InputEventScreenTouch and event.pressed:
		if placing_tower:
			_try_place_tower(event.position)
		elif _check_page_click(event.position) or _check_collectible_click(event.position):
			pass  # BATTD: Collectible picked up
		else:
			var tower = _find_tower_at(event.position)
			if tower:
				_select_tower(tower)
			else:
				_deselect_tower()
	elif event is InputEventScreenDrag:
		ghost_position = event.position

func _dist_to_path(pos: Vector2) -> float:
	var min_dist: float = 99999.0
	for p in path_points:
		var d = pos.distance_to(p)
		if d < min_dist:
			min_dist = d
	return min_dist

func _is_valid_placement(pos: Vector2) -> bool:
	var max_y = bottom_panel.position.y - 6.0 if bottom_panel else 622.0
	if pos.y < 55 or pos.y > max_y:
		return false
	var vp_w = get_viewport_rect().size.x
	if pos.x < 5 or pos.x > vp_w - 5:
		return false
	if _dist_to_path(pos) < MIN_PATH_DIST:
		return false
	for tp in placed_tower_positions:
		if pos.distance_to(tp) < MIN_TOWER_DIST:
			return false
	return true

func _get_discounted_cost(tower_type) -> int:
	var base_cost = tower_info[tower_type]["cost"]
	var discount = clampf(_get_knowledge_bonus("tower_discount") + _get_knowledge_bonus("upgrade_discount"), 0.0, 0.5)
	# BATTD: Placement streak discount
	var streak_disc = clampf(_placement_streak_count * PLACEMENT_STREAK_DISCOUNT, 0.0, 0.25)
	return int(base_cost * (1.0 - discount - streak_disc))

func _try_place_tower(pos: Vector2) -> void:
	if not _is_valid_placement(pos):
		info_label.text = "Can't place there!"
		return
	var cost = _get_discounted_cost(selected_tower)
	if not spend_gold(cost):
		info_label.text = "Need %dG! (Have %dG)" % [cost, gold]
		_insufficient_gold_flash = 1.0
		return

	var tower = tower_scenes[selected_tower].instantiate()
	tower.position = pos
	tower.base_cost = cost
	tower.set_meta("tower_type_enum", selected_tower)
	towers_node.add_child(tower)
	# Build animation
	if "_build_timer" in tower:
		tower._build_timer = 0.5
	_build_effects.append({"pos": pos, "timer": 0.5, "max_timer": 0.5})
	# Apply meta-progression buffs (level + knowledge + relics)
	_apply_meta_buffs(tower, selected_tower)

	placed_tower_positions.append(pos)
	purchased_towers[selected_tower] = true
	var tname = tower_info[selected_tower]["name"]

	# Disable the button — one purchase per tower
	if tower_buttons.has(selected_tower):
		tower_buttons[selected_tower].text = "PLACED"
		tower_buttons[selected_tower].disabled = true

	placing_tower = false
	cancel_button.visible = false
	# Store undo data
	undo_tower_data = {"node": tower, "type": selected_tower, "position": pos, "cost": cost, "timer": UNDO_DURATION}
	# BATTD: Placement streak tracking
	if _placement_streak_timer > 0.0:
		_placement_streak_count += 1
		if _placement_streak_count >= 2:
			spawn_floating_text(pos + Vector2(0, -50), "STREAK x%d!" % _placement_streak_count, Color(0.4, 1.0, 0.6), 14.0, 1.0)
	else:
		_placement_streak_count = 1
	_placement_streak_timer = PLACEMENT_STREAK_WINDOW
	undo_button.visible = true
	if _is_mobile:
		Input.vibrate_handheld(30)
	var quote = _play_placement_catchphrase(selected_tower)
	info_label.text = "%s: \"%s\"" % [tname, quote]
	# Track achievements + quests
	total_towers_placed += 1
	_check_achievement("novice_builder", 1)
	_check_achievement("master_builder", 1)
	_update_quest_progress("place_towers", 1)
	# Check full roster (all 6 types placed this game)
	_check_achievement("full_roster", purchased_towers.size())
	# Check synergies
	_check_synergies()
	# Layered music: fade in this character's instrument
	_fade_in_tower_layer(selected_tower)

# === TOWER STATS OVERLAY (draw near selected tower) ===
func _draw_tower_stats_overlay() -> void:
	var tower = selected_tower_node
	if not is_instance_valid(tower):
		return
	var tpos = tower.global_position
	# Position panel to the right of tower, or left if too close to edge
	var panel_x = tpos.x + 55.0
	if panel_x + 160.0 > 1240.0:
		panel_x = tpos.x - 215.0
	var panel_y = clampf(tpos.y - 60.0, 60.0, 520.0)
	var pw = 160.0
	var ph = 100.0
	# Dark panel with gold border (gothic style)
	draw_rect(Rect2(panel_x - 2, panel_y - 2, pw + 4, ph + 4), Color(0.8, 0.65, 0.2, 0.7))
	draw_rect(Rect2(panel_x, panel_y, pw, ph), Color(0.05, 0.03, 0.08, 0.92))
	var font = game_font
	var dmg = tower.damage_dealt if "damage_dealt" in tower else 0.0
	var kills = tower.kill_count if "kill_count" in tower else 0
	var tier = tower.upgrade_tier if "upgrade_tier" in tower else 0
	var elapsed = maxf(_time, 1.0)
	var dps = dmg / elapsed
	var y = panel_y + 16.0
	_udraw(font, Vector2(panel_x + 6, y), "DMG: %s" % _format_number(dmg), HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(1.0, 0.85, 0.3))
	y += 16.0
	_udraw(font, Vector2(panel_x + 6, y), "KILLS: %d" % kills, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.8, 0.9, 1.0))
	y += 16.0
	_udraw(font, Vector2(panel_x + 6, y), "DPS: %s" % _format_number(dps), HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.6, 1.0, 0.6))
	y += 16.0
	_udraw(font, Vector2(panel_x + 6, y), "TIER: %d" % tier, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.9, 0.8, 1.0))
	y += 16.0
	var prio_names = ["FIRST", "LAST", "CLOSE", "STRONG"]
	var prio = tower.targeting_priority if "targeting_priority" in tower else 0
	_udraw(font, Vector2(panel_x + 6, y), "TARGET: %s" % prio_names[clampi(prio, 0, 3)], HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.7, 0.7, 0.7))

# === WAVE PREVIEW PANEL ===
func _draw_wave_preview() -> void:
	if wave_preview_data.is_empty():
		return
	var font = game_font
	var px = 340.0
	var py = 90.0
	var pw = 600.0
	var ph = 80.0
	# Crimson border panel
	draw_rect(Rect2(px - 3, py - 3, pw + 6, ph + 6), Color(0.7, 0.15, 0.1, 0.8))
	draw_rect(Rect2(px - 1, py - 1, pw + 2, ph + 2), Color(0.85, 0.7, 0.2, 0.6))
	draw_rect(Rect2(px, py, pw, ph), Color(0.05, 0.03, 0.08, 0.93))
	# Title
	_udraw(font, Vector2(640, py + 18), "NEXT WAVE: %d" % (wave + 1), HORIZONTAL_ALIGNMENT_CENTER, -1, 16, Color(1.0, 0.85, 0.3))
	# Enemy info
	var info_parts: Array = []
	for wd in wave_preview_data:
		info_parts.append("%dx T%d" % [wd.get("count", 0), wd.get("tier", 0)])
	var info_text = " | ".join(info_parts)
	_udraw(font, Vector2(640, py + 40), info_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(0.9, 0.85, 0.8))
	# Timer bar
	var bar_pct = clampf(wave_preview_timer / 3.0, 0.0, 1.0)
	draw_rect(Rect2(px + 10, py + ph - 14, (pw - 20) * bar_pct, 6), Color(0.8, 0.65, 0.2, 0.7))
	draw_rect(Rect2(px + 10, py + ph - 14, pw - 20, 6), Color(0.4, 0.3, 0.2, 0.3))
	# Modifier badges
	if wave_preview_data.size() > 0:
		var mods = wave_preview_data[0].get("modifiers", [])
		var mx = 640.0 - float(mods.size()) * 40.0
		for mi in range(mods.size()):
			_udraw(font, Vector2(mx + mi * 80, py + 58), mods[mi], HORIZONTAL_ALIGNMENT_CENTER, -1, 11, Color(1.0, 0.4, 0.3))

func _generate_wave_preview(w: int) -> Array:
	var preview: Array = []
	var next_wave = w + 1
	if next_wave > total_waves:
		return preview
	# Analyze what the next wave would contain
	var base_count = 5 + next_wave * 2
	if endless_mode:
		base_count = 8 + next_wave * 3
	var tier = 0
	var wave_progress = float(next_wave) / float(max(1, total_waves))
	if wave_progress > 0.75:
		tier = 3
	elif wave_progress > 0.5:
		tier = 2
	elif wave_progress > 0.25:
		tier = 1
	var is_boss_wave = (next_wave % 10 == 0) or next_wave == total_waves
	var mods: Array = []
	if is_boss_wave:
		mods.append("BOSS")
	if endless_mode and next_wave % 5 == 0:
		mods.append(endless_mutation if endless_mutation != "" else "MUTATING")
	preview.append({"count": base_count, "tier": tier, "modifiers": mods})
	return preview

# ============================================================
# Helper: draw string in Cinzel uppercase
func _udraw(fnt: Font, pos: Vector2, text: String, halign: HorizontalAlignment = HORIZONTAL_ALIGNMENT_LEFT, width = -1, size: int = 16, color: Color = Color.WHITE) -> void:
	draw_string(fnt, pos, text.to_upper(), halign, width, size, color)

# DRAW — Level-specific backgrounds
# ============================================================
func _draw() -> void:
	if game_state == GameState.MENU:
		_draw_menu_background()
		# Menu view transition fade
		if menu_transition_alpha < 1.0:
			menu_transition_alpha = minf(menu_transition_alpha + 0.06, 1.0)
			draw_rect(Rect2(0, 35, 1280, 585), Color(0.03, 0.02, 0.06, 1.0 - menu_transition_alpha))
			queue_redraw()
		# === View transition dark overlay fade (Enhancement #48) ===
		if _menu_transition_alpha > 0.0:
			draw_rect(Rect2(0, 0, 1280, 720), Color(0.02, 0.02, 0.06, _menu_transition_alpha * 0.5))
		# === Stats summary banner (Enhancement #50) ===
		var stats_font = game_font
		var stats_y = 33.0
		draw_rect(Rect2(70, stats_y, 1140, 12), Color(0.02, 0.02, 0.06, 0.5))
		var stats_cx = 160.0
		_udraw(stats_font, Vector2(stats_cx, stats_y + 10), "DAMAGE: %s" % _format_number(float(total_damage)), HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.5, 0.5, 0.55, 0.45))
		stats_cx += 200.0
		_udraw(stats_font, Vector2(stats_cx, stats_y + 10), "KILLS: %s" % _format_number(float(total_enemies_killed)), HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.5, 0.5, 0.55, 0.45))
		stats_cx += 200.0
		_udraw(stats_font, Vector2(stats_cx, stats_y + 10), "GOLD EARNED: %s" % _format_number(float(total_gold_earned)), HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.5, 0.5, 0.55, 0.45))
		stats_cx += 220.0
		_udraw(stats_font, Vector2(stats_cx, stats_y + 10), "LEVELS: %d / %d" % [completed_levels.size(), levels.size()], HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.5, 0.5, 0.55, 0.45))

		if chest_opening_active:
			_draw_chest_opening()
		_draw_levelup_fanfare()
		_draw_session_recap()
		_draw_career_stats()
		if daily_reward_open:
			_draw_daily_reward()
		# Story dialog overlay (draws on top of everything in menu)
		if story_state.active:
			_draw_story_dialog()
		# Achievement popup in menu
		if achievement_popup_timer > 0.0:
			var font = game_font
			var a_alpha = clampf(achievement_popup_timer, 0.0, 1.0)
			draw_rect(Rect2(340, 20, 600, 40), Color(0.08, 0.12, 0.04, 0.85 * a_alpha))
			draw_rect(Rect2(340, 20, 600, 40), Color(0.4, 0.8, 0.2, 0.5 * a_alpha), false, 1.0)
			_udraw(font, Vector2(640, 37), achievement_popup_text, HORIZONTAL_ALIGNMENT_CENTER, 580, 14, Color(0.85, 0.75, 0.4, a_alpha))
			_udraw(font, Vector2(640, 53), achievement_popup_reward, HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.5, 0.8, 0.3, a_alpha))
		return

	var sky_color = Color(0.04, 0.06, 0.14)
	var ground_color = Color(0.08, 0.18, 0.06)
	if current_level >= 0 and current_level < levels.size():
		sky_color = levels[current_level]["sky_color"]
		ground_color = levels[current_level]["ground_color"]

	match current_level:
		0: _draw_prologue(sky_color, ground_color)
		1: _draw_sherlock_ch1(sky_color, ground_color)
		2: _draw_sherlock_ch2(sky_color, ground_color)
		3: _draw_sherlock_ch3(sky_color, ground_color)
		4: _draw_merlin_ch1(sky_color, ground_color)
		5: _draw_merlin_ch2(sky_color, ground_color)
		6: _draw_merlin_ch3(sky_color, ground_color)
		7: _draw_tarzan_ch1(sky_color, ground_color)
		8: _draw_tarzan_ch2(sky_color, ground_color)
		9: _draw_tarzan_ch3(sky_color, ground_color)
		10: _draw_dracula_ch1(sky_color, ground_color)
		11: _draw_dracula_ch2(sky_color, ground_color)
		12: _draw_dracula_ch3(sky_color, ground_color)
		13: _draw_frankenstein_ch1(sky_color, ground_color)
		14: _draw_frankenstein_ch2(sky_color, ground_color)
		15: _draw_frankenstein_ch3(sky_color, ground_color)
		16: _draw_robin_ch1(sky_color, ground_color)
		17: _draw_robin_ch2(sky_color, ground_color)
		18: _draw_robin_ch3(sky_color, ground_color)
		19: _draw_alice_ch1(sky_color, ground_color)
		20: _draw_alice_ch2(sky_color, ground_color)
		21: _draw_alice_ch3(sky_color, ground_color)
		22: _draw_oz_ch1(sky_color, ground_color)
		23: _draw_oz_ch2(sky_color, ground_color)
		24: _draw_oz_ch3(sky_color, ground_color)
		25: _draw_peter_ch1(sky_color, ground_color)
		26: _draw_peter_ch2(sky_color, ground_color)
		27: _draw_peter_ch3(sky_color, ground_color)
		28: _draw_phantom_ch1(sky_color, ground_color)
		29: _draw_phantom_ch2(sky_color, ground_color)
		30: _draw_phantom_ch3(sky_color, ground_color)
		31: _draw_scrooge_ch1(sky_color, ground_color)
		32: _draw_scrooge_ch2(sky_color, ground_color)
		33: _draw_scrooge_ch3(sky_color, ground_color)
		34: _draw_shadow_author_ch1(sky_color, ground_color)
		35: _draw_shadow_author_ch2(sky_color, ground_color)
		36: _draw_shadow_author_ch3(sky_color, ground_color)

	# Apply screen shake
	if _screen_shake_timer > 0.0:
		draw_set_transform(_screen_shake_offset, 0.0, Vector2.ONE)

	# === ENVIRONMENTAL PARTICLES ===
	if _env_particles.size() > 0:
		var env_theme = levels[current_level].get("character", 0) if current_level >= 0 and current_level < levels.size() else 0
		for ep in _env_particles:
			var ep_pos = Vector2(ep["x"], ep["y"])
			var ep_s = ep["size"]
			var ep_a = 0.2 + sin(_time * ep["freq"] + ep["phase"]) * 0.1
			match env_theme:
				0: draw_circle(ep_pos, ep_s, Color(0.3, 0.7, 0.2, ep_a))  # Robin Hood: green leaves
				1: draw_circle(ep_pos, ep_s * 0.8, Color(0.6, 0.3, 0.8, ep_a))  # Alice: purple sparkle
				2: draw_circle(ep_pos, ep_s * 0.7, Color(0.4, 0.9, 0.2, ep_a * 0.8))  # Witch: green motes
				3: draw_circle(ep_pos, ep_s * 0.6, Color(1.0, 0.88, 0.3, ep_a))  # Peter Pan: pixie dust
				4: draw_circle(ep_pos, ep_s, Color(0.5, 0.5, 0.5, ep_a * 0.7))  # Phantom: grey dust
				5: # Scrooge: white snowflakes
					draw_circle(ep_pos, ep_s * 0.7, Color(0.9, 0.92, 1.0, ep_a))
					draw_line(ep_pos - Vector2(ep_s, 0), ep_pos + Vector2(ep_s, 0), Color(0.9, 0.92, 1.0, ep_a * 0.5), 0.8)
					draw_line(ep_pos - Vector2(0, ep_s), ep_pos + Vector2(0, ep_s), Color(0.9, 0.92, 1.0, ep_a * 0.5), 0.8)
				6: draw_circle(ep_pos, ep_s, Color(0.1, 0.05, 0.15, ep_a * 0.8))  # Shadow Author: ink drops
				7: draw_circle(ep_pos, ep_s * 1.2, Color(0.6, 0.6, 0.6, ep_a * 0.4))  # Sherlock: fog wisps
				8: draw_circle(ep_pos, ep_s * 0.6, Color(0.3, 0.5, 1.0, ep_a))  # Merlin: arcane sparks
				9: # Tarzan: fireflies
					var ff = 0.3 + sin(_time * 3.0 + ep["phase"]) * 0.3
					draw_circle(ep_pos, ep_s * 0.5, Color(0.8, 0.9, 0.2, ff))
					draw_circle(ep_pos, ep_s * 1.2, Color(0.7, 0.8, 0.1, ff * 0.2))
				10: draw_circle(ep_pos, ep_s * 0.8, Color(0.5, 0.02, 0.02, ep_a * 0.7))  # Dracula: dark red motes
				11: # Frankenstein: electric sparks
					var fk = 0.3 + sin(_time * 6.0 + ep["phase"]) * 0.25
					draw_circle(ep_pos, ep_s * 0.5, Color(0.4, 0.7, 1.0, fk))
				_: draw_circle(ep_pos, ep_s, Color(0.5, 0.5, 0.5, ep_a * 0.5))

	# === Universal path overlay with direction arrows ===
	_draw_path_overlay()

	# === Draw placed Literary Instruments ===
	_draw_placed_instruments()

	# === Ghost tower preview (shared) ===
	if placing_tower:
		var valid = _is_valid_placement(ghost_position)
		var color = Color(0.2, 0.8, 0.2, 0.35) if valid else Color(0.9, 0.2, 0.2, 0.35)
		draw_circle(ghost_position, 24.0, color)
		if valid:
			var preview_range = tower_info[selected_tower]["range"]
			draw_arc(ghost_position, preview_range, 0, TAU, 64, Color(1, 1, 1, 0.12), 4.0)
			draw_arc(ghost_position, preview_range, 0, TAU, 64, Color(1, 1, 1, 0.3), 2.0)

	# === Cache tower group query for all tower overlays ===
	var _cached_towers = get_tree().get_nodes_in_group("towers")

	# === BUILD EFFECTS (collapsing golden ring + sparkles) ===
	for be in _build_effects:
		var be_t = 1.0 - clampf(be["timer"] / be["max_timer"], 0.0, 1.0)
		var be_alpha = 1.0 - be_t
		var be_r = 40.0 * (1.0 - be_t) + 10.0
		draw_arc(be["pos"], be_r, 0, TAU, 32, Color(1.0, 0.85, 0.2, be_alpha * 0.6), 2.5)
		# 6 orbiting sparkles
		for si in range(6):
			var sa = _time * 8.0 + float(si) * TAU / 6.0
			var sr = be_r * 0.8
			var sp = be["pos"] + Vector2(cos(sa), sin(sa)) * sr
			draw_circle(sp, 2.0 * be_alpha, Color(1.0, 0.95, 0.5, be_alpha * 0.7))

	# === Pulsing gold indicators on affordable-to-upgrade towers ===
	for tower in _cached_towers:
		if tower.upgrade_tier < 4 and tower.has_method("get_next_upgrade_info"):
			var info = tower.get_next_upgrade_info()
			if not info.is_empty() and gold >= info["cost"]:
				var pulse = (sin(_time * 4.0) + 1.0) * 0.5
				var dot_pos = tower.global_position + Vector2(0, -48)
				draw_circle(dot_pos, 6.0 + pulse * 3.0, Color(1.0, 0.84, 0.0, 0.6 + pulse * 0.3))
				draw_circle(dot_pos, 12.0 + pulse * 4.0, Color(1.0, 0.84, 0.0, 0.15 + pulse * 0.1))

	# === SYNERGY GLOW RINGS ON TOWERS ===
	if active_synergies.size() > 0:
		for tower in _cached_towers:
			if tower.has_method("has_synergy_buff") and tower.has_synergy_buff():
				var pulse = (sin(_time * 3.0) + 1.0) * 0.5
				draw_arc(tower.global_position, 30.0 + pulse * 5.0, 0, TAU, 32, Color(1.0, 0.84, 0.0, 0.25 + pulse * 0.2), 2.5)
				draw_arc(tower.global_position, 36.0 + pulse * 5.0, 0, TAU, 32, Color(1.0, 0.84, 0.0, 0.15 + pulse * 0.1), 1.5)

	# === SELECTED TOWER HIGHLIGHT & RANGE ===
	if selected_tower_node and is_instance_valid(selected_tower_node) and not placing_tower:
		var sel_pos = selected_tower_node.global_position
		var sel_pulse = (sin(_time * 4.0) + 1.0) * 0.5
		# Bright selection ring
		draw_arc(sel_pos, 22.0, 0, TAU, 32, Color(1.0, 1.0, 1.0, 0.5 + sel_pulse * 0.3), 2.5)
		draw_arc(sel_pos, 26.0, 0, TAU, 32, Color(1.0, 0.9, 0.5, 0.15 + sel_pulse * 0.1), 1.5)
		# Range indicator
		if selected_tower_node.has_method("get_attack_range"):
			var sel_range = selected_tower_node.get_attack_range()
			draw_arc(sel_pos, sel_range, 0, TAU, 64, Color(1, 1, 1, 0.08 + sel_pulse * 0.06), 3.0)
			draw_arc(sel_pos, sel_range, 0, TAU, 64, Color(1, 1, 1, 0.2 + sel_pulse * 0.1), 1.5)
		# === TARGETING LINE TO CURRENT TARGET ===
		if "target" in selected_tower_node and is_instance_valid(selected_tower_node.target):
			var tgt_pos = selected_tower_node.target.global_position
			var line_dir = (tgt_pos - sel_pos).normalized()
			var line_len = sel_pos.distance_to(tgt_pos)
			var dash_len = 8.0
			var gap_len = 6.0
			var scroll = fmod(_time * 60.0, dash_len + gap_len)
			var d = scroll
			var tgt_col = Color(1.0, 0.85, 0.3, 0.25 + sel_pulse * 0.15)
			while d < line_len:
				var seg_start = sel_pos + line_dir * d
				var seg_end = sel_pos + line_dir * minf(d + dash_len, line_len)
				draw_line(seg_start, seg_end, tgt_col, 1.5)
				d += dash_len + gap_len
			# Crosshair reticle on target
			var reticle_r = 10.0 + sel_pulse * 3.0
			draw_arc(tgt_pos, reticle_r, 0, TAU, 24, Color(1.0, 0.85, 0.3, 0.35), 1.5)
			for ti in range(4):
				var ta = float(ti) * PI / 2.0
				var tick_from = tgt_pos + Vector2(cos(ta), sin(ta)) * (reticle_r - 3.0)
				var tick_to = tgt_pos + Vector2(cos(ta), sin(ta)) * (reticle_r + 4.0)
				draw_line(tick_from, tick_to, Color(1.0, 0.85, 0.3, 0.4), 1.5)

	# === TOWER AURA COSMETICS ===
	var equipped_aura = equipped_cosmetics.get("auras", "")
	if equipped_aura != "":
		var aura_col = Color(0.5, 0.5, 0.5, 0.2)
		for cat_items in trophy_store_items.get("auras", []):
			if cat_items["id"] == equipped_aura:
				if equipped_aura == "aura_prismatic":
					aura_col = Color.from_hsv(fmod(_time * 0.4, 1.0), 0.6, 0.9, 0.25)
				else:
					aura_col = cat_items["color"]
				break
		for tower in _cached_towers:
			var aura_pulse = (sin(_time * 2.0 + tower.global_position.x * 0.01) + 1.0) * 0.5
			draw_arc(tower.global_position, 26.0 + aura_pulse * 4.0, 0, TAU, 32, aura_col, 2.5)

	# === BOSS RESCUE ANIMATION ===
	_draw_boss_rescue()

	# === STORYBOOK SHIELD INDICATOR ===
	if storybook_shield_charges > 0:
		var font = game_font
		_udraw(font, Vector2(700, 35), "Shield: %d" % storybook_shield_charges, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.3, 0.7, 0.9))

	# === ENCHANTED TOWERS INDICATOR ===
	if power_enchanted_timer > 0.0:
		var font = game_font
		_udraw(font, Vector2(820, 35), "Enchanted: %.0fs" % power_enchanted_timer, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1))

	# === SYNERGY BANNER ===
	if synergy_banner_timer > 0.0:
		var font = game_font
		var s_alpha = clampf(synergy_banner_timer, 0.0, 1.0)
		draw_rect(Rect2(240, 55, 800, 30), Color(0.1, 0.06, 0.02, 0.8 * s_alpha))
		draw_rect(Rect2(240, 55, 800, 30), Color(0.85, 0.65, 0.1, 0.5 * s_alpha), false, 1.0)
		_udraw(font, Vector2(640, 76), synergy_banner_text, HORIZONTAL_ALIGNMENT_CENTER, 780, 16, Color(1.0, 0.9, 0.5, s_alpha))

	# === ACHIEVEMENT POPUP ===
	if achievement_popup_timer > 0.0:
		var font = game_font
		var a_alpha = clampf(achievement_popup_timer, 0.0, 1.0)
		var a_y = 90.0
		draw_rect(Rect2(340, a_y, 600, 40), Color(0.08, 0.12, 0.04, 0.85 * a_alpha))
		draw_rect(Rect2(340, a_y, 600, 40), Color(0.4, 0.8, 0.2, 0.5 * a_alpha), false, 1.0)
		_udraw(font, Vector2(640, a_y + 17), achievement_popup_text, HORIZONTAL_ALIGNMENT_CENTER, 580, 14, Color(0.85, 0.75, 0.4, a_alpha))
		_udraw(font, Vector2(640, a_y + 33), achievement_popup_reward, HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.5, 0.8, 0.3, a_alpha))

	# === ODYSSEY PROGRESS INDICATOR ===
	if odyssey_active:
		var font = game_font
		_udraw(font, Vector2(580, 35), "ODYSSEY %d/3" % (odyssey_current_map + 1), HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.7, 0.5, 0.9))

	# === ODYSSEY TRANSITION OVERLAY ===
	if odyssey_transition_active:
		var font = game_font
		draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.7))
		_udraw(font, Vector2(640, 340), "ODYSSEY — Next Map in %.0fs..." % odyssey_transition_timer, HORIZONTAL_ALIGNMENT_CENTER, -1, 24, Color(0.85, 0.7, 0.2))
		if odyssey_current_map < odyssey_maps.size():
			var next_name = levels[odyssey_maps[odyssey_current_map]]["name"] if odyssey_maps[odyssey_current_map] < levels.size() else "?"
			_udraw(font, Vector2(640, 380), next_name, HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.7, 0.6, 0.4))

	# === POWER SELECTION OVERLAY ===
	if power_selection_open:
		_draw_power_selection()

	# === VICTORY FANFARE COSMETICS ===
	if chest_open:
		var fanfare = equipped_cosmetics.get("fanfares", "")
		if fanfare == "fanfare_confetti":
			for ci in range(40):
				var cx = fmod(ci * 97.0 + _time * (80.0 + ci * 3.0), 1280.0)
				var cy = fmod(ci * 53.0 + _time * (60.0 + ci * 2.0), 720.0)
				var cc = Color.from_hsv(fmod(float(ci) * 0.07, 1.0), 0.8, 0.95, 0.7)
				draw_rect(Rect2(cx, cy, 6, 4), cc)
		elif fanfare == "fanfare_fireworks":
			for fi in range(6):
				var fx = 200.0 + fi * 170.0
				var fy = 120.0 + sin(_time * 1.5 + fi) * 60.0
				var burst_t = fmod(_time * 0.8 + fi * 0.5, 2.0)
				if burst_t < 1.2:
					var fc = Color.from_hsv(fmod(float(fi) * 0.15, 1.0), 0.7, 1.0, clampf(1.2 - burst_t, 0.0, 1.0))
					for ri in range(12):
						var ra = TAU * float(ri) / 12.0
						var rd = burst_t * 60.0
						draw_circle(Vector2(fx + cos(ra) * rd, fy + sin(ra) * rd), 3.0, fc)
		elif fanfare == "fanfare_ovation":
			var font = game_font
			var clap_alpha = 0.5 + sin(_time * 6.0) * 0.3
			_udraw(font, Vector2(640, 250), "BRAVO!", HORIZONTAL_ALIGNMENT_CENTER, -1, 32, Color(1.0, 0.85, 0.3, clap_alpha))
			for oi in range(8):
				var ox = 100.0 + oi * 140.0
				var oy = 680.0 + sin(_time * 4.0 + oi * 0.8) * 8.0
				draw_circle(Vector2(ox, oy), 10.0, Color(0.8, 0.6, 0.4, 0.5))
				draw_circle(Vector2(ox, oy - 15), 7.0, Color(0.9, 0.7, 0.5, 0.5))

	# Reset transform (screen shake should not affect UI overlays)
	if _screen_shake_timer > 0.0:
		draw_set_transform(Vector2.ZERO, 0.0, Vector2.ONE)

	# === FLOATING DAMAGE TEXTS ===
	# BATTD2: Path traps
	_draw_path_traps()
	# BATTD2: Path events
	_draw_path_events()
	# BATTD2: Character bonds
	_draw_character_bonds()
	# BATTD2: Tower XP bars
	_draw_tower_xp_bars()
	# BATTD2: Overcharge effect
	_draw_overcharge_effect()
	# BATTD2: Storybook page
	_draw_storybook_page()
	# BATTD2: Enemy intel
	_draw_enemy_intel()
	# BATTD2: Blessing indicator
	_draw_blessing_indicator()
	# BATTD: Boss health bar
	_update_boss_health_bar()
	_draw_boss_health_bar()
	# BATTD: Kill counter
	_draw_kill_counter()
	# BATTD: Income breakdown
	if _income_display_timer > 0.0:
		_draw_income_breakdown()
	# BATTD: Synergy auras
	_draw_synergy_auras()
	# BATTD: Tower buff icons
	_draw_tower_buff_icons()
	# BATTD: Map collectibles
	_draw_map_collectibles()
	# BATTD: Bounty board
	_draw_bounty_board()
	if _floating_texts.size() > 0:
		var ft_font = game_font
		for ft in _floating_texts:
			var ft_alpha = clampf(ft["timer"] / ft["duration"], 0.0, 1.0)
			var ft_col = ft["color"]
			ft_col.a *= ft_alpha
			# Drop shadow for readability
			var shadow_col = Color(0.0, 0.0, 0.0, ft_alpha * 0.7)
			draw_string(ft_font, ft["pos"] + Vector2(1, 2), ft["text"].to_upper(), HORIZONTAL_ALIGNMENT_CENTER, -1, int(ft["size"]), shadow_col)
			draw_string(ft_font, ft["pos"], ft["text"].to_upper(), HORIZONTAL_ALIGNMENT_CENTER, -1, int(ft["size"]), ft_col)

	# === GOLD COIN PICKUP ARCS ===
	for gp in _gold_pickups:
		var gp_t = 1.0 - clampf(gp["timer"] / gp["max_timer"], 0.0, 1.0)
		var gp_alpha = 1.0 - gp_t * 0.5
		var gp_spin = gp["spin"] + gp_t * 12.0
		var gp_scale = abs(cos(gp_spin)) * 0.5 + 0.5
		var gp_r = 3.0 * gp_scale + 1.0
		# Spinning coin
		draw_circle(gp["pos"], gp_r, Color(0.85, 0.72, 0.2, gp_alpha))
		draw_circle(gp["pos"] + Vector2(-0.5, -0.5), gp_r * 0.5, Color(1.0, 0.92, 0.4, gp_alpha * 0.5))
		draw_arc(gp["pos"], gp_r, 0, TAU, 8, Color(0.7, 0.58, 0.12, gp_alpha * 0.6), 0.8)

	# === INK SPLATTERS ===
	for sp in _ink_splatters:
		var sp_alpha = clampf(sp["timer"] / 1.2, 0.0, 1.0)
		var sp_col = sp["color"]
		sp_col.a *= sp_alpha
		draw_circle(sp["pos"], sp["radius"], sp_col)

	# === AOE IMPACT CIRCLES ===
	for aoe in _aoe_impacts:
		var aoe_t = 1.0 - clampf(aoe["timer"] / aoe["max_timer"], 0.0, 1.0)
		var aoe_alpha = (1.0 - aoe_t) * 0.6
		var aoe_r = aoe["radius"] * (0.5 + aoe_t * 0.8)
		var aoe_col = aoe["color"]
		draw_arc(aoe["pos"], aoe_r, 0, TAU, 32, Color(aoe_col.r, aoe_col.g, aoe_col.b, aoe_alpha), 2.5)
		draw_arc(aoe["pos"], aoe_r * 0.7, 0, TAU, 24, Color(aoe_col.r, aoe_col.g, aoe_col.b, aoe_alpha * 0.5), 1.5)

	# === CRITICAL HIT FLASHES ===
	for crit in _crit_flashes:
		var crit_t = 1.0 - clampf(crit["timer"] / crit["max_timer"], 0.0, 1.0)
		var crit_alpha = (1.0 - crit_t) * 0.9
		var crit_r = 8.0 + crit_t * 16.0
		var crit_center_r = 4.0 * (1.0 - crit_t)
		var cp = crit["pos"]
		# 4-pointed star burst
		for si in range(4):
			var sa = float(si) * PI / 2.0 + PI / 4.0
			draw_line(cp, cp + Vector2(cos(sa), sin(sa)) * crit_r, Color(1.0, 0.95, 0.6, crit_alpha), 2.0)
		# Shrinking center circle
		draw_circle(cp, crit_center_r, Color(1.0, 1.0, 0.8, crit_alpha))

	# === LIFE LOSS FLASH (red screen flash) ===
	if _death_flash_timer > 0.0:
		var flash_a = clampf(_death_flash_timer / 0.15, 0.0, 1.0) * 0.5
		draw_rect(Rect2(0, 0, 1280, 720), Color(0.9, 0.1, 0.05, flash_a))
		# Red border vignette — thicker, more dramatic
		for bi in range(3):
			var b_alpha = flash_a * (0.8 - float(bi) * 0.2)
			var b_thick = 4.0 + float(bi) * 6.0
			draw_rect(Rect2(0, 0, 1280, b_thick), Color(1.0, 0.0, 0.0, b_alpha))
			draw_rect(Rect2(0, 720 - b_thick, 1280, b_thick), Color(1.0, 0.0, 0.0, b_alpha))
			draw_rect(Rect2(0, 0, b_thick, 720), Color(1.0, 0.0, 0.0, b_alpha))
			draw_rect(Rect2(1280 - b_thick, 0, b_thick, 720), Color(1.0, 0.0, 0.0, b_alpha))

	# === WAVE CLEAR POPUP (with glow) ===
	if _wave_clear_timer > 0.0 and not victory_chest_active:
		var wc_alpha = clampf(_wave_clear_timer / 1.5, 0.0, 1.0)
		var wc_slide = (1.0 - wc_alpha) * 30.0
		var font = game_font
		var wc_text = "WAVE %d CLEAR!" % _wave_clear_num
		var wc_y = 280 - wc_slide
		# Expanding burst particles
		var burst_progress = 1.0 - wc_alpha
		for pi in range(8):
			var p_angle = float(pi) * TAU / 8.0
			var p_dist = burst_progress * 160.0
			var p_pos = Vector2(640 + cos(p_angle) * p_dist, wc_y - 6 + sin(p_angle) * p_dist * 0.5)
			draw_circle(p_pos, (4.0 - burst_progress * 3.0) * wc_alpha, Color(0.4, 1.0, 0.5, wc_alpha * 0.5))
		# Glow backdrop — larger and brighter
		draw_circle(Vector2(640, wc_y - 6), 160.0, Color(0.2, 0.9, 0.3, wc_alpha * 0.12))
		draw_circle(Vector2(640, wc_y - 6), 80.0, Color(0.3, 1.0, 0.4, wc_alpha * 0.18))
		# Shadow text
		_udraw(font, Vector2(642, wc_y + 2), wc_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 40, Color(0, 0, 0, wc_alpha * 0.6))
		# Main text — bigger, bright green
		_udraw(font, Vector2(640, wc_y), wc_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 40, Color(0.3, 1.0, 0.4, wc_alpha))

	# === WAVE NUMBER BANNER ===
	if _wave_banner_timer > 0.0 and not victory_chest_active:
		var wb_alpha = clampf(_wave_banner_timer / 2.5, 0.0, 1.0)
		# Slide in from left (first 0.3s), linger, slide out right (last 0.3s)
		var wb_x_offset = 0.0
		if _wave_banner_timer > 2.2:
			wb_x_offset = -(2.5 - _wave_banner_timer) / 0.3 * 1280.0 + 1280.0
			wb_x_offset = -wb_x_offset
		elif _wave_banner_timer < 0.3:
			wb_x_offset = (0.3 - _wave_banner_timer) / 0.3 * 1280.0
		var wb_y = 180.0
		# Bounce effect on wave number
		var wb_bounce = 0.0
		if _wave_banner_timer > 2.0:
			var bt2 = (2.5 - _wave_banner_timer) / 0.5
			wb_bounce = sin(bt2 * PI) * 8.0
		var wb_col = Color(0.9, 0.15, 0.1) if _wave_banner_is_boss else Color(1.0, 0.85, 0.2)
		var wb_border_col = Color(0.7, 0.1, 0.05) if _wave_banner_is_boss else Color(0.8, 0.65, 0.1)
		# Dark translucent backdrop bar
		draw_rect(Rect2(wb_x_offset, wb_y - 20, 1280, 55), Color(0.0, 0.0, 0.0, wb_alpha * 0.65))
		# Gold/red borders
		draw_rect(Rect2(wb_x_offset, wb_y - 20, 1280, 3), Color(wb_border_col.r, wb_border_col.g, wb_border_col.b, wb_alpha * 0.8))
		draw_rect(Rect2(wb_x_offset, wb_y + 32, 1280, 3), Color(wb_border_col.r, wb_border_col.g, wb_border_col.b, wb_alpha * 0.8))
		# Wave number text with bounce
		var wb_text = "WAVE %d" % _wave_banner_num
		var font = game_font
		_udraw(font, Vector2(640 + wb_x_offset + 1, wb_y + 2 - wb_bounce), wb_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 32, Color(0, 0, 0, wb_alpha * 0.5))
		_udraw(font, Vector2(640 + wb_x_offset, wb_y - wb_bounce), wb_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 32, Color(wb_col.r, wb_col.g, wb_col.b, wb_alpha))
		# Subtitle wave name
		_udraw(font, Vector2(640 + wb_x_offset, wb_y + 22), _wave_banner_name, HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(0.8, 0.8, 0.8, wb_alpha * 0.6))

	# === BOSS WAVE ALERT (with glow) ===
	if _boss_alert_timer > 0.0:
		var ba_alpha = clampf(_boss_alert_timer / 2.5, 0.0, 1.0)
		var ba_scale = 1.0 + (1.0 - ba_alpha) * 0.3
		# Dark vignette
		draw_rect(Rect2(0, 240, 1280, 120), Color(0.0, 0.0, 0.0, ba_alpha * 0.7))
		# Red glow behind text
		draw_circle(Vector2(640, 305), 180.0, Color(0.9, 0.1, 0.05, ba_alpha * 0.08))
		draw_circle(Vector2(640, 305), 90.0, Color(1.0, 0.15, 0.05, ba_alpha * 0.12))
		# Red border flash — thicker
		draw_rect(Rect2(0, 240, 1280, 4), Color(0.9, 0.15, 0.1, ba_alpha * 0.9))
		draw_rect(Rect2(0, 356, 1280, 4), Color(0.9, 0.15, 0.1, ba_alpha * 0.9))
		# Alert text with shadow
		var font = game_font
		var alert_size = int(44.0 * ba_scale)
		_udraw(font, Vector2(642, 312), _boss_alert_text, HORIZONTAL_ALIGNMENT_CENTER, -1, alert_size, Color(0, 0, 0, ba_alpha * 0.5))
		_udraw(font, Vector2(640, 310), _boss_alert_text, HORIZONTAL_ALIGNMENT_CENTER, -1, alert_size, Color(1.0, 0.2, 0.1, ba_alpha))
		# Subtitle — larger for mobile
		_udraw(font, Vector2(640, 344), "Prepare your defenses!", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(1.0, 0.7, 0.5, ba_alpha * 0.8))

	# === COMBO KILL HUD ===
	if combo_count >= COMBO_MIN and combo_timer > 0.0:
		var combo_pulse = (sin(_time * 6.0) + 1.0) * 0.5
		var combo_alpha = clampf(combo_timer / COMBO_WINDOW, 0.0, 1.0)
		var combo_size = 24 + int(combo_pulse * 4.0) + mini(combo_count - COMBO_MIN, 10) * 2
		var combo_text = "COMBO x%d" % combo_count
		var combo_color = Color(1.0, 0.5 + combo_pulse * 0.3, 0.1, combo_alpha)
		# Glow
		draw_circle(Vector2(640, 80), 60.0 + combo_pulse * 10.0, Color(1.0, 0.4, 0.1, combo_alpha * 0.08))
		_udraw(game_font, Vector2(642, 82), combo_text, HORIZONTAL_ALIGNMENT_CENTER, -1, combo_size, Color(0, 0, 0, combo_alpha * 0.5))
		_udraw(game_font, Vector2(640, 80), combo_text, HORIZONTAL_ALIGNMENT_CENTER, -1, combo_size, combo_color)

	# === TOWER STATS OVERLAY ===
	if selected_tower_node and is_instance_valid(selected_tower_node) and not placing_tower:
		_draw_tower_stats_overlay()

	# === WAVE PREVIEW PANEL ===
	if wave_preview_active and not is_wave_active:
		_draw_wave_preview()

	# === ENDLESS MUTATION BANNER ===
	if endless_mode and endless_mutation != "":
		var mut_pulse = (sin(_time * 2.0) + 1.0) * 0.5
		var mut_color = Color(0.8, 0.2, 0.1, 0.7 + mut_pulse * 0.2)
		_udraw(game_font, Vector2(640, 52), "MUTATION: " + endless_mutation.to_upper(), HORIZONTAL_ALIGNMENT_CENTER, -1, 13, mut_color)

	# === BOSS RUSH WAVE INDICATOR ===
	if boss_rush_mode:
		_udraw(game_font, Vector2(640, 52), "BOSS RUSH — WAVE %d/10" % boss_rush_wave, HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(1.0, 0.3, 0.2, 0.9))

	# === PAUSED OVERLAY (gothic themed) ===
	if game_paused:
		# Dark translucent backdrop
		draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.55))
		# Dim pulsing vignette edges
		var pv_pulse = 0.15 + sin(_time * 1.5) * 0.05
		for pvi in range(4):
			var pv_thick = 20.0 + float(pvi) * 15.0
			var pv_a = pv_pulse * (0.4 - float(pvi) * 0.08)
			draw_rect(Rect2(0, 0, 1280, pv_thick), Color(0.05, 0.0, 0.08, pv_a))
			draw_rect(Rect2(0, 720 - pv_thick, 1280, pv_thick), Color(0.05, 0.0, 0.08, pv_a))
			draw_rect(Rect2(0, 0, pv_thick, 720), Color(0.05, 0.0, 0.08, pv_a))
			draw_rect(Rect2(1280 - pv_thick, 0, pv_thick, 720), Color(0.05, 0.0, 0.08, pv_a))
		# Centered panel with crimson+gold double border (gothic style)
		var pp_x = 390.0
		var pp_y = 240.0
		var pp_w = 500.0
		var pp_h = 240.0
		# Crimson outer border
		draw_rect(Rect2(pp_x - 3, pp_y - 3, pp_w + 6, pp_h + 6), Color(0.6, 0.1, 0.08, 0.8))
		# Gold inner border
		draw_rect(Rect2(pp_x - 1, pp_y - 1, pp_w + 2, pp_h + 2), Color(0.8, 0.65, 0.2, 0.7))
		# Dark panel fill
		draw_rect(Rect2(pp_x, pp_y, pp_w, pp_h), Color(0.04, 0.02, 0.06, 0.95))
		# "PAUSED" title in large gold text
		var font = game_font
		var pause_pulse = 0.85 + sin(_time * 2.0) * 0.1
		_udraw(font, Vector2(642, 302), "PAUSED", HORIZONTAL_ALIGNMENT_CENTER, -1, 48, Color(0, 0, 0, 0.5))
		_udraw(font, Vector2(640, 300), "PAUSED", HORIZONTAL_ALIGNMENT_CENTER, -1, 48, Color(1.0, 0.85, 0.2, pause_pulse))
		# Corner ornaments (small L-brackets)
		for ci in range(4):
			var cx = pp_x if ci % 2 == 0 else pp_x + pp_w
			var cy = pp_y if ci < 2 else pp_y + pp_h
			var cdx = 1.0 if ci % 2 == 0 else -1.0
			var cdy = 1.0 if ci < 2 else -1.0
			draw_line(Vector2(cx, cy), Vector2(cx + 15 * cdx, cy), Color(0.8, 0.65, 0.2, 0.6), 1.5)
			draw_line(Vector2(cx, cy), Vector2(cx, cy + 15 * cdy), Color(0.8, 0.65, 0.2, 0.6), 1.5)
		# Resume button area (drawn as highlight)
		var rb_y = 340.0
		draw_rect(Rect2(pp_x + 100, rb_y, pp_w - 200, 32), Color(0.15, 0.08, 0.2, 0.6))
		draw_rect(Rect2(pp_x + 100, rb_y, pp_w - 200, 32), Color(0.6, 0.1, 0.08, 0.4))
		_udraw(font, Vector2(640, rb_y + 22), "Resume", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.9, 0.85, 0.7, 0.9))
		# Quit to Menu button area
		var qb_y = 388.0
		draw_rect(Rect2(pp_x + 100, qb_y, pp_w - 200, 32), Color(0.15, 0.08, 0.2, 0.4))
		_udraw(font, Vector2(640, qb_y + 22), "Quit to Menu", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.7, 0.65, 0.6, 0.7))
		# Instructions
		_udraw(font, Vector2(640, 448), "%s or press Start Wave to continue" % _get_action_text(), HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(0.6, 0.6, 0.6, 0.5))

	# === ABILITY UNLOCK POPUP ===
	if _ability_popup_timer > 0.0:
		_draw_ability_popup()

	# === INSTRUMENT PLACEMENT HUD ===
	_draw_instrument_hud()

	# === BRANCH UPGRADE DISPLAY (on selected tower with tier 4) ===
	if selected_tower_node and is_instance_valid(selected_tower_node) and upgrade_panel.visible:
		_draw_branch_upgrade_panel()

	# === VICTORY BURST EFFECT ===
	if _victory_burst_timer > 0.0:
		var vb_t = 1.0 - clampf(_victory_burst_timer / 2.0, 0.0, 1.0)
		var vb_alpha = clampf(_victory_burst_timer / 2.0, 0.0, 1.0)
		# 3 expanding golden rings
		for ri in range(3):
			var ring_r = (vb_t * 300.0 + float(ri) * 60.0)
			var ring_alpha = vb_alpha * (0.3 - float(ri) * 0.08)
			draw_arc(Vector2(640, 360), ring_r, 0, TAU, 48, Color(1.0, 0.85, 0.2, ring_alpha), 3.0 - float(ri) * 0.5)
		# Warm vignette
		if vb_alpha > 0.3:
			draw_rect(Rect2(0, 0, 1280, 720), Color(1.0, 0.9, 0.5, vb_alpha * 0.08))
		# Star-shaped particles
		for vp in _victory_particles:
			if vp["timer"] > 0.0:
				var vp_alpha = clampf(vp["timer"] / 1.5, 0.0, 1.0)
				var vp_col = Color(1.0, 0.85 + randf() * 0.15, 0.2, vp_alpha * 0.8)
				var vp_pos = vp["pos"]
				# 4-line cross (star shape)
				for si in range(4):
					var sa = float(si) * PI / 2.0
					draw_line(vp_pos, vp_pos + Vector2(cos(sa), sin(sa)) * vp["size"], vp_col, 1.5)

	# === DEFEAT DRAMATIC EFFECT ===
	if _defeat_timer > 0.0:
		var df_t = 1.0 - clampf(_defeat_timer / 3.0, 0.0, 1.0)
		var df_alpha = clampf(df_t * 1.5, 0.0, 1.0)
		# Progressive edge vignette (5 darkening layers)
		for di in range(5):
			var d_thick = (8.0 + float(di) * 12.0) * df_alpha
			var d_a = df_alpha * (0.15 + float(di) * 0.06)
			draw_rect(Rect2(0, 0, 1280, d_thick), Color(0, 0, 0, d_a))
			draw_rect(Rect2(0, 720 - d_thick, 1280, d_thick), Color(0, 0, 0, d_a))
			draw_rect(Rect2(0, 0, d_thick, 720), Color(0, 0, 0, d_a))
			draw_rect(Rect2(1280 - d_thick, 0, d_thick, 720), Color(0, 0, 0, d_a))
		# Animated crack lines (appear sequentially)
		for ci in range(_defeat_cracks.size()):
			var crack_reveal = clampf(df_t * 10.0 - float(ci) * 0.8, 0.0, 1.0)
			if crack_reveal > 0.0:
				var c = _defeat_cracks[ci]
				var c_end = c["from"] + (c["to"] - c["from"]) * crack_reveal
				draw_line(c["from"], c_end, Color(0.15, 0.05, 0.05, df_alpha * 0.7), 2.0)
				draw_line(c["from"], c_end, Color(0.5, 0.1, 0.05, df_alpha * 0.3), 1.0)
		# Red ink drip streaks from top
		for di in range(8):
			var dx = 80.0 + float(di) * 145.0
			var drip_len = df_alpha * (60.0 + float(di % 3) * 30.0)
			draw_line(Vector2(dx, 0), Vector2(dx, drip_len), Color(0.6, 0.05, 0.02, df_alpha * 0.4), 3.0)
			draw_circle(Vector2(dx, drip_len), 2.5, Color(0.6, 0.05, 0.02, df_alpha * 0.5))

	# === VICTORY CHEST OVERLAY (draws over everything in GAME_OVER too) ===
	if chest_opening_active and victory_chest_active:
		_draw_chest_opening()
	# Story dialog in GAME_OVER state
	if story_state.active:
		_draw_story_dialog()

func _draw_ability_popup() -> void:
	var alpha = clampf(_ability_popup_timer, 0.0, 1.0)
	var cx = 640.0
	var cy = 360.0
	var pw = 500.0
	var ph = 120.0
	# Dark translucent background
	draw_rect(Rect2(cx - pw / 2, cy - ph / 2, pw, ph), Color(0.05, 0.03, 0.08, 0.85 * alpha))
	# Gold ornate border
	draw_rect(Rect2(cx - pw / 2, cy - ph / 2, pw, ph), Color(0.85, 0.7, 0.2, 0.9 * alpha), false, 3.0)
	draw_rect(Rect2(cx - pw / 2 + 4, cy - ph / 2 + 4, pw - 8, ph - 8), Color(0.7, 0.55, 0.15, 0.4 * alpha), false, 1.0)
	# Title
	_udraw(game_font, Vector2(cx - 120, cy - 25), "NEW ABILITY UNLOCKED!", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(1.0, 0.85, 0.3, alpha))
	# Character name + ability name
	var char_name = character_names[_ability_popup_tower_type] if _ability_popup_tower_type >= 0 and _ability_popup_tower_type < character_names.size() else ""
	_udraw(game_font, Vector2(cx - 140, cy + 5), char_name + " — " + _ability_popup_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(1.0, 1.0, 0.9, alpha))
	# Description
	if _ability_popup_desc != "":
		_udraw(game_font, Vector2(cx - 140, cy + 28), _ability_popup_desc, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.8, 0.8, 0.75, alpha * 0.8))
	# Glow effect
	var glow_pulse = (sin(_time * 5.0) + 1.0) * 0.5
	draw_circle(Vector2(cx - pw / 2 + 40, cy), 15.0 + glow_pulse * 5.0, Color(1.0, 0.85, 0.3, 0.1 * alpha))

# =============================================================================
# UNIVERSAL PATH DRAWING — themed road + BTD6-style entry/exit arrows
# =============================================================================

func _draw_path_overlay() -> void:
	if not enemy_path:
		return
	var curve = enemy_path.curve
	if not curve or curve.point_count < 2:
		return
	var pts = curve.tessellate(4, 4.0)
	if pts.size() < 2:
		return

	# Determine path theme from current_level
	var path_style = _get_path_style()
	var road_w = path_style["width"]
	var road_col = path_style["road_color"]
	var edge_col = path_style["edge_color"]
	var detail_col = path_style["detail_color"]
	var border_w = path_style["border_width"]
	var shadow_col = Color(0.0, 0.0, 0.0, 0.6)
	var edge_line_col = Color(edge_col.r * 0.5, edge_col.g * 0.5, edge_col.b * 0.5, 0.5)
	var has_center = path_style.get("center_line", false)

	# --- Combined single pass: shadow + edge + road + edge lines ---
	for k in range(pts.size() - 1):
		draw_line(pts[k], pts[k + 1], shadow_col, road_w + 10.0)
		draw_line(pts[k], pts[k + 1], edge_col, road_w + 4.0)
		draw_line(pts[k], pts[k + 1], road_col, road_w)
		if has_center:
			draw_line(pts[k], pts[k + 1], detail_col, 2.0)

	# --- Edge detail lines (combined into single pass) ---
	for k in range(0, pts.size() - 1, 2):
		var dir = (pts[k + 1] - pts[k]).normalized()
		var n = Vector2(-dir.y, dir.x)
		var half_w = road_w * 0.5
		draw_line(pts[k] + n * half_w, pts[k + 1] + n * half_w, edge_line_col, border_w)
		draw_line(pts[k] - n * half_w, pts[k + 1] - n * half_w, edge_line_col, border_w)

	# --- Surface detail (cracks, bricks, cobbles, etc.) ---
	_draw_path_surface_detail(pts, path_style)

	# --- Directional arrows along path (BTD6-style) ---
	_draw_path_arrows(pts, path_style)

	# --- Path danger zone glow (last 20% glows red) ---
	if pts.size() > 2:
		# Calculate total path length
		var total_len = 0.0
		for dz_i in range(pts.size() - 1):
			total_len += pts[dz_i].distance_to(pts[dz_i + 1])
		var threshold = total_len * 0.8
		# Check if any enemy is in danger zone
		var danger_pulse_speed = 2.0
		for enemy in get_tree().get_nodes_in_group("enemies"):
			if enemy.progress_ratio > 0.8:
				danger_pulse_speed = 6.0
				break
		var danger_pulse = 0.4 + sin(_time * danger_pulse_speed) * 0.2
		# Draw danger glow on segments past threshold
		var accum_len = 0.0
		for dz_i in range(pts.size() - 1):
			var seg_len = pts[dz_i].distance_to(pts[dz_i + 1])
			if accum_len + seg_len > threshold:
				var intensity = clampf((accum_len + seg_len - threshold) / (total_len - threshold), 0.0, 1.0)
				var glow_alpha = danger_pulse * intensity * 0.5
				draw_line(pts[dz_i], pts[dz_i + 1], Color(0.9, 0.1, 0.05, glow_alpha), road_w + 8.0)
				# Rising red particles at segment midpoints
				if dz_i % 4 == 0:
					var mid = (pts[dz_i] + pts[dz_i + 1]) * 0.5
					var ry = sin(_time * 2.0 + float(dz_i)) * 8.0 - 10.0
					draw_circle(mid + Vector2(0, ry), 2.0, Color(0.9, 0.15, 0.05, danger_pulse * intensity * 0.4))
			accum_len += seg_len

	# --- Entry and Exit markers ---
	_draw_entry_exit_markers(pts)

func _get_path_style() -> Dictionary:
	# Default road: sandy-brown dirt road
	var style = {
		"width": 36.0,
		"road_color": Color(0.25, 0.20, 0.14, 0.92),
		"edge_color": Color(0.18, 0.14, 0.08, 0.85),
		"detail_color": Color(0.30, 0.25, 0.18, 0.4),
		"border_width": 1.5,
		"center_line": false,
		"detail_type": "dirt",  # dirt, cobble, brick, tile, plank, ice, lab, jungle, ink
	}
	match current_level:
		0:  # Prologue — glowing ink
			style["road_color"] = Color(0.12, 0.06, 0.20, 0.92)
			style["edge_color"] = Color(0.20, 0.10, 0.35, 0.85)
			style["detail_color"] = Color(0.40, 0.20, 0.65, 0.35)
			style["detail_type"] = "ink"
		1, 2, 3:  # Sherlock — grimy London cobblestone
			style["road_color"] = Color(0.22, 0.18, 0.15, 0.95)
			style["edge_color"] = Color(0.14, 0.10, 0.08, 0.90)
			style["detail_color"] = Color(0.30, 0.24, 0.18, 0.45)
			style["detail_type"] = "cobble"
			style["width"] = 38.0
		4, 5, 6:  # Merlin — ancient stone flagstones
			style["road_color"] = Color(0.20, 0.22, 0.18, 0.92)
			style["edge_color"] = Color(0.12, 0.15, 0.08, 0.85)
			style["detail_color"] = Color(0.25, 0.30, 0.20, 0.4)
			style["detail_type"] = "stone"
			style["width"] = 36.0
		7, 8, 9:  # Tarzan — jungle dirt trail
			style["road_color"] = Color(0.22, 0.16, 0.08, 0.90)
			style["edge_color"] = Color(0.10, 0.14, 0.04, 0.80)
			style["detail_color"] = Color(0.28, 0.20, 0.10, 0.35)
			style["detail_type"] = "jungle"
			style["width"] = 34.0
		10, 11, 12:  # Dracula — dark stone
			style["road_color"] = Color(0.18, 0.12, 0.14, 0.95)
			style["edge_color"] = Color(0.10, 0.06, 0.08, 0.90)
			style["detail_color"] = Color(0.25, 0.15, 0.18, 0.4)
			style["detail_type"] = "cobble"
			style["width"] = 36.0
		13, 14, 15:  # Frankenstein — lab metal grating
			style["road_color"] = Color(0.20, 0.20, 0.22, 0.95)
			style["edge_color"] = Color(0.12, 0.12, 0.14, 0.90)
			style["detail_color"] = Color(0.28, 0.28, 0.32, 0.4)
			style["detail_type"] = "lab"
			style["width"] = 38.0
		16, 17, 18:  # Robin Hood — forest dirt path
			style["road_color"] = Color(0.24, 0.18, 0.10, 0.90)
			style["edge_color"] = Color(0.12, 0.16, 0.06, 0.80)
			style["detail_color"] = Color(0.30, 0.22, 0.12, 0.35)
			style["detail_type"] = "dirt"
			style["width"] = 34.0
		19, 20, 21:  # Alice — whimsical checkerboard
			style["road_color"] = Color(0.30, 0.22, 0.35, 0.92)
			style["edge_color"] = Color(0.22, 0.15, 0.28, 0.85)
			style["detail_color"] = Color(0.40, 0.30, 0.50, 0.4)
			style["detail_type"] = "tile"
			style["width"] = 36.0
		22, 23, 24:  # Oz — yellow brick road
			style["road_color"] = Color(0.50, 0.42, 0.12, 0.95)
			style["edge_color"] = Color(0.35, 0.28, 0.06, 0.90)
			style["detail_color"] = Color(0.60, 0.50, 0.15, 0.5)
			style["detail_type"] = "brick"
			style["width"] = 38.0
		25, 26, 27:  # Peter Pan — sandy/wooden
			style["road_color"] = Color(0.30, 0.24, 0.14, 0.90)
			style["edge_color"] = Color(0.20, 0.16, 0.08, 0.85)
			style["detail_color"] = Color(0.36, 0.28, 0.16, 0.4)
			style["detail_type"] = "plank"
			style["width"] = 36.0
		28, 29, 30:  # Phantom — dark opera stone
			style["road_color"] = Color(0.16, 0.14, 0.18, 0.95)
			style["edge_color"] = Color(0.10, 0.08, 0.12, 0.90)
			style["detail_color"] = Color(0.22, 0.18, 0.26, 0.4)
			style["detail_type"] = "stone"
			style["width"] = 36.0
		31, 32, 33:  # Scrooge — snowy cobblestone
			style["road_color"] = Color(0.28, 0.28, 0.30, 0.92)
			style["edge_color"] = Color(0.20, 0.20, 0.24, 0.85)
			style["detail_color"] = Color(0.40, 0.40, 0.45, 0.4)
			style["detail_type"] = "ice"
			style["width"] = 36.0
		34, 35, 36:  # Shadow Author — dark void
			style["road_color"] = Color(0.10, 0.06, 0.16, 0.95)
			style["edge_color"] = Color(0.06, 0.03, 0.10, 0.90)
			style["detail_color"] = Color(0.18, 0.10, 0.28, 0.4)
			style["detail_type"] = "ink"
			style["width"] = 38.0
	return style

func _draw_path_surface_detail(pts: PackedVector2Array, style: Dictionary) -> void:
	var detail_type = style.get("detail_type", "dirt")
	var road_w = style["width"]
	var half_w = road_w * 0.5

	match detail_type:
		"cobble":
			# Cobblestone grid pattern
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 12.0:
					step -= 12.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Cross lines (mortar)
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.08, 0.06, 0.04, 0.3), 1.0)
					# Offset bricks
					if int(step * 10) % 2 == 0:
						var mid = p + n * (half_w * 0.3)
						draw_line(mid + dir * 4, mid - dir * 4, Color(0.08, 0.06, 0.04, 0.25), 1.0)
		"brick":
			# Brick pattern (yellow brick road style)
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 14.0:
					step -= 14.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Mortar lines
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.35, 0.28, 0.06, 0.35), 1.0)
					# Vertical mortar (offset alternating)
					var row_offset = half_w * 0.5 if int(step * 5) % 2 == 0 else 0.0
					draw_line(p + n * row_offset + dir * 1, p + n * row_offset - dir * 1, Color(0.35, 0.28, 0.06, 0.25), 1.0)
		"stone":
			# Irregular stone flagstones
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 18.0:
					step -= 18.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Irregular cracks
					var crack_off = sin(float(k) * 1.7) * half_w * 0.4
					draw_line(p + n * (half_w - 2), p + n * crack_off, Color(0.06, 0.06, 0.04, 0.25), 1.0)
					draw_line(p - n * (half_w - 2), p - n * crack_off, Color(0.06, 0.06, 0.04, 0.25), 1.0)
					# Cross joint
					draw_line(p + n * (half_w - 3), p - n * (half_w - 3), Color(0.06, 0.06, 0.04, 0.2), 1.0)
		"dirt":
			# Dirt path — ruts and pebbles
			for k in range(0, pts.size() - 1, 6):
				var p = pts[k]
				var dir = (pts[k + 1] - pts[k]).normalized()
				var n = Vector2(-dir.y, dir.x)
				# Wheel ruts
				draw_line(p + n * 6, p + dir * 8 + n * 6, Color(0.18, 0.14, 0.08, 0.3), 2.0)
				draw_line(p - n * 6, p + dir * 8 - n * 6, Color(0.18, 0.14, 0.08, 0.3), 2.0)
			# Scattered pebbles
			for k in range(0, pts.size() - 1, 10):
				var p = pts[k]
				var off = Vector2(sin(float(k) * 2.3) * half_w * 0.6, cos(float(k) * 1.8) * 4.0)
				draw_circle(p + off, 2.0, Color(0.30, 0.24, 0.16, 0.3))
		"jungle":
			# Jungle trail — roots and mud
			for k in range(0, pts.size() - 1, 8):
				var p = pts[k]
				var dir = (pts[k + 1] - pts[k]).normalized()
				var n = Vector2(-dir.y, dir.x)
				# Root lines crossing path
				var root_w = half_w * (0.4 + sin(float(k) * 1.3) * 0.3)
				draw_line(p + n * root_w, p - n * root_w, Color(0.14, 0.10, 0.04, 0.25), 2.0)
			# Mud patches
			for k in range(0, pts.size() - 1, 14):
				var p = pts[k]
				var off = Vector2(sin(float(k) * 3.1) * 8.0, cos(float(k) * 2.7) * 5.0)
				draw_circle(p + off, 4.0 + sin(float(k)) * 2.0, Color(0.16, 0.12, 0.06, 0.2))
		"tile":
			# Alice tile pattern — alternating light/dark squares
			var step = 0.0
			var tile_idx = 0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 16.0:
					step -= 16.0
					tile_idx += 1
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Grid lines
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.20, 0.14, 0.25, 0.3), 1.0)
					# Alternating shade
					if tile_idx % 2 == 0:
						draw_line(p, p + dir * 8, Color(0.35, 0.25, 0.42, 0.15), road_w * 0.8)
		"plank":
			# Wooden planks
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 20.0:
					step -= 20.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Plank gap
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.12, 0.08, 0.04, 0.4), 1.5)
					# Wood grain
					draw_line(p + n * 4, p + dir * 12 + n * 4, Color(0.24, 0.18, 0.10, 0.15), 1.0)
					draw_line(p - n * 6, p + dir * 10 - n * 6, Color(0.24, 0.18, 0.10, 0.15), 1.0)
		"ice":
			# Icy cobblestone — frost lines
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 14.0:
					step -= 14.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.35, 0.38, 0.45, 0.25), 1.0)
			# Frost sparkles
			for k in range(0, pts.size() - 1, 8):
				var p = pts[k]
				var off = Vector2(sin(float(k) * 2.7) * half_w * 0.5, cos(float(k) * 1.9) * 3.0)
				var sparkle = (sin(_time * 4.0 + float(k) * 0.7) + 1.0) * 0.5
				draw_circle(p + off, 1.5, Color(0.7, 0.8, 1.0, sparkle * 0.3))
		"lab":
			# Metal grating — cross-hatch
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 12.0:
					step -= 12.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Grid
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.15, 0.15, 0.18, 0.3), 1.0)
					# Bolts at intersections
					if int(step * 3) % 2 == 0:
						draw_circle(p + n * (half_w * 0.5), 1.5, Color(0.30, 0.30, 0.35, 0.4))
						draw_circle(p - n * (half_w * 0.5), 1.5, Color(0.30, 0.30, 0.35, 0.4))
		"ink":
			# Ink/shadow — swirling particles
			for k in range(0, pts.size() - 1, 5):
				var p = pts[k]
				var off_x = sin(float(k) * 1.7 + _time * 0.5) * half_w * 0.5
				var off_y = cos(float(k) * 2.1 + _time * 0.3) * 4.0
				var glow = (sin(_time * 2.0 + float(k) * 0.4) + 1.0) * 0.5
				draw_circle(p + Vector2(off_x, off_y), 2.0 + glow, Color(0.40, 0.20, 0.65, 0.15 + glow * 0.15))
			# Center glow line
			for k in range(pts.size() - 1):
				var glow = (sin(_time * 1.5 + float(k) * 0.1) + 1.0) * 0.5
				draw_line(pts[k], pts[k + 1], Color(0.30, 0.15, 0.50, 0.08 + glow * 0.06), 4.0)

func _draw_path_arrows(pts: PackedVector2Array, style: Dictionary) -> void:
	# Draw chevron arrows along the path every ~120px showing direction of travel
	if pts.size() < 2:
		return
	var arrow_spacing = 120.0
	var half_w = style["width"] * 0.35
	var accumulated = 0.0
	var arrow_col = Color(1.0, 1.0, 1.0, 0.18)
	for k in range(pts.size() - 1):
		var seg_len = pts[k].distance_to(pts[k + 1])
		accumulated += seg_len
		if accumulated >= arrow_spacing:
			accumulated -= arrow_spacing
			var p = pts[k]
			var dir = (pts[k + 1] - pts[k]).normalized()
			var n = Vector2(-dir.y, dir.x)
			# Draw chevron (> shape pointing in travel direction)
			var tip = p + dir * 6.0
			var left = p - dir * 4.0 + n * half_w
			var right = p - dir * 4.0 - n * half_w
			draw_line(left, tip, arrow_col, 2.0)
			draw_line(right, tip, arrow_col, 2.0)

func _draw_entry_exit_markers(pts: PackedVector2Array) -> void:
	if pts.size() < 2:
		return
	# === SPAWN PORTAL (during active waves) ===
	var entry = pts[0]
	var entry_dir = (pts[1] - pts[0]).normalized()
	if is_wave_active and _spawn_portal_intensity > 0.0:
		var pi_a = _spawn_portal_intensity * 0.6
		# 3 concentric rotating rings (dark purple, counter-rotating)
		for ri in range(3):
			var ring_r = 18.0 + float(ri) * 10.0
			var ring_rot = _time * (2.5 - float(ri) * 0.8) * (1.0 if ri % 2 == 0 else -1.0)
			draw_arc(entry, ring_r, ring_rot, ring_rot + TAU * 0.7, 24, Color(0.3, 0.1, 0.5, pi_a * (0.4 - float(ri) * 0.1)), 2.5 - float(ri) * 0.5)
		# 6 spiral particles converging to center
		for si in range(6):
			var sa = _time * 4.0 + float(si) * TAU / 6.0
			var sr = 30.0 * _spawn_portal_intensity
			var sp = entry + Vector2(cos(sa), sin(sa)) * sr
			draw_circle(sp, 2.0, Color(0.4, 0.15, 0.6, pi_a * 0.5))
		# Central dark void
		draw_circle(entry, 8.0, Color(0.05, 0.0, 0.1, pi_a * 0.7))

	# === ENTRY marker (green, pulsing) ===
	var entry_pulse = 0.6 + sin(_time * 3.0) * 0.2
	# Green glow
	draw_circle(entry, 22.0, Color(0.1, 0.7, 0.2, entry_pulse * 0.2))
	draw_circle(entry, 14.0, Color(0.1, 0.8, 0.2, entry_pulse * 0.35))
	# Arrow pointing inward
	var e_tip = entry + entry_dir * 18.0
	var e_n = Vector2(-entry_dir.y, entry_dir.x)
	var e_base_l = entry - entry_dir * 4.0 + e_n * 10.0
	var e_base_r = entry - entry_dir * 4.0 - e_n * 10.0
	draw_colored_polygon(PackedVector2Array([e_tip, e_base_l, e_base_r]), Color(0.2, 0.9, 0.3, entry_pulse * 0.7))
	# "ENTER" label
	var font = game_font
	var lbl_pos = entry - entry_dir * 12.0 + e_n * 20.0
	# Position label based on entry direction to stay on-screen
	if entry.x < 50:
		lbl_pos = entry + Vector2(24, -8)
	elif entry.y < 80:
		lbl_pos = entry + Vector2(-16, 24)
	elif entry.x > 1230:
		lbl_pos = entry + Vector2(-50, -8)
	else:
		lbl_pos = entry + Vector2(-16, -22)
	_udraw(font, lbl_pos + Vector2(1, 1), "ENTER", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.0, 0.0, 0.0, entry_pulse * 0.5))
	_udraw(font, lbl_pos, "ENTER", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.3, 1.0, 0.4, entry_pulse * 0.7))

	# === EXIT marker (red, pulsing) ===
	var exit_pt = pts[pts.size() - 1]
	var exit_dir = (pts[pts.size() - 1] - pts[pts.size() - 2]).normalized()
	var exit_pulse = 0.6 + sin(_time * 3.0 + 1.5) * 0.2
	# Red glow
	draw_circle(exit_pt, 22.0, Color(0.7, 0.1, 0.1, exit_pulse * 0.2))
	draw_circle(exit_pt, 14.0, Color(0.8, 0.15, 0.1, exit_pulse * 0.35))
	# Arrow pointing outward
	var x_tip = exit_pt + exit_dir * 18.0
	var x_n = Vector2(-exit_dir.y, exit_dir.x)
	var x_base_l = exit_pt - exit_dir * 4.0 + x_n * 10.0
	var x_base_r = exit_pt - exit_dir * 4.0 - x_n * 10.0
	draw_colored_polygon(PackedVector2Array([x_tip, x_base_l, x_base_r]), Color(0.9, 0.2, 0.15, exit_pulse * 0.7))
	# "EXIT" label
	var xlbl_pos = exit_pt + exit_dir * 12.0 + x_n * 20.0
	if exit_pt.x > 1230:
		xlbl_pos = exit_pt + Vector2(-44, -8)
	elif exit_pt.y > 640:
		xlbl_pos = exit_pt + Vector2(-14, -22)
	elif exit_pt.x < 50:
		xlbl_pos = exit_pt + Vector2(24, -8)
	else:
		xlbl_pos = exit_pt + Vector2(-14, 22)
	_udraw(font, xlbl_pos + Vector2(1, 1), "EXIT", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.0, 0.0, 0.0, exit_pulse * 0.5))
	_udraw(font, xlbl_pos, "EXIT", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(1.0, 0.35, 0.3, exit_pulse * 0.7))

# =============================================================================
# NEW BACKGROUND FUNCTIONS FOR LEVELS 0-15 AND 34-36
# =============================================================================

func _draw_prologue(sky_color: Color, ground_color: Color) -> void:
	# Deep purple sky with swirling ink
	var sky_top := Color(0.02, 0.01, 0.06)
	var sky_bottom := Color(0.06, 0.03, 0.12)
	for i in range(30):
		var t := float(i) / 29.0
		var col := sky_top.lerp(sky_bottom, t)
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), col)
	# Dark ink ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.03, 0.02, 0.05))
	draw_rect(Rect2(0, 510, 1280, 15), Color(0.04, 0.03, 0.07))
	# Ink spirals
	for sp in range(6):
		var cx := 100.0 + float(sp) * 200.0
		var cy := 300.0 + sin(float(sp) * 1.7) * 80.0
		for r in range(12):
			var angle := float(r) * 0.55 + _time * 0.3 + float(sp) * 1.2
			var radius := 8.0 + float(r) * 4.5
			var px := cx + cos(angle) * radius
			var py := cy + sin(angle) * radius
			var alpha := 0.4 - float(r) * 0.03
			draw_circle(Vector2(px, py), 3.0 - float(r) * 0.15, Color(0.3, 0.1, 0.5, clampf(alpha, 0.05, 0.4)))
	# Torn page shapes
	for pg in range(5):
		var pgx := 80.0 + float(pg) * 260.0
		var pgy := 400.0 + sin(float(pg) * 2.1) * 40.0
		var page_col := Color(0.12, 0.10, 0.08, 0.15 + 0.05 * sin(_time * 0.8 + float(pg)))
		var pts := PackedVector2Array()
		pts.append(Vector2(pgx, pgy))
		pts.append(Vector2(pgx + 40, pgy - 20))
		pts.append(Vector2(pgx + 60, pgy - 15 + sin(float(pg) * 3.0) * 10.0))
		pts.append(Vector2(pgx + 80, pgy - 25))
		pts.append(Vector2(pgx + 70, pgy + 30))
		pts.append(Vector2(pgx + 20, pgy + 25))
		draw_colored_polygon(pts, page_col)
	# Glowing book edges
	for bk in range(4):
		var bx := 200.0 + float(bk) * 250.0
		var by := 460.0 + float(bk) * 15.0
		var glow := 0.3 + 0.2 * sin(_time * 1.5 + float(bk) * 0.9)
		draw_rect(Rect2(bx, by, 60, 8), Color(0.5, 0.3, 0.8, glow))
		draw_rect(Rect2(bx - 2, by + 8, 64, 35), Color(0.06, 0.04, 0.08))
		draw_rect(Rect2(bx, by + 10, 60, 3), Color(0.4, 0.25, 0.6, glow * 0.5))
		draw_rect(Rect2(bx, by + 16, 60, 3), Color(0.4, 0.25, 0.6, glow * 0.3))
	# Floating ink drops
	for dr in range(10):
		var dx := fmod(float(dr) * 137.5, 1280.0)
		var dy := 150.0 + fmod(float(dr) * 89.3, 350.0) + sin(_time * 0.7 + float(dr)) * 20.0
		var ds := 2.0 + sin(float(dr) * 2.3) * 1.5
		draw_circle(Vector2(dx, dy), ds, Color(0.15, 0.05, 0.25, 0.5))
	_draw_shadow_author_effects()

func _draw_sherlock_ch1(sky_color: Color, ground_color: Color) -> void:
	# Foggy gray London sky
	var sky_top := Color(0.04, 0.04, 0.06)
	var sky_bottom := Color(0.10, 0.10, 0.12)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Cobblestone ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.12, 0.10, 0.08))
	for cx in range(40):
		for cy in range(3):
			var off := 16.0 if cy % 2 == 1 else 0.0
			var bx := float(cx) * 32.0 + off
			var by := 525.0 + float(cy) * 30.0
			draw_rect(Rect2(bx, by, 30, 28), Color(0.10, 0.08, 0.06))
			draw_rect(Rect2(bx, by, 30, 28), Color(0.06, 0.05, 0.04), false, 1.0)
	# Rooftop silhouettes
	var roof_col := Color(0.03, 0.03, 0.05)
	for rt in range(8):
		var rx := float(rt) * 165.0
		var rh := 180.0 + sin(float(rt) * 2.7) * 60.0
		draw_rect(Rect2(rx, 520.0 - rh, 80, rh), roof_col)
		draw_colored_polygon(PackedVector2Array([Vector2(rx - 5, 520.0 - rh), Vector2(rx + 40, 520.0 - rh - 30 - sin(float(rt)) * 15.0), Vector2(rx + 85, 520.0 - rh)]), roof_col)
		# Chimney
		draw_rect(Rect2(rx + 15 + float(rt) * 3.0, 520.0 - rh - 25, 12, 25), roof_col)
	# Gas lamps
	for gl in range(5):
		var gx := 120.0 + float(gl) * 250.0
		draw_rect(Rect2(gx, 440, 4, 80), Color(0.08, 0.07, 0.05))
		draw_rect(Rect2(gx - 6, 435, 16, 10), Color(0.10, 0.08, 0.06))
		var flicker := 0.5 + 0.4 * sin(_time * 5.0 + float(gl) * 2.1)
		draw_circle(Vector2(gx + 2, 433), 6.0, Color(0.9, 0.7, 0.2, flicker))
		draw_circle(Vector2(gx + 2, 433), 14.0, Color(0.9, 0.6, 0.1, flicker * 0.2))
	# Fog layers
	for fl in range(4):
		var fy := 350.0 + float(fl) * 50.0
		var fog_shift := sin(_time * 0.2 + float(fl) * 1.5) * 40.0
		draw_rect(Rect2(-20 + fog_shift, fy, 1320, 20), Color(0.15, 0.15, 0.17, 0.08 + float(fl) * 0.02))
	# Brick wall section
	for bw in range(6):
		var wx := 50.0 + float(bw) * 40.0
		var wy := 430.0 + sin(float(bw) * 1.5) * 5.0
		draw_rect(Rect2(wx, wy, 35, 15), Color(0.14, 0.06, 0.04, 0.6))
	_draw_sherlock_novel(1)
	_draw_shadow_author_effects()

func _draw_sherlock_ch2(sky_color: Color, ground_color: Color) -> void:
	# Darker fog - deeper into London
	var sky_top := Color(0.03, 0.03, 0.05)
	var sky_bottom := Color(0.08, 0.08, 0.10)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.10, 0.08, 0.07))
	for cx in range(40):
		for cy in range(3):
			var off := 16.0 if cy % 2 == 1 else 0.0
			draw_rect(Rect2(float(cx) * 32.0 + off, 525.0 + float(cy) * 30.0, 30, 28), Color(0.08, 0.07, 0.05))
			draw_rect(Rect2(float(cx) * 32.0 + off, 525.0 + float(cy) * 30.0, 30, 28), Color(0.05, 0.04, 0.03), false, 1.0)
	# Rooftops with more detail
	var roof_col := Color(0.02, 0.02, 0.04)
	for rt in range(10):
		var rx := float(rt) * 135.0 - 20.0
		var rh := 150.0 + sin(float(rt) * 3.1) * 70.0
		draw_rect(Rect2(rx, 520.0 - rh, 70, rh), roof_col)
		draw_colored_polygon(PackedVector2Array([Vector2(rx - 5, 520.0 - rh), Vector2(rx + 35, 520.0 - rh - 35), Vector2(rx + 75, 520.0 - rh)]), roof_col)
		# Windows with yellow glow
		if rt % 2 == 0:
			var wy := 520.0 - rh + 30.0
			for w in range(2):
				var wx := rx + 15.0 + float(w) * 30.0
				var wglow := 0.3 + 0.2 * sin(_time * 2.0 + float(rt) + float(w))
				draw_rect(Rect2(wx, wy, 12, 15), Color(0.7, 0.55, 0.15, wglow))
	# Gas lamps
	for gl in range(4):
		var gx := 180.0 + float(gl) * 280.0
		draw_rect(Rect2(gx, 440, 4, 80), Color(0.08, 0.07, 0.05))
		var flicker := 0.5 + 0.4 * sin(_time * 6.0 + float(gl) * 1.8)
		draw_circle(Vector2(gx + 2, 435), 7.0, Color(0.9, 0.65, 0.15, flicker))
		draw_circle(Vector2(gx + 2, 435), 18.0, Color(0.8, 0.5, 0.1, flicker * 0.15))
	# Heavy fog
	for fl in range(6):
		var fy := 280.0 + float(fl) * 45.0
		var fog_shift := sin(_time * 0.15 + float(fl) * 1.1) * 60.0
		draw_rect(Rect2(-40 + fog_shift, fy, 1360, 25), Color(0.14, 0.14, 0.16, 0.06 + float(fl) * 0.015))
	# Magnifying glass detail (Sherlock theme)
	var mg_x := 1100.0
	var mg_y := 200.0
	draw_arc(Vector2(mg_x, mg_y), 20.0, 0, TAU, 32, Color(0.6, 0.5, 0.2, 0.3), 2.0)
	draw_line(Vector2(mg_x + 14, mg_y + 14), Vector2(mg_x + 30, mg_y + 30), Color(0.5, 0.4, 0.15, 0.3), 3.0)
	_draw_sherlock_novel(2)
	_draw_shadow_author_effects()

func _draw_sherlock_ch3(sky_color: Color, ground_color: Color) -> void:
	# Night scene - Reichenbach
	var sky_top := Color(0.02, 0.02, 0.04)
	var sky_bottom := Color(0.06, 0.06, 0.08)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.08, 0.06, 0.06))
	# Cobblestones
	for cx in range(40):
		for cy in range(3):
			var off := 16.0 if cy % 2 == 1 else 0.0
			draw_rect(Rect2(float(cx) * 32.0 + off, 525.0 + float(cy) * 30.0, 30, 28), Color(0.06, 0.05, 0.05))
			draw_rect(Rect2(float(cx) * 32.0 + off, 525.0 + float(cy) * 30.0, 30, 28), Color(0.04, 0.03, 0.03), false, 1.0)
	# Big Ben silhouette
	var ben_col := Color(0.02, 0.02, 0.03)
	draw_rect(Rect2(1050, 150, 50, 370), ben_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1045, 150), Vector2(1075, 90), Vector2(1105, 150)]), ben_col)
	draw_rect(Rect2(1055, 100, 40, 10), ben_col)
	# Clock face
	var clock_glow := 0.4 + 0.15 * sin(_time * 1.0)
	draw_circle(Vector2(1075, 200), 18.0, Color(0.8, 0.75, 0.5, clock_glow))
	draw_circle(Vector2(1075, 200), 16.0, Color(0.03, 0.03, 0.04))
	draw_line(Vector2(1075, 200), Vector2(1075, 188), Color(0.7, 0.65, 0.4, clock_glow), 1.5)
	draw_line(Vector2(1075, 200), Vector2(1083, 196), Color(0.7, 0.65, 0.4, clock_glow), 1.5)
	# More rooftops
	for rt in range(7):
		var rx := float(rt) * 150.0
		var rh := 120.0 + sin(float(rt) * 2.5) * 50.0
		draw_rect(Rect2(rx, 520.0 - rh, 80, rh), Color(0.02, 0.02, 0.04))
	# Gas lamps with red tint
	for gl in range(4):
		var gx := 150.0 + float(gl) * 240.0
		draw_rect(Rect2(gx, 445, 4, 75), Color(0.07, 0.06, 0.05))
		var flicker := 0.5 + 0.4 * sin(_time * 7.0 + float(gl) * 2.5)
		draw_circle(Vector2(gx + 2, 440), 6.0, Color(0.9, 0.5, 0.15, flicker))
		draw_circle(Vector2(gx + 2, 440), 16.0, Color(0.8, 0.4, 0.1, flicker * 0.15))
	# Dense fog
	for fl in range(8):
		var fy := 200.0 + float(fl) * 45.0
		var fog_shift := sin(_time * 0.18 + float(fl) * 0.8) * 50.0
		draw_rect(Rect2(-50 + fog_shift, fy, 1380, 20), Color(0.12, 0.12, 0.14, 0.05 + float(fl) * 0.012))
	_draw_sherlock_novel(3)
	_draw_shadow_author_effects()

func _draw_merlin_ch1(sky_color: Color, ground_color: Color) -> void:
	# Enchanted forest green sky
	var sky_top := Color(0.01, 0.04, 0.02)
	var sky_bottom := Color(0.04, 0.12, 0.06)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Earth ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.10, 0.08, 0.04))
	draw_rect(Rect2(0, 515, 1280, 8), Color(0.06, 0.10, 0.03))
	# Standing stones
	var stone_col := Color(0.08, 0.08, 0.07)
	for st in range(7):
		var sx := 80.0 + float(st) * 180.0
		var sh := 80.0 + sin(float(st) * 2.3) * 30.0
		var sw := 25.0 + sin(float(st) * 1.7) * 8.0
		draw_rect(Rect2(sx - sw / 2, 520.0 - sh, sw, sh), stone_col)
		draw_colored_polygon(PackedVector2Array([Vector2(sx - sw / 2 - 3, 520.0 - sh), Vector2(sx, 520.0 - sh - 15), Vector2(sx + sw / 2 + 3, 520.0 - sh)]), stone_col)
		# Rune glow on stones
		var rune_glow := 0.2 + 0.3 * sin(_time * 1.5 + float(st) * 0.8)
		draw_circle(Vector2(sx, 520.0 - sh / 2), 4.0, Color(0.2, 0.8, 0.3, rune_glow))
		draw_line(Vector2(sx - 5, 520.0 - sh / 2 - 8), Vector2(sx + 5, 520.0 - sh / 2 + 8), Color(0.2, 0.7, 0.3, rune_glow * 0.7), 1.0)
		draw_line(Vector2(sx + 5, 520.0 - sh / 2 - 8), Vector2(sx - 5, 520.0 - sh / 2 + 8), Color(0.2, 0.7, 0.3, rune_glow * 0.7), 1.0)
	# Rune circle on ground
	var rune_cx := 640.0
	var rune_cy := 480.0
	var rune_pulse := 0.15 + 0.1 * sin(_time * 1.2)
	draw_arc(Vector2(rune_cx, rune_cy), 60.0, 0, TAU, 48, Color(0.3, 0.9, 0.4, rune_pulse), 1.5)
	draw_arc(Vector2(rune_cx, rune_cy), 45.0, 0, TAU, 36, Color(0.2, 0.7, 0.3, rune_pulse * 0.7), 1.0)
	for r in range(6):
		var ra := float(r) * TAU / 6.0 + _time * 0.2
		var rx := rune_cx + cos(ra) * 52.0
		var ry := rune_cy + sin(ra) * 25.0
		draw_circle(Vector2(rx, ry), 3.0, Color(0.3, 0.9, 0.4, rune_pulse))
	# Mystical forest trees
	for tr in range(12):
		var tx := float(tr) * 110.0 + 20.0
		var th := 120.0 + sin(float(tr) * 1.9) * 40.0
		draw_rect(Rect2(tx - 4, 520.0 - th, 8, th), Color(0.04, 0.06, 0.02))
		draw_circle(Vector2(tx, 520.0 - th - 15), 22.0 + sin(float(tr)) * 8.0, Color(0.02, 0.06, 0.02, 0.7))
		# Mystical glow in canopy
		var t_glow := 0.1 + 0.1 * sin(_time * 2.0 + float(tr) * 1.3)
		draw_circle(Vector2(tx, 520.0 - th - 10), 5.0, Color(0.3, 0.9, 0.5, t_glow))
	_draw_merlin_novel(1)
	_draw_shadow_author_effects()

func _draw_merlin_ch2(sky_color: Color, ground_color: Color) -> void:
	# Deeper enchanted forest
	var sky_top := Color(0.01, 0.05, 0.03)
	var sky_bottom := Color(0.03, 0.10, 0.05)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.08, 0.07, 0.03))
	draw_rect(Rect2(0, 515, 1280, 8), Color(0.05, 0.08, 0.03))
	# Standing stones with lintel
	var stone_col := Color(0.07, 0.07, 0.06)
	for st in range(4):
		var sx := 200.0 + float(st) * 250.0
		draw_rect(Rect2(sx - 15, 380, 30, 140), stone_col)
		draw_rect(Rect2(sx + 55, 380, 30, 140), stone_col)
		draw_rect(Rect2(sx - 20, 370, 110, 15), stone_col)
		# Rune inscriptions
		var rg := 0.2 + 0.25 * sin(_time * 1.3 + float(st) * 1.1)
		for ri in range(3):
			draw_line(Vector2(sx - 5, 400 + float(ri) * 25), Vector2(sx + 5, 410 + float(ri) * 25), Color(0.1, 0.6, 0.3, rg), 1.5)
	# Mystical orbs floating
	for orb in range(8):
		var ox := 100.0 + float(orb) * 150.0
		var oy := 200.0 + sin(_time * 0.8 + float(orb) * 1.5) * 40.0
		var orb_alpha := 0.3 + 0.2 * sin(_time * 2.0 + float(orb))
		draw_circle(Vector2(ox, oy), 4.0, Color(0.4, 1.0, 0.5, orb_alpha))
		draw_circle(Vector2(ox, oy), 10.0, Color(0.3, 0.8, 0.4, orb_alpha * 0.3))
	# Mushrooms on ground
	for mu in range(10):
		var mx := fmod(float(mu) * 131.0, 1200.0) + 40.0
		var ms := 6.0 + sin(float(mu)) * 3.0
		draw_rect(Rect2(mx - 2, 510, 4, 10), Color(0.15, 0.12, 0.06))
		draw_arc(Vector2(mx, 510), ms, PI, TAU, 12, Color(0.6, 0.15, 0.1, 0.5), ms * 0.6)
	# Forest canopy
	for tr in range(15):
		var tx := float(tr) * 90.0
		var th := 100.0 + sin(float(tr) * 2.1) * 35.0
		draw_rect(Rect2(tx - 3, 520.0 - th, 6, th), Color(0.03, 0.05, 0.02))
		draw_circle(Vector2(tx, 520.0 - th - 12), 20.0 + sin(float(tr) * 1.3) * 6.0, Color(0.02, 0.05, 0.02, 0.65))
	_draw_merlin_novel(2)
	_draw_shadow_author_effects()

func _draw_merlin_ch3(sky_color: Color, ground_color: Color) -> void:
	# Camelot approach - magical night
	var sky_top := Color(0.01, 0.03, 0.02)
	var sky_bottom := Color(0.05, 0.10, 0.06)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.09, 0.07, 0.04))
	# Camelot castle silhouette in distance
	var cas_col := Color(0.03, 0.04, 0.03)
	draw_colored_polygon(PackedVector2Array([Vector2(900, 350), Vector2(950, 280), Vector2(1000, 260), Vector2(1080, 250), Vector2(1150, 270), Vector2(1200, 300), Vector2(1280, 340), Vector2(1280, 520), Vector2(900, 520)]), cas_col)
	draw_rect(Rect2(1020, 180, 40, 80), cas_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1015, 180), Vector2(1040, 140), Vector2(1065, 180)]), cas_col)
	# Pennant on tower
	var pennant_sway := sin(_time * 3.0) * 5.0
	draw_colored_polygon(PackedVector2Array([Vector2(1040, 142), Vector2(1040 + 15 + pennant_sway, 148), Vector2(1040, 155)]), Color(0.6, 0.1, 0.1, 0.5))
	# Magic particles rising
	for mp in range(15):
		var px := fmod(float(mp) * 97.0, 1200.0) + 40.0
		var py := 500.0 - fmod(_time * 30.0 + float(mp) * 40.0, 400.0)
		var mp_alpha := clampf(1.0 - (500.0 - py) / 400.0, 0.0, 0.5)
		draw_circle(Vector2(px, py), 2.0, Color(0.3, 0.9, 0.5, mp_alpha))
	# Large rune circle
	var rc_x := 400.0
	var rc_y := 470.0
	var rc_pulse := 0.12 + 0.08 * sin(_time * 1.0)
	draw_arc(Vector2(rc_x, rc_y), 80.0, 0, TAU, 64, Color(0.2, 0.8, 0.4, rc_pulse), 2.0)
	for r in range(8):
		var ra := float(r) * TAU / 8.0 + _time * 0.15
		draw_circle(Vector2(rc_x + cos(ra) * 70.0, rc_y + sin(ra) * 35.0), 3.5, Color(0.3, 1.0, 0.5, rc_pulse * 1.5))
	# Standing stones flanking
	for st in range(5):
		var sx := float(st) * 160.0 + 50.0
		var sh := 70.0 + sin(float(st) * 2.0) * 20.0
		draw_rect(Rect2(sx - 12, 520.0 - sh, 24, sh), Color(0.06, 0.06, 0.05))
	_draw_merlin_novel(3)
	_draw_shadow_author_effects()

func _draw_tarzan_ch1(sky_color: Color, ground_color: Color) -> void:
	# Tropical blue sky
	var sky_top := Color(0.02, 0.06, 0.12)
	var sky_bottom := Color(0.06, 0.14, 0.18)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Jungle green ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.04, 0.14, 0.02))
	draw_rect(Rect2(0, 515, 1280, 8), Color(0.03, 0.10, 0.02))
	# Vines hanging from top
	for v in range(12):
		var vx := float(v) * 110.0 + 30.0
		var vlen := 100.0 + sin(float(v) * 1.9) * 60.0
		var sway := sin(_time * 1.2 + float(v) * 0.7) * 8.0
		for seg in range(int(vlen / 8.0)):
			var sy := 50.0 + float(seg) * 8.0
			var sx := vx + sin(float(seg) * 0.3 + _time * 0.5) * sway * (float(seg) / (vlen / 8.0))
			draw_rect(Rect2(sx - 1.5, sy, 3, 9), Color(0.1, 0.25, 0.05, 0.7))
		# Leaf at bottom of vine
		var leaf_y := 50.0 + vlen
		var leaf_x := vx + sway * 0.8
		draw_colored_polygon(PackedVector2Array([Vector2(leaf_x, leaf_y), Vector2(leaf_x + 8, leaf_y + 5), Vector2(leaf_x, leaf_y + 12), Vector2(leaf_x - 8, leaf_y + 5)]), Color(0.15, 0.35, 0.05, 0.6))
	# Canopy leaves at top
	for cl in range(20):
		var cx := float(cl) * 68.0
		var cs := 30.0 + sin(float(cl) * 2.3) * 12.0
		draw_circle(Vector2(cx, 55.0 + sin(float(cl) * 1.5) * 15.0), cs, Color(0.02, 0.08, 0.02, 0.5))
		draw_circle(Vector2(cx + 20, 70.0 + sin(float(cl) * 2.1) * 10.0), cs * 0.7, Color(0.03, 0.10, 0.03, 0.4))
	# Exotic flowers
	for fl in range(8):
		var fx := fmod(float(fl) * 167.0, 1200.0) + 40.0
		var fy := 500.0 + sin(float(fl) * 2.5) * 15.0
		draw_rect(Rect2(fx - 1, fy - 20, 2, 22), Color(0.08, 0.20, 0.04))
		var petal_col := Color(0.8, 0.2 + sin(float(fl)) * 0.3, 0.3, 0.6)
		for p in range(5):
			var pa := float(p) * TAU / 5.0
			draw_circle(Vector2(fx + cos(pa) * 5.0, fy - 22 + sin(pa) * 5.0), 3.0, petal_col)
		draw_circle(Vector2(fx, fy - 22), 2.5, Color(0.9, 0.8, 0.2, 0.7))
	# Tree trunks
	for tr in range(6):
		var tx := float(tr) * 220.0 + 50.0
		draw_rect(Rect2(tx - 8, 350, 16, 170), Color(0.12, 0.07, 0.03))
		draw_rect(Rect2(tx - 6, 355, 4, 160), Color(0.10, 0.06, 0.02, 0.5))
	_draw_tarzan_novel(1)
	_draw_shadow_author_effects()

func _draw_tarzan_ch2(sky_color: Color, ground_color: Color) -> void:
	# Deeper jungle
	var sky_top := Color(0.02, 0.05, 0.10)
	var sky_bottom := Color(0.04, 0.12, 0.14)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.03, 0.12, 0.02))
	# Dense canopy
	for cl in range(25):
		var cx := float(cl) * 55.0
		var cs := 35.0 + sin(float(cl) * 1.7) * 10.0
		draw_circle(Vector2(cx, 60.0 + sin(float(cl) * 2.0) * 12.0), cs, Color(0.02, 0.07, 0.02, 0.55))
	# Thick vines
	for v in range(8):
		var vx := float(v) * 165.0 + 50.0
		var sway := sin(_time * 0.9 + float(v) * 0.9) * 12.0
		for seg in range(20):
			var sy := 50.0 + float(seg) * 12.0
			var sx := vx + sin(float(seg) * 0.25 + _time * 0.4) * sway * (float(seg) / 20.0)
			draw_rect(Rect2(sx - 2, sy, 4, 13), Color(0.08, 0.20, 0.04, 0.65))
	# Waterfall in background
	var wf_x := 900.0
	for ws in range(15):
		var wy := 200.0 + float(ws) * 22.0
		var wobble := sin(_time * 4.0 + float(ws) * 0.5) * 3.0
		draw_rect(Rect2(wf_x - 8 + wobble, wy, 16, 24), Color(0.3, 0.5, 0.7, 0.15))
	# Pool at bottom of waterfall
	draw_arc(Vector2(wf_x, 520), 30.0, PI, TAU, 24, Color(0.2, 0.4, 0.6, 0.2), 2.0)
	# Exotic flowers
	for fl in range(10):
		var fx := fmod(float(fl) * 131.0, 1200.0) + 40.0
		var fy := 505.0 + sin(float(fl) * 1.8) * 10.0
		draw_rect(Rect2(fx - 1, fy - 15, 2, 17), Color(0.06, 0.18, 0.03))
		var pcol := Color(0.9, 0.4 + sin(float(fl) * 0.7) * 0.3, 0.1, 0.5)
		for p in range(4):
			var pa := float(p) * TAU / 4.0 + 0.4
			draw_circle(Vector2(fx + cos(pa) * 4.0, fy - 17 + sin(pa) * 4.0), 2.5, pcol)
	# Parrots (simple colored dots on branches)
	for bird in range(3):
		var bx := 200.0 + float(bird) * 350.0
		var by := 150.0 + float(bird) * 30.0
		draw_circle(Vector2(bx, by), 5.0, Color(0.8, 0.2, 0.1, 0.6))
		draw_circle(Vector2(bx + 3, by - 4), 3.0, Color(0.2, 0.7, 0.1, 0.6))
	_draw_tarzan_novel(2)
	_draw_shadow_author_effects()

func _draw_tarzan_ch3(sky_color: Color, ground_color: Color) -> void:
	# Jungle summit - sunset hues
	var sky_top := Color(0.03, 0.07, 0.14)
	var sky_bottom := Color(0.10, 0.15, 0.08)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.05, 0.14, 0.03))
	# Treehouse platform silhouette
	var th_col := Color(0.06, 0.04, 0.02)
	draw_rect(Rect2(600, 300, 200, 12), th_col)
	draw_rect(Rect2(640, 312, 10, 208), th_col)
	draw_rect(Rect2(760, 312, 10, 208), th_col)
	# Ladder
	for ld in range(8):
		draw_rect(Rect2(645, 320 + float(ld) * 25, 120, 3), Color(0.08, 0.05, 0.02, 0.5))
	# Rope bridge
	for rb in range(20):
		var rx := 300.0 + float(rb) * 15.0
		var ry := 350.0 + sin(float(rb) * 0.3) * 15.0
		draw_rect(Rect2(rx, ry, 14, 3), Color(0.10, 0.06, 0.03, 0.5))
	# Heavy vines
	for v in range(10):
		var vx := float(v) * 135.0 + 20.0
		var sway := sin(_time * 1.0 + float(v) * 1.1) * 10.0
		for seg in range(18):
			var sy := 50.0 + float(seg) * 10.0
			var sx := vx + sin(float(seg) * 0.3) * sway * (float(seg) / 18.0)
			draw_rect(Rect2(sx - 2, sy, 4, 11), Color(0.08, 0.22, 0.04, 0.6))
	# Canopy
	for cl in range(22):
		var cx := float(cl) * 62.0
		draw_circle(Vector2(cx, 55.0 + sin(float(cl) * 1.8) * 12.0), 28.0 + sin(float(cl)) * 8.0, Color(0.02, 0.07, 0.02, 0.5))
	# Exotic flowers on ground
	for fl in range(6):
		var fx := fmod(float(fl) * 197.0, 1200.0) + 40.0
		draw_rect(Rect2(fx - 1, 500, 2, 20), Color(0.06, 0.15, 0.03))
		for p in range(5):
			var pa := float(p) * TAU / 5.0
			draw_circle(Vector2(fx + cos(pa) * 5.0, 498.0 + sin(pa) * 5.0), 3.0, Color(0.9, 0.6, 0.1, 0.5))
	_draw_tarzan_novel(3)
	_draw_shadow_author_effects()

func _draw_dracula_ch1(sky_color: Color, ground_color: Color) -> void:
	# Blood red-black sky
	var sky_top := Color(0.03, 0.01, 0.02)
	var sky_bottom := Color(0.10, 0.03, 0.06)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Dark earth ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.06, 0.04, 0.04))
	# Blood moon
	draw_circle(Vector2(200, 140), 45.0, Color(0.6, 0.1, 0.08, 0.15))
	draw_circle(Vector2(200, 140), 35.0, Color(0.7, 0.15, 0.1))
	draw_circle(Vector2(193, 135), 32.0, Color(0.6, 0.12, 0.08))
	# Moon craters
	draw_circle(Vector2(210, 130), 5.0, Color(0.5, 0.08, 0.06, 0.4))
	draw_circle(Vector2(195, 148), 4.0, Color(0.5, 0.08, 0.06, 0.3))
	# Bat silhouettes
	for bt in range(8):
		var bx := fmod(float(bt) * 173.0 + _time * 20.0, 1400.0) - 60.0
		var by := 100.0 + sin(_time * 1.5 + float(bt) * 1.3) * 30.0 + float(bt) * 20.0
		var wing := sin(_time * 6.0 + float(bt) * 2.0) * 8.0
		draw_line(Vector2(bx - 10, by + wing), Vector2(bx, by), Color(0.05, 0.02, 0.03, 0.7), 1.5)
		draw_line(Vector2(bx, by), Vector2(bx + 10, by + wing), Color(0.05, 0.02, 0.03, 0.7), 1.5)
		draw_circle(Vector2(bx, by), 2.5, Color(0.04, 0.02, 0.03, 0.7))
	# Crosses / gravestones
	for cr in range(6):
		var cx := 100.0 + float(cr) * 200.0
		var cy := 510.0
		draw_rect(Rect2(cx - 3, cy - 30, 6, 35), Color(0.08, 0.06, 0.05))
		draw_rect(Rect2(cx - 10, cy - 22, 20, 5), Color(0.08, 0.06, 0.05))
	# Castle silhouette in distance
	var cas_col := Color(0.03, 0.01, 0.02)
	draw_colored_polygon(PackedVector2Array([Vector2(950, 350), Vector2(1000, 250), Vector2(1050, 230), Vector2(1100, 220), Vector2(1180, 240), Vector2(1250, 280), Vector2(1280, 320), Vector2(1280, 520), Vector2(950, 520)]), cas_col)
	# Castle towers
	draw_rect(Rect2(1060, 150, 35, 80), cas_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1055, 150), Vector2(1077, 110), Vector2(1100, 150)]), cas_col)
	# Red fog
	for fl in range(4):
		var fy := 380.0 + float(fl) * 35.0
		var fog_shift := sin(_time * 0.2 + float(fl) * 1.0) * 30.0
		draw_rect(Rect2(-20 + fog_shift, fy, 1320, 18), Color(0.15, 0.03, 0.05, 0.06))
	_draw_dracula_novel(1)
	_draw_shadow_author_effects()

func _draw_dracula_ch2(sky_color: Color, ground_color: Color) -> void:
	# Inside the castle approach
	var sky_top := Color(0.04, 0.01, 0.03)
	var sky_bottom := Color(0.08, 0.02, 0.05)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.05, 0.03, 0.03))
	# Gothic arches
	for arch in range(5):
		var ax := float(arch) * 270.0 + 80.0
		var arch_col := Color(0.04, 0.02, 0.03)
		draw_rect(Rect2(ax - 30, 320, 10, 200), arch_col)
		draw_rect(Rect2(ax + 30, 320, 10, 200), arch_col)
		draw_arc(Vector2(ax + 5, 320), 35.0, PI, TAU, 24, arch_col, 10.0)
	# Candelabras
	for cn in range(4):
		var cx := 200.0 + float(cn) * 280.0
		draw_rect(Rect2(cx - 2, 420, 4, 100), Color(0.08, 0.06, 0.04))
		for c in range(3):
			var coff := float(c - 1) * 12.0
			var flicker := 0.5 + 0.4 * sin(_time * 5.5 + float(cn) * 2.0 + float(c))
			draw_circle(Vector2(cx + coff, 415), 4.0, Color(0.9, 0.4, 0.1, flicker))
			draw_circle(Vector2(cx + coff, 415), 10.0, Color(0.8, 0.3, 0.05, flicker * 0.15))
	# More bats
	for bt in range(6):
		var bx := fmod(float(bt) * 211.0 + _time * 15.0, 1400.0) - 60.0
		var by := 120.0 + sin(_time * 2.0 + float(bt) * 1.8) * 25.0 + float(bt) * 15.0
		var wing := sin(_time * 7.0 + float(bt) * 2.5) * 7.0
		draw_line(Vector2(bx - 9, by + wing), Vector2(bx, by), Color(0.04, 0.01, 0.02, 0.6), 1.5)
		draw_line(Vector2(bx, by), Vector2(bx + 9, by + wing), Color(0.04, 0.01, 0.02, 0.6), 1.5)
		draw_circle(Vector2(bx, by), 2.0, Color(0.03, 0.01, 0.02, 0.6))
	# Red mist
	for fl in range(5):
		var fy := 350.0 + float(fl) * 35.0
		var fog_shift := sin(_time * 0.15 + float(fl) * 0.9) * 40.0
		draw_rect(Rect2(-30 + fog_shift, fy, 1340, 20), Color(0.12, 0.02, 0.04, 0.05 + float(fl) * 0.01))
	# Coffins on ground
	for cf in range(3):
		var cfx := 300.0 + float(cf) * 300.0
		draw_rect(Rect2(cfx, 508, 40, 12), Color(0.07, 0.04, 0.03))
		draw_rect(Rect2(cfx + 2, 505, 36, 5), Color(0.08, 0.04, 0.03))
	_draw_dracula_novel(2)
	_draw_shadow_author_effects()

func _draw_dracula_ch3(sky_color: Color, ground_color: Color) -> void:
	# Dracula's throne room approach
	var sky_top := Color(0.05, 0.01, 0.03)
	var sky_bottom := Color(0.10, 0.03, 0.06)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.05, 0.03, 0.04))
	# Large blood moon behind clouds
	draw_circle(Vector2(640, 120), 55.0, Color(0.5, 0.08, 0.06, 0.12))
	draw_circle(Vector2(640, 120), 40.0, Color(0.65, 0.12, 0.08))
	# Clouds over moon
	for mc in range(3):
		var mcx := 600.0 + float(mc) * 35.0 + sin(_time * 0.3) * 10.0
		draw_circle(Vector2(mcx, 110.0 + float(mc) * 8.0), 20.0, Color(0.04, 0.02, 0.03, 0.6))
	# Gothic windows
	for gw in range(4):
		var wx := 150.0 + float(gw) * 300.0
		draw_rect(Rect2(wx, 250, 40, 100), Color(0.03, 0.01, 0.02))
		draw_arc(Vector2(wx + 20, 250), 20.0, PI, TAU, 16, Color(0.03, 0.01, 0.02), 20.0)
		var red_glow := 0.15 + 0.1 * sin(_time * 1.5 + float(gw))
		draw_rect(Rect2(wx + 3, 260, 34, 85), Color(0.4, 0.05, 0.08, red_glow))
	# Bats swarm
	for bt in range(12):
		var bx := fmod(float(bt) * 113.0 + _time * 25.0, 1500.0) - 100.0
		var by := 80.0 + sin(_time * 1.8 + float(bt) * 1.0) * 40.0 + float(bt) * 12.0
		var wing := sin(_time * 8.0 + float(bt) * 3.0) * 6.0
		draw_line(Vector2(bx - 8, by + wing), Vector2(bx, by), Color(0.03, 0.01, 0.02, 0.65), 1.5)
		draw_line(Vector2(bx, by), Vector2(bx + 8, by + wing), Color(0.03, 0.01, 0.02, 0.65), 1.5)
	# Crosses and gravestones
	for cr in range(8):
		var cx := 60.0 + float(cr) * 160.0
		draw_rect(Rect2(cx - 3, 490, 6, 30), Color(0.07, 0.05, 0.04))
		draw_rect(Rect2(cx - 9, 498, 18, 4), Color(0.07, 0.05, 0.04))
	# Red fog thicker
	for fl in range(6):
		var fy := 320.0 + float(fl) * 35.0
		var fog_shift := sin(_time * 0.12 + float(fl) * 0.7) * 50.0
		draw_rect(Rect2(-40 + fog_shift, fy, 1360, 22), Color(0.14, 0.02, 0.04, 0.05 + float(fl) * 0.01))
	_draw_dracula_novel(3)
	_draw_shadow_author_effects()

func _draw_frankenstein_ch1(sky_color: Color, ground_color: Color) -> void:
	# Storm gray sky
	var sky_top := Color(0.02, 0.02, 0.04)
	var sky_bottom := Color(0.06, 0.06, 0.08)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Stone floor
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.08, 0.08, 0.08))
	for sx in range(20):
		for sy in range(2):
			var off := 32.0 if sy % 2 == 1 else 0.0
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.07, 0.07, 0.07))
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.05, 0.05, 0.05), false, 1.0)
	# Tesla coils
	for tc in range(4):
		var tx := 150.0 + float(tc) * 280.0
		# Coil base
		draw_rect(Rect2(tx - 8, 430, 16, 90), Color(0.10, 0.08, 0.06))
		draw_rect(Rect2(tx - 15, 425, 30, 8), Color(0.12, 0.10, 0.08))
		# Coil rings
		for ring in range(5):
			var ry := 440.0 + float(ring) * 15.0
			draw_arc(Vector2(tx, ry), 10.0, 0, TAU, 16, Color(0.15, 0.12, 0.08), 2.0)
		# Sparks from top
		var spark_active := sin(_time * 8.0 + float(tc) * 2.5)
		if spark_active > 0.0:
			var spark_alpha := spark_active * 0.7
			for sp in range(3):
				var sa := float(sp) * TAU / 3.0 + _time * 5.0
				var sr := 15.0 + float(sp) * 8.0
				var sx2 := tx + cos(sa) * sr
				var sy2 := 420.0 + sin(sa) * sr * 0.5
				draw_line(Vector2(tx, 425), Vector2(sx2, sy2), Color(0.5, 0.6, 1.0, spark_alpha), 1.5)
				draw_circle(Vector2(sx2, sy2), 2.0, Color(0.6, 0.7, 1.0, spark_alpha))
	# Lightning bolts in sky
	var bolt_timer := fmod(_time * 0.5, 3.0)
	if bolt_timer < 0.15:
		var bolt_alpha := 0.6 - bolt_timer * 4.0
		var bx := 400.0 + sin(_time * 7.0) * 300.0
		draw_line(Vector2(bx, 50), Vector2(bx + 20, 150), Color(0.7, 0.75, 1.0, bolt_alpha), 2.0)
		draw_line(Vector2(bx + 20, 150), Vector2(bx - 10, 250), Color(0.7, 0.75, 1.0, bolt_alpha), 2.0)
		draw_line(Vector2(bx - 10, 250), Vector2(bx + 15, 350), Color(0.6, 0.65, 1.0, bolt_alpha * 0.7), 1.5)
	# Beakers on tables
	for bk in range(3):
		var bkx := 350.0 + float(bk) * 250.0
		draw_rect(Rect2(bkx - 15, 490, 30, 5), Color(0.10, 0.09, 0.08))
		# Beaker shape
		draw_rect(Rect2(bkx - 5, 470, 10, 20), Color(0.2, 0.3, 0.4, 0.3))
		var bubble := sin(_time * 3.0 + float(bk) * 1.5) * 0.3
		draw_circle(Vector2(bkx, 475), 3.0, Color(0.3, 0.8, 0.2, 0.3 + bubble))
	_draw_frankenstein_novel(1)
	_draw_shadow_author_effects()

func _draw_frankenstein_ch2(sky_color: Color, ground_color: Color) -> void:
	# Deeper into the lab
	var sky_top := Color(0.03, 0.03, 0.05)
	var sky_bottom := Color(0.05, 0.05, 0.07)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.07, 0.07, 0.07))
	# Stone floor tiles
	for sx in range(20):
		for sy in range(2):
			var off := 32.0 if sy % 2 == 1 else 0.0
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.06, 0.06, 0.06))
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.04, 0.04, 0.04), false, 1.0)
	# Operating table silhouette
	draw_rect(Rect2(500, 460, 200, 10), Color(0.10, 0.08, 0.06))
	draw_rect(Rect2(520, 470, 8, 50), Color(0.08, 0.06, 0.05))
	draw_rect(Rect2(680, 470, 8, 50), Color(0.08, 0.06, 0.05))
	# Chains from ceiling
	for ch in range(6):
		var cx := 100.0 + float(ch) * 200.0
		var sway := sin(_time * 1.5 + float(ch) * 1.0) * 5.0
		for link in range(8):
			var ly := 50.0 + float(link) * 18.0
			var lx := cx + sway * (float(link) / 8.0)
			draw_rect(Rect2(lx - 2, ly, 4, 8), Color(0.12, 0.10, 0.08, 0.5))
			draw_rect(Rect2(lx - 3, ly + 6, 6, 4), Color(0.10, 0.08, 0.07, 0.5))
	# Tesla coils (bigger)
	for tc in range(3):
		var tx := 200.0 + float(tc) * 350.0
		draw_rect(Rect2(tx - 12, 400, 24, 120), Color(0.10, 0.08, 0.06))
		draw_rect(Rect2(tx - 20, 395, 40, 10), Color(0.12, 0.10, 0.08))
		for ring in range(7):
			draw_arc(Vector2(tx, 410.0 + float(ring) * 14.0), 14.0, 0, TAU, 16, Color(0.14, 0.11, 0.08), 2.0)
		# Electric arcs between coils
		if tc < 2:
			var next_x := 200.0 + float(tc + 1) * 350.0
			var arc_on := sin(_time * 6.0 + float(tc) * 3.0)
			if arc_on > 0.3:
				var arc_alpha := (arc_on - 0.3) * 0.8
				var mid_x := (tx + next_x) / 2.0
				var mid_y := 395.0 + sin(_time * 4.0) * 20.0
				draw_line(Vector2(tx, 400), Vector2(mid_x, mid_y), Color(0.5, 0.6, 1.0, arc_alpha), 1.5)
				draw_line(Vector2(mid_x, mid_y), Vector2(next_x, 400), Color(0.5, 0.6, 1.0, arc_alpha), 1.5)
	# Green bubbling liquid
	for bk in range(5):
		var bkx := 80.0 + float(bk) * 250.0
		draw_rect(Rect2(bkx - 8, 480, 16, 25), Color(0.15, 0.25, 0.1, 0.3))
		var bub_y := 480.0 - fmod(_time * 15.0 + float(bk) * 10.0, 20.0)
		draw_circle(Vector2(bkx, bub_y), 2.0, Color(0.3, 0.8, 0.2, 0.4))
	_draw_frankenstein_novel(2)
	_draw_shadow_author_effects()

func _draw_frankenstein_ch3(sky_color: Color, ground_color: Color) -> void:
	# The creation scene - storm at peak
	var sky_top := Color(0.03, 0.02, 0.05)
	var sky_bottom := Color(0.06, 0.05, 0.08)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.08, 0.08, 0.08))
	# Stone floor
	for sx in range(20):
		for sy in range(2):
			var off := 32.0 if sy % 2 == 1 else 0.0
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.06, 0.06, 0.06))
	# Giant apparatus in center
	draw_rect(Rect2(560, 250, 160, 8), Color(0.12, 0.10, 0.08))
	draw_rect(Rect2(580, 258, 8, 262), Color(0.10, 0.08, 0.06))
	draw_rect(Rect2(692, 258, 8, 262), Color(0.10, 0.08, 0.06))
	# Gear/wheel
	draw_arc(Vector2(640, 300), 25.0, 0, TAU, 24, Color(0.12, 0.10, 0.08), 3.0)
	for g in range(8):
		var ga := float(g) * TAU / 8.0 + _time * 0.5
		draw_line(Vector2(640 + cos(ga) * 20.0, 300 + sin(ga) * 20.0), Vector2(640 + cos(ga) * 30.0, 300 + sin(ga) * 30.0), Color(0.12, 0.10, 0.08), 2.0)
	# Multiple lightning bolts
	for bolt in range(3):
		var bolt_timer := fmod(_time * 0.8 + float(bolt) * 1.0, 2.5)
		if bolt_timer < 0.12:
			var ba := 0.7 - bolt_timer * 5.5
			var bx := 200.0 + float(bolt) * 350.0 + sin(_time * 5.0 + float(bolt)) * 50.0
			draw_line(Vector2(bx, 50), Vector2(bx + 15, 130), Color(0.7, 0.8, 1.0, ba), 2.5)
			draw_line(Vector2(bx + 15, 130), Vector2(bx - 10, 220), Color(0.7, 0.8, 1.0, ba), 2.0)
			draw_line(Vector2(bx - 10, 220), Vector2(bx + 5, 310), Color(0.6, 0.7, 1.0, ba * 0.7), 1.5)
	# Tesla coils with heavy sparks
	for tc in range(2):
		var tx := 100.0 + float(tc) * 1000.0
		draw_rect(Rect2(tx - 10, 380, 20, 140), Color(0.10, 0.08, 0.06))
		draw_rect(Rect2(tx - 18, 375, 36, 10), Color(0.12, 0.10, 0.08))
		for ring in range(8):
			draw_arc(Vector2(tx, 390.0 + float(ring) * 14.0), 12.0, 0, TAU, 16, Color(0.14, 0.11, 0.08), 2.0)
		# Constant sparks
		for sp in range(4):
			var sa := float(sp) * TAU / 4.0 + _time * 7.0 + float(tc) * 1.5
			var sr := 20.0 + sin(_time * 3.0 + float(sp)) * 8.0
			var spark_a := 0.3 + 0.3 * sin(_time * 5.0 + float(sp) + float(tc))
			draw_line(Vector2(tx, 378), Vector2(tx + cos(sa) * sr, 378 + sin(sa) * sr * 0.6), Color(0.5, 0.6, 1.0, clampf(spark_a, 0.0, 0.6)), 1.5)
	# Bubbling vats
	for vat in range(4):
		var vx := 250.0 + float(vat) * 220.0
		draw_rect(Rect2(vx - 12, 485, 24, 35), Color(0.12, 0.20, 0.08, 0.35))
		for bub in range(3):
			var by := 485.0 - fmod(_time * 12.0 + float(vat) * 8.0 + float(bub) * 5.0, 25.0)
			draw_circle(Vector2(vx + sin(float(bub) * 2.0) * 5.0, by), 1.5, Color(0.3, 0.7, 0.2, 0.4))
	_draw_frankenstein_novel(3)
	_draw_shadow_author_effects()

func _draw_sherlock_novel(ch: int) -> void:
	# From Arthur Conan Doyle's Sherlock Holmes stories
	# 1. 221B Baker Street door with brass number plate
	var door_x := 80.0
	draw_rect(Rect2(door_x, 380, 30, 60), Color(0.08, 0.04, 0.02))
	draw_rect(Rect2(door_x + 2, 382, 26, 56), Color(0.12, 0.06, 0.03))
	var plate_glow := 0.5 + 0.2 * sin(_time * 1.5)
	draw_rect(Rect2(door_x + 8, 390, 14, 8), Color(0.7, 0.6, 0.2, plate_glow))
	# 2. Hansom cab silhouette moving across background
	var cab_x := fmod(_time * 15.0 + float(ch) * 400.0, 1500.0) - 100.0
	var cab_y := 480.0 - float(ch) * 10.0
	draw_rect(Rect2(cab_x, cab_y - 25, 35, 20), Color(0.04, 0.03, 0.02, 0.5))
	draw_rect(Rect2(cab_x + 5, cab_y - 35, 25, 12), Color(0.04, 0.03, 0.02, 0.5))
	draw_circle(Vector2(cab_x + 8, cab_y), 6.0, Color(0.04, 0.03, 0.02, 0.5))
	draw_circle(Vector2(cab_x + 30, cab_y), 6.0, Color(0.04, 0.03, 0.02, 0.5))
	draw_colored_polygon(PackedVector2Array([Vector2(cab_x - 25, cab_y - 10), Vector2(cab_x - 5, cab_y - 20), Vector2(cab_x - 5, cab_y - 5), Vector2(cab_x - 20, cab_y)]), Color(0.04, 0.03, 0.02, 0.45))
	# 3. Pipe smoke curling from a rooftop window
	var smoke_base := Vector2(250.0 + float(ch) * 100.0, 310.0)
	for s in range(8):
		var sx := smoke_base.x + sin(_time * 0.8 + float(s) * 0.6) * (3.0 + float(s) * 2.0)
		var sy := smoke_base.y - float(s) * 8.0
		draw_circle(Vector2(sx, sy), 2.5 + float(s) * 0.8, Color(0.3, 0.28, 0.25, 0.15 - float(s) * 0.015))
	# 4. Violin silhouette in window
	var vn_x := 1150.0
	var vn_y := 340.0 - float(ch) * 20.0
	draw_rect(Rect2(vn_x - 12, vn_y - 8, 24, 16), Color(0.6, 0.5, 0.15, 0.15))
	draw_arc(Vector2(vn_x, vn_y - 20), 6.0, 0, TAU, 12, Color(0.25, 0.12, 0.05, 0.35), 1.5)
	draw_rect(Rect2(vn_x - 1, vn_y - 20, 2, 30), Color(0.25, 0.12, 0.05, 0.35))
	draw_arc(Vector2(vn_x, vn_y + 5), 5.0, 0, TAU, 12, Color(0.25, 0.12, 0.05, 0.3), 1.5)
	# 5. The Strand Magazine page blowing in wind
	var pg_x := 500.0 + sin(_time * 0.4) * 80.0
	var pg_y := 490.0 + cos(_time * 0.6) * 10.0
	draw_rect(Rect2(pg_x - 8, pg_y - 10, 16, 20), Color(0.7, 0.65, 0.5, 0.2 + 0.1 * sin(_time)))
	# 6. Deerstalker hat on a post
	var hat_x := 700.0 + float(ch) * 80.0
	draw_rect(Rect2(hat_x - 2, 460, 4, 50), Color(0.06, 0.05, 0.04))
	draw_rect(Rect2(hat_x - 12, 455, 24, 8), Color(0.3, 0.2, 0.08, 0.5))
	draw_colored_polygon(PackedVector2Array([Vector2(hat_x - 14, 455), Vector2(hat_x, 445), Vector2(hat_x + 14, 455)]), Color(0.3, 0.2, 0.08, 0.5))
	draw_rect(Rect2(hat_x - 15, 455, 5, 10), Color(0.28, 0.18, 0.07, 0.4))
	draw_rect(Rect2(hat_x + 10, 455, 5, 10), Color(0.28, 0.18, 0.07, 0.4))
	# 7. Moriarty's shadow watching from alley (ch2/3)
	if ch >= 2:
		var m_x := 1200.0
		var m_a := 0.15 + 0.08 * sin(_time * 0.5)
		draw_circle(Vector2(m_x, 370), 5.0, Color(0.02, 0.01, 0.02, m_a))
		draw_rect(Rect2(m_x - 2.5, 375, 5, 35), Color(0.02, 0.01, 0.02, m_a))
		draw_rect(Rect2(m_x - 8, 375, 16, 3), Color(0.02, 0.01, 0.02, m_a * 0.7))
		draw_line(Vector2(m_x - 2, 410), Vector2(m_x - 5, 435), Color(0.02, 0.01, 0.02, m_a * 0.6), 2.0)
		draw_line(Vector2(m_x + 2, 410), Vector2(m_x + 5, 435), Color(0.02, 0.01, 0.02, m_a * 0.6), 2.0)
	# 8. Hound paw prints in fog (The Hound of the Baskervilles)
	for pw in range(4 + ch):
		var px := 350.0 + float(pw) * 60.0
		var py := 505.0 + sin(float(pw) * 2.0) * 5.0
		draw_circle(Vector2(px, py), 3.0, Color(0.08, 0.05, 0.03, 0.25))
		draw_circle(Vector2(px - 2, py - 3), 1.5, Color(0.08, 0.05, 0.03, 0.2))
		draw_circle(Vector2(px + 2, py - 3), 1.5, Color(0.08, 0.05, 0.03, 0.2))
		draw_circle(Vector2(px, py - 5), 1.5, Color(0.08, 0.05, 0.03, 0.2))
	# 9. Dancing Men cipher on wall (The Adventure of the Dancing Men)
	var dm_y := 430.0 + float(ch) * 5.0
	for dm in range(5):
		var dx := 400.0 + float(dm) * 25.0
		var da := 0.15 + 0.05 * sin(_time * 0.8 + float(dm))
		draw_circle(Vector2(dx, dm_y - 10), 2.0, Color(0.8, 0.7, 0.4, da))
		draw_line(Vector2(dx, dm_y - 8), Vector2(dx, dm_y), Color(0.8, 0.7, 0.4, da), 1.0)
		draw_line(Vector2(dx - 4, dm_y - 5), Vector2(dx + 4, dm_y - 5 - float(dm % 3) * 2.0), Color(0.8, 0.7, 0.4, da), 1.0)
		draw_line(Vector2(dx - 3, dm_y), Vector2(dx + 3, dm_y + 2), Color(0.8, 0.7, 0.4, da), 1.0)
	# 10. Reichenbach Falls mist (ch3) / Chemical apparatus (ch1/2)
	if ch == 3:
		for wm in range(6):
			var wy := 150.0 + float(wm) * 40.0
			var wobble := sin(_time * 2.5 + float(wm)) * 5.0
			draw_rect(Rect2(40 + wobble, wy, 25, 42), Color(0.4, 0.5, 0.6, 0.06))
		draw_line(Vector2(52, 100), Vector2(52, 400), Color(0.5, 0.6, 0.7, 0.08), 3.0)
	else:
		var bk_x := 160.0 + float(ch) * 40.0
		var bk_y := 380.0
		draw_rect(Rect2(bk_x, bk_y, 6, 12), Color(0.4, 0.5, 0.6, 0.2))
		draw_rect(Rect2(bk_x + 10, bk_y + 3, 8, 9), Color(0.4, 0.6, 0.4, 0.2))
		var bubble := sin(_time * 4.0) * 0.1
		draw_circle(Vector2(bk_x + 14, bk_y + 5), 1.5, Color(0.3, 0.7, 0.3, 0.2 + bubble))

func _draw_merlin_novel(ch: int) -> void:
	# From Arthurian legend / T.H. White "The Once and Future King"
	# 1. Excalibur embedded in stone (The Sword in the Stone)
	var ex_x := 150.0 + float(ch) * 50.0
	var ex_y := 490.0
	draw_rect(Rect2(ex_x - 15, ex_y, 30, 25), Color(0.1, 0.1, 0.08))
	draw_rect(Rect2(ex_x - 12, ex_y + 2, 24, 20), Color(0.12, 0.12, 0.09))
	var sword_glow := 0.3 + 0.2 * sin(_time * 1.2)
	draw_rect(Rect2(ex_x - 1.5, ex_y - 35, 3, 37), Color(0.7, 0.75, 0.8, sword_glow))
	draw_rect(Rect2(ex_x - 7, ex_y - 5, 14, 3), Color(0.6, 0.5, 0.2, sword_glow))
	draw_circle(Vector2(ex_x, ex_y - 3), 2.5, Color(0.8, 0.2, 0.2, sword_glow * 0.8))
	draw_circle(Vector2(ex_x, ex_y - 15), 20.0, Color(0.8, 0.9, 0.4, sword_glow * 0.08))
	# 2. Archimedes the owl perched on a branch
	var owl_x := 900.0 + float(ch) * 30.0
	var owl_y := 180.0
	var owl_bob := sin(_time * 1.0) * 2.0
	draw_circle(Vector2(owl_x, owl_y + owl_bob), 6.0, Color(0.25, 0.2, 0.12, 0.55))
	draw_circle(Vector2(owl_x, owl_y - 5 + owl_bob), 5.0, Color(0.28, 0.22, 0.14, 0.55))
	var blink := 1.0 if fmod(_time, 4.0) > 0.2 else 0.0
	draw_circle(Vector2(owl_x - 2.5, owl_y - 6 + owl_bob), 2.0, Color(0.9, 0.7, 0.1, 0.5 * blink))
	draw_circle(Vector2(owl_x + 2.5, owl_y - 6 + owl_bob), 2.0, Color(0.9, 0.7, 0.1, 0.5 * blink))
	draw_circle(Vector2(owl_x - 2.5, owl_y - 6 + owl_bob), 0.8, Color(0.05, 0.03, 0.02, 0.5 * blink))
	draw_circle(Vector2(owl_x + 2.5, owl_y - 6 + owl_bob), 0.8, Color(0.05, 0.03, 0.02, 0.5 * blink))
	draw_line(Vector2(owl_x - 30, owl_y + 8), Vector2(owl_x + 25, owl_y + 5 + owl_bob), Color(0.15, 0.08, 0.03, 0.5), 3.0)
	# 3. Crystal cave entrance (Mary Stewart's "The Crystal Cave")
	var cave_x := 50.0
	var cave_y := 460.0 + float(ch) * 10.0
	draw_arc(Vector2(cave_x + 20, cave_y), 20.0, PI, TAU, 16, Color(0.04, 0.04, 0.03, 0.6), 20.0)
	for cr in range(5):
		var cx := cave_x + 8.0 + float(cr) * 7.0
		var cy := cave_y - 5.0 - float(cr % 3) * 6.0
		var crystal_pulse := 0.3 + 0.2 * sin(_time * 2.0 + float(cr) * 1.2)
		draw_line(Vector2(cx, cy), Vector2(cx + 2, cy - 8), Color(0.4, 0.6, 0.9, crystal_pulse), 2.0)
	# 4. Round Table outline on ground
	var rt_x := 640.0
	var rt_y := 495.0
	var rt_pulse := 0.08 + 0.04 * sin(_time * 0.7)
	draw_arc(Vector2(rt_x, rt_y), 25.0, 0, TAU, 32, Color(0.5, 0.4, 0.15, rt_pulse), 2.0)
	for seat in range(12):
		var sa := float(seat) * TAU / 12.0
		draw_circle(Vector2(rt_x + cos(sa) * 28.0, rt_y + sin(sa) * 14.0), 2.0, Color(0.5, 0.4, 0.15, rt_pulse * 1.5))
	# 5. Lady of the Lake's arm rising from water (ch2/3)
	if ch >= 2:
		var ll_x := 350.0 + float(ch) * 40.0
		var ll_y := 510.0
		var rise := sin(_time * 0.5) * 3.0
		for rip in range(3):
			draw_arc(Vector2(ll_x, ll_y), 8.0 + float(rip) * 6.0, 0, TAU, 16, Color(0.2, 0.4, 0.7, 0.12 - float(rip) * 0.03), 1.0)
		draw_line(Vector2(ll_x, ll_y), Vector2(ll_x + 2, ll_y - 25 + rise), Color(0.7, 0.65, 0.55, 0.3), 2.5)
		draw_line(Vector2(ll_x + 2, ll_y - 25 + rise), Vector2(ll_x + 2, ll_y - 45 + rise), Color(0.8, 0.85, 0.9, 0.4), 1.5)
	# 6. Morgan le Fay's dark mirror
	var mir_x := 1100.0
	var mir_y := 400.0 - float(ch) * 15.0
	draw_rect(Rect2(mir_x - 10, mir_y - 15, 20, 30), Color(0.4, 0.3, 0.15, 0.3))
	draw_rect(Rect2(mir_x - 8, mir_y - 13, 16, 26), Color(0.03, 0.02, 0.06, 0.4))
	var swirl := sin(_time * 1.5) * 0.1
	draw_circle(Vector2(mir_x, mir_y), 5.0, Color(0.3, 0.1, 0.5, 0.15 + swirl))
	# 7. Druid staff with crystal orb
	var staff_x := 1050.0
	draw_line(Vector2(staff_x, 510), Vector2(staff_x, 430), Color(0.15, 0.08, 0.03, 0.4), 3.0)
	var orb_glow := 0.3 + 0.15 * sin(_time * 1.8)
	draw_circle(Vector2(staff_x, 425), 5.0, Color(0.3, 0.8, 0.5, orb_glow))
	draw_circle(Vector2(staff_x, 425), 10.0, Color(0.2, 0.6, 0.4, orb_glow * 0.2))
	# 8. Holy Grail glow (distant golden radiance)
	var grail_x := 640.0 + sin(_time * 0.2) * 5.0
	var grail_y := 100.0 + float(ch) * 10.0
	var grail_a := 0.05 + 0.03 * sin(_time * 0.6)
	draw_circle(Vector2(grail_x, grail_y), 30.0, Color(0.9, 0.8, 0.3, grail_a))
	draw_circle(Vector2(grail_x, grail_y), 15.0, Color(1.0, 0.9, 0.5, grail_a * 2.0))
	# 9. Enchanted suit of armor (floating, ghostly)
	var arm_x := 800.0 - float(ch) * 60.0
	var arm_bob := sin(_time * 0.8) * 4.0
	var arm_a := 0.15 + 0.05 * sin(_time * 1.2)
	draw_circle(Vector2(arm_x, 380 + arm_bob), 6.0, Color(0.3, 0.3, 0.35, arm_a))
	draw_rect(Rect2(arm_x - 5, 386 + arm_bob, 10, 20), Color(0.3, 0.3, 0.35, arm_a))
	draw_rect(Rect2(arm_x - 8, 386 + arm_bob, 16, 3), Color(0.3, 0.3, 0.35, arm_a * 0.8))
	# 10. Dragon in distant sky (ch3) / Fireflies (ch1/2)
	if ch == 3:
		var dr_x := 200.0 + sin(_time * 0.3) * 30.0
		var dr_y := 120.0 + cos(_time * 0.4) * 10.0
		var dr_a := 0.12
		draw_colored_polygon(PackedVector2Array([Vector2(dr_x - 20, dr_y), Vector2(dr_x + 25, dr_y - 5), Vector2(dr_x + 30, dr_y + 5), Vector2(dr_x - 15, dr_y + 3)]), Color(0.05, 0.08, 0.04, dr_a))
		var wing_flap := sin(_time * 2.5) * 8.0
		draw_colored_polygon(PackedVector2Array([Vector2(dr_x - 5, dr_y - 2), Vector2(dr_x + 10, dr_y - 15 + wing_flap), Vector2(dr_x + 20, dr_y - 5)]), Color(0.05, 0.08, 0.04, dr_a * 0.8))
	else:
		for ff in range(6):
			var ffx := fmod(float(ff) * 211.0 + sin(_time * 0.5 + float(ff)) * 40.0, 1200.0) + 40.0
			var ffy := 300.0 + sin(_time * 1.5 + float(ff) * 2.0) * 60.0
			var ff_glow := 0.3 + 0.2 * sin(_time * 3.0 + float(ff) * 1.5)
			draw_circle(Vector2(ffx, ffy), 1.5, Color(0.5, 0.9, 0.3, ff_glow))

func _draw_tarzan_novel(ch: int) -> void:
	# From Edgar Rice Burroughs' "Tarzan of the Apes"
	# 1. Mangani apes in the trees
	for ape in range(2 + ch):
		var ax := 200.0 + float(ape) * 300.0
		var ay := 200.0 + float(ape) * 30.0
		var ape_sway := sin(_time * 0.6 + float(ape) * 1.5) * 3.0
		var ape_a := 0.25
		draw_circle(Vector2(ax + ape_sway, ay), 7.0, Color(0.06, 0.04, 0.02, ape_a))
		draw_rect(Rect2(ax - 5 + ape_sway, ay + 7, 10, 12), Color(0.06, 0.04, 0.02, ape_a))
		draw_line(Vector2(ax + ape_sway, ay + 10), Vector2(ax - 12 + ape_sway, ay + 3), Color(0.06, 0.04, 0.02, ape_a * 0.8), 2.0)
		draw_line(Vector2(ax + ape_sway, ay + 10), Vector2(ax + 15 + ape_sway, ay + 5), Color(0.06, 0.04, 0.02, ape_a * 0.8), 2.0)
	# 2. Lord Greystoke's cabin (the marooned cabin)
	var cb_x := 100.0
	var cb_y := 460.0
	draw_rect(Rect2(cb_x, cb_y, 50, 35), Color(0.15, 0.08, 0.03, 0.35))
	draw_colored_polygon(PackedVector2Array([Vector2(cb_x - 5, cb_y), Vector2(cb_x + 25, cb_y - 18), Vector2(cb_x + 55, cb_y)]), Color(0.12, 0.06, 0.02, 0.35))
	draw_rect(Rect2(cb_x + 18, cb_y + 15, 12, 20), Color(0.08, 0.04, 0.02, 0.4))
	var win_glow := 0.15 + 0.1 * sin(_time * 1.5)
	draw_rect(Rect2(cb_x + 35, cb_y + 8, 8, 8), Color(0.7, 0.5, 0.15, win_glow))
	# 3. Kala's nest platform high in tree
	var nest_x := 1100.0 - float(ch) * 50.0
	var nest_y := 140.0
	draw_rect(Rect2(nest_x - 3, nest_y, 6, 380), Color(0.10, 0.06, 0.02, 0.4))
	draw_rect(Rect2(nest_x - 20, nest_y - 5, 40, 8), Color(0.12, 0.08, 0.03, 0.3))
	for lf in range(4):
		var la := float(lf) * TAU / 4.0 + _time * 0.2
		draw_circle(Vector2(nest_x + cos(la) * 15.0, nest_y - 5 + sin(la) * 8.0), 6.0, Color(0.1, 0.25, 0.05, 0.3))
	# 4. Sabor the lioness crouching
	var lion_x := 950.0 + float(ch) * 30.0
	var lion_y := 500.0
	var lion_a := 0.18 + 0.05 * sin(_time * 0.7)
	draw_colored_polygon(PackedVector2Array([Vector2(lion_x - 15, lion_y), Vector2(lion_x - 8, lion_y - 10), Vector2(lion_x + 15, lion_y - 8), Vector2(lion_x + 20, lion_y)]), Color(0.35, 0.25, 0.08, lion_a))
	draw_circle(Vector2(lion_x - 12, lion_y - 12), 5.0, Color(0.35, 0.25, 0.08, lion_a))
	draw_arc(Vector2(lion_x + 20, lion_y - 10), 10.0, -0.5, 1.5, 8, Color(0.35, 0.25, 0.08, lion_a * 0.7), 1.5)
	draw_circle(Vector2(lion_x - 14, lion_y - 14), 1.0, Color(0.9, 0.7, 0.1, lion_a * 2.0))
	draw_circle(Vector2(lion_x - 10, lion_y - 14), 1.0, Color(0.9, 0.7, 0.1, lion_a * 2.0))
	# 5. Ship wreckage on shore (the Fuwalda)
	var ship_x := 1180.0
	var ship_y := 510.0
	draw_line(Vector2(ship_x - 25, ship_y), Vector2(ship_x + 15, ship_y - 5), Color(0.12, 0.07, 0.03, 0.3), 3.0)
	draw_line(Vector2(ship_x - 10, ship_y - 5), Vector2(ship_x - 8, ship_y - 30), Color(0.10, 0.06, 0.03, 0.25), 2.0)
	var sail_sway := sin(_time * 1.0) * 3.0
	draw_colored_polygon(PackedVector2Array([Vector2(ship_x - 8, ship_y - 28), Vector2(ship_x + 5 + sail_sway, ship_y - 20), Vector2(ship_x - 5, ship_y - 12)]), Color(0.5, 0.45, 0.35, 0.15))
	# 6. Elephant herd in far distance
	for el in range(3):
		var ex := 400.0 + float(el) * 80.0
		var ey := 460.0 + float(el) * 5.0
		var el_a := 0.12 - float(el) * 0.02
		draw_circle(Vector2(ex, ey - 8), 8.0, Color(0.15, 0.14, 0.12, el_a))
		draw_rect(Rect2(ex - 7, ey, 14, 10), Color(0.15, 0.14, 0.12, el_a))
		draw_line(Vector2(ex - 5, ey + 10), Vector2(ex - 5, ey + 18), Color(0.15, 0.14, 0.12, el_a * 0.8), 2.0)
		draw_line(Vector2(ex + 5, ey + 10), Vector2(ex + 5, ey + 18), Color(0.15, 0.14, 0.12, el_a * 0.8), 2.0)
	# 7. Waziri tribal totem poles
	var tm_x := 750.0 + float(ch) * 40.0
	draw_rect(Rect2(tm_x - 5, 440, 10, 70), Color(0.15, 0.08, 0.03, 0.35))
	draw_circle(Vector2(tm_x, 450), 5.0, Color(0.2, 0.1, 0.04, 0.3))
	draw_circle(Vector2(tm_x - 2, 449), 1.0, Color(0.05, 0.03, 0.02, 0.3))
	draw_circle(Vector2(tm_x + 2, 449), 1.0, Color(0.05, 0.03, 0.02, 0.3))
	# 8. Tarzan's swinging vine (empty vine swaying)
	var rope_x := 600.0
	var rope_sway := sin(_time * 1.5) * 25.0
	for seg in range(12):
		var ry := 50.0 + float(seg) * 15.0
		var rx := rope_x + sin(float(seg) * 0.2) * rope_sway * (float(seg) / 12.0)
		draw_rect(Rect2(rx - 1, ry, 2, 16), Color(0.08, 0.2, 0.04, 0.3))
	draw_circle(Vector2(rope_x + rope_sway * 0.8, 230), 3.0, Color(0.1, 0.22, 0.05, 0.3))
	# 9. Crocodile lurking in water
	var croc_x := 500.0 + sin(_time * 0.3) * 20.0
	var croc_y := 518.0
	draw_colored_polygon(PackedVector2Array([Vector2(croc_x - 20, croc_y), Vector2(croc_x + 20, croc_y - 3), Vector2(croc_x + 25, croc_y + 2), Vector2(croc_x - 18, croc_y + 4)]), Color(0.12, 0.15, 0.06, 0.2))
	draw_circle(Vector2(croc_x + 15, croc_y - 4), 1.5, Color(0.6, 0.5, 0.1, 0.3))
	# 10. Opar ruins columns (The Return of Tarzan, ch2/3)
	if ch >= 2:
		for col in range(3):
			var colx := 50.0 + float(col) * 35.0
			var coly := 380.0 + float(col) * 15.0
			draw_rect(Rect2(colx - 4, coly, 8, 520.0 - coly), Color(0.15, 0.13, 0.1, 0.15))
			draw_rect(Rect2(colx - 6, coly - 3, 12, 5), Color(0.16, 0.14, 0.11, 0.15))

func _draw_dracula_novel(ch: int) -> void:
	# From Bram Stoker's "Dracula"
	# 1. Dracula's coffin with Transylvanian earth
	var coff_x := 100.0 + float(ch) * 80.0
	var coff_y := 500.0
	draw_rect(Rect2(coff_x - 20, coff_y, 40, 15), Color(0.08, 0.04, 0.03))
	draw_colored_polygon(PackedVector2Array([Vector2(coff_x - 20, coff_y), Vector2(coff_x - 25, coff_y + 7), Vector2(coff_x - 20, coff_y + 15)]), Color(0.08, 0.04, 0.03))
	draw_colored_polygon(PackedVector2Array([Vector2(coff_x + 20, coff_y), Vector2(coff_x + 25, coff_y + 7), Vector2(coff_x + 20, coff_y + 15)]), Color(0.08, 0.04, 0.03))
	var coffin_glow := 0.1 + 0.05 * sin(_time * 0.8)
	draw_rect(Rect2(coff_x - 15, coff_y + 2, 30, 2), Color(0.5, 0.05, 0.05, coffin_glow))
	# 2. Wolf pack - glowing eyes in darkness
	for wolf in range(3 + ch):
		var wx := 800.0 + float(wolf) * 40.0
		var wy := 470.0 + sin(float(wolf) * 2.0) * 15.0
		var wolf_blink := 1.0 if fmod(_time + float(wolf) * 1.3, 3.5) > 0.15 else 0.0
		draw_circle(Vector2(wx - 3, wy), 1.5, Color(0.7, 0.3, 0.05, 0.35 * wolf_blink))
		draw_circle(Vector2(wx + 3, wy), 1.5, Color(0.7, 0.3, 0.05, 0.35 * wolf_blink))
	# 3. Garlic flowers hanging (protection)
	for gr in range(4):
		var gx := 300.0 + float(gr) * 250.0
		var gy := 360.0 + float(ch) * 10.0
		draw_line(Vector2(gx, gy - 15), Vector2(gx, gy + 10), Color(0.4, 0.35, 0.15, 0.2), 1.5)
		for gb in range(3):
			draw_circle(Vector2(gx - 4.0 + float(gb) * 4.0, gy + 10 + float(gb) * 3.0), 3.0, Color(0.7, 0.65, 0.5, 0.2))
	# 4. Ship Demeter (ghost ship silhouette)
	var dem_x := 1050.0 + sin(_time * 0.15) * 10.0
	var dem_y := 280.0 - float(ch) * 20.0
	var dem_a := 0.12
	draw_colored_polygon(PackedVector2Array([Vector2(dem_x - 25, dem_y + 8), Vector2(dem_x - 30, dem_y), Vector2(dem_x + 30, dem_y), Vector2(dem_x + 25, dem_y + 8)]), Color(0.06, 0.03, 0.04, dem_a))
	draw_line(Vector2(dem_x - 10, dem_y), Vector2(dem_x - 10, dem_y - 25), Color(0.06, 0.03, 0.04, dem_a), 1.5)
	draw_line(Vector2(dem_x + 10, dem_y), Vector2(dem_x + 10, dem_y - 20), Color(0.06, 0.03, 0.04, dem_a), 1.5)
	var sail_blow := sin(_time * 0.8) * 3.0
	draw_colored_polygon(PackedVector2Array([Vector2(dem_x - 10, dem_y - 23), Vector2(dem_x - 5 + sail_blow, dem_y - 15), Vector2(dem_x - 10, dem_y - 8)]), Color(0.15, 0.1, 0.1, dem_a * 0.8))
	# 5. Mina Harker's journal (open book)
	var jn_x := 550.0 + float(ch) * 30.0
	draw_rect(Rect2(jn_x - 8, 508, 16, 10), Color(0.15, 0.08, 0.04, 0.25))
	draw_line(Vector2(jn_x, 508), Vector2(jn_x, 518), Color(0.1, 0.05, 0.03, 0.2), 0.5)
	# 6. Wooden stake and mallet (Van Helsing's tools)
	var stk_x := 650.0
	draw_line(Vector2(stk_x, 510), Vector2(stk_x, 490), Color(0.3, 0.2, 0.08, 0.25), 2.5)
	draw_colored_polygon(PackedVector2Array([Vector2(stk_x - 1.5, 490), Vector2(stk_x, 482), Vector2(stk_x + 1.5, 490)]), Color(0.35, 0.22, 0.08, 0.25))
	draw_rect(Rect2(stk_x + 8, 500, 12, 8), Color(0.2, 0.12, 0.05, 0.2))
	# 7. Crucifix hanging from archway (glowing faintly)
	var cr_x := 450.0 + float(ch) * 100.0
	var cr_y := 350.0
	var cr_glow := 0.2 + 0.1 * sin(_time * 1.5)
	draw_rect(Rect2(cr_x - 1.5, cr_y, 3, 18), Color(0.7, 0.6, 0.2, cr_glow))
	draw_rect(Rect2(cr_x - 6, cr_y + 4, 12, 3), Color(0.7, 0.6, 0.2, cr_glow))
	draw_circle(Vector2(cr_x, cr_y + 8), 8.0, Color(0.8, 0.7, 0.3, cr_glow * 0.15))
	# 8. Mirror with no reflection (cracked)
	var mr_x := 200.0 - float(ch) * 20.0
	draw_rect(Rect2(mr_x - 10, 365, 20, 30), Color(0.3, 0.25, 0.1, 0.2))
	draw_rect(Rect2(mr_x - 8, 367, 16, 26), Color(0.02, 0.02, 0.03, 0.3))
	draw_line(Vector2(mr_x - 5, 370), Vector2(mr_x + 3, 385), Color(0.15, 0.12, 0.1, 0.2), 0.5)
	# 9. Lucy's tomb (Highgate Cemetery, ch2/3)
	if ch >= 2:
		draw_rect(Rect2(732, 500, 36, 18), Color(0.1, 0.08, 0.07))
		draw_colored_polygon(PackedVector2Array([Vector2(732, 500), Vector2(750, 488), Vector2(768, 500)]), Color(0.1, 0.08, 0.07))
	# 10. Count's cape swirl (dissipating black shape)
	var cape_x := 400.0 + sin(_time * 0.4) * 15.0
	var cape_y := 350.0 + float(ch) * 20.0
	var cape_a := 0.08 + 0.04 * sin(_time * 0.6)
	for cv in range(5):
		var ca := float(cv) * 0.4 + _time * 0.8
		draw_line(Vector2(cape_x, cape_y), Vector2(cape_x + cos(ca) * 20.0, cape_y + sin(ca) * 15.0 + 10.0), Color(0.04, 0.01, 0.02, cape_a), 2.0)

func _draw_frankenstein_novel(ch: int) -> void:
	# From Mary Shelley's "Frankenstein; or, The Modern Prometheus"
	# 1. Laboratory with galvanic apparatus
	var lab_x := 100.0 + float(ch) * 30.0
	var lab_y := 400.0
	draw_rect(Rect2(lab_x, lab_y, 60, 40), Color(0.06, 0.06, 0.08, 0.3))
	draw_rect(Rect2(lab_x + 10, lab_y - 25, 8, 25), Color(0.15, 0.15, 0.2, 0.3))
	draw_circle(Vector2(lab_x + 14, lab_y - 28), 5.0, Color(0.15, 0.15, 0.2, 0.3))
	var spark := sin(_time * 8.0 + float(ch)) * 0.3
	if spark > 0.0:
		draw_line(Vector2(lab_x + 14, lab_y - 30), Vector2(lab_x + 14 + sin(_time * 12.0) * 10.0, lab_y - 40), Color(0.5, 0.6, 0.9, spark), 1.5)
	draw_rect(Rect2(lab_x + 30, lab_y + 5, 6, 15), Color(0.3, 0.5, 0.4, 0.2))
	draw_rect(Rect2(lab_x + 42, lab_y + 8, 8, 12), Color(0.4, 0.3, 0.5, 0.2))
	# 2. The Creature's footprints in snow/mud
	for fp in range(5):
		var fx := 300.0 + float(fp) * 50.0
		var fy := 510.0 + sin(float(fp) * 1.5) * 3.0
		draw_circle(Vector2(fx, fy), 4.0, Color(0.06, 0.05, 0.04, 0.15))
		draw_circle(Vector2(fx + 2, fy - 4), 1.5, Color(0.06, 0.05, 0.04, 0.12))
	# 3. Geneva lake reflecting moonlight
	var lake_x := 800.0
	for rp in range(8):
		var rx := lake_x - 40.0 + float(rp) * 12.0 + sin(_time * 0.5 + float(rp)) * 3.0
		draw_rect(Rect2(rx, 510, 10, 2), Color(0.3, 0.35, 0.4, 0.1 + 0.05 * sin(_time + float(rp))))
	# 4. De Lacey cottage (warm cottage in distance)
	var cot_x := 1100.0 - float(ch) * 40.0
	var cot_y := 430.0
	draw_rect(Rect2(cot_x, cot_y, 35, 25), Color(0.12, 0.08, 0.05, 0.25))
	draw_colored_polygon(PackedVector2Array([Vector2(cot_x - 3, cot_y), Vector2(cot_x + 17, cot_y - 12), Vector2(cot_x + 38, cot_y)]), Color(0.14, 0.08, 0.04, 0.25))
	var cot_glow := 0.2 + 0.1 * sin(_time * 1.0)
	draw_rect(Rect2(cot_x + 12, cot_y + 8, 8, 8), Color(0.7, 0.5, 0.15, cot_glow))
	# 5. Alpine peaks / Mont Blanc silhouette
	draw_colored_polygon(PackedVector2Array([Vector2(500, 400), Vector2(580, 200 - float(ch) * 20.0), Vector2(660, 380), Vector2(700, 250), Vector2(780, 400)]), Color(0.06, 0.06, 0.08, 0.3))
	draw_colored_polygon(PackedVector2Array([Vector2(560, 220 - float(ch) * 20.0), Vector2(580, 200 - float(ch) * 20.0), Vector2(600, 220 - float(ch) * 20.0)]), Color(0.3, 0.32, 0.35, 0.15))
	# 6. Anatomy table with draped form
	var tbl_x := 400.0 + float(ch) * 40.0
	draw_rect(Rect2(tbl_x, 480, 50, 4), Color(0.1, 0.08, 0.06, 0.3))
	draw_rect(Rect2(tbl_x + 3, 484, 3, 25), Color(0.08, 0.06, 0.05, 0.25))
	draw_rect(Rect2(tbl_x + 44, 484, 3, 25), Color(0.08, 0.06, 0.05, 0.25))
	draw_rect(Rect2(tbl_x + 5, 472, 40, 8), Color(0.15, 0.13, 0.12, 0.2))
	# 7. Lightning rod atop building
	var lr_x := 250.0 + float(ch) * 60.0
	draw_line(Vector2(lr_x, 320), Vector2(lr_x, 280), Color(0.2, 0.2, 0.25, 0.3), 2.0)
	draw_line(Vector2(lr_x - 8, 290), Vector2(lr_x + 8, 290), Color(0.2, 0.2, 0.25, 0.25), 1.5)
	var flash_check := sin(_time * 0.3 + float(ch) * 2.0)
	if flash_check > 0.95:
		draw_line(Vector2(lr_x, 280), Vector2(lr_x + sin(_time * 20.0) * 15.0, 50), Color(0.7, 0.7, 0.9, 0.3), 2.0)
	# 8. Arctic ice (Walton's ship frame story, ch3)
	if ch == 3:
		for ice in range(5):
			var ix := 900.0 + float(ice) * 60.0
			var iy := 480.0 + sin(float(ice) * 1.8) * 10.0
			draw_colored_polygon(PackedVector2Array([Vector2(ix - 15, iy + 15), Vector2(ix - 5, iy), Vector2(ix + 10, iy + 3), Vector2(ix + 15, iy + 15)]), Color(0.4, 0.45, 0.5, 0.15))
	# 9. Victor's scattered letters
	for lt in range(3):
		var lx := 700.0 + float(lt) * 35.0
		draw_rect(Rect2(lx - 5, 505 + float(lt) * 3.0, 10, 14), Color(0.6, 0.55, 0.4, 0.12))
	# 10. Creature watching from shadows (two yellow eyes)
	var cr_x := 1200.0 - float(ch) * 30.0
	var cr_y := 400.0 + float(ch) * 10.0
	var cr_blink := 1.0 if fmod(_time + float(ch) * 2.0, 5.0) > 0.2 else 0.0
	draw_circle(Vector2(cr_x - 4, cr_y), 2.0, Color(0.8, 0.7, 0.1, 0.25 * cr_blink))
	draw_circle(Vector2(cr_x + 4, cr_y), 2.0, Color(0.8, 0.7, 0.1, 0.25 * cr_blink))
	draw_rect(Rect2(cr_x - 8, cr_y - 20, 16, 50), Color(0.03, 0.03, 0.04, 0.08 * cr_blink))

func _draw_robin_novel(ch: int) -> void:
	# From Howard Pyle's "The Merry Adventures of Robin Hood"
	# 1. Major Oak (massive ancient oak tree)
	var oak_x := 120.0
	draw_rect(Rect2(oak_x - 15, 420, 30, 80), Color(0.12, 0.07, 0.03, 0.4))
	draw_rect(Rect2(oak_x - 12, 425, 8, 70), Color(0.10, 0.06, 0.02, 0.2))
	for oc in range(5):
		var ocx := oak_x - 40.0 + float(oc) * 22.0
		var ocy := 415.0 - float(oc % 3) * 15.0
		draw_circle(Vector2(ocx, ocy), 18.0 + sin(float(oc)) * 5.0, Color(0.08, 0.18, 0.04, 0.4))
	# 2. Nottingham Castle on distant hill
	var cas_x := 1050.0
	var cas_y := 250.0 - float(ch) * 15.0
	var cas_col := Color(0.06, 0.05, 0.04, 0.25)
	draw_rect(Rect2(cas_x - 30, cas_y, 60, 50), cas_col)
	draw_rect(Rect2(cas_x - 35, cas_y - 5, 10, 55), cas_col)
	draw_rect(Rect2(cas_x + 25, cas_y - 5, 10, 55), cas_col)
	for bt in range(6):
		draw_rect(Rect2(cas_x - 30 + float(bt) * 12, cas_y - 10, 8, 10), cas_col)
	draw_colored_polygon(PackedVector2Array([Vector2(cas_x - 80, 520), Vector2(cas_x - 40, cas_y + 50), Vector2(cas_x + 40, cas_y + 50), Vector2(cas_x + 80, 520)]), Color(0.06, 0.1, 0.04, 0.2))
	# 3. Archery target with arrows (Silver Arrow tournament)
	var tgt_x := 900.0 + float(ch) * 30.0
	draw_rect(Rect2(tgt_x - 2, 475, 4, 30), Color(0.12, 0.07, 0.03, 0.3))
	draw_circle(Vector2(tgt_x, 460), 15.0, Color(0.7, 0.65, 0.5, 0.25))
	draw_circle(Vector2(tgt_x, 460), 10.0, Color(0.7, 0.15, 0.1, 0.25))
	draw_circle(Vector2(tgt_x, 460), 5.0, Color(0.8, 0.7, 0.1, 0.3))
	draw_line(Vector2(tgt_x + 1, 460), Vector2(tgt_x + 20, 455), Color(0.3, 0.2, 0.08, 0.3), 1.5)
	# 4. "WANTED" poster nailed to tree
	var wp_x := 350.0 + float(ch) * 50.0
	draw_rect(Rect2(wp_x - 10, 410, 20, 25), Color(0.6, 0.55, 0.4, 0.2))
	draw_rect(Rect2(wp_x - 8, 412, 16, 3), Color(0.3, 0.1, 0.05, 0.15))
	draw_rect(Rect2(wp_x - 6, 418, 12, 12), Color(0.4, 0.3, 0.2, 0.1))
	# 5. Merry Men's campfire with smoke
	var fire_x := 600.0
	var fire_flicker := 0.3 + 0.15 * sin(_time * 5.0)
	draw_circle(Vector2(fire_x, 510), 8.0, Color(0.8, 0.4, 0.05, fire_flicker))
	draw_circle(Vector2(fire_x, 510), 15.0, Color(0.6, 0.2, 0.02, fire_flicker * 0.3))
	for sm in range(6):
		var smx := fire_x + sin(_time * 0.6 + float(sm) * 0.8) * (4.0 + float(sm) * 2.0)
		var smy := 495.0 - float(sm) * 12.0
		draw_circle(Vector2(smx, smy), 3.0 + float(sm) * 1.5, Color(0.2, 0.18, 0.15, 0.1 - float(sm) * 0.012))
	# 6. Friar Tuck's ale jug
	draw_rect(Rect2(618, 505, 8, 10), Color(0.25, 0.12, 0.05, 0.25))
	draw_arc(Vector2(626, 510), 4.0, -1.0, 1.0, 6, Color(0.25, 0.12, 0.05, 0.2), 1.5)
	# 7. Maid Marian's scarf on branch (green silk)
	var sc_sway := sin(_time * 1.2) * 8.0
	draw_line(Vector2(750, 380), Vector2(750 + sc_sway, 395), Color(0.2, 0.5, 0.25, 0.2), 2.0)
	draw_line(Vector2(750 + sc_sway, 395), Vector2(750 + sc_sway + 5, 410), Color(0.2, 0.5, 0.25, 0.15), 1.5)
	# 8. Sheriff's dark banner
	var ban_sway := sin(_time * 1.5) * 4.0
	draw_line(Vector2(1000, 350), Vector2(1000, 320), Color(0.08, 0.06, 0.04, 0.3), 2.0)
	draw_colored_polygon(PackedVector2Array([Vector2(1000, 320), Vector2(1018 + ban_sway, 325), Vector2(1015 + ban_sway, 340), Vector2(1000, 335)]), Color(0.1, 0.02, 0.02, 0.25))
	# 9. Lincoln green cloth on bush
	for lg in range(2):
		var lgx := 450.0 + float(lg) * 250.0
		draw_colored_polygon(PackedVector2Array([Vector2(lgx, 505), Vector2(lgx + 12, 498), Vector2(lgx + 20, 505), Vector2(lgx + 15, 512)]), Color(0.15, 0.35, 0.1, 0.2))
	# 10. Silver Arrow trophy (gleaming)
	var sa_x := 500.0 + float(ch) * 60.0
	var sa_gleam := 0.2 + 0.15 * sin(_time * 2.0)
	draw_line(Vector2(sa_x - 15, 498), Vector2(sa_x + 15, 492), Color(0.7, 0.75, 0.8, sa_gleam), 1.5)
	draw_colored_polygon(PackedVector2Array([Vector2(sa_x + 15, 492), Vector2(sa_x + 20, 489), Vector2(sa_x + 20, 495)]), Color(0.7, 0.75, 0.8, sa_gleam))

func _draw_alice_novel(ch: int) -> void:
	# From Lewis Carroll's "Alice's Adventures in Wonderland"
	# 1. Rabbit hole (dark opening in ground)
	var rh_x := 120.0 + float(ch) * 30.0
	draw_circle(Vector2(rh_x, 510), 12.0, Color(0.03, 0.02, 0.02, 0.4))
	draw_arc(Vector2(rh_x, 510), 12.0, 0, TAU, 16, Color(0.08, 0.06, 0.04, 0.3), 2.0)
	var card_fall := fmod(_time * 0.5, 3.0)
	if card_fall < 1.5:
		var cfy := 490.0 + card_fall * 20.0
		draw_rect(Rect2(rh_x - 3, cfy - 4, 6, 8), Color(0.9, 0.85, 0.7, 0.3 * (1.0 - card_fall / 1.5)))
	# 2. "Drink Me" bottle
	var dm_x := 350.0 + float(ch) * 40.0
	draw_rect(Rect2(dm_x - 3, 500, 6, 12), Color(0.3, 0.5, 0.6, 0.25))
	draw_rect(Rect2(dm_x - 1.5, 497, 3, 4), Color(0.3, 0.2, 0.1, 0.25))
	draw_rect(Rect2(dm_x - 4, 503, 8, 4), Color(0.7, 0.65, 0.5, 0.2))
	# 3. Mad Hatter's tea table
	var tt_x := 800.0 - float(ch) * 30.0
	draw_rect(Rect2(tt_x - 30, 480, 60, 4), Color(0.3, 0.2, 0.1, 0.25))
	draw_rect(Rect2(tt_x - 25, 484, 3, 20), Color(0.25, 0.15, 0.08, 0.2))
	draw_rect(Rect2(tt_x + 22, 484, 3, 20), Color(0.25, 0.15, 0.08, 0.2))
	draw_circle(Vector2(tt_x - 10, 475), 5.0, Color(0.6, 0.5, 0.3, 0.25))
	draw_arc(Vector2(tt_x - 15, 473), 3.0, PI * 0.5, PI * 1.5, 6, Color(0.5, 0.4, 0.25, 0.2), 1.5)
	for tc in range(3):
		draw_rect(Rect2(tt_x + float(tc) * 12.0 - 2, 476, 5, 4), Color(0.65, 0.55, 0.4, 0.2))
	var steam_a := 0.08 + 0.04 * sin(_time * 2.0)
	draw_circle(Vector2(tt_x - 10, 466), 3.0, Color(0.4, 0.38, 0.35, steam_a))
	# 4. Playing card soldiers
	for pc in range(2):
		var px := 200.0 + float(pc) * 50.0 + float(ch) * 80.0
		draw_rect(Rect2(px - 5, 462, 10, 25), Color(0.9, 0.85, 0.75, 0.2))
		draw_circle(Vector2(px, 472), 2.5, Color(0.8, 0.15, 0.1, 0.25))
		draw_line(Vector2(px - 2, 487), Vector2(px - 3, 494), Color(0.1, 0.08, 0.06, 0.15), 1.0)
		draw_line(Vector2(px + 2, 487), Vector2(px + 3, 494), Color(0.1, 0.08, 0.06, 0.15), 1.0)
	# 5. Caterpillar's mushroom with hookah smoke
	var cm_x := 950.0 + float(ch) * 20.0
	draw_rect(Rect2(cm_x - 4, 490, 8, 15), Color(0.7, 0.65, 0.5, 0.2))
	draw_arc(Vector2(cm_x, 490), 12.0, PI, TAU, 12, Color(0.7, 0.2, 0.3, 0.25), 12.0)
	for hr in range(4):
		var hry := 470.0 - float(hr) * 15.0
		var hrx := cm_x + sin(_time * 0.8 + float(hr)) * 8.0
		draw_arc(Vector2(hrx, hry), 4.0 + float(hr) * 1.5, 0, TAU, 12, Color(0.4, 0.4, 0.5, 0.08 - float(hr) * 0.015), 1.0)
	# 6. White Rabbit's pocket watch
	var pw_x := 500.0 + float(ch) * 25.0
	draw_circle(Vector2(pw_x, 508), 5.0, Color(0.7, 0.6, 0.2, 0.25))
	draw_circle(Vector2(pw_x, 508), 4.0, Color(0.85, 0.8, 0.7, 0.2))
	draw_line(Vector2(pw_x, 508), Vector2(pw_x + cos(_time * 0.5) * 2.5, 508 + sin(_time * 0.5) * 2.5), Color(0.1, 0.08, 0.05, 0.25), 0.5)
	draw_line(Vector2(pw_x + 4, 505), Vector2(pw_x + 15, 500), Color(0.6, 0.5, 0.15, 0.15), 0.5)
	# 7. Flamingo croquet mallet
	draw_arc(Vector2(650, 495), 12.0, PI * 0.5, PI * 1.5, 8, Color(0.85, 0.4, 0.5, 0.2), 2.0)
	draw_circle(Vector2(638, 495), 3.0, Color(0.85, 0.4, 0.5, 0.2))
	draw_circle(Vector2(660, 507), 4.0, Color(0.4, 0.3, 0.2, 0.2))
	# 8. "Eat Me" cake
	var ek_x := 280.0 + float(ch) * 20.0
	draw_rect(Rect2(ek_x - 5, 508, 10, 6), Color(0.7, 0.55, 0.3, 0.2))
	draw_rect(Rect2(ek_x - 4, 507, 8, 2), Color(0.8, 0.75, 0.65, 0.2))
	draw_circle(Vector2(ek_x, 506), 1.5, Color(0.7, 0.1, 0.1, 0.25))
	# 9. Looking-Glass (ornate mirror, ch2/3)
	if ch >= 2:
		draw_rect(Rect2(1138, 382, 24, 40), Color(0.5, 0.35, 0.1, 0.2))
		draw_rect(Rect2(1140, 384, 20, 36), Color(0.3, 0.35, 0.4, 0.15))
		var rip_a := 0.08 + 0.04 * sin(_time * 1.5)
		draw_circle(Vector2(1150, 402), 8.0, Color(0.5, 0.6, 0.8, rip_a))
	# 10. Pool of Tears (rippling puddle)
	var pt_x := 700.0 + float(ch) * 20.0
	draw_circle(Vector2(pt_x, 515), 20.0, Color(0.2, 0.3, 0.5, 0.1))
	for rip in range(3):
		var rr := 8.0 + float(rip) * 7.0 + sin(_time * 0.8 + float(rip)) * 2.0
		draw_arc(Vector2(pt_x, 515), rr, 0, TAU, 16, Color(0.3, 0.4, 0.6, 0.06), 1.0)

func _draw_oz_novel(ch: int) -> void:
	# From L. Frank Baum's "The Wonderful Wizard of Oz"
	# 1. Flying monkey silhouette
	var fm_x := fmod(_time * 25.0 + float(ch) * 300.0, 1500.0) - 100.0
	var fm_y := 120.0 + sin(_time * 1.5) * 20.0
	var fm_a := 0.2
	draw_circle(Vector2(fm_x, fm_y), 4.0, Color(0.15, 0.1, 0.06, fm_a))
	draw_rect(Rect2(fm_x - 3, fm_y + 4, 6, 8), Color(0.15, 0.1, 0.06, fm_a))
	var wing_f := sin(_time * 5.0) * 6.0
	draw_line(Vector2(fm_x - 3, fm_y + 2), Vector2(fm_x - 14, fm_y - 5 + wing_f), Color(0.15, 0.1, 0.06, fm_a), 1.5)
	draw_line(Vector2(fm_x + 3, fm_y + 2), Vector2(fm_x + 14, fm_y - 5 + wing_f), Color(0.15, 0.1, 0.06, fm_a), 1.5)
	# 2. Ruby slippers (glinting)
	var sl_x := 400.0 + float(ch) * 40.0
	var sl_sparkle := 0.2 + 0.15 * sin(_time * 3.0)
	draw_colored_polygon(PackedVector2Array([Vector2(sl_x - 6, 515), Vector2(sl_x - 4, 510), Vector2(sl_x + 6, 510), Vector2(sl_x + 8, 515)]), Color(0.8, 0.15, 0.15, sl_sparkle))
	draw_circle(Vector2(sl_x + 1, 512), 2.0, Color(1.0, 0.4, 0.4, sl_sparkle * 0.8))
	# 3. Tin Woodman's oil can
	var oc_x := 700.0 + float(ch) * 30.0
	draw_rect(Rect2(oc_x, 502, 8, 12), Color(0.35, 0.35, 0.4, 0.2))
	draw_rect(Rect2(oc_x + 2, 499, 3, 4), Color(0.3, 0.3, 0.35, 0.2))
	draw_line(Vector2(oc_x + 8, 504), Vector2(oc_x + 14, 500), Color(0.35, 0.35, 0.4, 0.15), 1.5)
	# 4. Wicked Witch's crystal ball
	var cb_x := 150.0 + float(ch) * 40.0
	draw_circle(Vector2(cb_x, 460), 8.0, Color(0.1, 0.08, 0.06, 0.3))
	var ball_glow := 0.2 + 0.1 * sin(_time * 1.2)
	draw_circle(Vector2(cb_x, 460), 7.0, Color(0.2, 0.6, 0.3, ball_glow))
	draw_circle(Vector2(cb_x - 2, 458), 2.0, Color(0.4, 0.9, 0.5, ball_glow * 0.6))
	draw_rect(Rect2(cb_x - 5, 468, 10, 4), Color(0.1, 0.08, 0.06, 0.25))
	# 5. Scarecrow's hat on ground
	draw_colored_polygon(PackedVector2Array([Vector2(538, 510), Vector2(562, 510), Vector2(558, 507), Vector2(542, 507)]), Color(0.2, 0.15, 0.08, 0.2))
	draw_rect(Rect2(545, 498, 10, 10), Color(0.2, 0.15, 0.08, 0.2))
	for st in range(3):
		var sta := float(st) * 0.8 - 0.8
		draw_line(Vector2(550 + cos(sta) * 4, 498), Vector2(550 + cos(sta) * 10, 494 - float(st) * 2.0), Color(0.6, 0.5, 0.2, 0.15), 1.0)
	# 6. Oz's curtain (hiding the man behind)
	var cur_x := 1000.0 - float(ch) * 20.0
	var cur_sway := sin(_time * 0.8) * 3.0
	draw_rect(Rect2(cur_x, 350, 30, 80), Color(0.15, 0.4, 0.12, 0.15))
	draw_line(Vector2(cur_x + 5, 350), Vector2(cur_x + 5 + cur_sway, 430), Color(0.12, 0.35, 0.1, 0.1), 1.0)
	draw_line(Vector2(cur_x + 15, 350), Vector2(cur_x + 15 - cur_sway, 430), Color(0.12, 0.35, 0.1, 0.1), 1.0)
	# 7. Cowardly Lion's courage medal
	var md_shine := 0.2 + 0.1 * sin(_time * 2.5)
	draw_circle(Vector2(850, 505), 4.0, Color(0.7, 0.6, 0.15, md_shine))
	for ray in range(5):
		var ra := float(ray) * TAU / 5.0 - PI / 2.0
		draw_line(Vector2(850, 505), Vector2(850 + cos(ra) * 6.0, 505 + sin(ra) * 6.0), Color(0.8, 0.7, 0.2, md_shine * 0.7), 1.0)
	# 8. Good Witch's bubble (floating iridescent sphere)
	var bub_x := 250.0 + sin(_time * 0.3) * 20.0
	var bub_y := 200.0 + cos(_time * 0.4) * 15.0
	var bub_a := 0.1 + 0.05 * sin(_time * 1.5)
	draw_arc(Vector2(bub_x, bub_y), 15.0, 0, TAU, 24, Color(0.7, 0.5, 0.8, bub_a), 1.5)
	draw_circle(Vector2(bub_x - 4, bub_y - 5), 2.0, Color(0.9, 0.85, 0.95, bub_a * 1.5))
	# 9. Additional deadly poppies near path
	for pp in range(5):
		var px := 100.0 + float(pp) * 100.0
		var p_sway := sin(_time * 1.0 + float(pp)) * 2.0
		draw_line(Vector2(px, 505), Vector2(px + p_sway, 492), Color(0.1, 0.25, 0.05, 0.3), 1.0)
		draw_circle(Vector2(px + p_sway, 490), 3.0, Color(0.8, 0.1, 0.08, 0.3))
	# 10. Toto (small dog silhouette)
	var toto_x := 600.0 + sin(_time * 0.5) * 5.0
	draw_circle(Vector2(toto_x, 505), 3.0, Color(0.15, 0.1, 0.06, 0.2))
	draw_rect(Rect2(toto_x - 4, 507, 8, 5), Color(0.15, 0.1, 0.06, 0.2))

func _draw_peter_novel(ch: int) -> void:
	# From J.M. Barrie's "Peter and Wendy"
	# 1. Jolly Roger pirate ship silhouette
	var jr_x := 200.0 + float(ch) * 30.0
	var jr_bob := sin(_time * 0.6) * 3.0
	var jr_a := 0.2
	draw_colored_polygon(PackedVector2Array([Vector2(jr_x - 30, 470 + jr_bob), Vector2(jr_x - 35, 465 + jr_bob), Vector2(jr_x + 35, 465 + jr_bob), Vector2(jr_x + 30, 470 + jr_bob)]), Color(0.08, 0.05, 0.03, jr_a))
	draw_line(Vector2(jr_x, 465 + jr_bob), Vector2(jr_x, 425 + jr_bob), Color(0.08, 0.05, 0.03, jr_a), 2.0)
	var flag_sway := sin(_time * 2.0) * 4.0
	draw_rect(Rect2(jr_x + 2, 427 + jr_bob, 15, 10), Color(0.05, 0.03, 0.02, jr_a))
	draw_circle(Vector2(jr_x + 9, 432 + jr_bob), 2.0, Color(0.5, 0.45, 0.35, jr_a))
	draw_colored_polygon(PackedVector2Array([Vector2(jr_x, 430 + jr_bob), Vector2(jr_x + 20 + flag_sway, 445 + jr_bob), Vector2(jr_x, 458 + jr_bob)]), Color(0.5, 0.45, 0.35, jr_a * 0.5))
	# 2. Tick-Tock the Crocodile
	var croc_x := 900.0 + sin(_time * 0.3) * 30.0
	draw_colored_polygon(PackedVector2Array([Vector2(croc_x - 18, 512), Vector2(croc_x - 15, 506), Vector2(croc_x + 20, 507), Vector2(croc_x + 25, 512)]), Color(0.15, 0.2, 0.08, 0.2))
	draw_colored_polygon(PackedVector2Array([Vector2(croc_x + 20, 507), Vector2(croc_x + 32, 508), Vector2(croc_x + 20, 512)]), Color(0.15, 0.2, 0.08, 0.2))
	draw_circle(Vector2(croc_x + 18, 505), 1.5, Color(0.7, 0.6, 0.1, 0.3))
	var tick := sin(_time * 6.0)
	if tick > 0.8:
		draw_circle(Vector2(croc_x, 510), 3.0, Color(0.8, 0.7, 0.2, 0.1))
	# 3. Tinker Bell (tiny glowing fairy)
	var tb_x := 600.0 + sin(_time * 1.2) * 50.0
	var tb_y := 180.0 + cos(_time * 0.9) * 30.0
	var tb_glow := 0.3 + 0.15 * sin(_time * 4.0)
	draw_circle(Vector2(tb_x, tb_y), 2.0, Color(0.9, 0.9, 0.3, tb_glow))
	draw_circle(Vector2(tb_x, tb_y), 6.0, Color(0.8, 0.8, 0.2, tb_glow * 0.25))
	for pd in range(6):
		var pdx := tb_x - cos(_time * 1.2 - float(pd) * 0.3) * 50.0
		var pdy := tb_y + float(pd) * 5.0 - cos(_time * 0.9 - float(pd) * 0.3) * 30.0
		draw_circle(Vector2(pdx, pdy + float(pd) * 2.0), 1.0, Color(0.9, 0.85, 0.3, tb_glow * (0.3 - float(pd) * 0.04)))
	# 4. Lost Boys' hideout entrance (tree stump)
	var lb_x := 450.0 + float(ch) * 20.0
	draw_rect(Rect2(lb_x - 10, 485, 20, 20), Color(0.12, 0.07, 0.03, 0.3))
	draw_circle(Vector2(lb_x, 495), 12.0, Color(0.1, 0.06, 0.02, 0.3))
	draw_arc(Vector2(lb_x, 500), 6.0, PI, TAU, 8, Color(0.08, 0.04, 0.02, 0.25), 5.0)
	# 5. Captain Hook's hook (gleaming)
	var hk_gleam := 0.2 + 0.1 * sin(_time * 2.0)
	draw_arc(Vector2(1100, 490 + float(ch) * 5.0), 5.0, 0.5, PI + 0.5, 8, Color(0.5, 0.5, 0.55, hk_gleam), 2.0)
	draw_line(Vector2(1100, 485 + float(ch) * 5.0), Vector2(1100, 475 + float(ch) * 5.0), Color(0.5, 0.5, 0.55, hk_gleam), 2.0)
	# 6. Skull Rock
	var sr_x := 1050.0 - float(ch) * 30.0
	draw_circle(Vector2(sr_x, 430), 18.0, Color(0.12, 0.1, 0.08, 0.25))
	draw_colored_polygon(PackedVector2Array([Vector2(sr_x - 15, 440), Vector2(sr_x + 15, 440), Vector2(sr_x + 10, 452), Vector2(sr_x - 10, 452)]), Color(0.12, 0.1, 0.08, 0.25))
	draw_circle(Vector2(sr_x - 5, 428), 3.0, Color(0.03, 0.02, 0.02, 0.3))
	draw_circle(Vector2(sr_x + 5, 428), 3.0, Color(0.03, 0.02, 0.02, 0.3))
	# 7. Wendy's thimble ("kiss")
	draw_circle(Vector2(750 + float(ch) * 15.0, 512), 2.5, Color(0.5, 0.5, 0.55, 0.2))
	var th_shine := 0.15 + 0.1 * sin(_time * 2.5)
	draw_circle(Vector2(749 + float(ch) * 15.0, 511), 1.0, Color(0.7, 0.7, 0.75, th_shine))
	# 8. Mermaid tails splashing
	for mt in range(2):
		var mx := 300.0 + float(mt) * 100.0 + float(ch) * 20.0
		var splash_t := fmod(_time * 0.4 + float(mt) * 1.5, 4.0)
		if splash_t < 1.0:
			var tail_y := 508 - splash_t * 15.0
			draw_colored_polygon(PackedVector2Array([Vector2(mx - 5, 508), Vector2(mx, tail_y), Vector2(mx + 5, 508)]), Color(0.2, 0.5, 0.5, 0.2 * (1.0 - splash_t)))
	# 9. Never Bird's nest (floating)
	var nb_x := 800.0 + sin(_time * 0.4) * 10.0
	draw_circle(Vector2(nb_x, 510), 8.0, Color(0.2, 0.15, 0.05, 0.2))
	draw_circle(Vector2(nb_x - 2, 507), 2.0, Color(0.7, 0.7, 0.65, 0.15))
	draw_circle(Vector2(nb_x + 2, 507), 2.0, Color(0.7, 0.7, 0.65, 0.15))
	# 10. Darling nursery window (distant warm glow)
	var nw_y := 150.0 + float(ch) * 15.0
	var nw_glow := 0.12 + 0.06 * sin(_time * 0.8)
	draw_rect(Rect2(92, nw_y - 10, 16, 20), Color(0.7, 0.55, 0.15, nw_glow))
	draw_line(Vector2(100, nw_y - 10), Vector2(100, nw_y + 10), Color(0.15, 0.1, 0.08, nw_glow * 2.0), 1.0)
	draw_line(Vector2(92, nw_y), Vector2(108, nw_y), Color(0.15, 0.1, 0.08, nw_glow * 2.0), 1.0)
	draw_rect(Rect2(82, nw_y - 12, 4, 24), Color(0.3, 0.15, 0.15, nw_glow * 0.8))
	draw_rect(Rect2(114, nw_y - 12, 4, 24), Color(0.3, 0.15, 0.15, nw_glow * 0.8))

func _draw_phantom_novel(ch: int) -> void:
	# From Gaston Leroux's "The Phantom of the Opera"
	# 1. Opera chandelier (the famous falling chandelier)
	var chand_x := 640.0
	var chand_y := 100.0 + float(ch) * 10.0
	var chand_sway := sin(_time * 0.5) * 3.0
	draw_line(Vector2(chand_x, 50), Vector2(chand_x + chand_sway, chand_y), Color(0.5, 0.45, 0.2, 0.2), 1.5)
	draw_arc(Vector2(chand_x + chand_sway, chand_y), 20.0, 0, PI, 16, Color(0.6, 0.5, 0.2, 0.2), 2.0)
	for cd in range(7):
		var cdx := chand_x + chand_sway - 18.0 + float(cd) * 6.0
		var cdy := chand_y + 3.0 + sin(float(cd) * 1.5) * 3.0
		var sparkle := 0.15 + 0.1 * sin(_time * 3.0 + float(cd) * 1.2)
		draw_line(Vector2(cdx, chand_y), Vector2(cdx, cdy + 5), Color(0.6, 0.55, 0.3, sparkle), 0.5)
		draw_circle(Vector2(cdx, cdy + 6), 1.0, Color(0.8, 0.75, 0.4, sparkle * 1.3))
	for cn in range(5):
		var cnx := chand_x + chand_sway - 12.0 + float(cn) * 6.0
		var flicker := 0.3 + 0.2 * sin(_time * 6.0 + float(cn) * 2.0)
		draw_circle(Vector2(cnx, chand_y - 3), 2.0, Color(0.9, 0.7, 0.2, flicker))
	# 2. Phantom's white half-mask
	var mask_x := 100.0 + float(ch) * 40.0
	var mask_a := 0.15 + 0.05 * sin(_time * 0.6)
	draw_arc(Vector2(mask_x, 400), 8.0, PI, TAU, 12, Color(0.85, 0.82, 0.78, mask_a), 8.0)
	draw_circle(Vector2(mask_x + 3, 398), 2.0, Color(0.03, 0.02, 0.02, mask_a * 1.5))
	# 3. Underground lake with boat
	for lw in range(10):
		var lwx := float(lw) * 130.0
		var lwy := 510.0 - float(ch) * 5.0 + sin(_time * 0.5 + float(lw) * 0.8) * 2.0
		draw_rect(Rect2(lwx, lwy, 128, 3), Color(0.05, 0.08, 0.12, 0.12))
	var boat_x := 800.0 + sin(_time * 0.2) * 15.0
	draw_colored_polygon(PackedVector2Array([Vector2(boat_x - 12, 510 - float(ch) * 5.0), Vector2(boat_x - 15, 506 - float(ch) * 5.0), Vector2(boat_x + 15, 506 - float(ch) * 5.0), Vector2(boat_x + 12, 510 - float(ch) * 5.0)]), Color(0.1, 0.07, 0.04, 0.2))
	# 4. Pipe organ
	var org_x := 1100.0
	var org_y := 380.0 + float(ch) * 10.0
	for op in range(7):
		var ph := 30.0 + sin(float(op) * 1.5) * 15.0
		draw_rect(Rect2(org_x - 18.0 + float(op) * 6.0, org_y - ph, 4, ph), Color(0.25, 0.2, 0.15, 0.2))
	draw_rect(Rect2(org_x - 20, org_y, 40, 5), Color(0.15, 0.1, 0.06, 0.25))
	# 5. Red rose with black ribbon (Erik's signature)
	var rose_x := 500.0 + float(ch) * 30.0
	draw_line(Vector2(rose_x, 510), Vector2(rose_x, 497), Color(0.1, 0.25, 0.08, 0.3), 1.5)
	draw_circle(Vector2(rose_x, 495), 4.0, Color(0.7, 0.08, 0.1, 0.3))
	draw_circle(Vector2(rose_x, 495), 2.5, Color(0.6, 0.05, 0.08, 0.35))
	draw_line(Vector2(rose_x - 3, 502), Vector2(rose_x + 8, 505), Color(0.03, 0.02, 0.02, 0.25), 1.5)
	# 6. Box Five (Phantom's private box)
	var bx_x := 350.0 + float(ch) * 20.0
	draw_rect(Rect2(bx_x, 380, 30, 20), Color(0.15, 0.04, 0.04, 0.15))
	draw_rect(Rect2(bx_x + 3, 385, 10, 10), Color(0.4, 0.08, 0.08, 0.2))
	draw_rect(Rect2(bx_x + 17, 385, 10, 10), Color(0.4, 0.08, 0.08, 0.2))
	draw_line(Vector2(bx_x, 398), Vector2(bx_x + 30, 398), Color(0.5, 0.4, 0.15, 0.15), 1.5)
	# 7. Trapdoor (the Phantom's escape routes)
	var td_x := 700.0 - float(ch) * 20.0
	draw_rect(Rect2(td_x - 10, 512, 20, 4), Color(0.08, 0.06, 0.04, 0.3))
	draw_rect(Rect2(td_x - 8, 510, 16, 4), Color(0.02, 0.01, 0.02, 0.35))
	# 8. Christine's mirror (two-way mirror to lair)
	draw_rect(Rect2(238, 390 - float(ch) * 10.0, 24, 36), Color(0.4, 0.3, 0.15, 0.2))
	draw_rect(Rect2(240, 392 - float(ch) * 10.0, 20, 32), Color(0.15, 0.18, 0.22, 0.15))
	var ghost_a := 0.06 + 0.03 * sin(_time * 0.8)
	draw_circle(Vector2(250, 400 - float(ch) * 10.0), 3.0, Color(0.5, 0.45, 0.4, ghost_a))
	# 9. Punjab lasso (coiled rope)
	var ls_x := 600.0 + float(ch) * 25.0
	for lp in range(3):
		draw_arc(Vector2(ls_x, 508), 4.0 + float(lp) * 2.5, 0, TAU, 12, Color(0.25, 0.18, 0.08, 0.15), 1.5)
	# 10. Opera stage curtains (red velvet at edges)
	for cy in range(8):
		var cw := 30.0 - float(cy) * 2.0
		draw_rect(Rect2(0, 50.0 + float(cy) * 55.0, cw, 55), Color(0.4, 0.05, 0.05, 0.08))
		draw_rect(Rect2(1280.0 - cw, 50.0 + float(cy) * 55.0, cw, 55), Color(0.4, 0.05, 0.05, 0.08))

func _draw_scrooge_novel(ch: int) -> void:
	# From Charles Dickens' "A Christmas Carol"
	# 1. Marley's door knocker (face appearing)
	var dk_x := 80.0 + float(ch) * 20.0
	draw_rect(Rect2(dk_x - 15, 410, 30, 50), Color(0.08, 0.05, 0.03, 0.3))
	var face_pulse := 0.15 + 0.1 * sin(_time * 0.8)
	draw_arc(Vector2(dk_x, 430), 5.0, 0, TAU, 12, Color(0.6, 0.5, 0.15, face_pulse), 2.0)
	draw_circle(Vector2(dk_x, 422), 5.0, Color(0.4, 0.5, 0.45, face_pulse * 0.5))
	draw_circle(Vector2(dk_x - 2, 421), 1.0, Color(0.1, 0.15, 0.12, face_pulse * 0.7))
	draw_circle(Vector2(dk_x + 2, 421), 1.0, Color(0.1, 0.15, 0.12, face_pulse * 0.7))
	# 2. Marley's chains (heavy iron links)
	for cl in range(8):
		var cx := 150.0 + float(cl) * 15.0
		var cy := 500.0 + sin(_time * 0.5 + float(cl) * 0.4) * 3.0
		draw_arc(Vector2(cx, cy), 3.0, 0, TAU, 8, Color(0.3, 0.28, 0.25, 0.15), 1.5)
	draw_rect(Rect2(265, 498, 6, 5), Color(0.25, 0.22, 0.15, 0.15))
	# 3. Counting house desk with candle
	var desk_x := 1050.0 - float(ch) * 30.0
	draw_rect(Rect2(desk_x, 470, 50, 6), Color(0.12, 0.07, 0.03, 0.3))
	draw_rect(Rect2(desk_x + 5, 476, 5, 30), Color(0.1, 0.06, 0.03, 0.25))
	draw_rect(Rect2(desk_x + 40, 476, 5, 30), Color(0.1, 0.06, 0.03, 0.25))
	draw_rect(Rect2(desk_x + 20, 458, 3, 12), Color(0.7, 0.65, 0.5, 0.25))
	var candle_flicker := 0.4 + 0.2 * sin(_time * 5.0)
	draw_circle(Vector2(desk_x + 21, 456), 3.0, Color(0.9, 0.7, 0.2, candle_flicker))
	draw_circle(Vector2(desk_x + 21, 456), 8.0, Color(0.8, 0.5, 0.1, candle_flicker * 0.15))
	draw_rect(Rect2(desk_x + 28, 466, 12, 4), Color(0.15, 0.08, 0.04, 0.2))
	# 4. Tiny Tim's crutch
	var tc_x := 400.0 + float(ch) * 30.0
	draw_line(Vector2(tc_x, 510), Vector2(tc_x + 5, 475), Color(0.3, 0.2, 0.08, 0.2), 2.0)
	draw_line(Vector2(tc_x + 3, 480), Vector2(tc_x + 12, 478), Color(0.3, 0.2, 0.08, 0.2), 2.0)
	# 5. Ghost of Christmas Past (candle-flame figure)
	var gp_x := 300.0 - float(ch) * 30.0
	var gp_glow := 0.1 + 0.06 * sin(_time * 1.5)
	draw_circle(Vector2(gp_x, 335), 4.0, Color(0.9, 0.8, 0.4, gp_glow))
	draw_colored_polygon(PackedVector2Array([Vector2(gp_x - 5, 340), Vector2(gp_x + 5, 340), Vector2(gp_x + 3, 365), Vector2(gp_x - 3, 365)]), Color(0.8, 0.7, 0.3, gp_glow * 0.8))
	draw_circle(Vector2(gp_x, 335), 15.0, Color(0.9, 0.85, 0.5, gp_glow * 0.2))
	# 6. Ghost of Christmas Present (holly wreath, ch2/3)
	if ch >= 2:
		var gpr_x := 550.0
		var gpr_a := 0.1 + 0.04 * sin(_time * 1.0)
		draw_circle(Vector2(gpr_x, 355), 8.0, Color(0.3, 0.5, 0.2, gpr_a))
		draw_rect(Rect2(gpr_x - 10, 363, 20, 25), Color(0.25, 0.45, 0.15, gpr_a))
		draw_circle(Vector2(gpr_x + 12, 360), 5.0, Color(0.15, 0.35, 0.1, gpr_a))
		draw_circle(Vector2(gpr_x + 12, 360), 2.0, Color(0.6, 0.1, 0.08, gpr_a))
	# 7. Ghost of Christmas Yet to Come (ch3 only)
	if ch == 3:
		var gf_a := 0.1 + 0.04 * sin(_time * 0.6)
		draw_colored_polygon(PackedVector2Array([Vector2(892, 320), Vector2(908, 320), Vector2(912, 360), Vector2(888, 360)]), Color(0.02, 0.02, 0.03, gf_a))
		draw_circle(Vector2(900, 318), 8.0, Color(0.02, 0.02, 0.03, gf_a))
		draw_line(Vector2(908, 335), Vector2(925, 330), Color(0.3, 0.28, 0.22, gf_a), 1.5)
	# 8. Clock striking twelve
	var clk_x := 700.0 + float(ch) * 25.0
	draw_circle(Vector2(clk_x, 380), 12.0, Color(0.12, 0.08, 0.05, 0.2))
	draw_circle(Vector2(clk_x, 380), 10.0, Color(0.15, 0.1, 0.06, 0.15))
	for hr in range(12):
		var ha := float(hr) * TAU / 12.0 - PI / 2.0
		draw_circle(Vector2(clk_x + cos(ha) * 8.0, 380 + sin(ha) * 8.0), 0.8, Color(0.5, 0.4, 0.15, 0.15))
	draw_line(Vector2(clk_x, 380), Vector2(clk_x, 373), Color(0.4, 0.3, 0.1, 0.2), 1.0)
	draw_line(Vector2(clk_x, 380), Vector2(clk_x, 375), Color(0.4, 0.3, 0.1, 0.2), 1.5)
	# 9. Snow falling
	for sn in range(15):
		var snx := fmod(float(sn) * 97.0, 1280.0)
		var sny := fmod(_time * 20.0 + float(sn) * 50.0, 600.0) + 50.0
		draw_circle(Vector2(snx + sin(_time * 0.5 + float(sn)) * 10.0, sny), 1.5, Color(0.7, 0.72, 0.75, 0.12))
	# 10. Scrooge's gravestone (ch2/3)
	if ch >= 2:
		draw_rect(Rect2(1140, 490, 20, 25), Color(0.08, 0.07, 0.06, 0.2))
		draw_arc(Vector2(1150, 490), 10.0, PI, TAU, 8, Color(0.08, 0.07, 0.06, 0.2), 10.0)
		var text_a := 0.06 + 0.03 * sin(_time * 0.5)
		draw_rect(Rect2(1144, 495, 12, 2), Color(0.15, 0.13, 0.1, text_a))



# === BATTD: GEAR FUSION FORGE ===
func _can_fuse_gear(rarity: String) -> bool:
	var next_rarity = {"tattered": "bound", "bound": "gilded", "gilded": "mythic", "mythic": "forbidden"}
	if not next_rarity.has(rarity):
		return false
	var count = 0
	for bid in owned_bindings:
		var bdata = _find_binding(bid)
		if bdata.get("rarity", "") == rarity:
			count += 1
	return count >= 3

func _perform_gear_fusion(rarity: String) -> Dictionary:
	var next_rarity_map = {"tattered": "bound", "bound": "gilded", "gilded": "mythic", "mythic": "forbidden"}
	if not next_rarity_map.has(rarity):
		return {}
	var target_rarity = next_rarity_map[rarity]
	# Find 3 gear of this rarity
	var to_consume: Array = []
	for bid in owned_bindings:
		if to_consume.size() >= 3:
			break
		var bdata = _find_binding(bid)
		if bdata.get("rarity", "") == rarity:
			# Don't consume equipped gear
			var is_equipped = false
			for t in equipped_bindings:
				if bid in equipped_bindings[t]:
					is_equipped = true
					break
			if not is_equipped:
				to_consume.append(bid)
	if to_consume.size() < 3:
		return {}
	# Remove consumed gear
	for bid in to_consume:
		owned_bindings.erase(bid)
	# Pick random gear of next rarity
	var candidates: Array = []
	for bdef in TOME_BINDINGS:
		if bdef.get("rarity", "") == target_rarity:
			candidates.append(bdef)
	if candidates.is_empty():
		return {}
	# Wish list boost: 50% chance to pick from wish list if applicable
	var picked = candidates[randi() % candidates.size()]
	if gear_wish_list.size() > 0 and randf() < 0.5:
		var wish_candidates: Array = []
		for c in candidates:
			if c.get("effect", "") in gear_wish_list or c.get("character", "") in gear_wish_list:
				wish_candidates.append(c)
		if wish_candidates.size() > 0:
			picked = wish_candidates[randi() % wish_candidates.size()]
	owned_bindings[picked["id"]] = owned_bindings.get(picked["id"], 0) + 1
	_save_game()
	return picked

# === BATTD: BOSS HEALTH BAR ===
func _update_boss_health_bar() -> void:
	_active_boss_node = null
	for enemy in get_tree().get_nodes_in_group("enemies"):
		if is_instance_valid(enemy) and "boss_scale" in enemy and enemy.boss_scale > 1.0:
			if "health" in enemy and enemy.health > 0:
				_active_boss_node = enemy
				_boss_hp_bar_timer = 0.3
				break

func _draw_boss_health_bar() -> void:
	if not is_instance_valid(_active_boss_node):
		return
	if not "health" in _active_boss_node or not "max_health" in _active_boss_node:
		return
	var hp = _active_boss_node.health
	var max_hp = _active_boss_node.max_health
	if hp <= 0 or max_hp <= 0:
		return
	var bar_x = 340.0
	var bar_y = 58.0
	var bar_w = 600.0
	var bar_h = 18.0
	var pct = clampf(float(hp) / float(max_hp), 0.0, 1.0)
	# Background
	draw_rect(Rect2(bar_x - 2, bar_y - 2, bar_w + 4, bar_h + 4), Color(0.7, 0.15, 0.1, 0.8))
	draw_rect(Rect2(bar_x, bar_y, bar_w, bar_h), Color(0.05, 0.02, 0.05, 0.9))
	# HP fill (red to yellow gradient based on HP)
	var fill_col = Color(0.9, 0.15, 0.1) if pct < 0.3 else (Color(0.9, 0.6, 0.1) if pct < 0.6 else Color(0.7, 0.15, 0.4))
	draw_rect(Rect2(bar_x, bar_y, bar_w * pct, bar_h), fill_col)
	# Shimmer
	var shimmer_x = bar_x + fmod(_time * 120.0, bar_w)
	if shimmer_x < bar_x + bar_w * pct:
		draw_rect(Rect2(shimmer_x, bar_y, 3, bar_h), Color(1.0, 1.0, 1.0, 0.15))
	# HP text
	var hp_text = "%s / %s" % [_format_number(hp), _format_number(max_hp)]
	_udraw(game_font, Vector2(640, bar_y + 14), hp_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(1.0, 0.95, 0.9, 0.9))
	# Boss name
	_udraw(game_font, Vector2(640, bar_y - 4), "BOSS", HORIZONTAL_ALIGNMENT_CENTER, -1, 11, Color(1.0, 0.7, 0.3, 0.8))

# === BATTD: ENEMY KILL COUNTER ===
func _draw_kill_counter() -> void:
	if not is_wave_active:
		return
	var total = _wave_enemies_total
	if total <= 0:
		return
	var killed = _wave_enemies_killed
	var text = "%d / %d" % [killed, total]
	var pct = clampf(float(killed) / float(total), 0.0, 1.0)
	var col = Color(0.7, 0.85, 1.0, 0.7)
	if pct > 0.8:
		col = Color(0.3, 1.0, 0.4, 0.8)
	_udraw(game_font, Vector2(640, 695), text, HORIZONTAL_ALIGNMENT_CENTER, -1, 13, col)

# === BATTD: INCOME BREAKDOWN ===
func _draw_income_breakdown() -> void:
	if _income_display_timer <= 0.0:
		return
	var alpha = clampf(_income_display_timer / 1.0, 0.0, 1.0)
	var ix = 400.0
	var iy = 130.0
	draw_rect(Rect2(ix, iy, 480, 70), Color(0.03, 0.02, 0.06, 0.85 * alpha))
	draw_rect(Rect2(ix, iy, 480, 70), Color(0.7, 0.55, 0.2, 0.4 * alpha), false, 1.0)
	var font = game_font
	_udraw(font, Vector2(640, iy + 16), "INCOME BREAKDOWN", HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(1.0, 0.85, 0.3, alpha))
	var parts: Array = []
	if _income_breakdown.get("wave_bonus", 0) > 0:
		parts.append("Wave: +%dG" % _income_breakdown["wave_bonus"])
	if _income_breakdown.get("early_send", 0) > 0:
		parts.append("Rush: +%dG" % _income_breakdown["early_send"])
	if _income_breakdown.get("combo", 0) > 0:
		parts.append("Combo: +%dG" % _income_breakdown["combo"])
	if _income_breakdown.get("lucky", 0) > 0:
		parts.append("Lucky: +%d" % _income_breakdown["lucky"])
	if _wave_rush_bonus > 0:
		parts.append("Speed: +%dG" % _wave_rush_bonus)
	var info = " | ".join(parts) if parts.size() > 0 else "No bonus income"
	_udraw(font, Vector2(640, iy + 38), info, HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(0.85, 0.8, 0.7, alpha))

# === BATTD: TOWER SYNERGY AURA VISUALS ===
func _draw_synergy_auras() -> void:
	if active_synergies.is_empty():
		return
	for tower in get_tree().get_nodes_in_group("towers"):
		if not is_instance_valid(tower):
			continue
		var tpos = tower.global_position
		var pulse = (sin(_time * 3.0 + tpos.x * 0.01) + 1.0) * 0.5
		var aura_alpha = 0.06 + pulse * 0.04
		# Draw a subtle glowing ring
		var r = 45.0 + pulse * 5.0
		draw_arc(tpos, r, 0, TAU, 32, Color(0.6, 0.3, 1.0, aura_alpha), 2.0)
		draw_arc(tpos, r + 3, 0, TAU, 32, Color(0.8, 0.5, 1.0, aura_alpha * 0.5), 1.0)

# === BATTD: TOWER BUFF ICONS ===
func _draw_tower_buff_icons() -> void:
	for tower in get_tree().get_nodes_in_group("towers"):
		if not is_instance_valid(tower):
			continue
		var tpos = tower.global_position
		var icon_x = tpos.x - 16.0
		var icon_y = tpos.y + 22.0
		var icon_count = 0
		# Show upgrade tier as small stars
		var tier = tower.upgrade_tier if "upgrade_tier" in tower else 0
		if tier > 0:
			for si in range(mini(tier, 4)):
				draw_circle(Vector2(icon_x + si * 8, icon_y), 3.0, Color(1.0, 0.85, 0.2, 0.7))
			icon_count += 1
		# Show if tower has active ability ready
		if "active_ability_ready" in tower and tower.active_ability_ready:
			var ay = icon_y + (icon_count * 10)
			draw_circle(Vector2(tpos.x, ay), 4.0, Color(0.2, 0.8, 1.0, 0.5 + sin(_time * 4.0) * 0.3))

# === BATTD: MAP COLLECTIBLES ===
func _generate_map_collectibles() -> void:
	_map_collectibles.clear()
	var rng = RandomNumberGenerator.new()
	rng.seed = current_level * 12345 + 67890
	for i in range(MAX_MAP_COLLECTIBLES):
		var cx = rng.randf_range(80.0, 1200.0)
		var cy = rng.randf_range(100.0, 600.0)
		# Avoid placing too close to path
		var too_close = false
		for pp in path_points:
			if Vector2(cx, cy).distance_to(pp) < 50.0:
				too_close = true
				break
		if too_close:
			cx = rng.randf_range(80.0, 1200.0)
			cy = rng.randf_range(100.0, 600.0)
		var reward_type = ["gold", "shards", "quills"][i % 3]
		var reward_amount = [15, 3, 2][i % 3]
		_map_collectibles.append({
			"pos": Vector2(cx, cy),
			"collected": false,
			"reward_type": reward_type,
			"reward_amount": reward_amount,
			"pulse_offset": rng.randf() * TAU,
		})

func _draw_map_collectibles() -> void:
	for mc in _map_collectibles:
		if mc["collected"]:
			continue
		var pos = mc["pos"]
		var pulse = (sin(_time * 2.5 + mc["pulse_offset"]) + 1.0) * 0.5
		var r = 8.0 + pulse * 3.0
		# Glowing orb
		draw_circle(pos, r + 6, Color(1.0, 0.85, 0.3, 0.08 + pulse * 0.05))
		draw_circle(pos, r, Color(1.0, 0.9, 0.4, 0.5 + pulse * 0.3))
		draw_circle(pos, r * 0.5, Color(1.0, 1.0, 0.8, 0.8))
		# Sparkle
		var spark_a = _time * 3.0 + mc["pulse_offset"]
		for s in range(3):
			var sa = spark_a + s * TAU / 3.0
			var sx = pos.x + cos(sa) * (r + 4.0)
			var sy = pos.y + sin(sa) * (r + 4.0)
			draw_circle(Vector2(sx, sy), 1.5, Color(1.0, 1.0, 0.6, 0.6))

func _check_collectible_click(mouse_pos: Vector2) -> bool:
	for mc in _map_collectibles:
		if mc["collected"]:
			continue
		if mouse_pos.distance_to(mc["pos"]) < 25.0:
			mc["collected"] = true
			_collectibles_found_this_game += 1
			if mc["reward_type"] == "gold":
				add_gold(mc["reward_amount"])
				spawn_floating_text(mc["pos"], "+%dG" % mc["reward_amount"], Color(1.0, 0.85, 0.2), 16.0, 1.2)
			elif mc["reward_type"] == "shards":
				player_relic_shards += mc["reward_amount"]
				spawn_floating_text(mc["pos"], "+%d Shards" % mc["reward_amount"], Color(0.6, 0.4, 1.0), 16.0, 1.2)
			elif mc["reward_type"] == "quills":
				player_quills += mc["reward_amount"]
				spawn_floating_text(mc["pos"], "+%d Quills" % mc["reward_amount"], Color(0.2, 0.8, 0.6), 16.0, 1.2)
			return true
	return false

# === BATTD: BOUNTY BOARD ===
func _generate_bounties() -> void:
	_active_bounties.clear()
	var rng = RandomNumberGenerator.new()
	rng.seed = int(_time * 1000) + current_level
	var bounty_pool = [
		{"desc": "Defeat %d enemies", "kill_type": "any", "target_range": [10, 30], "reward_type": "gold", "reward_range": [20, 50]},
		{"desc": "Defeat %d elite enemies", "kill_type": "tier2", "target_range": [3, 8], "reward_type": "shards", "reward_range": [3, 8]},
		{"desc": "Defeat %d champion enemies", "kill_type": "tier3", "target_range": [2, 5], "reward_type": "quills", "reward_range": [2, 5]},
		{"desc": "Defeat a boss", "kill_type": "boss", "target_range": [1, 1], "reward_type": "shards", "reward_range": [5, 12]},
	]
	# Pick 2 random bounties
	bounty_pool.shuffle()
	for i in range(mini(2, bounty_pool.size())):
		var bp = bounty_pool[i]
		var target = rng.randi_range(bp["target_range"][0], bp["target_range"][1])
		var reward = rng.randi_range(bp["reward_range"][0], bp["reward_range"][1])
		_active_bounties.append({
			"desc": bp["desc"] % target if bp["desc"].find("%d") >= 0 else bp["desc"],
			"kill_type": bp["kill_type"],
			"target": target,
			"progress": 0,
			"reward_type": bp["reward_type"],
			"reward_amount": reward,
		})

func _draw_bounty_board() -> void:
	if _active_bounties.is_empty():
		return
	var bx = 4.0
	var by = 420.0
	var font = game_font
	_udraw(font, Vector2(bx + 2, by), "BOUNTIES", HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(1.0, 0.7, 0.2, 0.6))
	by += 14.0
	for bounty in _active_bounties:
		var done = bounty["progress"] >= bounty["target"]
		var col = Color(0.3, 1.0, 0.4, 0.7) if done else Color(0.8, 0.75, 0.65, 0.5)
		var status = "DONE" if done else "%d/%d" % [bounty["progress"], bounty["target"]]
		var text = "%s [%s]" % [bounty["desc"], status]
		_udraw(font, Vector2(bx + 2, by), text, HORIZONTAL_ALIGNMENT_LEFT, -1, 9, col)
		by += 12.0

# === BATTD: GEAR AUTO-EQUIP ===
func _auto_equip_best_gear(tower_type) -> int:
	if not survivor_progress.has(tower_type):
		return 0
	var max_slots = _get_binding_slots(tower_type)
	var current_equipped = equipped_bindings.get(tower_type, []).duplicate()
	# Get all owned unequipped gear
	var available: Array = []
	for bid in owned_bindings:
		var is_eq = false
		for t in equipped_bindings:
			if bid in equipped_bindings[t]:
				is_eq = true
				break
		if not is_eq:
			available.append(bid)
	# Also include currently equipped on this tower
	for bid in current_equipped:
		available.append(bid)
	# Score each piece of gear
	var scored: Array = []
	var rarity_scores = {"tattered": 1, "bound": 2, "gilded": 3, "mythic": 4, "forbidden": 5}
	for bid in available:
		var bdata = _find_binding(bid)
		if bdata.is_empty():
			continue
		var score = rarity_scores.get(bdata.get("rarity", "tattered"), 1)
		# Bonus for character-specific gear
		var char_name = ""
		var tower_names_map = {TowerType.ROBIN_HOOD: "robin_hood", TowerType.ALICE: "alice", TowerType.WICKED_WITCH: "wicked_witch", TowerType.PETER_PAN: "peter_pan", TowerType.PHANTOM: "phantom", TowerType.SCROOGE: "scrooge", TowerType.SHERLOCK: "sherlock", TowerType.TARZAN: "tarzan", TowerType.DRACULA: "dracula", TowerType.MERLIN: "merlin", TowerType.FRANKENSTEIN: "frankenstein", TowerType.SHADOW_AUTHOR: "shadow_author"}
		char_name = tower_names_map.get(tower_type, "")
		if bdata.get("character", "") == char_name:
			score += 2  # Prefer character gear for set bonus
		scored.append({"id": bid, "score": score})
	# Sort by score descending
	scored.sort_custom(func(a, b): return a["score"] > b["score"])
	# Equip top N
	equipped_bindings[tower_type] = []
	var equipped_count = 0
	for entry in scored:
		if equipped_count >= max_slots:
			break
		equipped_bindings[tower_type].append(entry["id"])
		equipped_count += 1
	_save_game()
	return equipped_count

# === BATTD: CRIT STREAK ===
func register_crit_hit() -> void:
	_crit_streak += 1
	_crit_streak_timer = 3.0
	if _crit_streak > _crit_streak_best:
		_crit_streak_best = _crit_streak
	if _crit_streak >= 3:
		spawn_floating_text(Vector2(640, 120), "CRIT STREAK x%d!" % _crit_streak, Color(1.0, 0.3, 0.1), 16.0, 0.8)

func get_crit_streak_bonus() -> float:
	if _crit_streak < 3:
		return 0.0
	return clampf(float(_crit_streak - 2) * 0.05, 0.0, 0.50)  # +5% per streak, max +50%

# === BATTD: POST-VICTORY STATS ===
func _draw_stats_recap() -> void:
	if not _show_stats_screen or _session_stats.is_empty():
		return
	var font = game_font
	var cx = 640.0
	var cy = 280.0
	draw_rect(Rect2(340, 200, 600, 280), Color(0.03, 0.02, 0.06, 0.95))
	draw_rect(Rect2(340, 200, 600, 280), Color(0.7, 0.55, 0.2, 0.6), false, 2.0)
	_udraw(font, Vector2(cx, 225), "BATTLE RECAP", HORIZONTAL_ALIGNMENT_CENTER, -1, 20, Color(1.0, 0.85, 0.3))
	var stats_list = [
		["Waves Cleared", str(_session_stats.get("waves_cleared", 0))],
		["Enemies Defeated", str(_session_stats.get("total_kills", 0))],
		["Gold Earned", str(_session_stats.get("total_gold_earned", 0))],
		["Lucky Drops", str(_session_stats.get("lucky_drops", 0))],
		["Bounties Done", str(_session_stats.get("bounties_done", 0))],
		["Best Combo", str(_session_stats.get("combo_best", 0))],
		["Early Send Bonus", "+%dG" % _session_stats.get("early_send_total", 0)],
	]
	var sy = 250.0
	for stat in stats_list:
		_udraw(font, Vector2(400, sy), stat[0] + ":", HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.8, 0.75, 0.65))
		_udraw(font, Vector2(860, sy), stat[1], HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(1.0, 0.9, 0.6))
		sy += 22.0
	_udraw(font, Vector2(cx, sy + 15), "Tap to continue", HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(0.6, 0.6, 0.6, 0.5 + sin(_time * 3.0) * 0.3))

# === BATTD: GEAR WISH LIST MANAGEMENT ===
func _toggle_wish_list(effect_type: String) -> void:
	if effect_type in gear_wish_list:
		gear_wish_list.erase(effect_type)
	else:
		if gear_wish_list.size() >= 3:
			gear_wish_list.pop_front()
		gear_wish_list.append(effect_type)
	_save_game()


# === BATTD2: INSTA-TOWERS ===
func _place_insta_tower(pos: Vector2, insta_idx: int) -> void:
	if insta_idx < 0 or insta_idx >= insta_towers.size():
		return
	if not _is_valid_placement(pos):
		info_label.text = "Can't place there!"
		return
	var insta = insta_towers[insta_idx]
	var tower_type = insta.get("type", TowerType.ROBIN_HOOD)
	if not tower_scenes.has(tower_type) and not new_tower_scenes.has(tower_type):
		return
	var scene = tower_scenes.get(tower_type, new_tower_scenes.get(tower_type, null))
	if not scene:
		return
	var tower = scene.instantiate()
	tower.position = pos
	tower.base_cost = 0
	tower.set_meta("tower_type_enum", tower_type)
	towers_node.add_child(tower)
	_apply_meta_buffs(tower, tower_type)
	placed_tower_positions.append(pos)
	# Apply pre-built tier
	var target_tier = insta.get("tier", 0)
	for t in range(target_tier):
		if tower.has_method("purchase_upgrade"):
			tower.purchase_upgrade()
	_build_effects.append({"pos": pos, "timer": 0.5, "max_timer": 0.5})
	spawn_floating_text(pos + Vector2(0, -30), "INSTA-TOWER!", Color(0.3, 1.0, 0.8), 18.0, 1.5)
	insta_towers.remove_at(insta_idx)
	_placing_insta = false
	_insta_index = -1
	_save_game()

func _award_insta_tower() -> void:
	var types = [TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH, TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE]
	var t = types[randi() % types.size()]
	var tier = randi_range(0, 2)  # Tier 0-2
	insta_towers.append({"type": t, "tier": tier})
	var tname = tower_info[t]["name"]
	spawn_floating_text(Vector2(640, 260), "INSTA-TOWER: %s T%d!" % [tname, tier], Color(0.3, 1.0, 0.8), 16.0, 2.0)

# === BATTD2: GEAR ENCHANTING ===
func _enchant_gear(binding_id: String) -> Dictionary:
	if player_quills < ENCHANT_COST_QUILLS:
		return {}
	var bdata = _find_binding(binding_id)
	if bdata.is_empty():
		return {}
	player_quills -= ENCHANT_COST_QUILLS
	var effect = ENCHANT_EFFECTS[randi() % ENCHANT_EFFECTS.size()]
	var bonus_val = randf_range(0.03, 0.08)
	# Store enchantment as metadata on the binding
	if not bdata.has("enchant"):
		bdata["enchant"] = {"effect": effect, "value": bonus_val}
	_save_game()
	return {"effect": effect, "value": bonus_val}

# === BATTD2: CHARACTER BONDS ===
func _check_character_bonds() -> void:
	_active_bonds.clear()
	var tower_positions: Dictionary = {}  # TowerType -> Vector2
	for tower in get_tree().get_nodes_in_group("towers"):
		if not is_instance_valid(tower):
			continue
		var sp = tower.get_script().resource_path.get_file() if tower.get_script() else ""
		var type_map = {"robin_hood.gd": 0, "alice.gd": 1, "wicked_witch.gd": 2, "peter_pan.gd": 3, "phantom.gd": 4, "scrooge.gd": 5, "sherlock.gd": 6, "tarzan.gd": 7, "dracula.gd": 8, "merlin.gd": 9, "frankenstein.gd": 10, "shadow_author.gd": 11}
		if type_map.has(sp):
			tower_positions[type_map[sp]] = tower.global_position
	for pair in BOND_PAIRS:
		if tower_positions.has(pair[0]) and tower_positions.has(pair[1]):
			var dist = tower_positions[pair[0]].distance_to(tower_positions[pair[1]])
			if dist <= BOND_RADIUS:
				_active_bonds.append({"pair": pair, "bonus": BOND_BONUS})

func _draw_character_bonds() -> void:
	for bond in _active_bonds:
		var tower_positions: Dictionary = {}
		for tower in get_tree().get_nodes_in_group("towers"):
			if not is_instance_valid(tower):
				continue
			var sp = tower.get_script().resource_path.get_file() if tower.get_script() else ""
			var type_map = {"robin_hood.gd": 0, "alice.gd": 1, "wicked_witch.gd": 2, "peter_pan.gd": 3, "phantom.gd": 4, "scrooge.gd": 5, "sherlock.gd": 6, "tarzan.gd": 7, "dracula.gd": 8, "merlin.gd": 9, "frankenstein.gd": 10, "shadow_author.gd": 11}
			if type_map.has(sp):
				tower_positions[type_map[sp]] = tower.global_position
		if tower_positions.has(bond["pair"][0]) and tower_positions.has(bond["pair"][1]):
			var p1 = tower_positions[bond["pair"][0]]
			var p2 = tower_positions[bond["pair"][1]]
			var mid = (p1 + p2) * 0.5
			var pulse = (sin(_time * 2.0) + 1.0) * 0.5
			draw_line(p1, p2, Color(1.0, 0.7, 0.3, 0.08 + pulse * 0.06), 2.0)
			draw_circle(mid, 6.0 + pulse * 3.0, Color(1.0, 0.8, 0.3, 0.1 + pulse * 0.05))
			_udraw(game_font, mid + Vector2(0, -12), "BOND", HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(1.0, 0.8, 0.3, 0.4 + pulse * 0.2))

# === BATTD2: MULTI-WAVE RUSH ===
func _start_multi_wave(count: int) -> void:
	if is_wave_active:
		return
	_multi_wave_active = true
	_multi_wave_count = count
	# Double/triple the gold bonus for risk
	var multi_bonus = 10 * count
	add_gold(multi_bonus)
	spawn_floating_text(Vector2(640, 240), "MULTI-WAVE x%d! +%dG" % [count, multi_bonus], Color(1.0, 0.4, 0.1), 20.0, 1.5)
	_start_next_wave()

# === BATTD2: PATH TRAPS ===
func _place_path_trap(pos: Vector2, trap_type: int) -> bool:
	if trap_type < 0 or trap_type >= TRAP_TYPES.size():
		return false
	var trap = TRAP_TYPES[trap_type]
	var cost = trap["cost"]
	if not spend_gold(cost):
		info_label.text = "Need %dG for %s!" % [cost, trap["name"]]
		_insufficient_gold_flash = 1.0
		return false
	if _dist_to_path(pos) > 50.0:
		add_gold(cost)
		info_label.text = "Must place on the path!"
		return false
	_path_traps.append({
		"pos": pos,
		"type": trap_type,
		"uses_left": trap.get("uses", 5),
		"damage": trap.get("damage", 0.0),
		"slow": trap.get("slow", 0.0),
		"duration": trap.get("duration", 0.0),
		"radius": 40.0,
	})
	spawn_floating_text(pos + Vector2(0, -20), trap["name"] + "!", Color(0.8, 0.4, 0.1), 14.0, 1.0)
	_placing_trap = -1
	return true

func _process_path_traps() -> void:
	for enemy in get_tree().get_nodes_in_group("enemies"):
		if not is_instance_valid(enemy):
			continue
		for trap in _path_traps:
			if trap["uses_left"] <= 0:
				continue
			if enemy.global_position.distance_to(trap["pos"]) < trap["radius"]:
				if trap["damage"] > 0 and enemy.has_method("take_damage"):
					enemy.take_damage(trap["damage"], "physical")
					trap["uses_left"] -= 1
					spawn_damage_number(enemy.global_position, trap["damage"], false)
				elif trap["slow"] > 0 and "speed_multiplier" in enemy:
					enemy.speed_multiplier = maxf(enemy.speed_multiplier - trap["slow"], 0.2)
					trap["uses_left"] -= 1
	# Remove depleted traps
	_path_traps = _path_traps.filter(func(t): return t["uses_left"] > 0)

func _draw_path_traps() -> void:
	for trap in _path_traps:
		var pos = trap["pos"]
		var t_type = trap["type"]
		var alpha = 0.6 + sin(_time * 2.0 + pos.x * 0.01) * 0.2
		if t_type == 0:  # Spike strip
			for si in range(5):
				var sx = pos.x - 12 + si * 6
				draw_line(Vector2(sx, pos.y), Vector2(sx, pos.y - 6), Color(0.7, 0.7, 0.7, alpha), 1.5)
		elif t_type == 1:  # Tar pit
			draw_circle(pos, 15.0, Color(0.15, 0.1, 0.05, alpha * 0.7))
			draw_circle(pos, 10.0, Color(0.1, 0.08, 0.03, alpha * 0.9))
		elif t_type == 2:  # Fire mine
			draw_circle(pos, 8.0, Color(0.9, 0.3, 0.1, alpha * 0.5))
			draw_circle(pos, 4.0, Color(1.0, 0.6, 0.2, alpha))
		# Uses remaining
		_udraw(game_font, pos + Vector2(0, 10), str(trap["uses_left"]), HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(1.0, 1.0, 1.0, 0.5))

# === BATTD2: TOWER SACRIFICE ===
func _sacrifice_tower(source: Node2D, target: Node2D) -> void:
	if not is_instance_valid(source) or not is_instance_valid(target):
		return
	if source == target:
		return
	# Grant +15% permanent damage buff to target
	if "bonus_damage_mult" in target:
		target.bonus_damage_mult += 0.15
	elif target.has_method("set_meta"):
		var current = target.get_meta("sacrifice_bonus", 0.0)
		target.set_meta("sacrifice_bonus", current + 0.15)
	# Sell source for 0 gold (sacrifice = no refund)
	var src_pos = source.global_position
	var idx = placed_tower_positions.find(src_pos)
	if idx >= 0:
		placed_tower_positions.remove_at(idx)
	source.queue_free()
	spawn_floating_text(target.global_position + Vector2(0, -30), "SACRIFICE +15%!", Color(1.0, 0.3, 0.8), 18.0, 1.5)
	_sacrifice_mode = false
	_sacrifice_source = null
	_deselect_tower()

# === BATTD2: ENEMY INTEL ===
func _show_enemy_intel(enemy: Node2D) -> void:
	_intel_target = enemy
	_intel_timer = 4.0

func _draw_enemy_intel() -> void:
	if not is_instance_valid(_intel_target) or _intel_timer <= 0.0:
		return
	var enemy = _intel_target
	var pos = enemy.global_position
	var alpha = clampf(_intel_timer / 1.0, 0.0, 1.0)
	var px = pos.x + 30.0
	var py = pos.y - 60.0
	if px + 140.0 > 1260.0:
		px = pos.x - 170.0
	draw_rect(Rect2(px - 2, py - 2, 144, 72), Color(0.7, 0.15, 0.1, 0.6 * alpha))
	draw_rect(Rect2(px, py, 140, 68), Color(0.05, 0.03, 0.06, 0.9 * alpha))
	var hp = enemy.health if "health" in enemy else 0
	var max_hp = enemy.max_health if "max_health" in enemy else 1
	var spd = enemy.speed if "speed" in enemy else 0
	var tier = enemy.enemy_tier if "enemy_tier" in enemy else 0
	var is_boss = enemy.boss_scale > 1.0 if "boss_scale" in enemy else false
	var y = py + 14.0
	var font = game_font
	_udraw(font, Vector2(px + 4, y), "HP: %s/%s" % [_format_number(hp), _format_number(max_hp)], HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(1.0, 0.4, 0.3, alpha))
	y += 14.0
	_udraw(font, Vector2(px + 4, y), "SPD: %.0f" % spd, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.3, 0.8, 1.0, alpha))
	y += 14.0
	_udraw(font, Vector2(px + 4, y), "TIER: %d" % tier, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.8, 0.8, 0.5, alpha))
	y += 14.0
	if is_boss:
		_udraw(font, Vector2(px + 4, y), "BOSS", HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(1.0, 0.3, 0.1, alpha))
	# HP bar on enemy
	var bar_w = 30.0
	var pct = clampf(float(hp) / float(max(1, max_hp)), 0.0, 1.0)
	draw_rect(Rect2(pos.x - bar_w * 0.5, pos.y - 20, bar_w, 4), Color(0.2, 0.2, 0.2, alpha * 0.8))
	draw_rect(Rect2(pos.x - bar_w * 0.5, pos.y - 20, bar_w * pct, 4), Color(0.9, 0.2, 0.1, alpha))

# === BATTD2: WAVE BLESSING ===
func _activate_blessing(blessing_idx: int) -> bool:
	if blessing_idx < 0 or blessing_idx >= BLESSING_OPTIONS.size():
		return false
	if not spend_gold(BLESSING_COST):
		info_label.text = "Need %dG for blessing!" % BLESSING_COST
		_insufficient_gold_flash = 1.0
		return false
	var blessing = BLESSING_OPTIONS[blessing_idx]
	_blessing_active = true
	_blessing_timer = BLESSING_DURATION
	_blessing_type = blessing["type"]
	# Apply buff to all towers temporarily
	for tower in get_tree().get_nodes_in_group("towers"):
		if is_instance_valid(tower) and tower.has_method("set_meta"):
			tower.set_meta("blessing_" + _blessing_type, blessing["value"])
	spawn_floating_text(Vector2(640, 200), "BLESSING: %s!" % blessing["name"], Color(0.4, 0.8, 1.0), 20.0, 2.0)
	return true

func _draw_blessing_indicator() -> void:
	if not _blessing_active:
		return
	var pct = clampf(_blessing_timer / BLESSING_DURATION, 0.0, 1.0)
	var bar_w = 120.0
	var bar_x = 640.0 - bar_w * 0.5
	var bar_y = 50.0
	draw_rect(Rect2(bar_x, bar_y, bar_w, 6), Color(0.1, 0.1, 0.15, 0.6))
	draw_rect(Rect2(bar_x, bar_y, bar_w * pct, 6), Color(0.3, 0.7, 1.0, 0.8))
	_udraw(game_font, Vector2(640, bar_y - 2), _blessing_type.to_upper(), HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(0.4, 0.8, 1.0, 0.7))

# === BATTD2: EMERGENCY RECALL ===
func _emergency_recall() -> void:
	if not is_wave_active:
		return
	var total_refund = 0
	var towers_to_remove: Array = []
	for tower in get_tree().get_nodes_in_group("towers"):
		if is_instance_valid(tower):
			var sv = 0
			if tower.has_method("get_sell_value"):
				sv = int(tower.get_sell_value() * 0.5)  # 50% of sell value (which is already 60%)
			total_refund += sv
			towers_to_remove.append(tower)
	for tower in towers_to_remove:
		var tpos = tower.global_position
		var idx = placed_tower_positions.find(tpos)
		if idx >= 0:
			placed_tower_positions.remove_at(idx)
		tower.queue_free()
	placed_tower_positions.clear()
	purchased_towers.clear()
	add_gold(total_refund)
	spawn_floating_text(Vector2(640, 300), "EMERGENCY RECALL +%dG!" % total_refund, Color(1.0, 0.3, 0.2), 22.0, 2.0)
	_screen_shake_timer = 0.5
	_screen_shake_intensity = 6.0
	info_label.text = "All towers recalled! +%dG refunded." % total_refund

# === BATTD2: TOWER XP BAR ===
func _draw_tower_xp_bars() -> void:
	for tower in get_tree().get_nodes_in_group("towers"):
		if not is_instance_valid(tower):
			continue
		if not "damage_dealt" in tower:
			continue
		var tpos = tower.global_position
		var dmg = tower.damage_dealt
		# Simple XP bar based on damage thresholds
		var xp_threshold = 500.0 + float(tower.upgrade_tier if "upgrade_tier" in tower else 0) * 1000.0
		var pct = clampf(fmod(dmg, xp_threshold) / xp_threshold, 0.0, 1.0)
		var bar_w = 24.0
		var bar_h = 3.0
		var bx = tpos.x - bar_w * 0.5
		var by = tpos.y + 18.0
		draw_rect(Rect2(bx, by, bar_w, bar_h), Color(0.15, 0.15, 0.2, 0.5))
		draw_rect(Rect2(bx, by, bar_w * pct, bar_h), Color(0.3, 0.7, 1.0, 0.6))

# === BATTD2: OVERCHARGE ===
func _overcharge_tower(tower: Node2D) -> bool:
	if not is_instance_valid(tower):
		return false
	if not spend_gold(OVERCHARGE_COST):
		info_label.text = "Need %dG to overcharge!" % OVERCHARGE_COST
		_insufficient_gold_flash = 1.0
		return false
	_overcharged_tower = tower
	_overcharge_timer = OVERCHARGE_DURATION
	if "fire_rate" in tower:
		tower.set_meta("overcharge_original_rate", tower.fire_rate)
		tower.fire_rate *= 0.5  # Half fire rate = double speed
	spawn_floating_text(tower.global_position + Vector2(0, -30), "OVERCHARGED!", Color(1.0, 0.5, 0.1), 18.0, 1.5)
	return true

func _draw_overcharge_effect() -> void:
	if not is_instance_valid(_overcharged_tower) or _overcharge_timer <= 0.0:
		return
	var pos = _overcharged_tower.global_position
	var pulse = (sin(_time * 8.0) + 1.0) * 0.5
	var r = 20.0 + pulse * 8.0
	draw_arc(pos, r, 0, TAU, 24, Color(1.0, 0.5, 0.1, 0.15 + pulse * 0.1), 2.0)
	draw_arc(pos, r + 4, 0, TAU, 24, Color(1.0, 0.7, 0.2, 0.08), 1.0)
	# Timer text
	_udraw(game_font, pos + Vector2(0, -25), "%.0fs" % _overcharge_timer, HORIZONTAL_ALIGNMENT_CENTER, -1, 10, Color(1.0, 0.7, 0.2, 0.7))

# === BATTD2: PATH EVENTS ===
func _spawn_path_event() -> void:
	if path_points.is_empty():
		return
	var idx = randi() % path_points.size()
	var pos = path_points[idx]
	var event_types = ["lightning", "rockfall", "fire_burst"]
	var etype = event_types[randi() % event_types.size()]
	var damage = randf_range(30.0, 80.0)
	_path_events.append({"pos": pos, "type": etype, "timer": 2.0, "damage": damage, "hit": false})
	# Deal damage to nearby enemies
	for enemy in get_tree().get_nodes_in_group("enemies"):
		if is_instance_valid(enemy) and enemy.global_position.distance_to(pos) < 50.0:
			if enemy.has_method("take_damage"):
				enemy.take_damage(damage, "physical")
				spawn_damage_number(enemy.global_position, damage, false)

func _draw_path_events() -> void:
	for pe in _path_events:
		var pos = pe["pos"]
		var t = pe["timer"]
		var alpha = clampf(t / 1.0, 0.0, 1.0)
		if pe["type"] == "lightning":
			# Lightning bolt effect
			var top = pos + Vector2(randf_range(-5, 5), -80)
			for i in range(4):
				var p1 = top.lerp(pos, float(i) / 4.0) + Vector2(randf_range(-8, 8), 0)
				var p2 = top.lerp(pos, float(i + 1) / 4.0) + Vector2(randf_range(-8, 8), 0)
				draw_line(p1, p2, Color(0.8, 0.9, 1.0, alpha * 0.7), 2.0)
			draw_circle(pos, 15.0 * alpha, Color(0.7, 0.85, 1.0, alpha * 0.15))
		elif pe["type"] == "rockfall":
			draw_circle(pos, 12.0 * alpha, Color(0.5, 0.4, 0.3, alpha * 0.5))
			draw_circle(pos, 6.0, Color(0.6, 0.5, 0.4, alpha * 0.7))
		elif pe["type"] == "fire_burst":
			draw_circle(pos, 20.0 * alpha, Color(1.0, 0.4, 0.1, alpha * 0.2))
			draw_circle(pos, 10.0, Color(1.0, 0.6, 0.2, alpha * 0.5))

# === BATTD2: GEAR REROLL ===
func _reroll_gear(binding_id: String) -> Dictionary:
	if player_relic_shards < REROLL_SHARD_COST:
		return {}
	var bdata = _find_binding(binding_id)
	if bdata.is_empty():
		return {}
	var current_rarity = bdata.get("rarity", "tattered")
	player_relic_shards -= REROLL_SHARD_COST
	# Remove old binding
	owned_bindings.erase(binding_id)
	# Unequip if equipped
	for t in equipped_bindings:
		if binding_id in equipped_bindings[t]:
			equipped_bindings[t].erase(binding_id)
	# Find a random binding of the same rarity
	var candidates: Array = []
	for b in TOME_BINDINGS:
		if b.get("rarity", "") == current_rarity and b["id"] != binding_id:
			candidates.append(b)
	if candidates.is_empty():
		owned_bindings[binding_id] = owned_bindings.get(binding_id, 0) + 1  # Give back if no alternatives
		return {}
	var picked = candidates[randi() % candidates.size()]
	owned_bindings[picked["id"]] = owned_bindings.get(picked["id"], 0) + 1
	_save_game()
	return picked

# === BATTD2: STORYBOOK PAGE DRAWING ===
func _draw_storybook_page() -> void:
	if _level_page_collected:
		return
	var pos = _level_page_pos
	var pulse = (sin(_time * 2.0) + 1.0) * 0.5
	# Glowing page/scroll
	var pw = 14.0
	var ph = 18.0
	draw_rect(Rect2(pos.x - pw * 0.5, pos.y - ph * 0.5, pw, ph), Color(0.95, 0.9, 0.7, 0.7 + pulse * 0.2))
	draw_rect(Rect2(pos.x - pw * 0.5, pos.y - ph * 0.5, pw, ph), Color(0.85, 0.7, 0.3, 0.8), false, 1.0)
	# Text lines on page
	for li in range(3):
		var ly = pos.y - ph * 0.3 + li * 4.0
		draw_line(Vector2(pos.x - 4, ly), Vector2(pos.x + 4, ly), Color(0.4, 0.3, 0.2, 0.5), 0.5)
	# Glow
	draw_circle(pos, 16.0 + pulse * 4.0, Color(1.0, 0.9, 0.5, 0.06 + pulse * 0.04))

func _check_page_click(mouse_pos: Vector2) -> bool:
	if _level_page_collected:
		return false
	if mouse_pos.distance_to(_level_page_pos) < 25.0:
		_level_page_collected = true
		storybook_pages_found[str(current_level)] = true
		player_relic_shards += PAGE_SHARD_REWARD
		spawn_floating_text(_level_page_pos, "PAGE FOUND! +%d Shards" % PAGE_SHARD_REWARD, Color(0.95, 0.85, 0.4), 16.0, 1.5)
		_save_game()
		return true
	return false

# === BATTD2: GEAR SET DISPLAY ===
func _get_set_progress(tower_type) -> Dictionary:
	var char_name = ""
	var tower_names_map = {TowerType.ROBIN_HOOD: "robin_hood", TowerType.ALICE: "alice", TowerType.WICKED_WITCH: "wicked_witch", TowerType.PETER_PAN: "peter_pan", TowerType.PHANTOM: "phantom", TowerType.SCROOGE: "scrooge", TowerType.SHERLOCK: "sherlock", TowerType.TARZAN: "tarzan", TowerType.DRACULA: "dracula", TowerType.MERLIN: "merlin", TowerType.FRANKENSTEIN: "frankenstein", TowerType.SHADOW_AUTHOR: "shadow_author"}
	char_name = tower_names_map.get(tower_type, "")
	var total = 0
	var owned = 0
	for b in TOME_BINDINGS:
		if b.get("character", "") == char_name:
			total += 1
			if b["id"] in owned_bindings:
				owned += 1
	return {"owned": owned, "total": total, "character": char_name}

# === BATTD2: CHALLENGE HANDICAPS ===
func _apply_handicaps() -> void:
	for h in _handicaps_active:
		if h.has("gold_mult"):
			gold = int(float(gold) * h["gold_mult"])
		if h.has("lives_reduce"):
			lives = maxi(1, lives - h["lives_reduce"])
	update_hud()


# === LAYERED MUSIC SYSTEM FUNCTIONS ===

func _get_song_for_level(level_idx: int) -> int:
	for i in MAP_SONGS.size():
		if level_idx in MAP_SONGS[i]["levels"]:
			return i
	return 0  # Default to first song

func _start_layered_music(level_idx: int) -> void:
	_stop_layered_music()
	_music_song_index = _get_song_for_level(level_idx)
	var song = MAP_SONGS[_music_song_index]
	var bpm: float = float(song["bpm"])
	var beats_per_bar: int = 4
	var total_beats: int = MUSIC_LOOP_BARS * beats_per_bar  # 16 beats
	var beat_dur: float = 60.0 / bpm
	var loop_dur: float = float(total_beats) * beat_dur
	var loop_samples: int = int(MUSIC_GEN_RATE * loop_dur)
	var root: float = song["root"]
	var scale: Array = song["scale"]
	var chords: Array = song["chord_roots"]

	# Generate 7 layers
	var layer_wavs: Array = []

	# --- Layer 0: DRUMS (kick + snare + hi-hat + ghost notes + fill) ---
	var drum_data := PackedFloat32Array()
	drum_data.resize(loop_samples)
	var drum_rng := RandomNumberGenerator.new()
	drum_rng.seed = _music_song_index * 42424
	for beat in total_beats:
		var beat_start: int = int(float(beat) * beat_dur * MUSIC_GEN_RATE)
		var bar_num: int = beat / 4
		var beat_in_bar: int = beat % 4
		# --- KICK: downbeat + occasional pickup kicks ---
		var play_kick: bool = beat_in_bar == 0
		# Add pickup kick on beat 3 of bars 1 and 3 for groove
		if beat_in_bar == 3 and (bar_num == 1 or bar_num == 3):
			play_kick = true
		if play_kick:
			for s in mini(int(MUSIC_GEN_RATE * 0.08), loop_samples - beat_start):
				var t: float = float(s) / MUSIC_GEN_RATE
				var env: float = exp(-t * 40.0)
				var kick: float = sin(t * (80.0 - t * 300.0) * TAU) * env * 0.30
				drum_data[beat_start + s] += kick
		# --- SNARE: backbeat + ghost notes ---
		if beat_in_bar == 2:
			drum_rng.seed = beat * 1234 + _music_song_index * 5678
			for s in mini(int(MUSIC_GEN_RATE * 0.06), loop_samples - beat_start):
				var t: float = float(s) / MUSIC_GEN_RATE
				var env: float = exp(-t * 30.0)
				var snare: float = (drum_rng.randf() * 2.0 - 1.0) * env * 0.15
				snare += sin(t * 200.0 * TAU) * exp(-t * 60.0) * 0.12
				drum_data[beat_start + s] += snare
		# Ghost snare on the "e" of beat 1 and "a" of beat 3 (16th note subdivisions)
		if beat_in_bar == 1 or beat_in_bar == 3:
			var ghost_offset: int = int(beat_dur * 0.25 * MUSIC_GEN_RATE)  # 16th note offset
			var ghost_start: int = beat_start + ghost_offset
			if ghost_start < loop_samples:
				drum_rng.seed = beat * 5555 + _music_song_index * 9876
				var ghost_vol: float = 0.08 + drum_rng.randf() * 0.04  # Soft, humanized
				for s in mini(int(MUSIC_GEN_RATE * 0.03), loop_samples - ghost_start):
					var t: float = float(s) / MUSIC_GEN_RATE
					var env: float = exp(-t * 50.0)
					drum_data[ghost_start + s] += (drum_rng.randf() * 2.0 - 1.0) * env * ghost_vol
		# --- FILL on last bar, beats 3-4 (rapid snare + tom hits) ---
		if bar_num == 3 and beat_in_bar >= 2:
			for fill_16th in 4:
				var fill_offset: int = beat_start + int(float(fill_16th) * beat_dur * 0.25 * MUSIC_GEN_RATE)
				if fill_offset >= loop_samples:
					break
				drum_rng.seed = beat * 3333 + fill_16th * 7777 + _music_song_index * 1111
				# Alternating high/low tom feel (different pitch)
				var tom_freq: float = 120.0 + float(fill_16th) * 30.0
				for s in mini(int(MUSIC_GEN_RATE * 0.04), loop_samples - fill_offset):
					var t: float = float(s) / MUSIC_GEN_RATE
					var env: float = exp(-t * 35.0)
					var tom: float = sin(t * tom_freq * TAU) * env * 0.18
					tom += (drum_rng.randf() * 2.0 - 1.0) * exp(-t * 60.0) * 0.08
					drum_data[fill_offset + s] += tom
		# --- HI-HAT: every beat + offbeat 8ths ---
		drum_rng.seed = beat * 9999 + _music_song_index * 3210
		# Open hi-hat on beat for a slightly longer ring
		var hh_decay: float = 120.0 if beat_in_bar != 1 else 60.0  # Open hat on beat 2
		for s in mini(int(MUSIC_GEN_RATE * 0.025), loop_samples - beat_start):
			var t: float = float(s) / MUSIC_GEN_RATE
			var env: float = exp(-t * hh_decay)
			var hh: float = (drum_rng.randf() * 2.0 - 1.0) * env * 0.05
			drum_data[beat_start + s] += hh
		# Offbeat 8th note hi-hat (slightly softer)
		var offbeat: int = beat_start + int(beat_dur * 0.5 * MUSIC_GEN_RATE)
		if offbeat < loop_samples:
			drum_rng.seed = beat * 7777 + _music_song_index * 4321
			for s in mini(int(MUSIC_GEN_RATE * 0.015), loop_samples - offbeat):
				var t: float = float(s) / MUSIC_GEN_RATE
				var env: float = exp(-t * 160.0)
				drum_data[offbeat + s] += (drum_rng.randf() * 2.0 - 1.0) * env * 0.05
	# Clamp drums
	for i in drum_data.size():
		drum_data[i] = clampf(drum_data[i], -1.0, 1.0)
	layer_wavs.append(_make_looping_wav(drum_data))

	# Helper: get frequency for a scale degree
	# degree 0 = root, degree 7 = octave up, etc.
	# We use the scale array to map degree → semitones → freq

	# --- Layer 1: ROBIN HOOD — Plucked Strings (arpeggiated chords) ---
	var strings_data := PackedFloat32Array()
	strings_data.resize(loop_samples)
	for bar in MUSIC_LOOP_BARS:
		var chord_root_semi: int = chords[bar % chords.size()]
		# Arpeggio: root, 3rd, 5th, octave (4 notes per bar = 1 per beat)
		var arp_degrees := [0, 2, 4, 7]  # scale degrees for arpeggio
		for beat_in_bar in 4:
			var beat_idx: int = bar * 4 + beat_in_bar
			var beat_start: int = int(float(beat_idx) * beat_dur * MUSIC_GEN_RATE)
			var deg: int = arp_degrees[beat_in_bar]
			var semi: int = chord_root_semi + scale[deg % scale.size()] + (12 if deg >= 7 else 0)
			var freq: float = root * pow(2.0, float(semi) / 12.0) * 2.0  # octave up for brightness
			var note_len: int = mini(int(MUSIC_GEN_RATE * beat_dur * 0.8), loop_samples - beat_start)
			for s in note_len:
				var t: float = float(s) / MUSIC_GEN_RATE
				# Plucked string: fast attack, medium decay, odd harmonics
				var env: float = exp(-t * 8.0) * 0.18
				var samp: float = sin(t * freq * TAU) + sin(t * freq * 3.0 * TAU) * 0.15 * exp(-t * 12.0)
				samp += sin(t * freq * 5.0 * TAU) * 0.05 * exp(-t * 18.0)
				strings_data[beat_start + s] += samp * env
	for i in strings_data.size():
		strings_data[i] = clampf(strings_data[i], -1.0, 1.0)
	layer_wavs.append(_make_looping_wav(strings_data))

	# --- Layer 2: ALICE — Music Box (bright bell-like tones, melody) ---
	var mbox_data := PackedFloat32Array()
	mbox_data.resize(loop_samples)
	# Music box plays a simple melody using scale degrees
	var melody_pattern := [0, 2, 4, 5, 4, 2, 3, 1, 0, 4, 5, 7, 4, 2, 1, 0]
	for note_i in melody_pattern.size():
		var beat_idx: int = note_i
		if beat_idx >= total_beats:
			break
		var beat_start: int = int(float(beat_idx) * beat_dur * MUSIC_GEN_RATE)
		var bar_idx: int = beat_idx / 4
		var chord_root_semi: int = chords[bar_idx % chords.size()]
		var deg: int = melody_pattern[note_i]
		var semi: int = chord_root_semi + scale[deg % scale.size()] + (12 if deg >= 7 else 0)
		var freq: float = root * pow(2.0, float(semi) / 12.0) * 4.0  # 2 octaves up for music box
		var note_len: int = mini(int(MUSIC_GEN_RATE * beat_dur * 0.6), loop_samples - beat_start)
		for s in note_len:
			var t: float = float(s) / MUSIC_GEN_RATE
			# Bell-like: sharp attack, quick decay, inharmonic partials
			var env: float = exp(-t * 12.0) * 0.15
			var samp: float = sin(t * freq * TAU) * 0.6
			samp += sin(t * freq * 2.0 * TAU) * 0.3 * exp(-t * 15.0)
			samp += sin(t * freq * 3.003 * TAU) * 0.1 * exp(-t * 20.0)  # Slight inharmonicity
			mbox_data[beat_start + s] += samp * env
	for i in mbox_data.size():
		mbox_data[i] = clampf(mbox_data[i], -1.0, 1.0)
	layer_wavs.append(_make_looping_wav(mbox_data))

	# --- Layer 3: WICKED WITCH — Dark Organ (sustained chords, low register) ---
	var organ_data := PackedFloat32Array()
	organ_data.resize(loop_samples)
	for bar in MUSIC_LOOP_BARS:
		var chord_root_semi: int = chords[bar % chords.size()]
		var bar_start: int = int(float(bar * 4) * beat_dur * MUSIC_GEN_RATE)
		var bar_len: int = mini(int(4.0 * beat_dur * MUSIC_GEN_RATE), loop_samples - bar_start)
		# Play full chord (root + 3rd + 5th) sustained for the bar
		var chord_degrees := [0, 2, 4]  # Scale degrees: root, 3rd, 5th
		for ci in chord_degrees.size():
			var semi: int = chord_root_semi + scale[chord_degrees[ci] % scale.size()]
			var freq: float = root * pow(2.0, float(semi) / 12.0) * 0.5  # Octave down
			for s in bar_len:
				var t: float = float(s) / MUSIC_GEN_RATE
				# Organ: sustained, slight vibrato, drawbar harmonics
				var fade_in: float = minf(t * 8.0, 1.0)
				var fade_out: float = minf(float(bar_len - s) / (MUSIC_GEN_RATE * 0.05), 1.0)
				var env: float = fade_in * fade_out * 0.07
				var vibrato: float = sin(t * 5.5 * TAU) * 0.003
				var samp: float = sin(t * freq * (1.0 + vibrato) * TAU)
				samp += sin(t * freq * 2.0 * (1.0 + vibrato) * TAU) * 0.5  # 2nd harmonic (8')
				samp += sin(t * freq * 4.0 * (1.0 + vibrato) * TAU) * 0.25  # 4th harmonic (4')
				organ_data[bar_start + s] += samp * env
	for i in organ_data.size():
		organ_data[i] = clampf(organ_data[i], -1.0, 1.0)
	layer_wavs.append(_make_looping_wav(organ_data))

	# --- Layer 4: PETER PAN — Flute (airy lead melody, breathy) ---
	var flute_data := PackedFloat32Array()
	flute_data.resize(loop_samples)
	# Flute plays a counter-melody (offset from Alice's pattern)
	var flute_pattern := [4, 5, 7, 5, 4, 2, 0, 2, 4, 7, 5, 4, 2, 0, 1, 2]
	var flute_rest_rng := RandomNumberGenerator.new()
	flute_rest_rng.seed = _music_song_index * 11111
	var flute_breath_rng := RandomNumberGenerator.new()
	flute_breath_rng.seed = _music_song_index * 22222
	for note_i in flute_pattern.size():
		var beat_idx: int = note_i
		if beat_idx >= total_beats:
			break
		# Some notes are rests (skip randomly ~15%)
		if flute_rest_rng.randf() < 0.15:
			continue
		var beat_start: int = int(float(beat_idx) * beat_dur * MUSIC_GEN_RATE)
		var bar_idx: int = beat_idx / 4
		var chord_root_semi: int = chords[bar_idx % chords.size()]
		var deg: int = flute_pattern[note_i]
		var semi: int = chord_root_semi + scale[deg % scale.size()] + (12 if deg >= 7 else 0)
		var freq: float = root * pow(2.0, float(semi) / 12.0) * 4.0  # High register
		var note_len: int = mini(int(MUSIC_GEN_RATE * beat_dur * 0.7), loop_samples - beat_start)
		for s in note_len:
			var t: float = float(s) / MUSIC_GEN_RATE
			# Flute: soft attack, pure tone with slight breathiness
			var attack: float = minf(t * 20.0, 1.0)
			var release: float = minf(float(note_len - s) / (MUSIC_GEN_RATE * 0.03), 1.0)
			var env: float = attack * release * 0.12
			var vibrato: float = sin(t * 5.0 * TAU) * 0.005 * minf(t * 3.0, 1.0)
			var samp: float = sin(t * freq * (1.0 + vibrato) * TAU)
			# Add breath noise (separate RNG so it doesn't corrupt rest pattern)
			samp += (flute_breath_rng.randf() * 2.0 - 1.0) * 0.05 * env
			flute_data[beat_start + s] += samp * env
	for i in flute_data.size():
		flute_data[i] = clampf(flute_data[i], -1.0, 1.0)
	layer_wavs.append(_make_looping_wav(flute_data))

	# --- Layer 5: PHANTOM — Piano (dramatic arpeggios, fuller sound) ---
	var piano_data := PackedFloat32Array()
	piano_data.resize(loop_samples)
	# Piano plays 8th note arpeggios (2 notes per beat = 32 notes total)
	for beat in total_beats:
		var bar_idx: int = beat / 4
		var chord_root_semi: int = chords[bar_idx % chords.size()]
		for sub in 2:  # 2 eighth notes per beat
			var time_offset: float = float(beat) * beat_dur + float(sub) * beat_dur * 0.5
			var sample_start: int = int(time_offset * MUSIC_GEN_RATE)
			if sample_start >= loop_samples:
				break
			# Ascending then descending arpeggio pattern
			var arp_seq := [0, 2, 4, 7, 4, 2, 0, 4]
			var note_idx: int = (beat * 2 + sub) % arp_seq.size()
			var deg: int = arp_seq[note_idx]
			var semi: int = chord_root_semi + scale[deg % scale.size()] + (12 if deg >= 7 else 0)
			var freq: float = root * pow(2.0, float(semi) / 12.0) * 2.0
			var note_len: int = mini(int(MUSIC_GEN_RATE * beat_dur * 0.4), loop_samples - sample_start)
			for s in note_len:
				var t: float = float(s) / MUSIC_GEN_RATE
				# Piano: sharp hammer attack, medium sustain, rich harmonics
				var env: float = exp(-t * 6.0) * 0.13
				var samp: float = sin(t * freq * TAU)
				samp += sin(t * freq * 2.0 * TAU) * 0.3 * exp(-t * 8.0)
				samp += sin(t * freq * 3.0 * TAU) * 0.12 * exp(-t * 10.0)
				samp += sin(t * freq * 4.0 * TAU) * 0.06 * exp(-t * 14.0)
				# Hammer thump (crisp knock, not muddy rumble)
				samp += sin(t * 300.0 * TAU) * exp(-t * 400.0) * 0.12
				piano_data[sample_start + s] += samp * env
	for i in piano_data.size():
		piano_data[i] = clampf(piano_data[i], -1.0, 1.0)
	layer_wavs.append(_make_looping_wav(piano_data))

	# --- Layer 6: SCROOGE — Brass (warm tuba/horn bassline, half notes) ---
	var brass_data := PackedFloat32Array()
	brass_data.resize(loop_samples)
	# Brass plays half-note bassline (2 notes per bar)
	for bar in MUSIC_LOOP_BARS:
		var chord_root_semi: int = chords[bar % chords.size()]
		for half in 2:
			var beat_idx: int = bar * 4 + half * 2
			var beat_start: int = int(float(beat_idx) * beat_dur * MUSIC_GEN_RATE)
			# Alternate root and 5th
			var deg: int = 0 if half == 0 else 4
			var semi: int = chord_root_semi + scale[deg % scale.size()]
			var freq: float = root * pow(2.0, float(semi) / 12.0)  # Low register
			var note_len: int = mini(int(MUSIC_GEN_RATE * beat_dur * 1.8), loop_samples - beat_start)
			for s in note_len:
				var t: float = float(s) / MUSIC_GEN_RATE
				# Brass: warm attack, sustained, even harmonics
				var attack: float = minf(t * 12.0, 1.0)
				var release: float = minf(float(note_len - s) / (MUSIC_GEN_RATE * 0.04), 1.0)
				var env: float = attack * release * 0.12
				var vibrato: float = sin(t * 4.5 * TAU) * 0.004 * minf(t * 2.0, 1.0)
				var vf: float = freq * (1.0 + vibrato)
				var samp: float = sin(t * vf * TAU)
				samp += sin(t * vf * 2.0 * TAU) * 0.4  # Strong 2nd harmonic (brass character)
				samp += sin(t * vf * 3.0 * TAU) * 0.2
				samp += sin(t * vf * 4.0 * TAU) * 0.1
				brass_data[beat_start + s] += samp * env
	for i in brass_data.size():
		brass_data[i] = clampf(brass_data[i], -1.0, 1.0)
	layer_wavs.append(_make_looping_wav(brass_data))

	# Create AudioStreamPlayers for each layer
	_music_layers.clear()
	_music_layer_targets = [0.20, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Only drums audible initially
	_music_layer_current = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
	_music_tempo_mult = 1.0
	for i in layer_wavs.size():
		var player := AudioStreamPlayer.new()
		player.stream = layer_wavs[i]
		player.volume_db = -80.0  # Start silent (will fade in via _process)
		player.bus = "Master"
		add_child(player)
		_music_layers.append(player)
	# Start all layers simultaneously
	for player in _music_layers:
		player.play()
	# Drums fade in smoothly (don't jump to full volume)
	_music_layer_current[0] = 0.01
	_music_layers[0].volume_db = linear_to_db(0.01)
	_music_max_tier_cache = 0
	_music_intensity = 0.0
	_music_layers_active = true

func _make_looping_wav(samples: PackedFloat32Array) -> AudioStreamWAV:
	var wav := AudioStreamWAV.new()
	wav.format = AudioStreamWAV.FORMAT_16_BITS
	wav.mix_rate = MUSIC_GEN_RATE
	wav.stereo = false
	wav.loop_mode = AudioStreamWAV.LOOP_FORWARD
	wav.loop_begin = 0
	wav.loop_end = samples.size()
	var data := PackedByteArray()
	data.resize(samples.size() * 2)
	for i in samples.size():
		var val := int(clampf(samples[i], -1.0, 1.0) * 32767.0)
		data[i * 2] = val & 0xFF
		data[i * 2 + 1] = (val >> 8) & 0xFF
	wav.data = data
	return wav

func _stop_layered_music() -> void:
	for player in _music_layers:
		if is_instance_valid(player):
			player.stop()
			player.queue_free()
	_music_layers.clear()
	_music_layers_active = false
	_music_layer_targets = [0.35, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
	_music_layer_current = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
	_music_max_tier_cache = 0
	_music_intensity = 0.0
	_music_tempo_mult = 1.0

func _fade_in_tower_layer(tower_type: int) -> void:
	if not TOWER_LAYER_MAP.has(tower_type):
		return
	var layer_idx: int = TOWER_LAYER_MAP[tower_type]
	if layer_idx < _music_layer_targets.size():
		_music_layer_targets[layer_idx] = 0.40  # Fade to this volume
	_refresh_music_max_tier()

func _fade_out_tower_layer(tower_type: int) -> void:
	if not TOWER_LAYER_MAP.has(tower_type):
		return
	var layer_idx: int = TOWER_LAYER_MAP[tower_type]
	if layer_idx < _music_layer_targets.size():
		_music_layer_targets[layer_idx] = 0.0  # Fade out
	# Defer tier refresh since tower may not be freed yet
	get_tree().create_timer(0.1).timeout.connect(_refresh_music_max_tier)

func _refresh_music_max_tier() -> void:
	_music_max_tier_cache = 0
	for tower in get_tree().get_nodes_in_group("towers"):
		if "upgrade_tier" in tower:
			_music_max_tier_cache = maxi(_music_max_tier_cache, tower.upgrade_tier)

func _pulse_tower_layer(tower_type: int) -> void:
	# Brief volume spike when tower attacks — adds musical punch
	if not TOWER_LAYER_MAP.has(tower_type):
		return
	if not _music_layers_active:
		return
	var layer_idx: int = TOWER_LAYER_MAP[tower_type]
	if layer_idx >= _music_layers.size():
		return
	if _music_layer_targets[layer_idx] > 0.0:
		# Temporarily boost volume
		_music_layer_current[layer_idx] = minf(_music_layer_targets[layer_idx] + 0.08, 1.0)

func _update_layered_music(delta: float) -> void:
	if not _music_layers_active:
		return
	# Dynamic mix: calculate total active volume to prevent clipping
	var active_count: int = 0
	for i in range(1, _music_layer_targets.size()):
		if _music_layer_targets[i] > 0.0:
			active_count += 1
	# Scale individual volumes down as more layers are added (prevents Master bus clipping)
	# 1 layer: full volume, 6 layers: each at ~55% to keep total reasonable
	var mix_scale: float = 1.0 / maxf(1.0, 1.0 + float(active_count) * 0.25)
	# Boss/late-wave intensity: boost drums + overall slightly
	var intensity_target: float = 0.0
	if is_wave_active:
		intensity_target = clampf(float(wave) / maxf(float(total_waves), 1.0), 0.0, 1.0) * 0.3
		# Extra intensity during boss waves (every 5th wave typically)
		if wave > 0 and wave % 5 == 0:
			intensity_target = minf(intensity_target + 0.15, 0.5)
	_music_intensity = lerpf(_music_intensity, intensity_target, delta * 0.3)
	# Smooth volume transitions with asymmetric fade speeds
	for i in _music_layers.size():
		if not is_instance_valid(_music_layers[i]):
			continue
		var target: float = _music_layer_targets[i] * mix_scale
		# Drums get intensity boost
		if i == 0:
			target += _music_intensity * 0.1
		var current: float = _music_layer_current[i]
		if abs(current - target) > 0.001:
			if current < target:
				# Fade IN: fast and snappy for satisfying instrument entry
				_music_layer_current[i] = minf(current + MUSIC_FADE_IN_SPEED * delta, target)
			elif current > target + 0.1:
				# Pulse decay: fast snap-back from attack pulses
				_music_layer_current[i] = maxf(current - MUSIC_PULSE_DECAY_SPEED * delta, target)
			else:
				# Fade OUT: gradual and smooth for natural exit
				_music_layer_current[i] = maxf(current - MUSIC_FADE_OUT_SPEED * delta, target)
		var vol: float = _music_layer_current[i]
		if vol < 0.001:
			_music_layers[i].volume_db = -80.0
		else:
			_music_layers[i].volume_db = linear_to_db(vol)
	# Tempo scaling using cached max tier (avoid scanning all towers every frame)
	var target_tempo: float = 1.0 + float(_music_max_tier_cache) * 0.03
	# Add slight tempo bump from intensity
	target_tempo += _music_intensity * 0.04
	_music_tempo_mult = lerpf(_music_tempo_mult, target_tempo, delta * 0.5)
	for player in _music_layers:
		if is_instance_valid(player):
			player.pitch_scale = _music_tempo_mult

func _get_active_layer_count() -> int:
	var count: int = 0
	for i in range(1, _music_layer_targets.size()):
		if _music_layer_targets[i] > 0.0:
			count += 1
	return count

func _draw_shadow_author_effects() -> void:
	var font = game_font
	# --- Floating shadow figures (skinny human silhouettes, black smoke) ---
	for fig in _sa_shadow_figures:
		var fig_angle = _time * fig["speed"] + fig["phase"]
		var fx = fig["cx"] + cos(fig_angle) * fig["radius"]
		var fy = fig["cy"] + sin(fig_angle * 0.7) * fig["radius"] * 0.4
		var fh = fig["height"]
		var fig_a = 0.20 + sin(_time * 1.5 + fig["phase"]) * 0.08
		# Body (skinny elongated shape)
		var body_sway = sin(_time * 2.0 + fig["phase"]) * 3.0
		# Head
		draw_circle(Vector2(fx + body_sway * 0.5, fy - fh), 4.0, Color(0.02, 0.01, 0.04, fig_a))
		# Torso (thin rectangle)
		draw_rect(Rect2(fx - 1.5 + body_sway * 0.3, fy - fh + 4, 3, fh * 0.5), Color(0.02, 0.01, 0.04, fig_a * 0.9))
		# Arms (wispy, reaching)
		var arm_sway = sin(_time * 3.0 + fig["phase"]) * 6.0
		draw_line(Vector2(fx + body_sway * 0.3, fy - fh * 0.7), Vector2(fx - 10 + arm_sway, fy - fh * 0.5), Color(0.02, 0.01, 0.04, fig_a * 0.7), 1.5)
		draw_line(Vector2(fx + body_sway * 0.3, fy - fh * 0.7), Vector2(fx + 10 - arm_sway, fy - fh * 0.5), Color(0.02, 0.01, 0.04, fig_a * 0.7), 1.5)
		# Legs (trailing, smoky)
		draw_line(Vector2(fx + body_sway * 0.2, fy - fh * 0.3), Vector2(fx - 4 + body_sway, fy), Color(0.02, 0.01, 0.04, fig_a * 0.6), 1.5)
		draw_line(Vector2(fx + body_sway * 0.2, fy - fh * 0.3), Vector2(fx + 4 + body_sway, fy + 3), Color(0.02, 0.01, 0.04, fig_a * 0.5), 1.5)
		# Smoke trail (dissipating particles behind movement)
		for si in range(5):
			var trail_angle = fig_angle - float(si) * 0.15
			var tx = fig["cx"] + cos(trail_angle) * fig["radius"]
			var ty = fig["cy"] + sin(trail_angle * 0.7) * fig["radius"] * 0.4
			var smoke_a = fig_a * (0.3 - float(si) * 0.05)
			draw_circle(Vector2(tx, ty - fh * 0.3), 3.0 + float(si) * 1.5, Color(0.03, 0.01, 0.06, smoke_a))
		# Glowing eyes (faint crimson)
		var eye_glow = 0.3 + sin(_time * 4.0 + fig["phase"]) * 0.15
		draw_circle(Vector2(fx - 2 + body_sway * 0.5, fy - fh - 1), 1.0, Color(0.6, 0.1, 0.15, eye_glow * fig_a))
		draw_circle(Vector2(fx + 2 + body_sway * 0.5, fy - fh - 1), 1.0, Color(0.6, 0.1, 0.15, eye_glow * fig_a))

	# --- Shadow Author taunt (appears once, then lightning exit) ---
	# Trigger taunt at randomized time into level (once only)
	if not _sa_taunt_triggered and _time > _sa_taunt_trigger_time and _sa_taunt_timer < 0:
		_sa_taunt_triggered = true
		_sa_taunt_timer = 0.0

	if _sa_taunt_timer >= 0:
		_sa_taunt_timer += get_process_delta_time()
		var t = _sa_taunt_timer
		var sx = _sa_taunt_x
		var sy = _sa_taunt_y

		if t < 1.5:
			# Phase 1: Smoke cloud appears (0-1.5s)
			var smoke_progress = clampf(t / 1.5, 0.0, 1.0)
			var smoke_a = smoke_progress * 0.6
			for ci in range(12):
				var ca = float(ci) * TAU / 12.0 + t * 2.0
				var cr = 20.0 * smoke_progress + sin(t * 4.0 + float(ci)) * 8.0
				var cx2 = sx + cos(ca) * cr
				var cy2 = sy + sin(ca) * cr * 0.6
				draw_circle(Vector2(cx2, cy2), 6.0 + sin(t * 3.0 + float(ci)) * 3.0, Color(0.05, 0.02, 0.08, smoke_a * (0.8 - float(ci) * 0.05)))
			# Figure materializing from smoke
			if t > 0.8:
				var mat_a = clampf((t - 0.8) / 0.7, 0.0, 1.0) * 0.7
				# Tall dark figure
				draw_circle(Vector2(sx, sy - 55), 7, Color(0.03, 0.01, 0.05, mat_a))  # Head
				draw_rect(Rect2(sx - 4, sy - 48, 8, 30), Color(0.03, 0.01, 0.05, mat_a))  # Torso
				# Long cloak/robe
				draw_colored_polygon(PackedVector2Array([Vector2(sx - 12, sy - 20), Vector2(sx, sy - 48), Vector2(sx + 12, sy - 20), Vector2(sx + 8, sy), Vector2(sx - 8, sy)]), Color(0.03, 0.01, 0.05, mat_a))
				# Glowing purple eyes
				draw_circle(Vector2(sx - 3, sy - 56), 1.5, Color(0.6, 0.2, 0.8, mat_a * 1.2))
				draw_circle(Vector2(sx + 3, sy - 56), 1.5, Color(0.6, 0.2, 0.8, mat_a * 1.2))

		elif t < 4.5:
			# Phase 2: Standing, taunting (1.5-4.5s)
			var idle_sway = sin(t * 2.0) * 2.0
			var sa_a = 0.7
			# Full figure
			draw_circle(Vector2(sx + idle_sway, sy - 55), 7, Color(0.03, 0.01, 0.05, sa_a))
			draw_rect(Rect2(sx - 4 + idle_sway, sy - 48, 8, 30), Color(0.03, 0.01, 0.05, sa_a))
			draw_colored_polygon(PackedVector2Array([Vector2(sx - 12 + idle_sway, sy - 20), Vector2(sx + idle_sway, sy - 48), Vector2(sx + 12 + idle_sway, sy - 20), Vector2(sx + 8 + idle_sway, sy), Vector2(sx - 8 + idle_sway, sy)]), Color(0.03, 0.01, 0.05, sa_a))
			# Purple eyes (menacing pulse)
			var eye_p = 0.8 + sin(t * 5.0) * 0.2
			draw_circle(Vector2(sx - 3 + idle_sway, sy - 56), 2.0, Color(0.7, 0.2, 0.9, eye_p))
			draw_circle(Vector2(sx + 3 + idle_sway, sy - 56), 2.0, Color(0.7, 0.2, 0.9, eye_p))
			# Eye glow halo
			draw_circle(Vector2(sx + idle_sway, sy - 56), 12, Color(0.5, 0.15, 0.7, 0.08))
			# Raised arm (beckoning/taunting)
			var arm_raise = sin(t * 1.5) * 5.0
			draw_line(Vector2(sx + 4 + idle_sway, sy - 40), Vector2(sx + 20 + idle_sway, sy - 50 + arm_raise), Color(0.03, 0.01, 0.05, sa_a * 0.8), 2.5)
			# Dark aura around figure
			for ai in range(6):
				var aa = float(ai) * TAU / 6.0 + t * 0.8
				var ar = 25.0 + sin(t * 1.5 + float(ai)) * 5.0
				draw_circle(Vector2(sx + cos(aa) * ar + idle_sway, sy - 25 + sin(aa) * ar * 0.5), 3.0, Color(0.04, 0.01, 0.06, 0.12))
			# Residual smoke at feet
			for fi2 in range(4):
				var smoke_x = sx - 15 + float(fi2) * 10.0 + sin(t * 2.0 + float(fi2)) * 5.0
				draw_circle(Vector2(smoke_x + idle_sway, sy + 3), 5.0, Color(0.04, 0.02, 0.06, 0.15 - float(fi2) * 0.03))

		elif t < 5.0:
			# Phase 3: Lightning bolt strikes down (4.5-5.0s)
			var flash_t = (t - 4.5) / 0.5
			# Screen flash
			var flash_a = (1.0 - flash_t) * 0.3
			draw_rect(Rect2(0, 0, 1280, 720), Color(0.8, 0.7, 1.0, flash_a))
			# Lightning bolt from sky to feet
			var bolt_a = (1.0 - flash_t) * 0.9
			var bolt_x = sx
			var bolt_segments = 8
			var prev_bx = bolt_x
			var prev_by = 50.0  # Top of screen
			for bi in range(bolt_segments):
				var seg_t = float(bi + 1) / float(bolt_segments)
				var next_by = 50.0 + (sy - 50.0) * seg_t
				var jitter = sin(float(bi) * 3.7 + t * 20.0) * (15.0 - seg_t * 10.0)
				var next_bx = bolt_x + jitter
				# Main bolt (thick bright)
				draw_line(Vector2(prev_bx, prev_by), Vector2(next_bx, next_by), Color(0.9, 0.8, 1.0, bolt_a), 3.0)
				# Glow
				draw_line(Vector2(prev_bx, prev_by), Vector2(next_bx, next_by), Color(0.6, 0.4, 0.9, bolt_a * 0.4), 8.0)
				# Branch bolts (smaller forks)
				if bi % 2 == 0 and bi < bolt_segments - 1:
					var fork_dir = 1.0 if bi % 4 == 0 else -1.0
					draw_line(Vector2(next_bx, next_by), Vector2(next_bx + fork_dir * 25, next_by + 20), Color(0.8, 0.7, 1.0, bolt_a * 0.5), 1.5)
				prev_bx = next_bx
				prev_by = next_by
			# Impact flash at feet
			draw_circle(Vector2(sx, sy), 30 * (1.0 - flash_t), Color(0.8, 0.6, 1.0, bolt_a * 0.5))
			draw_circle(Vector2(sx, sy), 15 * (1.0 - flash_t), Color(1.0, 0.9, 1.0, bolt_a * 0.7))
			# Figure dissolving
			var dissolve_a = (1.0 - flash_t) * 0.5
			draw_circle(Vector2(sx, sy - 30), 15, Color(0.03, 0.01, 0.05, dissolve_a))

		else:
			# Phase 4: Done, reset timer to stop drawing
			_sa_taunt_timer = -1.0

func _draw_shadow_author_ch1(sky_color: Color, ground_color: Color) -> void:
	# Pure black sky with ink
	var sky_top := Color(0.01, 0.005, 0.02)
	var sky_bottom := Color(0.03, 0.02, 0.04)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Ink pool ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.02, 0.02, 0.04))
	# Ink ripples on ground
	for rp in range(6):
		var rx := 100.0 + float(rp) * 200.0
		var ry := 550.0
		var ripple_r := 20.0 + sin(_time * 1.0 + float(rp) * 1.5) * 10.0
		draw_arc(Vector2(rx, ry), ripple_r, 0, TAU, 24, Color(0.08, 0.05, 0.12, 0.15), 1.0)
		draw_arc(Vector2(rx, ry), ripple_r * 0.6, 0, TAU, 16, Color(0.08, 0.05, 0.12, 0.1), 1.0)
	# Dripping ink from top
	for dr in range(15):
		var dx := fmod(float(dr) * 89.0, 1280.0)
		var drip_speed := 40.0 + float(dr) * 5.0
		var dy := fmod(_time * drip_speed + float(dr) * 50.0, 520.0) + 50.0
		var drip_len := 15.0 + sin(float(dr)) * 8.0
		draw_rect(Rect2(dx - 1.5, dy, 3, drip_len), Color(0.05, 0.02, 0.08, 0.4))
		draw_circle(Vector2(dx, dy + drip_len), 2.5, Color(0.06, 0.03, 0.10, 0.5))
	# Floating quills
	for q in range(5):
		var qx := 100.0 + float(q) * 250.0
		var qy := 200.0 + sin(_time * 0.6 + float(q) * 1.2) * 30.0
		var qa := sin(_time * 0.3 + float(q)) * 0.3
		# Quill shaft
		draw_line(Vector2(qx - 15, qy + 10), Vector2(qx + 15, qy - 10), Color(0.4, 0.3, 0.2, 0.4), 1.5)
		# Feather
		draw_colored_polygon(PackedVector2Array([Vector2(qx + 10, qy - 8), Vector2(qx + 20, qy - 15), Vector2(qx + 18, qy - 3)]), Color(0.3, 0.2, 0.15, 0.35))
		# Nib
		draw_line(Vector2(qx - 15, qy + 10), Vector2(qx - 20, qy + 15), Color(0.5, 0.4, 0.1, 0.5), 1.0)
	# Open books on ground
	for bk in range(4):
		var bx := 150.0 + float(bk) * 280.0
		var by := 500.0
		# Book covers
		draw_colored_polygon(PackedVector2Array([Vector2(bx - 25, by), Vector2(bx - 5, by - 5), Vector2(bx, by + 2), Vector2(bx - 20, by + 8)]), Color(0.08, 0.04, 0.02, 0.5))
		draw_colored_polygon(PackedVector2Array([Vector2(bx, by + 2), Vector2(bx + 5, by - 5), Vector2(bx + 25, by), Vector2(bx + 20, by + 8)]), Color(0.07, 0.03, 0.02, 0.5))
		# Page glow
		var pg := 0.1 + 0.05 * sin(_time * 1.5 + float(bk))
		draw_rect(Rect2(bx - 18, by + 1, 16, 5), Color(0.3, 0.25, 0.15, pg))
		draw_rect(Rect2(bx + 2, by + 1, 16, 5), Color(0.3, 0.25, 0.15, pg))
	# Text fragments floating
	for tf in range(8):
		var tx := fmod(float(tf) * 163.0 + _time * 8.0, 1400.0) - 60.0
		var ty := 300.0 + sin(float(tf) * 2.0) * 100.0 + sin(_time * 0.5 + float(tf)) * 15.0
		draw_rect(Rect2(tx, ty, 20 + float(tf) * 3, 2), Color(0.25, 0.20, 0.15, 0.2))
		draw_rect(Rect2(tx, ty + 4, 15 + float(tf) * 2, 2), Color(0.25, 0.20, 0.15, 0.15))
	_draw_shadow_author_effects()

func _draw_shadow_author_ch2(sky_color: Color, ground_color: Color) -> void:
	# Deeper into shadow realm
	var sky_top := Color(0.01, 0.005, 0.015)
	var sky_bottom := Color(0.025, 0.015, 0.035)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.02, 0.015, 0.035))
	# Ink waterfalls from edges
	for wf in range(3):
		var wx := float(wf) * 500.0 + 150.0
		for ws in range(12):
			var wy := 50.0 + float(ws) * 40.0
			var wobble := sin(_time * 3.0 + float(ws) * 0.6 + float(wf)) * 4.0
			draw_rect(Rect2(wx - 5 + wobble, wy, 10, 42), Color(0.04, 0.02, 0.06, 0.2))
	# Shadow tendrils rising from ground
	for st in range(10):
		var sx := float(st) * 130.0 + 40.0
		var sway := sin(_time * 0.8 + float(st) * 0.9) * 15.0
		for seg in range(10):
			var sy := 520.0 - float(seg) * 15.0
			var sx2 := sx + sway * (float(seg) / 10.0)
			draw_rect(Rect2(sx2 - 2, sy, 4, 16), Color(0.03, 0.01, 0.05, 0.4 - float(seg) * 0.035))
	# Scattered pages
	for pg in range(6):
		var px := fmod(float(pg) * 197.0 + sin(_time * 0.4 + float(pg)) * 20.0, 1200.0) + 40.0
		var py := 250.0 + sin(float(pg) * 1.7) * 80.0 + sin(_time * 0.5 + float(pg)) * 10.0
		var rot := sin(_time * 0.3 + float(pg)) * 0.2
		draw_rect(Rect2(px, py, 20, 26), Color(0.12, 0.10, 0.08, 0.15))
		draw_rect(Rect2(px + 2, py + 3, 16, 2), Color(0.08, 0.06, 0.04, 0.1))
		draw_rect(Rect2(px + 2, py + 7, 14, 2), Color(0.08, 0.06, 0.04, 0.1))
		draw_rect(Rect2(px + 2, py + 11, 16, 2), Color(0.08, 0.06, 0.04, 0.1))
	# Giant quill in background
	draw_line(Vector2(900, 100), Vector2(1050, 400), Color(0.15, 0.10, 0.06, 0.2), 3.0)
	draw_colored_polygon(PackedVector2Array([Vector2(880, 90), Vector2(900, 100), Vector2(870, 130), Vector2(860, 110)]), Color(0.12, 0.08, 0.04, 0.2))
	# Ink drips (heavier)
	for dr in range(20):
		var dx := fmod(float(dr) * 67.0, 1280.0)
		var drip_speed := 35.0 + float(dr) * 4.0
		var dy := fmod(_time * drip_speed + float(dr) * 40.0, 520.0) + 50.0
		draw_rect(Rect2(dx - 1, dy, 2, 12 + sin(float(dr)) * 5.0), Color(0.04, 0.02, 0.07, 0.35))
	# Glowing runes on ground (shadow magic)
	for rn in range(5):
		var rx := 120.0 + float(rn) * 240.0
		var rg := 0.1 + 0.08 * sin(_time * 1.2 + float(rn) * 1.0)
		draw_arc(Vector2(rx, 530), 15.0, 0, TAU, 16, Color(0.3, 0.1, 0.5, rg), 1.5)
	_draw_shadow_author_effects()

func _draw_shadow_author_ch3(sky_color: Color, ground_color: Color) -> void:
	# Final confrontation - pure darkness
	var sky_top := Color(0.008, 0.004, 0.015)
	var sky_bottom := Color(0.02, 0.01, 0.03)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.015, 0.01, 0.03))
	# Central dark vortex
	for vr in range(8):
		var vr_r := 30.0 + float(vr) * 20.0
		var vr_angle := _time * (0.5 - float(vr) * 0.05)
		draw_arc(Vector2(640, 350), vr_r, vr_angle, vr_angle + TAU * 0.7, 32, Color(0.06, 0.02, 0.10, 0.12 - float(vr) * 0.012), 2.0)
	# Ink explosion particles
	for ip in range(20):
		var ia := float(ip) * TAU / 20.0 + _time * 0.3
		var ir := 80.0 + sin(_time * 0.8 + float(ip) * 0.5) * 40.0
		var ix := 640.0 + cos(ia) * ir
		var iy := 350.0 + sin(ia) * ir * 0.5
		draw_circle(Vector2(ix, iy), 2.0 + sin(_time + float(ip)) * 1.0, Color(0.08, 0.03, 0.15, 0.3))
	# Massive dripping ink
	for dr in range(25):
		var dx := fmod(float(dr) * 53.0, 1280.0)
		var drip_speed := 30.0 + float(dr) * 3.0
		var dy := fmod(_time * drip_speed + float(dr) * 35.0, 520.0) + 50.0
		var drip_w := 2.0 + sin(float(dr) * 1.3) * 1.0
		draw_rect(Rect2(dx - drip_w / 2, dy, drip_w, 18 + sin(float(dr)) * 6.0), Color(0.05, 0.02, 0.08, 0.4))
	# Floating open books (larger)
	for bk in range(5):
		var bx := 100.0 + float(bk) * 240.0
		var by := 200.0 + sin(_time * 0.4 + float(bk) * 1.3) * 30.0
		draw_colored_polygon(PackedVector2Array([Vector2(bx - 20, by), Vector2(bx - 2, by - 8), Vector2(bx, by), Vector2(bx - 15, by + 10)]), Color(0.10, 0.06, 0.03, 0.35))
		draw_colored_polygon(PackedVector2Array([Vector2(bx, by), Vector2(bx + 2, by - 8), Vector2(bx + 20, by), Vector2(bx + 15, by + 10)]), Color(0.09, 0.05, 0.03, 0.35))
		# Glowing text
		var tg := 0.1 + 0.05 * sin(_time * 1.8 + float(bk))
		draw_rect(Rect2(bx - 14, by + 2, 12, 1.5), Color(0.4, 0.3, 0.6, tg))
		draw_rect(Rect2(bx + 2, by + 2, 12, 1.5), Color(0.4, 0.3, 0.6, tg))
	# Quills orbiting center
	for q in range(4):
		var qa := float(q) * TAU / 4.0 + _time * 0.4
		var qr := 150.0 + sin(_time * 0.5 + float(q)) * 20.0
		var qx := 640.0 + cos(qa) * qr
		var qy := 350.0 + sin(qa) * qr * 0.4
		draw_line(Vector2(qx - 8, qy + 5), Vector2(qx + 8, qy - 5), Color(0.3, 0.2, 0.12, 0.35), 1.5)
		draw_colored_polygon(PackedVector2Array([Vector2(qx + 6, qy - 4), Vector2(qx + 14, qy - 10), Vector2(qx + 12, qy)]), Color(0.25, 0.15, 0.08, 0.3))
	# Shadow tendrils from edges
	for st in range(8):
		var from_left := st < 4
		var sx := 0.0 if from_left else 1280.0
		var sy := 200.0 + float(st % 4) * 80.0
		var reach := 80.0 + sin(_time * 0.7 + float(st)) * 30.0
		var dir := 1.0 if from_left else -1.0
		for seg in range(6):
			var seg_x := sx + dir * float(seg) * (reach / 6.0)
			var seg_y := sy + sin(float(seg) * 0.5 + _time * 0.5) * 10.0
			draw_rect(Rect2(seg_x - 2, seg_y - 2, 4 + reach / 6.0, 4), Color(0.03, 0.01, 0.05, 0.3 - float(seg) * 0.04))
	_draw_shadow_author_effects()

func _draw_robin_ch1(sky_color: Color, ground_color: Color) -> void:
	# --- SKY GRADIENT ---
	var sky_top := Color(0.02, 0.06, 0.10)
	var sky_mid := Color(0.04, 0.12, 0.08)
	var sky_horizon := Color(0.12, 0.18, 0.06)
	var amber_haze := Color(0.25, 0.15, 0.04, 0.35)
	for i in range(60):
		var t: float = float(i) / 59.0
		var col: Color
		if t < 0.5:
			col = sky_top.lerp(sky_mid, t * 2.0)
		else:
			col = sky_mid.lerp(sky_horizon, (t - 0.5) * 2.0)
		var haze_strength: float = clampf(t - 0.5, 0.0, 0.5) * 2.0
		col = col.lerp(amber_haze, haze_strength * 0.4)
		var y0: float = 50.0 + float(i) * 9.6
		draw_rect(Rect2(0, y0, 1280, 10.6), col)

	# --- STARS ---
	var star_seeds: Array = [37, 71, 113, 157, 199, 241, 283, 311, 347, 389, 421, 463, 509, 557, 601, 643, 691, 733, 787, 823]
	for s in range(star_seeds.size()):
		var sd: int = star_seeds[s]
		var sx: float = fmod(float(sd) * 7.3, 1280.0)
		var sy: float = 55.0 + fmod(float(sd) * 3.7, 200.0)
		var twinkle: float = 0.4 + 0.6 * absf(sin(_time * 1.5 + float(sd)))
		draw_circle(Vector2(sx, sy), 1.0 + twinkle * 0.5, Color(0.8, 0.85, 0.95, twinkle * 0.7))

	# --- FULL MOON ---
	var moon_center := Vector2(900, 120)
	for g in range(5):
		draw_circle(moon_center, 42.0 + float(g) * 12.0, Color(0.7, 0.75, 0.9, 0.06 - float(g) * 0.01))
	draw_circle(moon_center, 42.0, Color(0.82, 0.85, 0.92))
	draw_circle(moon_center + Vector2(-8, -5), 40.0, Color(0.78, 0.80, 0.88))
	draw_circle(moon_center + Vector2(-10, 5), 6.0, Color(0.72, 0.74, 0.82, 0.4))
	draw_circle(moon_center + Vector2(12, -8), 4.0, Color(0.72, 0.74, 0.82, 0.3))
	draw_circle(moon_center + Vector2(5, 14), 3.5, Color(0.72, 0.74, 0.82, 0.35))

	# --- MOONBEAMS ---
	for mb in range(5):
		var beam_x: float = 850.0 + float(mb) * 30.0
		var sway: float = sin(_time * 0.4 + float(mb) * 1.2) * 15.0
		var beam_alpha: float = 0.03 + 0.015 * sin(_time * 0.6 + float(mb))
		draw_colored_polygon(PackedVector2Array([Vector2(beam_x - 5 + sway * 0.3, 160), Vector2(beam_x + 5 + sway * 0.3, 160), Vector2(beam_x + 40 + sway, 620), Vector2(beam_x - 40 + sway, 620)]), Color(0.7, 0.75, 0.9, beam_alpha))

	# --- NOTTINGHAM CASTLE SILHOUETTE ---
	var castle_col := Color(0.03, 0.04, 0.06)
	draw_colored_polygon(PackedVector2Array([Vector2(950, 280), Vector2(1000, 200), Vector2(1050, 180), Vector2(1120, 170), Vector2(1200, 185), Vector2(1280, 220), Vector2(1280, 280)]), castle_col)
	draw_rect(Rect2(1060, 100, 80, 80), castle_col)
	for bt in range(5):
		draw_rect(Rect2(1060 + bt * 18, 92, 10, 12), castle_col)
	draw_rect(Rect2(1020, 110, 30, 70), castle_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1015, 110), Vector2(1035, 75), Vector2(1055, 110)]), castle_col)
	draw_rect(Rect2(1150, 105, 35, 75), castle_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1145, 105), Vector2(1167, 68), Vector2(1190, 105)]), castle_col)
	draw_circle(Vector2(1100, 180), 15.0, Color(0.02, 0.02, 0.04))
	draw_rect(Rect2(1085, 180, 30, 20), Color(0.02, 0.02, 0.04))
	draw_rect(Rect2(1000, 170, 60, 10), castle_col)
	draw_rect(Rect2(1140, 165, 70, 10), castle_col)
	var tf1: float = 0.5 + 0.5 * sin(_time * 6.0 + 1.0)
	var tf2: float = 0.5 + 0.5 * sin(_time * 7.3 + 3.0)
	draw_circle(Vector2(1035, 130), 2.5, Color(0.9, 0.5, 0.1, 0.5 + tf1 * 0.5))
	draw_circle(Vector2(1035, 130), 5.0, Color(0.9, 0.4, 0.1, 0.15 + tf1 * 0.1))
	draw_circle(Vector2(1167, 125), 2.5, Color(0.9, 0.5, 0.1, 0.5 + tf2 * 0.5))
	draw_circle(Vector2(1167, 125), 5.0, Color(0.9, 0.4, 0.1, 0.15 + tf2 * 0.1))

	# --- DISTANT BACKGROUND TREES ---
	for dt in range(18):
		var dtx: float = float(dt) * 75.0 + 20.0
		var dty: float = 260.0 + sin(float(dt) * 2.3) * 30.0
		var dts: float = 50.0 + sin(float(dt) * 1.7) * 15.0
		draw_rect(Rect2(dtx - 3, dty, 6, 60), Color(0.02, 0.05, 0.08, 0.85))
		draw_circle(Vector2(dtx, dty - 10), dts * 0.5, Color(0.02, 0.05, 0.08, 0.85))
		draw_circle(Vector2(dtx - dts * 0.25, dty), dts * 0.4, Color(0.02, 0.05, 0.08, 0.85))

	# --- BROOK / STREAM ---
	var brook_pts: PackedVector2Array = PackedVector2Array()
	var brook_bottom: PackedVector2Array = PackedVector2Array()
	var bpx_arr: Array = [500, 530, 570, 620, 660, 680, 690, 700, 720, 750]
	var bpy_arr: Array = [380, 395, 415, 430, 445, 465, 485, 510, 540, 570]
	for bp in range(bpx_arr.size()):
		brook_pts.append(Vector2(float(bpx_arr[bp]) - 12, float(bpy_arr[bp])))
		brook_bottom.insert(0, Vector2(float(bpx_arr[bp]) + 12, float(bpy_arr[bp])))
	brook_pts.append_array(brook_bottom)
	draw_colored_polygon(brook_pts, Color(0.05, 0.1, 0.25, 0.8))
	for sh in range(8):
		var shx: float = float(bpx_arr[sh]) + sin(_time * 2.5 + float(sh)) * 4.0
		var shy: float = float(bpy_arr[sh]) + cos(_time * 1.8 + float(sh)) * 2.0
		draw_line(Vector2(shx - 5, shy), Vector2(shx + 5, shy), Color(0.2, 0.3, 0.6, 0.15 + 0.1 * sin(_time * 2.0)), 1.5)

	# --- LITTLE JOHN'S BRIDGE ---
	var bridge_x: float = 660.0
	var bridge_y: float = 440.0
	for pl in range(6):
		draw_rect(Rect2(bridge_x - 15 + float(pl) * 7, bridge_y - 3, 6, 28), Color(0.25, 0.15, 0.06))
	draw_line(Vector2(bridge_x - 18, bridge_y - 6), Vector2(bridge_x + 30, bridge_y - 6), Color(0.15, 0.08, 0.03), 2.5)
	draw_line(Vector2(bridge_x - 18, bridge_y + 28), Vector2(bridge_x + 30, bridge_y + 28), Color(0.15, 0.08, 0.03), 2.5)
	draw_rect(Rect2(bridge_x - 20, bridge_y - 10, 5, 42), Color(0.15, 0.08, 0.03))
	draw_rect(Rect2(bridge_x + 28, bridge_y - 10, 5, 42), Color(0.15, 0.08, 0.03))

	# --- GROUND LAYERS ---
	draw_rect(Rect2(0, 480, 1280, 240), Color(0.04, 0.12, 0.03))
	draw_rect(Rect2(0, 490, 1280, 130), Color(0.06, 0.14, 0.04))
	draw_rect(Rect2(0, 580, 1280, 48), Color(0.05, 0.10, 0.03))
	# moss rocks
	var rock_seeds: Array = [120, 340, 580, 800, 1050, 250, 700, 950]
	for r in range(rock_seeds.size()):
		var rx: float = float(rock_seeds[r])
		var ry: float = 530.0 + fmod(float(rock_seeds[r]) * 0.37, 60.0)
		var rs: float = 6.0 + fmod(float(rock_seeds[r]) * 0.13, 8.0)
		draw_circle(Vector2(rx, ry), rs, Color(0.15, 0.15, 0.12))
		draw_arc(Vector2(rx, ry - rs * 0.3), rs * 0.8, 2.8, 6.0, 8, Color(0.1, 0.3, 0.08, 0.7), 2.0)
	# ferns
	for f in range(15):
		var fx: float = fmod(float(f) * 97.0, 1280.0)
		var fy: float = 510.0 + fmod(float(f) * 43.0, 70.0)
		for frond in range(5):
			var angle: float = -0.8 + float(frond) * 0.4
			draw_line(Vector2(fx, fy), Vector2(fx + cos(angle) * 14.0, fy - sin(absf(angle) + 0.5) * 10.0), Color(0.06, 0.22, 0.05, 0.8), 1.5)
	# fallen leaves
	for lf in range(40):
		var lfx: float = fmod(float(lf) * 31.7, 1280.0)
		var lfy: float = 500.0 + fmod(float(lf) * 17.3, 100.0)
		var leaf_colors: Array = [Color(0.6, 0.35, 0.05, 0.6), Color(0.7, 0.2, 0.05, 0.5), Color(0.65, 0.5, 0.1, 0.55)]
		draw_circle(Vector2(lfx, lfy), 1.5 + fmod(float(lf) * 0.3, 1.5), leaf_colors[lf % 3])

	# --- PATH ---
	if enemy_path and enemy_path.curve:
		var pp: PackedVector2Array = enemy_path.curve.get_baked_points()
		if pp.size() > 1:
			for i in range(pp.size() - 1):
				draw_line(pp[i], pp[i + 1], Color(0.06, 0.18, 0.04, 0.5), 32.0)
			for i in range(pp.size() - 1):
				draw_line(pp[i], pp[i + 1], Color(0.08, 0.05, 0.02), 28.0)
			for i in range(pp.size() - 1):
				draw_line(pp[i], pp[i + 1], Color(0.18, 0.12, 0.05), 22.0)
			for i in range(pp.size() - 1):
				var p0: Vector2 = pp[i]
				var p1: Vector2 = pp[i + 1]
				var dir: Vector2 = (p1 - p0).normalized()
				var perp := Vector2(-dir.y, dir.x)
				draw_line(p0 + perp * 4.0, p1 + perp * 4.0, Color(0.22, 0.16, 0.08, 0.5), 1.5)
				draw_line(p0 - perp * 4.0, p1 - perp * 4.0, Color(0.22, 0.16, 0.08, 0.5), 1.5)
			for pb in range(20):
				var idx: int = (pb * 7) % pp.size()
				draw_circle(pp[idx] + Vector2(sin(float(pb) * 3.1) * 8.0, cos(float(pb) * 2.7) * 3.0), 1.5, Color(0.25, 0.2, 0.15, 0.6))

	# --- MIDGROUND TREES ---
	var mtx_arr: Array = [320, 480, 750, 920, 1100, 60, 1220]
	var mty_arr: Array = [340, 370, 320, 360, 340, 380, 350]
	for mt in range(mtx_arr.size()):
		var mtx: float = float(mtx_arr[mt])
		var mty: float = float(mty_arr[mt])
		draw_rect(Rect2(mtx - 5, mty, 10, 120), Color(0.12, 0.07, 0.03))
		draw_line(Vector2(mtx - 5, mty + 115), Vector2(mtx - 18, mty + 125), Color(0.12, 0.07, 0.03), 3.0)
		draw_line(Vector2(mtx + 5, mty + 115), Vector2(mtx + 16, mty + 125), Color(0.12, 0.07, 0.03), 3.0)
		draw_circle(Vector2(mtx, mty - 20), 35.0, Color(0.04, 0.14, 0.03, 0.9))
		draw_circle(Vector2(mtx - 25, mty - 5), 28.0, Color(0.04, 0.14, 0.03, 0.9))
		draw_circle(Vector2(mtx + 22, mty - 8), 30.0, Color(0.04, 0.14, 0.03, 0.9))

	# --- THE MAJOR OAK ---
	var oak_x: float = 150.0
	var oak_y: float = 300.0
	# massive trunk
	draw_colored_polygon(PackedVector2Array([Vector2(oak_x - 30, oak_y + 200), Vector2(oak_x - 35, oak_y + 150), Vector2(oak_x - 28, oak_y + 80), Vector2(oak_x - 22, oak_y + 20), Vector2(oak_x - 15, oak_y - 20), Vector2(oak_x + 15, oak_y - 20), Vector2(oak_x + 25, oak_y + 20), Vector2(oak_x + 30, oak_y + 80), Vector2(oak_x + 38, oak_y + 150), Vector2(oak_x + 32, oak_y + 200)]), Color(0.14, 0.08, 0.03))
	# bark texture
	for bl in range(8):
		var by: float = oak_y + 10.0 + float(bl) * 22.0
		draw_line(Vector2(oak_x - 18 + sin(float(bl) * 1.5) * 5.0, by), Vector2(oak_x - 12 + sin(float(bl) * 1.5) * 5.0, by + 18), Color(0.08, 0.04, 0.02), 1.5)
		draw_line(Vector2(oak_x + 8 - sin(float(bl) * 1.5) * 5.0, by + 5), Vector2(oak_x + 14 - sin(float(bl) * 1.5) * 5.0, by + 20), Color(0.08, 0.04, 0.02), 1.5)
	# massive branches
	draw_line(Vector2(oak_x - 15, oak_y), Vector2(oak_x - 80, oak_y - 60), Color(0.14, 0.08, 0.03), 10.0)
	draw_line(Vector2(oak_x + 15, oak_y), Vector2(oak_x + 90, oak_y - 50), Color(0.14, 0.08, 0.03), 9.0)
	draw_line(Vector2(oak_x - 10, oak_y - 10), Vector2(oak_x - 50, oak_y - 90), Color(0.14, 0.08, 0.03), 7.0)
	draw_line(Vector2(oak_x + 10, oak_y - 10), Vector2(oak_x + 40, oak_y - 80), Color(0.14, 0.08, 0.03), 7.0)
	draw_line(Vector2(oak_x, oak_y - 15), Vector2(oak_x + 10, oak_y - 100), Color(0.14, 0.08, 0.03), 6.0)
	draw_line(Vector2(oak_x - 80, oak_y - 60), Vector2(oak_x - 110, oak_y - 85), Color(0.08, 0.04, 0.02), 4.0)
	draw_line(Vector2(oak_x + 90, oak_y - 50), Vector2(oak_x + 130, oak_y - 70), Color(0.08, 0.04, 0.02), 4.0)
	# enormous canopy
	for cp_data in [[0, -80, 70], [-60, -50, 55], [65, -45, 55], [-30, -100, 45], [30, -95, 48], [-85, -70, 35], [95, -60, 38]]:
		draw_circle(Vector2(oak_x + cp_data[0], oak_y + cp_data[1]), float(cp_data[2]), Color(0.03, 0.12, 0.02, 0.95))
	draw_circle(Vector2(oak_x + 20, oak_y - 110), 20.0, Color(0.05, 0.18, 0.04, 0.85))
	# treehouse platform
	draw_rect(Rect2(oak_x - 25, oak_y - 30, 55, 5), Color(0.2, 0.12, 0.04))
	draw_rect(Rect2(oak_x - 25, oak_y - 48, 3, 18), Color(0.18, 0.1, 0.04))
	draw_rect(Rect2(oak_x + 27, oak_y - 48, 3, 18), Color(0.18, 0.1, 0.04))
	draw_line(Vector2(oak_x - 25, oak_y - 48), Vector2(oak_x + 30, oak_y - 48), Color(0.18, 0.1, 0.04), 2.0)
	# rope ladder
	draw_line(Vector2(oak_x + 5, oak_y - 25), Vector2(oak_x + 5, oak_y + 55), Color(0.35, 0.25, 0.1), 1.5)
	draw_line(Vector2(oak_x + 15, oak_y - 25), Vector2(oak_x + 15, oak_y + 55), Color(0.35, 0.25, 0.1), 1.5)
	for rung in range(6):
		draw_line(Vector2(oak_x + 5, oak_y - 15 + float(rung) * 11.0), Vector2(oak_x + 15, oak_y - 15 + float(rung) * 11.0), Color(0.35, 0.25, 0.1), 1.5)
	# hanging game
	draw_line(Vector2(oak_x + 90, oak_y - 50), Vector2(oak_x + 90, oak_y - 30), Color(0.35, 0.25, 0.1), 1.5)
	draw_circle(Vector2(oak_x + 90, oak_y - 24), 4.0, Color(0.2, 0.12, 0.06))
	draw_line(Vector2(oak_x + 90, oak_y - 20), Vector2(oak_x + 87, oak_y - 12), Color(0.18, 0.1, 0.05), 1.5)

	# --- ROBIN HOOD'S CAMP ---
	var camp_x: float = 160.0
	var camp_y: float = 510.0
	draw_colored_polygon(PackedVector2Array([Vector2(camp_x - 50, camp_y + 30), Vector2(camp_x - 25, camp_y - 10), Vector2(camp_x, camp_y + 30)]), Color(0.12, 0.2, 0.06))
	draw_colored_polygon(PackedVector2Array([Vector2(camp_x - 32, camp_y + 30), Vector2(camp_x - 25, camp_y + 8), Vector2(camp_x - 18, camp_y + 30)]), Color(0.04, 0.04, 0.03))
	draw_colored_polygon(PackedVector2Array([Vector2(camp_x + 30, camp_y + 25), Vector2(camp_x + 50, camp_y - 5), Vector2(camp_x + 70, camp_y + 25)]), Color(0.2, 0.14, 0.06))
	draw_colored_polygon(PackedVector2Array([Vector2(camp_x + 5, camp_y + 10), Vector2(camp_x + 18, camp_y - 12), Vector2(camp_x + 32, camp_y + 10)]), Color(0.08, 0.14, 0.04))
	draw_rect(Rect2(camp_x - 15, camp_y + 35, 30, 5), Color(0.2, 0.12, 0.04))
	draw_rect(Rect2(camp_x + 20, camp_y + 40, 25, 5), Color(0.2, 0.12, 0.04))
	# weapon rack
	draw_line(Vector2(camp_x + 85, camp_y + 5), Vector2(camp_x + 85, camp_y + 45), Color(0.2, 0.12, 0.05), 2.5)
	draw_line(Vector2(camp_x + 100, camp_y + 5), Vector2(camp_x + 100, camp_y + 45), Color(0.2, 0.12, 0.05), 2.5)
	draw_arc(Vector2(camp_x + 89, camp_y + 20), 8.0, 1.2, 5.1, 10, Color(0.3, 0.18, 0.06), 1.5)
	draw_arc(Vector2(camp_x + 95, camp_y + 25), 7.0, 1.2, 5.1, 10, Color(0.3, 0.18, 0.06), 1.5)
	# WANTED poster
	draw_rect(Rect2(oak_x + 35, oak_y + 60, 22, 28), Color(0.7, 0.6, 0.4, 0.8))
	draw_rect(Rect2(oak_x + 36, oak_y + 61, 20, 5), Color(0.3, 0.1, 0.05, 0.7))
	for tl in range(4):
		draw_line(Vector2(oak_x + 38, oak_y + 70 + float(tl) * 4.5), Vector2(oak_x + 54, oak_y + 70 + float(tl) * 4.5), Color(0.3, 0.2, 0.1, 0.5), 1.0)
	draw_circle(Vector2(oak_x + 46, oak_y + 59), 1.5, Color(0.3, 0.3, 0.3))

	# --- DECORATIONS ---
	for dec in _decorations:
		var dtype: String = dec["type"]
		var dpos: Vector2 = dec["pos"]
		var dsize: float = dec["size"]
		var dextra: float = dec["extra"]
		if dtype == "oak_tree":
			draw_rect(Rect2(dpos.x - dsize * 0.15, dpos.y - dsize * 0.2, dsize * 0.3, dsize * 0.8), Color(0.1, 0.06, 0.02))
			draw_circle(dpos + Vector2(0, -dsize * 0.4), dsize * 0.5, Color(0.03, 0.15, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, -dsize * 0.2), dsize * 0.35, Color(0.03, 0.15, 0.03, 0.9))
		elif dtype == "target":
			draw_circle(dpos, 7.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 5.0, Color(0.7, 0.15, 0.1))
			draw_circle(dpos, 3.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 1.5, Color(0.7, 0.15, 0.1))
			draw_line(dpos + Vector2(-8, -4), dpos, Color(0.3, 0.2, 0.05), 1.5)
			draw_line(Vector2(dpos.x, dpos.y + 7), Vector2(dpos.x, dpos.y + 16), Color(0.2, 0.12, 0.04), 2.5)
		elif dtype == "bush":
			draw_circle(dpos, dsize * 0.5, Color(0.04, 0.16 + dextra * 0.05, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, dsize * 0.1), dsize * 0.35, Color(0.04, 0.16, 0.03, 0.9))
			draw_circle(dpos + Vector2(dsize * 0.25, dsize * 0.08), dsize * 0.38, Color(0.04, 0.16, 0.03, 0.9))
			if dextra > 0.5:
				for b in range(3):
					draw_circle(dpos + Vector2(cos(float(b) * 2.1) * dsize * 0.25, sin(float(b) * 2.1) * dsize * 0.15 - dsize * 0.1), 2.0, Color(0.5, 0.05, 0.1))
		elif dtype == "deer":
			var deer_col := Color(0.15, 0.1, 0.05)
			var facing: float = -1.0 if dextra > 0.5 else 1.0
			var body_pts: PackedVector2Array = PackedVector2Array()
			for da in range(16):
				body_pts.append(dpos + Vector2(cos(float(da) * TAU / 16.0) * dsize * 0.4 * facing, sin(float(da) * TAU / 16.0) * dsize * 0.2))
			draw_colored_polygon(body_pts, deer_col)
			var head_pos: Vector2 = dpos + Vector2(dsize * 0.5 * facing, -dsize * 0.35)
			draw_line(dpos + Vector2(dsize * 0.3 * facing, -dsize * 0.1), head_pos, deer_col, dsize * 0.1)
			draw_circle(head_pos, dsize * 0.1, deer_col)
			var ab: Vector2 = head_pos + Vector2(0, -dsize * 0.1)
			draw_line(ab, ab + Vector2(-dsize * 0.12 * facing, -dsize * 0.2), deer_col, 1.5)
			draw_line(ab, ab + Vector2(dsize * 0.08 * facing, -dsize * 0.22), deer_col, 1.5)
			draw_line(ab + Vector2(-dsize * 0.12 * facing, -dsize * 0.2), ab + Vector2(-dsize * 0.2 * facing, -dsize * 0.25), deer_col, 1.0)
			for li in range(4):
				var loff: Array = [-0.2, -0.08, 0.08, 0.2]
				draw_line(Vector2(dpos.x + loff[li] * dsize * facing, dpos.y + dsize * 0.15), Vector2(dpos.x + loff[li] * dsize * facing + facing * 2.0, dpos.y + dsize * 0.45), deer_col, 2.0)
			draw_circle(head_pos + Vector2(dsize * 0.05 * facing, -dsize * 0.02), 1.0, Color(0.4, 0.3, 0.1))
		elif dtype == "campfire":
			var fi: float = 0.7 + 0.3 * sin(_time * 5.0 + dextra * 10.0)
			draw_circle(dpos, dsize * 3.0, Color(0.4, 0.15, 0.02, 0.08 * fi))
			draw_circle(dpos, dsize * 2.0, Color(0.5, 0.2, 0.03, 0.12 * fi))
			for fs in range(8):
				draw_circle(dpos + Vector2(cos(float(fs) * TAU / 8.0) * dsize * 0.7, sin(float(fs) * TAU / 8.0) * dsize * 0.35), 3.0, Color(0.2, 0.18, 0.15))
			draw_line(dpos + Vector2(-dsize * 0.5, dsize * 0.15), dpos + Vector2(dsize * 0.5, dsize * 0.15), Color(0.2, 0.1, 0.02), 4.0)
			for fl in range(6):
				var flame_x: float = dpos.x + sin(float(fl) * 1.7 + _time * 4.0) * dsize * 0.3
				var flame_h: float = dsize * (0.6 + 0.4 * sin(_time * 6.0 + float(fl) * 2.0)) * fi
				var fc: Color = Color(0.95, 0.85, 0.2, 0.9) if fl < 2 else (Color(0.95, 0.5, 0.05, 0.85) if fl < 4 else Color(0.8, 0.2, 0.02, 0.7))
				draw_line(Vector2(flame_x, dpos.y + dsize * 0.1), Vector2(flame_x + sin(_time * 3.0 + float(fl)) * 3.0, dpos.y - flame_h), fc, 3.5 - float(fl) * 0.3)
			draw_circle(dpos + Vector2(0, -dsize * 0.1), dsize * 0.2, Color(1.0, 0.9, 0.4, 0.4 * fi))
			# cooking spit and pot
			draw_line(Vector2(dpos.x - dsize * 1.2, dpos.y + dsize * 0.2), Vector2(dpos.x - dsize * 1.2, dpos.y - dsize * 0.6), Color(0.2, 0.12, 0.04), 2.5)
			draw_line(Vector2(dpos.x + dsize * 1.2, dpos.y + dsize * 0.2), Vector2(dpos.x + dsize * 1.2, dpos.y - dsize * 0.6), Color(0.2, 0.12, 0.04), 2.5)
			draw_line(Vector2(dpos.x - dsize * 1.2, dpos.y - dsize * 0.6), Vector2(dpos.x + dsize * 1.2, dpos.y - dsize * 0.6), Color(0.2, 0.12, 0.04), 2.0)
			draw_arc(Vector2(dpos.x, dpos.y - dsize * 0.3), dsize * 0.2, 0, PI, 10, Color(0.12, 0.12, 0.12), 3.0)
			# smoke
			for sm in range(4):
				var smoke_t: float = fmod(_time * 0.8 + float(sm) * 0.7, 3.0)
				draw_circle(Vector2(dpos.x + sin(smoke_t * 2.0 + float(sm)) * 10.0, dpos.y - dsize * 0.8 - smoke_t * 30.0), 4.0 + smoke_t * 5.0, Color(0.4, 0.4, 0.45, clampf(0.25 - smoke_t * 0.08, 0.0, 0.25)))
			# sparks
			for sp in range(6):
				var spark_t: float = fmod(_time * 1.5 + float(sp) * 0.5, 2.0)
				draw_circle(Vector2(dpos.x + sin(spark_t * 3.0 + float(sp) * 2.0) * 15.0, dpos.y - dsize * 0.3 - spark_t * 40.0), 1.0, Color(1.0, 0.7, 0.1, clampf(0.8 - spark_t * 0.4, 0.0, 0.8)))

	# --- FOREGROUND TREE FRAMING ---
	draw_rect(Rect2(-10, 200, 35, 500), Color(0.06, 0.03, 0.01))
	draw_circle(Vector2(12, 180), 60.0, Color(0.02, 0.08, 0.02, 0.95))
	draw_circle(Vector2(-15, 210), 45.0, Color(0.02, 0.08, 0.02, 0.95))
	draw_line(Vector2(25, 250), Vector2(120, 200), Color(0.06, 0.03, 0.01), 5.0)
	draw_rect(Rect2(1258, 280, 30, 440), Color(0.06, 0.03, 0.01))
	draw_circle(Vector2(1270, 260), 50.0, Color(0.02, 0.08, 0.02, 0.95))

	# --- FIREFLIES ---
	for ff in range(18):
		var ff_phase: float = _time * 0.6 + float(ff) * 1.1
		var ff_x: float = 100.0 + fmod(float(ff) * 73.0, 1080.0) + sin(ff_phase) * 20.0
		var ff_y: float = 300.0 + fmod(float(ff) * 47.0, 250.0) + cos(ff_phase * 0.7) * 15.0
		var ff_alpha: float = clampf(0.5 + 0.5 * sin(ff_phase * 2.5), 0.0, 1.0)
		draw_circle(Vector2(ff_x, ff_y), 4.0, Color(0.9, 0.8, 0.2, ff_alpha * 0.3))
		draw_circle(Vector2(ff_x, ff_y), 1.5, Color(1.0, 0.95, 0.4, ff_alpha))

	# --- FALLING LEAVES ---
	for fl in range(8):
		var leaf_phase: float = fmod(_time * 0.3 + float(fl) * 2.5, 6.0)
		var leaf_x: float = 100.0 + fmod(float(fl) * 157.0, 1080.0) + sin(leaf_phase * 1.5) * 30.0 + leaf_phase * 8.0
		var leaf_y: float = 100.0 + leaf_phase * 85.0
		if leaf_y < 620.0:
			var leaf_cols: Array = [Color(0.7, 0.4, 0.05, 0.6), Color(0.6, 0.15, 0.05, 0.6), Color(0.65, 0.5, 0.1, 0.6)]
			draw_circle(Vector2(leaf_x + cos(leaf_phase * 3.0) * 3.0, leaf_y + sin(leaf_phase * 3.0) * 1.5), 2.5, leaf_cols[fl % 3])

	# --- WARM GLOW OVERLAY ---
	for dec3 in _decorations:
		if dec3["type"] == "campfire":
			var gp: Vector2 = dec3["pos"]
			var gpulse: float = 0.8 + 0.2 * sin(_time * 3.0)
			for gr in range(4):
				draw_circle(gp, 60.0 + float(gr) * 40.0, Color(0.9, 0.5, 0.1, (0.04 - float(gr) * 0.008) * gpulse))

	# --- BRANCHES OVER MOON ---
	draw_line(Vector2(870, 100), Vector2(940, 130), Color(0.02, 0.06, 0.02), 3.5)
	draw_line(Vector2(920, 90), Vector2(960, 140), Color(0.02, 0.06, 0.02), 2.5)
	draw_circle(Vector2(935, 125), 10.0, Color(0.02, 0.07, 0.02, 0.85))
	draw_circle(Vector2(955, 120), 8.0, Color(0.02, 0.07, 0.02, 0.8))
	_draw_robin_novel(1)
	_draw_shadow_author_effects()

func _draw_alice_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Oversized moon
	var moon_pos = Vector2(1000, 100)
	draw_circle(moon_pos, 55, Color(0.85, 0.7, 0.9, 0.3))
	draw_circle(moon_pos, 45, Color(0.9, 0.75, 0.95, 0.45))
	draw_circle(moon_pos, 35, Color(0.95, 0.82, 0.98, 0.55))
	draw_arc(moon_pos, 50.0 + sin(_time * 0.5) * 3.0, 0, TAU, 48, Color(0.9, 0.75, 0.95, 0.1), 2.0)
	# Cheshire Cat grin
	var grin_alpha = (sin(_time * 0.7) + 1.0) * 0.5
	if grin_alpha > 0.15:
		var gc = Vector2(950, 350) + Vector2(sin(_time * 0.3) * 5.0, cos(_time * 0.4) * 3.0)
		draw_arc(gc, 20.0, 0.1, PI - 0.1, 16, Color(0.9, 0.3, 0.8, grin_alpha * 0.6), 2.5)
		for i in range(7):
			var tooth_a = 0.2 + float(i) * 0.37
			draw_line(gc + Vector2.from_angle(tooth_a) * 18.0, gc + Vector2.from_angle(tooth_a) * 22.0, Color(0.95, 0.95, 0.9, grin_alpha * 0.5), 1.5)
		draw_circle(gc + Vector2(-12, -18), 5.0, Color(0.8, 0.9, 0.1, grin_alpha * 0.7))
		draw_circle(gc + Vector2(12, -18), 5.0, Color(0.8, 0.9, 0.1, grin_alpha * 0.7))
		draw_circle(gc + Vector2(-12, -18), 2.0, Color(0.1, 0.05, 0.2, grin_alpha * 0.7))
		draw_circle(gc + Vector2(12, -18), 2.0, Color(0.1, 0.05, 0.2, grin_alpha * 0.7))
	# Checkerboard patches
	for i in range(12):
		var cx = float(i) * 110.0 + 20.0
		for j in range(6):
			var cy = 380.0 + float(j) * 40.0
			var is_white = (i + j) % 2 == 0
			var tc = Color(0.85, 0.82, 0.78, 0.08) if is_white else Color(0.05, 0.04, 0.06, 0.1)
			draw_rect(Rect2(cx, cy, 40, 40), tc)
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"giant_mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var glow_pulse = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 0.8, mp.y - ms * 4.0, ms * 1.6, ms * 4.0), Color(0.85, 0.8, 0.7, 0.5))
				var cap_center = mp + Vector2(0, -ms * 4.5)
				draw_circle(cap_center, ms * 3.0 + 4.0, Color(0.7, 0.2, 0.8, 0.1 + glow_pulse * 0.08))
				draw_circle(cap_center, ms * 3.0, Color(0.8, 0.25, 0.4, 0.5))
				draw_circle(cap_center + Vector2(-ms, -ms * 0.5), ms * 0.5, Color(1, 0.95, 0.85, 0.4))
			"floating_card":
				var cp = dec["pos"]
				var drift_y = sin(_time * 0.8 + dec["extra"]) * 15.0
				var drift_x = cos(_time * 0.5 + dec["extra"]) * 8.0
				var card_pos = cp + Vector2(drift_x, drift_y)
				draw_rect(Rect2(card_pos.x - 4, card_pos.y - 6, 8, 12), Color(1.0, 0.98, 0.9, 0.25))
				var suit_col = Color(0.8, 0.15, 0.15, 0.35) if dec["extra"] > 3.0 else Color(0.1, 0.1, 0.1, 0.35)
				draw_circle(card_pos, 2.0, suit_col)
			"rose":
				var rp = dec["pos"]
				var sway = sin(_time * 1.2 + dec["extra"]) * 2.0
				draw_line(rp, rp + Vector2(sway, -12), Color(0.15, 0.4, 0.1, 0.45), 1.5)
				var bloom = rp + Vector2(sway, -12)
				var rc = Color(0.85, 0.1, 0.15, 0.5) if dec["extra"] < 0.5 else Color(0.95, 0.9, 0.85, 0.5)
				draw_circle(bloom, dec["size"], rc)
			"teacup":
				var tp = dec["pos"]
				draw_rect(Rect2(tp.x - 4, tp.y - 5, 8, 6), Color(0.8, 0.75, 0.6, 0.4))
				draw_arc(Vector2(tp.x + 5, tp.y - 2), 3, -PI * 0.5, PI * 0.5, 6, Color(0.8, 0.75, 0.6, 0.35), 1.0)
	# Path (mosaic tile road)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.15, 0.08, 0.18), 52.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.55, 0.4, 0.6), 44.0)
		for i in range(0, points.size() - 1, 8):
			var tile_alt = (i / 8) % 2 == 0
			var tc = Color(0.7, 0.5, 0.75, 0.35) if tile_alt else Color(0.45, 0.3, 0.55, 0.35)
			draw_rect(Rect2(points[i].x - 4, points[i].y - 4, 8, 8), tc)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.7, 0.55, 0.75, 0.2), 12.0)
	# Foreground haze
	for i in range(6):
		draw_circle(Vector2(float(i) * 220.0 + sin(_time * 0.3 + float(i)) * 30.0, 580.0), 60.0, Color(0.6, 0.3, 0.7, 0.03))
	_draw_alice_novel(1)
	_draw_shadow_author_effects()

func _draw_oz_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Tornado funnel in distance
	var tornado_x = 1100.0 + sin(_time * 0.3) * 15.0
	for i in range(20):
		var t = float(i) / 19.0
		var y_pos = lerp(400.0, 60.0, t)
		var width = lerp(50.0, 8.0, t)
		var sway = sin(_time * 2.0 + t * 4.0) * (10.0 * (1.0 - t))
		draw_line(Vector2(tornado_x + sway - width, y_pos), Vector2(tornado_x + sway + width, y_pos), Color(0.25, 0.28, 0.2, 0.08 + t * 0.06), 3.0)
	# Emerald City silhouette
	var city_x = 300.0
	var city_base_y = 180.0
	draw_rect(Rect2(city_x - 70, city_base_y, 140, 20), Color(0.1, 0.3, 0.12, 0.35))
	var towers_data = [{"x": -50.0, "h": 80.0, "w": 14.0}, {"x": -25.0, "h": 110.0, "w": 16.0}, {"x": 0.0, "h": 140.0, "w": 20.0}, {"x": 25.0, "h": 100.0, "w": 15.0}, {"x": 50.0, "h": 70.0, "w": 12.0}]
	for td in towers_data:
		var tx = city_x + td["x"]
		var tw = td["w"]
		var th = td["h"]
		draw_rect(Rect2(tx - tw * 0.5, city_base_y - th, tw, th), Color(0.12, 0.35, 0.15, 0.4))
		draw_colored_polygon(PackedVector2Array([Vector2(tx - tw * 0.5, city_base_y - th), Vector2(tx + tw * 0.5, city_base_y - th), Vector2(tx, city_base_y - th - 20)]), Color(0.1, 0.4, 0.15, 0.45))
	for i in range(8):
		var sparkle = (sin(_time * 3.0 + float(i) * 1.7) + 1.0) * 0.5
		if sparkle > 0.6:
			draw_circle(Vector2(city_x - 55.0 + float(i) * 15.0, city_base_y - 30.0 - float(i % 3) * 35.0), 1.5, Color(0.4, 1.0, 0.5, sparkle * 0.5))
	draw_circle(Vector2(city_x, city_base_y - 50), 80.0, Color(0.15, 0.5, 0.2, 0.04 + sin(_time) * 0.015))
	# Ground terrain
	draw_rect(Rect2(0, 440, 1280, 190), Color(0.12, 0.22, 0.06, 0.3))
	draw_rect(Rect2(0, 520, 1280, 110), Color(0.1, 0.18, 0.04, 0.25))
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"poppy":
				var pp = dec["pos"]
				var ps = dec["size"]
				var sway = sin(_time * 1.3 + dec["extra"]) * 2.0
				draw_line(pp, pp + Vector2(sway, -ps * 6.0), Color(0.15, 0.35, 0.1, 0.5), 1.0)
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 2.5, Color(0.85, 0.12, 0.1, 0.55))
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 0.7, Color(0.15, 0.1, 0.05, 0.5))
			"emerald_crystal":
				var ep = dec["pos"]
				var es = dec["size"]
				var sparkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				draw_colored_polygon(PackedVector2Array([ep + Vector2(0, -es * 2), ep + Vector2(es, 0), ep + Vector2(0, es), ep + Vector2(-es, 0)]), Color(0.2, 0.8, 0.3, 0.4 + sparkle * 0.15))
			"scarecrow":
				var sp = dec["pos"]
				var ss = dec["size"]
				draw_line(sp, sp + Vector2(0, -ss * 2), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_line(sp + Vector2(-ss, -ss * 1.5), sp + Vector2(ss, -ss * 1.5), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_circle(sp + Vector2(0, -ss * 2.2), ss * 0.5, Color(0.6, 0.5, 0.2, 0.45))
	# Path (yellow brick road)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.2, 0.15, 0.05), 52.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.75, 0.6, 0.15), 44.0)
		for i in range(0, points.size() - 1, 10):
			var bright = Color(0.85, 0.72, 0.2, 0.4)
			var dark = Color(0.65, 0.5, 0.1, 0.35)
			if (i / 10) % 2 == 0:
				draw_rect(Rect2(points[i].x - 8, points[i].y - 10, 16, 9), bright)
				draw_rect(Rect2(points[i].x - 8, points[i].y + 1, 16, 9), dark)
			else:
				draw_rect(Rect2(points[i].x - 8, points[i].y - 10, 16, 9), dark)
				draw_rect(Rect2(points[i].x - 8, points[i].y + 1, 16, 9), bright)
		for i in range(0, points.size() - 1, 30):
			var shimmer = (sin(_time * 2.0 + float(i) * 0.5) + 1.0) * 0.5
			if shimmer > 0.7:
				draw_circle(points[i], 3.0, Color(1.0, 0.95, 0.5, shimmer * 0.2))
	_draw_oz_novel(1)
	_draw_shadow_author_effects()

func _draw_peter_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Stars
	for dec in _decorations:
		if dec["type"] == "star":
			var twinkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
			var alpha = dec["size"] * (0.4 + twinkle * 0.6)
			draw_circle(dec["pos"], 1.0 + twinkle * 0.8, Color(1.0, 0.97, 0.8, alpha))
	# Second star to the right
	var second_star = Vector2(980, 72)
	var ss_twinkle = (sin(_time * 1.5) + 1.0) * 0.5
	draw_circle(second_star, 3.0 + ss_twinkle, Color(1.0, 0.95, 0.6, 0.9))
	draw_circle(second_star, 6.0 + ss_twinkle * 2.0, Color(1.0, 0.95, 0.6, 0.15))
	for a in [0, PI / 2.0, PI / 4.0, -PI / 4.0]:
		var ray = Vector2.from_angle(a) * (5.0 + ss_twinkle * 3.0)
		draw_line(second_star - ray, second_star + ray, Color(1.0, 0.95, 0.7, 0.25), 1.0)
	# Moon
	draw_circle(Vector2(180, 90), 28, Color(0.9, 0.88, 0.7, 0.7))
	draw_circle(Vector2(190, 84), 24, Color(0.04, 0.06, 0.14))
	# Mermaid Lagoon
	var lagoon_center = Vector2(1050, 500)
	draw_circle(lagoon_center, 70, Color(0.1, 0.35, 0.45, 0.5))
	draw_circle(lagoon_center, 60, Color(0.15, 0.45, 0.55, 0.4))
	draw_circle(lagoon_center, 45, Color(0.2, 0.55, 0.65, 0.35))
	for i in range(3):
		draw_arc(lagoon_center, 30.0 + float(i) * 15.0 + sin(_time * 0.8 + float(i)) * 3.0, 0, TAU, 24, Color(0.4, 0.7, 0.8, 0.12), 1.0)
	# Skull Rock
	var skull_pos = Vector2(100, 480)
	draw_circle(skull_pos, 22, Color(0.3, 0.28, 0.25))
	draw_circle(skull_pos, 18, Color(0.38, 0.35, 0.3))
	draw_circle(skull_pos + Vector2(-5, -4), 4, Color(0.12, 0.1, 0.08))
	draw_circle(skull_pos + Vector2(5, -4), 4, Color(0.12, 0.1, 0.08))
	for i in range(5):
		draw_line(Vector2(skull_pos.x - 5.0 + float(i) * 2.5, skull_pos.y + 7), Vector2(skull_pos.x - 5.0 + float(i) * 2.5, skull_pos.y + 11), Color(0.35, 0.32, 0.28), 1.5)
	# Jolly Roger
	var ship_x = 850.0
	var ship_y = 110.0
	draw_colored_polygon(PackedVector2Array([Vector2(ship_x - 40, ship_y), Vector2(ship_x + 40, ship_y), Vector2(ship_x + 30, ship_y + 12), Vector2(ship_x - 30, ship_y + 12)]), Color(0.12, 0.08, 0.06, 0.5))
	draw_line(Vector2(ship_x, ship_y), Vector2(ship_x, ship_y - 35), Color(0.15, 0.1, 0.08, 0.5), 2.0)
	draw_colored_polygon(PackedVector2Array([Vector2(ship_x, ship_y - 30), Vector2(ship_x + 20, ship_y - 20), Vector2(ship_x, ship_y - 8)]), Color(0.2, 0.15, 0.12, 0.35))
	# Ground cover
	draw_rect(Rect2(0, 400, 1280, 230), Color(0.08, 0.2, 0.06, 0.3))
	draw_rect(Rect2(0, 500, 1280, 130), Color(0.06, 0.16, 0.04, 0.2))
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var mh = dec["extra"]
				draw_line(mp, mp + Vector2(0, -ms * 1.5), Color(0.85, 0.82, 0.7), ms * 0.4)
				var cap_col = Color(0.8, 0.2, 0.15, 0.7) if mh < 0.33 else (Color(0.7, 0.5, 0.15, 0.7) if mh < 0.66 else Color(0.6, 0.2, 0.6, 0.7))
				draw_circle(mp + Vector2(0, -ms * 1.5), ms, cap_col)
				draw_circle(mp + Vector2(-ms * 0.3, -ms * 1.7), ms * 0.2, Color(1, 1, 1, 0.5))
			"jungle_tree":
				var tp = dec["pos"]
				var cr = dec["size"]
				var sh = dec["extra"]
				var th = cr * 0.8
				draw_line(tp, tp + Vector2(0, -th), Color(0.3 + sh, 0.2 + sh, 0.08), 3.0 + cr * 0.1)
				draw_circle(tp + Vector2(0, -th), cr, Color(0.1 + sh, 0.35 + sh, 0.08 + sh * 0.5, 0.55))
				draw_circle(tp + Vector2(-cr * 0.4, -th + cr * 0.2), cr * 0.6, Color(0.12 + sh, 0.37 + sh, 0.1, 0.5))
				if cr > 20:
					draw_line(tp + Vector2(-cr * 0.3, -th + cr * 0.5), tp + Vector2(-cr * 0.4, -th + cr + 8), Color(0.15, 0.4, 0.1, 0.3), 1.0)
			"fairy":
				var fp = dec["pos"]
				var fo = dec["extra"]
				var drift = Vector2(sin(_time * 1.2 + fo) * 8.0, cos(_time * 0.9 + fo) * 5.0)
				var pulse = (sin(_time * 3.0 + fo) + 1.0) * 0.5
				draw_circle(fp + drift, 1.5 + pulse, Color(1.0, 0.92, 0.3, 0.5 + pulse * 0.3))
				draw_circle(fp + drift, 4.0 + pulse * 2.0, Color(1.0, 0.9, 0.3, 0.08 + pulse * 0.06))
	# Underground Home
	var tree_home = Vector2(1180, 350)
	draw_rect(Rect2(tree_home.x - 16, tree_home.y - 60, 32, 80), Color(0.3, 0.18, 0.08))
	draw_rect(Rect2(tree_home.x - 12, tree_home.y - 55, 24, 70), Color(0.38, 0.24, 0.1))
	draw_circle(tree_home + Vector2(0, 5), 7, Color(0.12, 0.08, 0.04))
	draw_circle(tree_home + Vector2(0, -65), 35, Color(0.12, 0.35, 0.08, 0.7))
	draw_circle(tree_home + Vector2(-18, -55), 22, Color(0.14, 0.38, 0.1, 0.6))
	draw_circle(tree_home + Vector2(18, -55), 22, Color(0.1, 0.32, 0.07, 0.6))
	# Path (jungle trail)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.15, 0.1, 0.05), 52.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.35, 0.22, 0.1), 44.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.45, 0.32, 0.16, 0.5), 24.0)
	_draw_peter_novel(1)
	_draw_shadow_author_effects()

func _draw_phantom_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Organ pipes silhouette
	var organ_x = 640.0
	var pipe_widths = [6, 8, 10, 12, 14, 14, 12, 10, 8, 6]
	var pipe_heights = [80, 100, 120, 145, 160, 155, 140, 115, 95, 75]
	var pipe_x = organ_x - 55.0
	for i in range(pipe_widths.size()):
		draw_rect(Rect2(pipe_x, 100.0 - pipe_heights[i], pipe_widths[i], pipe_heights[i]), Color(0.12, 0.06, 0.08, 0.5))
		draw_rect(Rect2(pipe_x - 1, 100.0 - pipe_heights[i] - 3, pipe_widths[i] + 2, 4), Color(0.25, 0.15, 0.1, 0.45))
		pipe_x += float(pipe_widths[i]) + 3.0
	# Red velvet curtains
	for i in range(8):
		var cx = 10.0 + float(i) * 8.0
		var fold = sin(float(i) * 1.2) * 4.0
		draw_line(Vector2(cx + fold, 50), Vector2(cx + fold * 0.5, 620), Color(0.35, 0.04, 0.06, 0.55 - float(i) * 0.05), 8.0)
	for i in range(8):
		var cx = 1270.0 - float(i) * 8.0
		var fold = sin(float(i) * 1.2) * 4.0
		draw_line(Vector2(cx - fold, 50), Vector2(cx - fold * 0.5, 620), Color(0.35, 0.04, 0.06, 0.55 - float(i) * 0.05), 8.0)
	draw_circle(Vector2(85, 200), 6, Color(0.85, 0.65, 0.1, 0.5))
	draw_circle(Vector2(1195, 200), 6, Color(0.85, 0.65, 0.1, 0.5))
	# Grand chandelier
	var chandelier_sway = sin(_time * 0.6) * 8.0
	var ch_center = Vector2(640 + chandelier_sway, 80)
	draw_line(Vector2(640, 50), ch_center, Color(0.7, 0.55, 0.15, 0.5), 2.0)
	draw_arc(ch_center, 35, 0, TAU, 24, Color(0.8, 0.65, 0.15, 0.5), 2.5)
	for i in range(8):
		var angle = float(i) * TAU / 8.0 + _time * 0.1
		var arm_end = ch_center + Vector2.from_angle(angle) * 35.0
		draw_line(ch_center + Vector2.from_angle(angle) * 28.0, arm_end, Color(0.8, 0.65, 0.15, 0.45), 1.5)
		var flicker = sin(_time * 5.0 + float(i) * 2.0) * 0.15
		draw_circle(arm_end + Vector2(0, -3), 2.5 + flicker, Color(1.0, 0.8, 0.2, 0.6 + flicker))
	for i in range(12):
		var angle = float(i) * TAU / 12.0
		var crystal_pos = ch_center + Vector2.from_angle(angle) * 22.0 + Vector2(0, 8)
		var sparkle = (sin(_time * 4.0 + float(i) * 1.5) + 1.0) * 0.5
		draw_line(crystal_pos, crystal_pos + Vector2(0, 6 + sparkle * 3), Color(0.9, 0.85, 1.0, 0.2 + sparkle * 0.2), 1.0)
	# Underground lake
	draw_rect(Rect2(0, 560, 1280, 68), Color(0.03, 0.02, 0.06, 0.7))
	for i in range(32):
		var wave_y = 560.0 + sin(_time * 1.2 + float(i) * 0.8) * 2.0
		draw_line(Vector2(float(i) * 42.0, wave_y), Vector2(float(i) * 42.0 + 42, wave_y + sin(_time * 1.2 + float(i + 1) * 0.8) * 2.0), Color(0.15, 0.1, 0.25, 0.3), 1.5)
	draw_circle(Vector2(640 + chandelier_sway, 585), 30, Color(0.3, 0.2, 0.05, 0.06))
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"candelabra":
				var cp = dec["pos"]
				var cs = dec["size"]
				draw_line(cp, cp + Vector2(0, -cs * 12.0), Color(0.6, 0.45, 0.1, 0.5), 2.5)
				draw_line(cp + Vector2(-cs * 3, 0), cp + Vector2(cs * 3, 0), Color(0.6, 0.45, 0.1, 0.45), 2.0)
				var arm_top = cp + Vector2(0, -cs * 12.0)
				draw_line(arm_top, arm_top + Vector2(-cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				draw_line(arm_top, arm_top + Vector2(cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				var flames = [arm_top + Vector2(0, -cs * 2), arm_top + Vector2(-cs * 5, -cs * 5), arm_top + Vector2(cs * 5, -cs * 5)]
				for fi in range(flames.size()):
					var flicker = sin(_time * 5.5 + dec["extra"] + float(fi) * 1.7) * 0.2
					draw_circle(flames[fi], 2.5 + flicker, Color(1.0, 0.75, 0.15, 0.6 + flicker))
					draw_circle(flames[fi], 18.0, Color(1.0, 0.6, 0.1, 0.02))
			"mirror":
				var mp = dec["pos"]
				var ms = dec["size"]
				draw_rect(Rect2(mp.x - ms * 8 - 3, mp.y - ms * 12 - 3, ms * 16 + 6, ms * 24 + 6), Color(0.8, 0.6, 0.1, 0.45))
				draw_rect(Rect2(mp.x - ms * 8, mp.y - ms * 12, ms * 16, ms * 24), Color(0.08, 0.05, 0.12, 0.7))
				var shimmer = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 5, mp.y - ms * 8, ms * 3, ms * 16), Color(0.4, 0.35, 0.5, shimmer * 0.1))
			"rose":
				var rp = dec["pos"]
				draw_circle(rp, dec["size"], Color(0.85, 0.1, 0.1, 0.5))
				draw_circle(rp, dec["size"] * 0.5, Color(0.95, 0.2, 0.15, 0.4))
			"sheet_music":
				var smp = dec["pos"]
				var sms = dec["size"]
				var drift = sin(_time * 0.6 + dec["extra"]) * 5.0
				draw_rect(Rect2(smp.x - sms + drift, smp.y - sms * 1.5, sms * 2, sms * 3), Color(0.85, 0.82, 0.7, 0.2))
				for line_idx in range(5):
					draw_line(Vector2(smp.x - sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Vector2(smp.x + sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Color(0.2, 0.15, 0.1, 0.15), 0.5)
	# Path (stone floor with red carpet)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.15, 0.1, 0.08), 54.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.25, 0.2, 0.18), 46.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.5, 0.06, 0.08, 0.55), 24.0)
		for i in range(points.size() - 1):
			if i + 1 < points.size():
				var dir = (points[i + 1] - points[i]).normalized()
				var perp = Vector2(-dir.y, dir.x)
				draw_line(points[i] + perp * 12, points[i + 1] + perp * 12, Color(0.8, 0.6, 0.1, 0.18), 1.5)
				draw_line(points[i] - perp * 12, points[i + 1] - perp * 12, Color(0.8, 0.6, 0.1, 0.18), 1.5)
		for i in range(0, points.size() - 1, 24):
			draw_colored_polygon(PackedVector2Array([points[i] + Vector2(0, -5), points[i] + Vector2(4, 0), points[i] + Vector2(0, 5), points[i] + Vector2(-4, 0)]), Color(0.85, 0.65, 0.1, 0.2))
	_draw_phantom_novel(1)
	_draw_shadow_author_effects()

func _draw_scrooge_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Fog layers
	for i in range(6):
		var fog_y = 200.0 + float(i) * 70.0
		draw_rect(Rect2(-20 + sin(_time * 0.15 + float(i) * 1.5) * 40.0, fog_y, 1320, 30), Color(0.4, 0.42, 0.5, 0.04))
	# Victorian building silhouettes
	var bldg_data = [{"x": 50.0, "w": 100.0, "h": 150.0}, {"x": 155.0, "w": 80.0, "h": 130.0}, {"x": 240.0, "w": 110.0, "h": 170.0}, {"x": 360.0, "w": 90.0, "h": 140.0}, {"x": 460.0, "w": 70.0, "h": 120.0}, {"x": 750.0, "w": 100.0, "h": 155.0}, {"x": 860.0, "w": 85.0, "h": 135.0}, {"x": 950.0, "w": 110.0, "h": 165.0}, {"x": 1070.0, "w": 95.0, "h": 145.0}, {"x": 1170.0, "w": 80.0, "h": 125.0}]
	var bldg_base_y = 340.0
	for bd in bldg_data:
		var bx = bd["x"]
		var bw = bd["w"]
		var bh = bd["h"]
		draw_rect(Rect2(bx, bldg_base_y - bh, bw, bh), Color(0.06, 0.06, 0.08, 0.6))
		draw_colored_polygon(PackedVector2Array([Vector2(bx - 3, bldg_base_y - bh), Vector2(bx + bw + 3, bldg_base_y - bh), Vector2(bx + bw * 0.5, bldg_base_y - bh - 15)]), Color(0.07, 0.06, 0.09, 0.55))
		for wy in range(3):
			for wx_off in range(3):
				var win_x = bx + 10.0 + float(wx_off) * (bw - 20.0) / 2.0
				var win_y = bldg_base_y - bh + 20.0 + float(wy) * 35.0
				if win_y < bldg_base_y - 10:
					var lit = sin(float(int(bx) + wx_off * 7 + wy * 13) * 0.5) > 0
					draw_rect(Rect2(win_x, win_y, 8, 10), Color(0.7, 0.55, 0.2, 0.2) if lit else Color(0.04, 0.04, 0.06, 0.4))
		var ch_x = bx + bw * 0.3
		draw_rect(Rect2(ch_x, bldg_base_y - bh - 25, 8, 20), Color(0.08, 0.07, 0.09, 0.55))
		for sc in range(3):
			draw_circle(Vector2(ch_x + 4.0 + sin(_time * 0.5 + bd["x"] * 0.01 + float(sc)) * 5.0, bldg_base_y - bh - 28.0 - float(sc) * 12.0), 5.0 + float(sc) * 3.0, Color(0.4, 0.4, 0.45, 0.08 - float(sc) * 0.02))
	# Church steeple
	var church_x = 620.0
	draw_rect(Rect2(church_x - 18, bldg_base_y - 200, 36, 200), Color(0.07, 0.06, 0.09, 0.65))
	draw_colored_polygon(PackedVector2Array([Vector2(church_x - 20, bldg_base_y - 200), Vector2(church_x + 20, bldg_base_y - 200), Vector2(church_x, bldg_base_y - 260)]), Color(0.06, 0.05, 0.08, 0.6))
	draw_line(Vector2(church_x, bldg_base_y - 260), Vector2(church_x, bldg_base_y - 275), Color(0.3, 0.28, 0.25, 0.45), 2.0)
	draw_line(Vector2(church_x - 6, bldg_base_y - 268), Vector2(church_x + 6, bldg_base_y - 268), Color(0.3, 0.28, 0.25, 0.45), 2.0)
	# Clock face
	var clock_center = Vector2(church_x, bldg_base_y - 170)
	draw_circle(clock_center, 12, Color(0.75, 0.7, 0.6, 0.4))
	draw_circle(clock_center, 10, Color(0.15, 0.12, 0.1, 0.5))
	draw_line(clock_center, clock_center + Vector2(0, -8), Color(0.85, 0.8, 0.6, 0.5), 1.5)
	draw_line(clock_center, clock_center + Vector2(0, -9.5), Color(0.85, 0.8, 0.6, 0.4), 1.0)
	# Thames river
	var river_y = 555.0
	draw_rect(Rect2(0, river_y, 1280, 73), Color(0.04, 0.05, 0.08, 0.65))
	for i in range(24):
		var ry = river_y + 10.0 + sin(_time * 0.8 + float(i) * 0.6) * 2.0
		draw_line(Vector2(float(i) * 56.0, ry), Vector2(float(i) * 56.0 + 56, ry + sin(_time * 0.8 + float(i + 1) * 0.6) * 2.0), Color(0.15, 0.18, 0.25, 0.2), 1.0)
	# Ground
	draw_rect(Rect2(0, bldg_base_y, 1280, river_y - bldg_base_y), Color(ground_color.r, ground_color.g, ground_color.b, 0.35))
	for i in range(40):
		draw_circle(Vector2(float(i) * 33.0 + sin(float(i) * 2.3) * 10.0, bldg_base_y + 5.0), 12.0, Color(0.8, 0.82, 0.88, 0.06))
	# Snowflakes
	for i in range(30):
		var sx = fmod(float(i) * 43.7 + sin(_time * 0.6 + float(i)) * 20.0, 1280.0)
		var sy = fmod(_time * 15.0 * (0.5 + fmod(float(i) * 0.3, 1.0)) + float(i) * 50.0, 620.0) + 50.0
		draw_circle(Vector2(sx, sy), 1.5 + fmod(float(i) * 0.7, 1.0), Color(0.9, 0.92, 0.95, 0.3))
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"lamp_post":
				var lp = dec["pos"]
				var ls = dec["size"]
				draw_line(lp, lp + Vector2(0, -ls * 1.4), Color(0.15, 0.12, 0.1, 0.6), 3.0)
				var lamp_top = lp + Vector2(0, -ls * 1.4)
				draw_rect(Rect2(lamp_top.x - ls * 0.2, lamp_top.y - ls * 0.4, ls * 0.4, ls * 0.4), Color(0.18, 0.14, 0.1, 0.5))
				var flicker = sin(_time * 6.0 + dec["extra"]) * 0.15
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.15 + flicker, Color(1.0, 0.75, 0.2, 0.55 + flicker))
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.8, Color(1.0, 0.7, 0.2, 0.04))
			"bare_tree":
				var tp = dec["pos"]
				var ts = dec["size"]
				var sh = dec["extra"]
				draw_line(tp, tp + Vector2(0, -ts * 1.4), Color(0.12, 0.1, 0.08, 0.5), 3.0)
				var branch_base = tp + Vector2(0, -ts * 1.4)
				for b in range(4):
					var b_angle = -PI * 0.6 + float(b) * 0.4 + sin(float(int(sh * 100) + b)) * 0.2
					var b_len = ts * (0.6 + float(b) * 0.2)
					draw_line(branch_base + Vector2(0, float(b) * ts * 0.2), branch_base + Vector2(0, float(b) * ts * 0.2) + Vector2.from_angle(b_angle) * b_len, Color(0.12, 0.1, 0.08, 0.4), 1.5)
			"snow_pile":
				draw_circle(dec["pos"], dec["size"], Color(0.85, 0.87, 0.9, 0.15))
				draw_circle(dec["pos"] + Vector2(dec["size"] * 0.3, -dec["size"] * 0.2), dec["size"] * 0.7, Color(0.88, 0.9, 0.92, 0.12))
			"chimney":
				var cp = dec["pos"]
				var cs = dec["size"]
				draw_rect(Rect2(cp.x - cs * 0.4, cp.y - cs * 2, cs * 0.8, cs * 2), Color(0.15, 0.12, 0.1, 0.4))
				var cf = sin(_time * 0.5 + dec["extra"]) * 4.0
				draw_circle(Vector2(cp.x + cf, cp.y - cs * 2.2), 4.0, Color(0.4, 0.4, 0.45, 0.06))
	# Path (cobblestone)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.08, 0.08, 0.1), 54.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.22, 0.2, 0.22), 46.0)
		for i in range(0, points.size() - 1, 8):
			if i + 1 < points.size():
				var dir = (points[i + 1] - points[i]).normalized()
				var perp = Vector2(-dir.y, dir.x)
				for j in range(-2, 3):
					var stone_x = points[i] + perp * float(j) * 9.0 + dir * float((i / 8) % 2) * 4.0
					var stone_shade = 0.18 + sin(float(i + j * 37) * 0.7) * 0.04
					draw_rect(Rect2(stone_x.x - 3.5, stone_x.y - 3.5, 7, 7), Color(stone_shade, stone_shade, stone_shade + 0.02, 0.4))
		for i in range(0, points.size() - 1, 20):
			draw_circle(points[i] + Vector2(6, -3), 4.0, Color(0.85, 0.87, 0.9, 0.12))
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.28, 0.26, 0.28, 0.18), 16.0)
	_draw_scrooge_novel(1)
	_draw_shadow_author_effects()


func _draw_robin_ch2(sky_color: Color, ground_color: Color) -> void:
	# --- Sky gradient: dark blue-green night sky ---
	for sy in range(0, 50):
		var t: float = float(sy) / 50.0
		var band_color := Color(
			sky_color.r * 0.3 + 0.02 * t,
			sky_color.g * 0.35 + 0.04 * t,
			sky_color.b * 0.5 + 0.06 * t
		)
		draw_line(Vector2(0, float(sy)), Vector2(1280, float(sy)), band_color, 1.5)

	# --- Stars twinkling in night sky ---
	for si in range(45):
		var sx: float = fmod(float(si) * 173.7 + 51.3, 1280.0)
		var star_y: float = fmod(float(si) * 97.1 + 13.7, 45.0) + 5.0
		var twinkle: float = 0.4 + 0.6 * clampf(sin(_time * (1.5 + float(si) * 0.2) + float(si) * 3.7), 0.0, 1.0)
		var star_size: float = 1.0 + fmod(float(si) * 0.7, 1.5)
		draw_circle(Vector2(sx, star_y), star_size, Color(0.85, 0.9, 1.0, twinkle * 0.8))

	# --- Crescent moon ---
	var moon_x: float = 1050.0 + sin(_time * 0.05) * 5.0
	draw_circle(Vector2(moon_x, 25.0), 18.0, Color(0.9, 0.92, 0.8, 0.85))
	draw_circle(Vector2(moon_x + 7.0, 22.0), 15.0, Color(sky_color.r * 0.3, sky_color.g * 0.35, sky_color.b * 0.5))

	# --- Deep sky to forest canopy transition ---
	for sy2 in range(50, 160):
		var t2: float = float(sy2 - 50) / 110.0
		var canopy_col := Color(
			lerp(sky_color.r * 0.3, 0.01, t2),
			lerp(sky_color.g * 0.35, 0.06, t2),
			lerp(sky_color.b * 0.5, 0.03, t2)
		)
		draw_line(Vector2(0, float(sy2)), Vector2(1280, float(sy2)), canopy_col, 1.5)

	# --- Dense forest canopy silhouettes (background layer) ---
	for ct in range(30):
		var cx: float = fmod(float(ct) * 97.3 + 22.0, 1400.0) - 60.0
		var cy: float = 100.0 + fmod(float(ct) * 31.7, 70.0)
		var crad: float = 40.0 + fmod(float(ct) * 17.3, 35.0)
		var sway: float = sin(_time * 0.4 + float(ct) * 0.8) * 3.0
		var canopy_dark := Color(0.01, 0.04 + fmod(float(ct) * 0.003, 0.02), 0.01, 0.92)
		draw_circle(Vector2(cx + sway, cy), crad, canopy_dark)
		draw_circle(Vector2(cx + sway - crad * 0.5, cy + 10.0), crad * 0.7, canopy_dark)

	# --- Sheriff's torches visible through distant trees ---
	for ti in range(5):
		var torch_x: float = 180.0 + float(ti) * 220.0 + sin(_time * 0.3 + float(ti)) * 15.0
		var torch_y: float = 140.0 + fmod(float(ti) * 23.0, 40.0)
		var torch_flicker: float = 0.6 + 0.4 * sin(_time * 7.0 + float(ti) * 4.3)
		# Distant glow halo
		draw_circle(Vector2(torch_x, torch_y), 25.0, Color(0.6, 0.25, 0.02, 0.06 * torch_flicker))
		draw_circle(Vector2(torch_x, torch_y), 14.0, Color(0.7, 0.35, 0.05, 0.1 * torch_flicker))
		# Torch flame
		draw_circle(Vector2(torch_x, torch_y), 4.5, Color(0.95, 0.7, 0.1, 0.7 * torch_flicker))
		draw_circle(Vector2(torch_x, torch_y - 3.0), 2.5, Color(1.0, 0.9, 0.4, 0.8 * torch_flicker))

	# --- Owl silhouettes perched on branches ---
	for oi in range(3):
		var owl_x: float = 200.0 + float(oi) * 400.0 + sin(_time * 0.15 + float(oi) * 2.0) * 8.0
		var owl_y: float = 115.0 + float(oi) * 18.0
		var owl_col := Color(0.02, 0.02, 0.02, 0.9)
		# Body
		draw_circle(Vector2(owl_x, owl_y), 8.0, owl_col)
		# Head
		draw_circle(Vector2(owl_x, owl_y - 9.0), 5.5, owl_col)
		# Ear tufts
		draw_line(Vector2(owl_x - 4.0, owl_y - 13.0), Vector2(owl_x - 6.0, owl_y - 18.0), owl_col, 2.0)
		draw_line(Vector2(owl_x + 4.0, owl_y - 13.0), Vector2(owl_x + 6.0, owl_y - 18.0), owl_col, 2.0)
		# Eyes glow
		var blink: float = 1.0 if fmod(_time + float(oi) * 3.0, 5.0) > 0.3 else 0.0
		draw_circle(Vector2(owl_x - 2.5, owl_y - 9.5), 1.8, Color(0.9, 0.7, 0.1, 0.7 * blink))
		draw_circle(Vector2(owl_x + 2.5, owl_y - 9.5), 1.8, Color(0.9, 0.7, 0.1, 0.7 * blink))
		# Branch underneath
		draw_line(Vector2(owl_x - 30.0, owl_y + 8.0), Vector2(owl_x + 30.0, owl_y + 6.0), Color(0.06, 0.03, 0.01), 3.0)

	# --- Ground layers: forest floor with leaves ---
	for gy in range(280, 628):
		var gt: float = float(gy - 280) / 348.0
		var gx_wave: float = sin(float(gy) * 0.03 + _time * 0.15) * 0.02
		var floor_col := Color(
			lerp(0.04, ground_color.r * 0.6, gt) + gx_wave,
			lerp(0.08, ground_color.g * 0.5, gt),
			lerp(0.02, ground_color.b * 0.3, gt)
		)
		draw_line(Vector2(0, float(gy)), Vector2(1280, float(gy)), floor_col, 1.5)

	# --- Rushing river with rapids (horizontal, mid-ground) ---
	var river_y: float = 400.0
	for ry in range(30):
		var ry_f: float = float(ry)
		var river_t: float = ry_f / 30.0
		var river_wave: float = sin(ry_f * 0.5 + _time * 2.5) * 3.0
		var depth_col := Color(
			0.05 + 0.08 * river_t,
			0.12 + 0.15 * river_t + 0.03 * sin(_time * 1.5 + ry_f * 0.3),
			0.25 + 0.2 * river_t,
			0.85
		)
		draw_line(Vector2(0, river_y + ry_f + river_wave), Vector2(1280, river_y + ry_f + river_wave), depth_col, 1.5)
	# Rapids / white water foam
	for ri in range(20):
		var rapid_x: float = fmod(float(ri) * 127.3 + _time * 60.0, 1400.0) - 60.0
		var rapid_y: float = river_y + 5.0 + fmod(float(ri) * 11.3, 22.0)
		var foam_alpha: float = 0.3 + 0.4 * sin(_time * 4.0 + float(ri) * 2.7)
		draw_circle(Vector2(rapid_x, rapid_y), 3.0 + sin(_time * 3.0 + float(ri)) * 1.5, Color(0.85, 0.9, 0.95, clampf(foam_alpha, 0.0, 1.0)))

	# --- Little John's stone bridge (centerpiece) ---
	var bridge_cx: float = 640.0
	var bridge_top: float = river_y - 10.0
	# Stone arch
	var arch_pts: PackedVector2Array = PackedVector2Array()
	for ai in range(21):
		var angle: float = PI * float(ai) / 20.0
		arch_pts.append(Vector2(bridge_cx + cos(angle) * 80.0, bridge_top + 30.0 - sin(angle) * 35.0))
	for ai2 in range(20, -1, -1):
		var angle2: float = PI * float(ai2) / 20.0
		arch_pts.append(Vector2(bridge_cx + cos(angle2) * 70.0, bridge_top + 30.0 - sin(angle2) * 28.0))
	draw_colored_polygon(arch_pts, Color(0.25, 0.22, 0.18))
	# Bridge deck
	draw_rect(Rect2(bridge_cx - 85.0, bridge_top - 8.0, 170.0, 14.0), Color(0.3, 0.27, 0.2))
	# Stone texture lines on bridge
	for sl in range(8):
		var slx: float = bridge_cx - 75.0 + float(sl) * 20.0
		draw_line(Vector2(slx, bridge_top - 8.0), Vector2(slx, bridge_top + 5.0), Color(0.2, 0.17, 0.12, 0.5), 1.0)
	# Railings
	for rail in range(9):
		var rx: float = bridge_cx - 80.0 + float(rail) * 20.0
		draw_line(Vector2(rx, bridge_top - 8.0), Vector2(rx, bridge_top - 22.0), Color(0.2, 0.17, 0.12), 2.5)
	draw_line(Vector2(bridge_cx - 80.0, bridge_top - 22.0), Vector2(bridge_cx + 80.0, bridge_top - 22.0), Color(0.22, 0.19, 0.14), 3.0)

	# --- Wanted posters on trees ---
	for wp in range(4):
		var poster_x: float = 90.0 + float(wp) * 310.0
		var poster_y: float = 260.0 + fmod(float(wp) * 37.0, 40.0)
		# Parchment
		draw_rect(Rect2(poster_x - 12.0, poster_y - 16.0, 24.0, 30.0), Color(0.85, 0.78, 0.6, 0.85))
		draw_rect(Rect2(poster_x - 11.0, poster_y - 15.0, 22.0, 28.0), Color(0.0, 0.0, 0.0, 1.0), false, 1.0)
		# "WANTED" text line
		draw_line(Vector2(poster_x - 7.0, poster_y - 10.0), Vector2(poster_x + 7.0, poster_y - 10.0), Color(0.15, 0.05, 0.02), 1.5)
		# Face circle
		draw_circle(Vector2(poster_x, poster_y + 2.0), 5.0, Color(0.7, 0.6, 0.45, 0.6))
		# Nail
		draw_circle(Vector2(poster_x, poster_y - 16.0), 1.5, Color(0.4, 0.4, 0.4))

	# --- Decorations loop ---
	for dec in _decorations:
		var dtype: String = dec["type"]
		var dpos: Vector2 = dec["pos"]
		var dsize: float = dec["size"]
		var dextra: float = dec["extra"]
		if dtype == "oak_tree":
			draw_rect(Rect2(dpos.x - dsize * 0.15, dpos.y - dsize * 0.2, dsize * 0.3, dsize * 0.8), Color(0.1, 0.06, 0.02))
			draw_circle(dpos + Vector2(0, -dsize * 0.4), dsize * 0.5, Color(0.03, 0.15, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, -dsize * 0.2), dsize * 0.35, Color(0.03, 0.15, 0.03, 0.9))
		elif dtype == "target":
			draw_circle(dpos, 7.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 5.0, Color(0.7, 0.15, 0.1))
			draw_circle(dpos, 3.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 1.5, Color(0.7, 0.15, 0.1))
			draw_line(dpos + Vector2(-8, -4), dpos, Color(0.3, 0.2, 0.05), 1.5)
			draw_line(Vector2(dpos.x, dpos.y + 7), Vector2(dpos.x, dpos.y + 16), Color(0.2, 0.12, 0.04), 2.5)
		elif dtype == "bush":
			draw_circle(dpos, dsize * 0.5, Color(0.04, 0.16 + dextra * 0.05, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, dsize * 0.1), dsize * 0.35, Color(0.04, 0.16, 0.03, 0.9))
			draw_circle(dpos + Vector2(dsize * 0.25, dsize * 0.08), dsize * 0.38, Color(0.04, 0.16, 0.03, 0.9))
		elif dtype == "deer":
			var deer_col := Color(0.15, 0.1, 0.05)
			var facing: float = -1.0 if dextra > 0.5 else 1.0
			var body_pts: PackedVector2Array = PackedVector2Array()
			for da in range(16):
				body_pts.append(dpos + Vector2(cos(float(da) * TAU / 16.0) * dsize * 0.4 * facing, sin(float(da) * TAU / 16.0) * dsize * 0.2))
			draw_colored_polygon(body_pts, deer_col)
			var head_pos: Vector2 = dpos + Vector2(dsize * 0.5 * facing, -dsize * 0.35)
			draw_line(dpos + Vector2(dsize * 0.3 * facing, -dsize * 0.1), head_pos, deer_col, dsize * 0.1)
			draw_circle(head_pos, dsize * 0.1, deer_col)
		elif dtype == "campfire":
			var fi: float = 0.7 + 0.3 * sin(_time * 5.0 + dextra * 10.0)
			draw_circle(dpos, dsize * 3.0, Color(0.4, 0.15, 0.02, 0.08 * fi))
			draw_circle(dpos, dsize * 2.0, Color(0.5, 0.2, 0.03, 0.12 * fi))
			for fs in range(8):
				draw_circle(dpos + Vector2(cos(float(fs) * TAU / 8.0) * dsize * 0.7, sin(float(fs) * TAU / 8.0) * dsize * 0.35), 3.0, Color(0.2, 0.18, 0.15))
			for fl2 in range(6):
				var flame_x: float = dpos.x + sin(float(fl2) * 1.7 + _time * 4.0) * dsize * 0.3
				var flame_h: float = dsize * (0.6 + 0.4 * sin(_time * 6.0 + float(fl2) * 2.0)) * fi
				var fc: Color = Color(0.95, 0.85, 0.2, 0.9) if fl2 < 2 else (Color(0.95, 0.5, 0.05, 0.85) if fl2 < 4 else Color(0.8, 0.2, 0.02, 0.7))
				draw_line(Vector2(flame_x, dpos.y + dsize * 0.1), Vector2(flame_x + sin(_time * 3.0 + float(fl2)) * 3.0, dpos.y - flame_h), fc, 3.5 - float(fl2) * 0.3)

	# --- Path rendering: dark forest dirt trail ---
	if enemy_path and enemy_path.curve:
		var curve: Curve2D = enemy_path.curve
		var path_len: float = curve.get_baked_length()
		var prev_pt: Vector2 = curve.sample_baked(0.0)
		for pi in range(1, 101):
			var pt: Vector2 = curve.sample_baked(float(pi) / 100.0 * path_len)
			# Main trail
			draw_line(prev_pt, pt, Color(0.12, 0.08, 0.04), 26.0)
			# Darker edges
			var perp: Vector2 = (pt - prev_pt).normalized().rotated(PI * 0.5)
			draw_line(prev_pt + perp * 12.0, pt + perp * 12.0, Color(0.06, 0.04, 0.02, 0.6), 4.0)
			draw_line(prev_pt - perp * 12.0, pt - perp * 12.0, Color(0.06, 0.04, 0.02, 0.6), 4.0)
			prev_pt = pt
		# Footprints / muddy patches
		for mi in range(15):
			var mud_offset: float = (float(mi) + 0.5) / 15.0
			var mud_pt: Vector2 = curve.sample_baked(mud_offset * path_len)
			var mud_side: float = -5.0 if mi % 2 == 0 else 5.0
			draw_circle(mud_pt + Vector2(mud_side, 0), 2.5, Color(0.08, 0.05, 0.02, 0.5))

	# --- Rolling fog (foreground effect) ---
	for fi2 in range(12):
		var fog_x: float = fmod(float(fi2) * 160.0 - _time * 18.0, 1500.0) - 100.0
		var fog_y: float = 350.0 + fmod(float(fi2) * 47.0, 200.0)
		var fog_pulse: float = 0.03 + 0.025 * sin(_time * 0.6 + float(fi2) * 1.3)
		var fog_rad: float = 60.0 + 20.0 * sin(_time * 0.4 + float(fi2) * 0.9)
		draw_circle(Vector2(fog_x, fog_y), fog_rad, Color(0.5, 0.55, 0.6, fog_pulse))
		draw_circle(Vector2(fog_x + 40.0, fog_y + 10.0), fog_rad * 0.7, Color(0.5, 0.55, 0.6, fog_pulse * 0.7))

	# --- Fireflies (animated foreground sparkles) ---
	for ff in range(18):
		var ff_x: float = fmod(float(ff) * 151.0 + sin(_time * 0.8 + float(ff) * 2.1) * 40.0, 1280.0)
		var ff_y: float = 200.0 + fmod(float(ff) * 67.0, 350.0) + sin(_time * 1.2 + float(ff) * 1.7) * 15.0
		var ff_alpha: float = clampf(0.5 + 0.5 * sin(_time * 3.0 + float(ff) * 4.1), 0.0, 1.0)
		draw_circle(Vector2(ff_x, ff_y), 2.0, Color(0.7, 0.9, 0.3, ff_alpha * 0.7))
		draw_circle(Vector2(ff_x, ff_y), 5.0, Color(0.7, 0.9, 0.3, ff_alpha * 0.15))


## Robin Hood Chapter 3: "Siege of Nottingham"
## Nottingham Castle walls, siege ladders, moat with drawbridge, castle towers with
## archer windows, burning arrows arcing across sky, dawn breaking golden, Robin's flag.
	_draw_robin_novel(2)
	_draw_shadow_author_effects()

func _draw_robin_ch3(sky_color: Color, ground_color: Color) -> void:
	# --- Sky gradient: warm dawn breaking ---
	for sy in range(0, 50):
		var t: float = float(sy) / 50.0
		var dawn_col := Color(
			lerp(sky_color.r * 0.4, sky_color.r * 0.9, t),
			lerp(sky_color.g * 0.2, sky_color.g * 0.6, t),
			lerp(sky_color.b * 0.3, sky_color.b * 0.5, t)
		)
		draw_line(Vector2(0, float(sy)), Vector2(1280, float(sy)), dawn_col, 1.5)

	# --- Golden horizon glow ---
	for hg in range(20):
		var hg_t: float = float(hg) / 20.0
		var glow_alpha: float = 0.12 * (1.0 - hg_t) * (0.8 + 0.2 * sin(_time * 0.5))
		draw_line(Vector2(0, 50.0 - float(hg)), Vector2(1280, 50.0 - float(hg)), Color(1.0, 0.75, 0.2, glow_alpha), 1.5)

	# --- Fading stars at dawn ---
	for si in range(20):
		var sx: float = fmod(float(si) * 173.7 + 51.3, 1280.0)
		var star_y: float = fmod(float(si) * 97.1 + 5.0, 40.0) + 3.0
		var fade: float = clampf(0.3 + 0.2 * sin(_time * 1.0 + float(si) * 2.3), 0.0, 1.0)
		draw_circle(Vector2(sx, star_y), 1.0, Color(0.9, 0.85, 0.7, fade * 0.4))

	# --- Burning arrows arcing across sky (animated) ---
	for ba in range(6):
		var arrow_phase: float = fmod(_time * 0.7 + float(ba) * 1.8, 4.0)
		var arrow_t: float = arrow_phase / 4.0
		var arrow_start_x: float = -40.0 + float(ba) * 50.0
		var arrow_end_x: float = 400.0 + float(ba) * 150.0
		var arrow_x: float = lerp(arrow_start_x, arrow_end_x, arrow_t)
		var arrow_arc: float = -120.0 * sin(arrow_t * PI)
		var arrow_y: float = 45.0 + arrow_arc + float(ba) * 3.0
		if arrow_t > 0.02 and arrow_t < 0.98 and arrow_x > 0.0 and arrow_x < 1280.0:
			# Arrow body
			var arrow_dir: float = atan2(arrow_arc * 0.1, 5.0)
			var ax2: float = arrow_x - cos(arrow_dir) * 12.0
			var ay2: float = arrow_y - sin(arrow_dir) * 12.0
			draw_line(Vector2(ax2, ay2), Vector2(arrow_x, arrow_y), Color(0.3, 0.2, 0.05), 1.5)
			# Flame on tip
			var flame_fl: float = 0.7 + 0.3 * sin(_time * 8.0 + float(ba) * 3.0)
			draw_circle(Vector2(arrow_x, arrow_y), 4.0, Color(0.95, 0.6, 0.05, 0.6 * flame_fl))
			draw_circle(Vector2(arrow_x, arrow_y), 2.5, Color(1.0, 0.9, 0.3, 0.8 * flame_fl))
			# Smoke trail
			for st in range(4):
				var trail_x: float = ax2 - float(st) * 6.0
				var trail_y: float = ay2 + float(st) * 2.0
				draw_circle(Vector2(trail_x, trail_y), 2.0 + float(st) * 0.5, Color(0.3, 0.3, 0.3, 0.15 - float(st) * 0.03))

	# --- Sky to ground transition ---
	for sy2 in range(50, 180):
		var t2: float = float(sy2 - 50) / 130.0
		var mid_col := Color(
			lerp(sky_color.r * 0.9, 0.35, t2),
			lerp(sky_color.g * 0.6, 0.3, t2),
			lerp(sky_color.b * 0.5, 0.25, t2)
		)
		draw_line(Vector2(0, float(sy2)), Vector2(1280, float(sy2)), mid_col, 1.5)

	# --- Nottingham Castle (dominating background) ---
	var castle_base_y: float = 180.0
	# Main wall
	draw_rect(Rect2(200.0, castle_base_y, 880.0, 200.0), Color(0.3, 0.28, 0.24))
	# Battlements (crenellations)
	for cr in range(22):
		var cr_x: float = 200.0 + float(cr) * 40.0
		if cr % 2 == 0:
			draw_rect(Rect2(cr_x, castle_base_y - 20.0, 30.0, 20.0), Color(0.32, 0.3, 0.26))

	# Left tower
	draw_rect(Rect2(140.0, castle_base_y - 100.0, 80.0, 300.0), Color(0.28, 0.26, 0.22))
	# Left tower roof (conical shape)
	var ltower_pts: PackedVector2Array = PackedVector2Array([
		Vector2(180.0, castle_base_y - 140.0),
		Vector2(135.0, castle_base_y - 100.0),
		Vector2(225.0, castle_base_y - 100.0)
	])
	draw_colored_polygon(ltower_pts, Color(0.2, 0.08, 0.08))
	# Left tower archer windows
	for aw in range(3):
		var aw_y: float = castle_base_y - 70.0 + float(aw) * 55.0
		draw_rect(Rect2(172.0, aw_y, 6.0, 16.0), Color(0.05, 0.05, 0.08))
		draw_rect(Rect2(169.0, aw_y + 5.0, 12.0, 4.0), Color(0.05, 0.05, 0.08))
		# Arrow slit glow (interior light)
		var glow_f: float = 0.3 + 0.2 * sin(_time * 2.0 + float(aw) * 1.5)
		draw_circle(Vector2(175.0, aw_y + 8.0), 4.0, Color(0.8, 0.5, 0.1, glow_f * 0.3))

	# Right tower
	draw_rect(Rect2(1060.0, castle_base_y - 80.0, 80.0, 280.0), Color(0.28, 0.26, 0.22))
	var rtower_pts: PackedVector2Array = PackedVector2Array([
		Vector2(1100.0, castle_base_y - 120.0),
		Vector2(1055.0, castle_base_y - 80.0),
		Vector2(1145.0, castle_base_y - 80.0)
	])
	draw_colored_polygon(rtower_pts, Color(0.2, 0.08, 0.08))
	for aw2 in range(3):
		var aw2_y: float = castle_base_y - 50.0 + float(aw2) * 50.0
		draw_rect(Rect2(1092.0, aw2_y, 6.0, 16.0), Color(0.05, 0.05, 0.08))
		draw_rect(Rect2(1089.0, aw2_y + 5.0, 12.0, 4.0), Color(0.05, 0.05, 0.08))

	# Central keep (taller)
	draw_rect(Rect2(540.0, castle_base_y - 70.0, 200.0, 270.0), Color(0.33, 0.3, 0.27))
	# Keep battlements
	for kb in range(5):
		var kb_x: float = 540.0 + float(kb) * 40.0
		if kb % 2 == 0:
			draw_rect(Rect2(kb_x, castle_base_y - 88.0, 28.0, 18.0), Color(0.35, 0.32, 0.28))
	# Keep gate (large arched entrance)
	var gate_pts: PackedVector2Array = PackedVector2Array()
	for gi in range(21):
		var g_angle: float = PI * float(gi) / 20.0
		gate_pts.append(Vector2(640.0 + cos(g_angle) * 28.0, castle_base_y + 100.0 - sin(g_angle) * 35.0))
	gate_pts.append(Vector2(668.0, castle_base_y + 200.0))
	gate_pts.append(Vector2(612.0, castle_base_y + 200.0))
	draw_colored_polygon(gate_pts, Color(0.06, 0.04, 0.04))
	# Portcullis lines
	for pc in range(5):
		var pcx: float = 618.0 + float(pc) * 11.0
		draw_line(Vector2(pcx, castle_base_y + 68.0), Vector2(pcx, castle_base_y + 200.0), Color(0.2, 0.18, 0.15), 2.0)
	for pcr in range(6):
		var pcry: float = castle_base_y + 80.0 + float(pcr) * 20.0
		draw_line(Vector2(614.0, pcry), Vector2(666.0, pcry), Color(0.2, 0.18, 0.15), 1.5)

	# --- Robin's flag on left tower ---
	var flag_x: float = 180.0
	var flag_y: float = castle_base_y - 140.0
	# Pole
	draw_line(Vector2(flag_x, flag_y), Vector2(flag_x, flag_y - 40.0), Color(0.4, 0.35, 0.2), 2.0)
	# Flag waving
	var flag_wave: float = sin(_time * 3.0) * 5.0
	var flag_pts: PackedVector2Array = PackedVector2Array([
		Vector2(flag_x, flag_y - 40.0),
		Vector2(flag_x + 28.0, flag_y - 37.0 + flag_wave),
		Vector2(flag_x + 25.0, flag_y - 25.0 + flag_wave * 0.6),
		Vector2(flag_x, flag_y - 22.0)
	])
	draw_colored_polygon(flag_pts, Color(0.15, 0.5, 0.15))
	# Arrow emblem on flag
	draw_line(Vector2(flag_x + 8.0, flag_y - 33.0 + flag_wave * 0.4), Vector2(flag_x + 20.0, flag_y - 30.0 + flag_wave * 0.7), Color(0.9, 0.85, 0.3), 1.5)

	# --- Moat (water around castle base) ---
	var moat_y: float = castle_base_y + 200.0
	for my in range(25):
		var my_f: float = float(my)
		var moat_wave: float = sin(my_f * 0.6 + _time * 1.5) * 2.0
		var moat_col := Color(
			0.06 + 0.04 * sin(_time * 0.8 + my_f * 0.2),
			0.15 + 0.08 * (my_f / 25.0),
			0.3 + 0.1 * (my_f / 25.0),
			0.9
		)
		draw_line(Vector2(0, moat_y + my_f + moat_wave), Vector2(1280, moat_y + my_f + moat_wave), moat_col, 1.5)
	# Water reflections
	for wr in range(10):
		var wr_x: float = fmod(float(wr) * 137.0 + _time * 12.0, 1280.0)
		var wr_y: float = moat_y + 5.0 + fmod(float(wr) * 7.3, 18.0)
		var wr_alpha: float = 0.15 + 0.1 * sin(_time * 2.0 + float(wr) * 1.9)
		draw_line(Vector2(wr_x - 8.0, wr_y), Vector2(wr_x + 8.0, wr_y), Color(0.6, 0.7, 0.8, wr_alpha), 1.0)

	# --- Drawbridge ---
	var db_x: float = 640.0
	var db_angle: float = 0.1 * sin(_time * 0.3)
	draw_rect(Rect2(db_x - 30.0, moat_y - 4.0, 60.0, 8.0), Color(0.25, 0.15, 0.06))
	# Planks
	for pl in range(6):
		var plx: float = db_x - 28.0 + float(pl) * 10.0
		draw_line(Vector2(plx, moat_y - 4.0), Vector2(plx, moat_y + 4.0), Color(0.18, 0.1, 0.04, 0.6), 1.0)
	# Chains
	draw_line(Vector2(db_x - 25.0, moat_y - 4.0), Vector2(db_x - 20.0, castle_base_y + 195.0), Color(0.35, 0.33, 0.3), 2.0)
	draw_line(Vector2(db_x + 25.0, moat_y - 4.0), Vector2(db_x + 20.0, castle_base_y + 195.0), Color(0.35, 0.33, 0.3), 2.0)

	# --- Siege ladders leaning against walls ---
	for li in range(3):
		var ladder_x: float = 280.0 + float(li) * 260.0
		var ladder_bot: float = moat_y - 2.0
		var ladder_top: float = castle_base_y + 10.0
		var ladder_lean: float = 20.0 + sin(_time * 0.4 + float(li) * 2.0) * 3.0
		# Side rails
		draw_line(Vector2(ladder_x - 6.0, ladder_bot), Vector2(ladder_x - 6.0 + ladder_lean, ladder_top), Color(0.3, 0.2, 0.08), 3.0)
		draw_line(Vector2(ladder_x + 6.0, ladder_bot), Vector2(ladder_x + 6.0 + ladder_lean, ladder_top), Color(0.3, 0.2, 0.08), 3.0)
		# Rungs
		var rungs: int = 8
		for ru in range(rungs):
			var rung_t: float = float(ru + 1) / float(rungs + 1)
			var rx1: float = lerp(ladder_x - 6.0, ladder_x - 6.0 + ladder_lean, rung_t)
			var rx2: float = lerp(ladder_x + 6.0, ladder_x + 6.0 + ladder_lean, rung_t)
			var rung_y: float = lerp(ladder_bot, ladder_top, rung_t)
			draw_line(Vector2(rx1, rung_y), Vector2(rx2, rung_y), Color(0.28, 0.18, 0.06), 2.0)

	# --- Ground layers: battlefield/earth ---
	for gy in range(int(moat_y) + 25, 628):
		var gt: float = float(gy - int(moat_y) - 25) / float(628 - int(moat_y) - 25)
		var ground_col := Color(
			lerp(0.2, ground_color.r * 0.7, gt),
			lerp(0.18, ground_color.g * 0.6, gt),
			lerp(0.12, ground_color.b * 0.4, gt)
		)
		draw_line(Vector2(0, float(gy)), Vector2(1280, float(gy)), ground_col, 1.5)

	# --- Stone wall texture on castle ---
	for sr in range(12):
		for sc in range(24):
			var stone_x: float = 200.0 + float(sc) * 37.0 + fmod(float(sr) * 17.0, 18.0)
			var stone_y: float = castle_base_y + float(sr) * 16.5
			if stone_x < 1080.0 and stone_y < castle_base_y + 195.0:
				draw_rect(Rect2(stone_x, stone_y, 34.0, 14.0), Color(0.25, 0.23, 0.19, 0.25), false, 0.5)

	# --- Decorations loop ---
	for dec in _decorations:
		var dtype: String = dec["type"]
		var dpos: Vector2 = dec["pos"]
		var dsize: float = dec["size"]
		var dextra: float = dec["extra"]
		if dtype == "oak_tree":
			draw_rect(Rect2(dpos.x - dsize * 0.15, dpos.y - dsize * 0.2, dsize * 0.3, dsize * 0.8), Color(0.1, 0.06, 0.02))
			draw_circle(dpos + Vector2(0, -dsize * 0.4), dsize * 0.5, Color(0.03, 0.15, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, -dsize * 0.2), dsize * 0.35, Color(0.03, 0.15, 0.03, 0.9))
		elif dtype == "target":
			draw_circle(dpos, 7.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 5.0, Color(0.7, 0.15, 0.1))
			draw_circle(dpos, 3.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 1.5, Color(0.7, 0.15, 0.1))
			draw_line(dpos + Vector2(-8, -4), dpos, Color(0.3, 0.2, 0.05), 1.5)
			draw_line(Vector2(dpos.x, dpos.y + 7), Vector2(dpos.x, dpos.y + 16), Color(0.2, 0.12, 0.04), 2.5)
		elif dtype == "bush":
			draw_circle(dpos, dsize * 0.5, Color(0.04, 0.16 + dextra * 0.05, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, dsize * 0.1), dsize * 0.35, Color(0.04, 0.16, 0.03, 0.9))
			draw_circle(dpos + Vector2(dsize * 0.25, dsize * 0.08), dsize * 0.38, Color(0.04, 0.16, 0.03, 0.9))
		elif dtype == "deer":
			var deer_col := Color(0.15, 0.1, 0.05)
			var facing: float = -1.0 if dextra > 0.5 else 1.0
			var body_pts: PackedVector2Array = PackedVector2Array()
			for da in range(16):
				body_pts.append(dpos + Vector2(cos(float(da) * TAU / 16.0) * dsize * 0.4 * facing, sin(float(da) * TAU / 16.0) * dsize * 0.2))
			draw_colored_polygon(body_pts, deer_col)
			var head_pos: Vector2 = dpos + Vector2(dsize * 0.5 * facing, -dsize * 0.35)
			draw_line(dpos + Vector2(dsize * 0.3 * facing, -dsize * 0.1), head_pos, deer_col, dsize * 0.1)
			draw_circle(head_pos, dsize * 0.1, deer_col)
		elif dtype == "campfire":
			var fi: float = 0.7 + 0.3 * sin(_time * 5.0 + dextra * 10.0)
			draw_circle(dpos, dsize * 3.0, Color(0.4, 0.15, 0.02, 0.08 * fi))
			draw_circle(dpos, dsize * 2.0, Color(0.5, 0.2, 0.03, 0.12 * fi))
			for fs in range(8):
				draw_circle(dpos + Vector2(cos(float(fs) * TAU / 8.0) * dsize * 0.7, sin(float(fs) * TAU / 8.0) * dsize * 0.35), 3.0, Color(0.2, 0.18, 0.15))
			for fl2 in range(6):
				var flame_x: float = dpos.x + sin(float(fl2) * 1.7 + _time * 4.0) * dsize * 0.3
				var flame_h: float = dsize * (0.6 + 0.4 * sin(_time * 6.0 + float(fl2) * 2.0)) * fi
				var fc: Color = Color(0.95, 0.85, 0.2, 0.9) if fl2 < 2 else (Color(0.95, 0.5, 0.05, 0.85) if fl2 < 4 else Color(0.8, 0.2, 0.02, 0.7))
				draw_line(Vector2(flame_x, dpos.y + dsize * 0.1), Vector2(flame_x + sin(_time * 3.0 + float(fl2)) * 3.0, dpos.y - flame_h), fc, 3.5 - float(fl2) * 0.3)

	# --- Path rendering: castle cobblestone (gray) ---
	if enemy_path and enemy_path.curve:
		var curve: Curve2D = enemy_path.curve
		var path_len: float = curve.get_baked_length()
		var prev_pt: Vector2 = curve.sample_baked(0.0)
		for pi in range(1, 101):
			var pt: Vector2 = curve.sample_baked(float(pi) / 100.0 * path_len)
			# Main cobblestone path
			draw_line(prev_pt, pt, Color(0.35, 0.33, 0.3), 28.0)
			# Lighter center
			draw_line(prev_pt, pt, Color(0.42, 0.4, 0.36), 18.0)
			# Edge stones
			var perp: Vector2 = (pt - prev_pt).normalized().rotated(PI * 0.5)
			draw_line(prev_pt + perp * 13.0, pt + perp * 13.0, Color(0.28, 0.26, 0.22, 0.7), 3.0)
			draw_line(prev_pt - perp * 13.0, pt - perp * 13.0, Color(0.28, 0.26, 0.22, 0.7), 3.0)
			prev_pt = pt
		# Cobblestone texture marks
		for ci in range(25):
			var cb_offset: float = (float(ci) + 0.3) / 25.0
			var cb_pt: Vector2 = curve.sample_baked(cb_offset * path_len)
			for cj in range(3):
				var cx_off: float = -7.0 + float(cj) * 7.0
				var cy_off: float = sin(float(ci) * 2.3 + float(cj) * 1.1) * 3.0
				draw_rect(Rect2(cb_pt.x + cx_off - 3.0, cb_pt.y + cy_off - 2.0, 6.0, 4.0), Color(0.3, 0.28, 0.25, 0.35), false, 0.8)

	# --- Smoke rising from castle (foreground effect) ---
	for sm in range(8):
		var smoke_base_x: float = 500.0 + float(sm) * 40.0
		var smoke_phase: float = fmod(_time * 0.5 + float(sm) * 1.2, 6.0)
		var smoke_y: float = castle_base_y - 20.0 - smoke_phase * 25.0
		var smoke_alpha: float = clampf(0.15 * (1.0 - smoke_phase / 6.0), 0.0, 0.15)
		var smoke_rad: float = 8.0 + smoke_phase * 6.0
		var smoke_drift: float = sin(_time * 0.8 + float(sm) * 0.7) * smoke_phase * 4.0
		draw_circle(Vector2(smoke_base_x + smoke_drift, smoke_y), smoke_rad, Color(0.3, 0.3, 0.3, smoke_alpha))

	# --- Dawn light rays (foreground atmospheric) ---
	for dr in range(5):
		var ray_x: float = 100.0 + float(dr) * 280.0
		var ray_alpha: float = 0.03 + 0.02 * sin(_time * 0.4 + float(dr) * 1.5)
		var ray_pts: PackedVector2Array = PackedVector2Array([
			Vector2(ray_x, 0.0),
			Vector2(ray_x - 40.0, 628.0),
			Vector2(ray_x + 60.0, 628.0),
			Vector2(ray_x + 15.0, 0.0)
		])
		draw_colored_polygon(ray_pts, Color(1.0, 0.85, 0.4, ray_alpha))

	# --- Embers / sparks floating up (animated) ---
	for em in range(15):
		var ember_phase: float = fmod(_time * 1.2 + float(em) * 0.9, 3.5)
		var ember_x: float = fmod(float(em) * 107.0 + sin(_time * 0.5 + float(em) * 1.3) * 30.0, 1280.0)
		var ember_y: float = 500.0 - ember_phase * 120.0 + sin(_time * 2.0 + float(em) * 2.7) * 10.0
		var ember_alpha: float = clampf(0.8 * (1.0 - ember_phase / 3.5), 0.0, 0.8)
		if ember_y > 50.0:
			draw_circle(Vector2(ember_x, ember_y), 1.5, Color(1.0, 0.6, 0.1, ember_alpha))
			draw_circle(Vector2(ember_x, ember_y), 3.5, Color(1.0, 0.5, 0.05, ember_alpha * 0.2))
	_draw_robin_novel(3)
	_draw_shadow_author_effects()

func _draw_alice_ch2(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — deep purple twilight ===
	var sky_steps := 24
	for i in range(sky_steps):
		var t := float(i) / float(sky_steps)
		var y_start := 50.0 + t * 290.0
		var band_h := 290.0 / float(sky_steps) + 1.0
		var band_col := sky_color.lerp(Color(0.15, 0.08, 0.25), t)
		# Subtle purple haze pulsing
		var haze := clampf(sin(_time * 0.3 + t * 2.0), 0.0, 1.0) * 0.06
		band_col = band_col.lerp(Color(0.5, 0.2, 0.6), haze)
		draw_rect(Rect2(0, y_start, 1280, band_h), band_col)

	# === ATMOSPHERE — swirling tea steam and madness particles ===
	for i in range(18):
		var sx := fmod(float(i) * 173.7 + _time * 8.0, 1280.0)
		var sy := 80.0 + sin(_time * 0.6 + float(i) * 0.9) * 60.0 + float(i) * 14.0
		var steam_alpha := clampf(sin(_time * 0.7 + float(i) * 1.3), 0.0, 1.0) * 0.12
		draw_circle(Vector2(sx, sy), 6.0 + sin(_time + float(i)) * 3.0, Color(0.8, 0.7, 0.9, steam_alpha))

	# Floating question marks / madness sparkles
	for i in range(10):
		var qx := fmod(float(i) * 127.3, 1280.0)
		var qy := 100.0 + sin(_time * 0.4 + float(i) * 2.1) * 40.0 + float(i) * 20.0
		var q_alpha := clampf(sin(_time * 1.1 + float(i) * 0.7), 0.0, 1.0) * 0.15
		draw_circle(Vector2(qx, qy), 2.0, Color(1.0, 0.9, 0.3, q_alpha))

	# === CHESHIRE CAT GRIN — fading in and out ===
	var cat_x := 200.0 + sin(_time * 0.15) * 30.0
	var cat_y := 140.0 + cos(_time * 0.2) * 15.0
	var grin_alpha := clampf(sin(_time * 0.5), 0.0, 1.0) * 0.7
	if grin_alpha > 0.05:
		# Wide crescent grin
		var grin_w := 60.0
		var grin_pts := 16
		for i in range(grin_pts - 1):
			var t1 := float(i) / float(grin_pts - 1)
			var t2 := float(i + 1) / float(grin_pts - 1)
			var x1 := cat_x - grin_w * 0.5 + t1 * grin_w
			var x2 := cat_x - grin_w * 0.5 + t2 * grin_w
			var curve1 := sin(t1 * PI) * 12.0
			var curve2 := sin(t2 * PI) * 12.0
			draw_line(Vector2(x1, cat_y + curve1), Vector2(x2, cat_y + curve2), Color(0.9, 0.5, 0.9, grin_alpha), 2.5)
		# Teeth lines
		for i in range(6):
			var tx := cat_x - 20.0 + float(i) * 8.0
			var tt := (tx - (cat_x - grin_w * 0.5)) / grin_w
			var ty := cat_y + sin(tt * PI) * 12.0
			draw_line(Vector2(tx, ty - 2.0), Vector2(tx, ty + 3.0), Color(1.0, 1.0, 1.0, grin_alpha * 0.6), 1.0)
		# Eyes above grin (floating, glowing)
		var eye_alpha := grin_alpha * 0.8
		draw_circle(Vector2(cat_x - 18.0, cat_y - 20.0), 5.0, Color(0.6, 0.9, 0.2, eye_alpha))
		draw_circle(Vector2(cat_x + 18.0, cat_y - 20.0), 5.0, Color(0.6, 0.9, 0.2, eye_alpha))
		draw_circle(Vector2(cat_x - 18.0, cat_y - 20.0), 2.0, Color(0.1, 0.05, 0.2, eye_alpha))
		draw_circle(Vector2(cat_x + 18.0, cat_y - 20.0), 2.0, Color(0.1, 0.05, 0.2, eye_alpha))

	# === LANDMARKS ===
	# --- Massive tea table (center) ---
	var table_y := 360.0
	var table_x := 640.0
	# Table legs
	draw_rect(Rect2(table_x - 200.0, table_y, 16.0, 80.0), Color(0.35, 0.2, 0.1, 0.7))
	draw_rect(Rect2(table_x + 184.0, table_y, 16.0, 80.0), Color(0.35, 0.2, 0.1, 0.7))
	# Table top
	draw_rect(Rect2(table_x - 220.0, table_y - 8.0, 440.0, 16.0), Color(0.45, 0.28, 0.15, 0.75))
	# Table cloth drape
	for i in range(10):
		var drape_x := table_x - 210.0 + float(i) * 46.0
		var drape_sag := sin(float(i) * 0.8 + 1.0) * 8.0
		draw_line(Vector2(drape_x, table_y - 6.0), Vector2(drape_x + 23.0, table_y + drape_sag), Color(0.85, 0.8, 0.95, 0.35), 1.5)

	# --- Oversized teapot (on table, center) ---
	var pot_x := table_x
	var pot_y := table_y - 50.0
	# Body
	draw_circle(Vector2(pot_x, pot_y), 30.0, Color(0.6, 0.45, 0.7, 0.55))
	draw_circle(Vector2(pot_x, pot_y), 26.0, Color(0.7, 0.55, 0.8, 0.45))
	# Lid
	draw_rect(Rect2(pot_x - 18.0, pot_y - 34.0, 36.0, 6.0), Color(0.6, 0.45, 0.7, 0.6))
	draw_circle(Vector2(pot_x, pot_y - 38.0), 5.0, Color(0.65, 0.5, 0.75, 0.6))
	# Spout
	draw_line(Vector2(pot_x + 28.0, pot_y - 10.0), Vector2(pot_x + 55.0, pot_y - 30.0), Color(0.6, 0.45, 0.7, 0.5), 4.0)
	# Steam from spout
	for i in range(5):
		var st_y := pot_y - 35.0 - float(i) * 10.0
		var st_x := pot_x + 55.0 + sin(_time * 1.2 + float(i) * 0.8) * 8.0
		var st_a := 0.2 - float(i) * 0.035
		draw_circle(Vector2(st_x, st_y), 4.0 + float(i) * 1.5, Color(0.9, 0.85, 1.0, clampf(st_a, 0.0, 1.0)))
	# Handle
	draw_arc(Vector2(pot_x - 30.0, pot_y - 5.0), 14.0, PI * 0.5, PI * 1.5, 10, Color(0.6, 0.45, 0.7, 0.5), 3.0)

	# --- Oversized teacups on table ---
	for i in range(4):
		var cx := table_x - 150.0 + float(i) * 100.0
		if absf(cx - pot_x) < 40.0:
			cx += 60.0
		var cy := table_y - 20.0
		var cup_col := Color(0.75, 0.6 + float(i) * 0.05, 0.85, 0.5)
		draw_rect(Rect2(cx - 12.0, cy - 16.0, 24.0, 18.0), cup_col)
		draw_arc(Vector2(cx + 14.0, cy - 8.0), 7.0, -PI * 0.5, PI * 0.5, 8, cup_col, 2.0)
		# Liquid inside
		draw_rect(Rect2(cx - 10.0, cy - 12.0, 20.0, 4.0), Color(0.6, 0.4, 0.15, 0.35))

	# --- Broken pocket watches ---
	for i in range(5):
		var wx := 80.0 + float(i) * 260.0
		var wy := 300.0 + sin(float(i) * 1.7) * 40.0
		var watch_r := 14.0
		# Watch face
		draw_circle(Vector2(wx, wy), watch_r, Color(0.85, 0.78, 0.55, 0.35))
		draw_arc(Vector2(wx, wy), watch_r, 0.0, TAU, 12, Color(0.6, 0.5, 0.3, 0.4), 1.5)
		# Hands (spinning erratically)
		var hand_angle := _time * (1.5 + float(i) * 0.7)
		var hx := cos(hand_angle) * watch_r * 0.7
		var hy := sin(hand_angle) * watch_r * 0.7
		draw_line(Vector2(wx, wy), Vector2(wx + hx, wy + hy), Color(0.2, 0.15, 0.1, 0.5), 1.5)
		# Crack line
		draw_line(Vector2(wx - 4.0, wy - 6.0), Vector2(wx + 6.0, wy + 8.0), Color(0.3, 0.25, 0.2, 0.3), 1.0)

	# --- Croquet mallets (flamingo-shaped) ---
	for i in range(3):
		var mx := 950.0 + float(i) * 100.0
		var my := 380.0 + float(i) * 30.0
		var lean := sin(_time * 0.6 + float(i)) * 0.15
		# Shaft
		var shaft_top := Vector2(mx + sin(lean) * 50.0, my - 50.0)
		draw_line(Vector2(mx, my), shaft_top, Color(0.95, 0.55, 0.65, 0.4), 3.0)
		# Flamingo head
		draw_circle(shaft_top, 6.0, Color(0.95, 0.6, 0.7, 0.45))
		draw_circle(shaft_top + Vector2(4.0, -2.0), 2.0, Color(0.2, 0.15, 0.1, 0.4))
		# Beak
		draw_line(shaft_top + Vector2(5.0, 0.0), shaft_top + Vector2(11.0, 1.0), Color(0.9, 0.7, 0.2, 0.4), 1.5)

	# === GROUND — chess board tiles ===
	var ground_y := 440.0
	draw_rect(Rect2(0, ground_y, 1280, 628.0 - ground_y), ground_color)
	var tile_size := 40.0
	var cols := int(1280.0 / tile_size) + 1
	var rows := int((628.0 - ground_y) / tile_size) + 1
	for row in range(rows):
		for col in range(cols):
			var is_dark := (row + col) % 2 == 0
			var tile_col: Color
			if is_dark:
				tile_col = Color(0.2, 0.12, 0.25, 0.25)
			else:
				tile_col = Color(0.85, 0.78, 0.9, 0.15)
			draw_rect(Rect2(float(col) * tile_size, ground_y + float(row) * tile_size, tile_size, tile_size), tile_col)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"giant_mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var glow_pulse = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 0.8, mp.y - ms * 4.0, ms * 1.6, ms * 4.0), Color(0.85, 0.8, 0.7, 0.5))
				var cap_center = mp + Vector2(0, -ms * 4.5)
				draw_circle(cap_center, ms * 3.0 + 4.0, Color(0.7, 0.2, 0.8, 0.1 + glow_pulse * 0.08))
				draw_circle(cap_center, ms * 3.0, Color(0.8, 0.25, 0.4, 0.5))
				draw_circle(cap_center + Vector2(-ms, -ms * 0.5), ms * 0.5, Color(1, 0.95, 0.85, 0.4))
			"floating_card":
				var cp = dec["pos"]
				var drift_y = sin(_time * 0.8 + dec["extra"]) * 15.0
				var drift_x = cos(_time * 0.5 + dec["extra"]) * 8.0
				var card_pos = cp + Vector2(drift_x, drift_y)
				draw_rect(Rect2(card_pos.x - 4, card_pos.y - 6, 8, 12), Color(1.0, 0.98, 0.9, 0.25))
				var suit_col = Color(0.8, 0.15, 0.15, 0.35) if dec["extra"] > 3.0 else Color(0.1, 0.1, 0.1, 0.35)
				draw_circle(card_pos, 2.0, suit_col)
			"rose":
				var rp = dec["pos"]
				var sway = sin(_time * 1.2 + dec["extra"]) * 2.0
				draw_line(rp, rp + Vector2(sway, -12), Color(0.15, 0.4, 0.1, 0.45), 1.5)
				var bloom = rp + Vector2(sway, -12)
				var rc = Color(0.85, 0.1, 0.15, 0.5) if dec["extra"] < 0.5 else Color(0.95, 0.9, 0.85, 0.5)
				draw_circle(bloom, dec["size"], rc)
			"teacup":
				var tp2 = dec["pos"]
				draw_rect(Rect2(tp2.x - 4, tp2.y - 5, 8, 6), Color(0.8, 0.75, 0.6, 0.4))
				draw_arc(Vector2(tp2.x + 5, tp2.y - 2), 3, -PI * 0.5, PI * 0.5, 6, Color(0.8, 0.75, 0.6, 0.35), 1.0)

	# === FOREGROUND ===
	# Floating teaspoons drifting across bottom
	for i in range(6):
		var sp_x := fmod(float(i) * 213.0 + _time * 12.0, 1400.0) - 60.0
		var sp_y := 560.0 + sin(_time * 0.5 + float(i) * 1.1) * 20.0
		var sp_alpha := 0.2 + sin(_time * 0.8 + float(i)) * 0.08
		# Spoon handle
		draw_line(Vector2(sp_x, sp_y), Vector2(sp_x + 18.0, sp_y - 2.0), Color(0.75, 0.7, 0.5, clampf(sp_alpha, 0.0, 1.0)), 1.5)
		# Spoon bowl
		draw_circle(Vector2(sp_x - 4.0, sp_y + 1.0), 4.0, Color(0.75, 0.7, 0.5, clampf(sp_alpha, 0.0, 1.0)))

	# Sugar cubes tumbling
	for i in range(4):
		var sc_x := 100.0 + float(i) * 300.0
		var sc_y := 590.0 + sin(_time * 0.9 + float(i) * 2.0) * 8.0
		var rot := _time * 0.4 + float(i) * 1.5
		var sz := 6.0
		draw_rect(Rect2(sc_x - sz * 0.5, sc_y - sz * 0.5, sz, sz), Color(0.95, 0.93, 0.88, 0.2 + sin(rot) * 0.05))

	# Bottom haze — purple mist
	for i in range(8):
		var hz_t := float(i) / 8.0
		var hz_y := 600.0 + hz_t * 28.0
		draw_rect(Rect2(0, hz_y, 1280, 4.0), Color(0.25, 0.12, 0.35, 0.08 + hz_t * 0.06))
	_draw_alice_novel(2)
	_draw_shadow_author_effects()


func _draw_alice_ch3(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — dark crimson royal sky ===
	var sky_steps := 24
	for i in range(sky_steps):
		var t := float(i) / float(sky_steps)
		var y_start := 50.0 + t * 290.0
		var band_h := 290.0 / float(sky_steps) + 1.0
		var band_col := sky_color.lerp(Color(0.3, 0.05, 0.08), t)
		# Pulsing red atmosphere
		var throb := clampf(sin(_time * 0.4 + t * 1.5), 0.0, 1.0) * 0.05
		band_col = band_col.lerp(Color(0.6, 0.05, 0.1), throb)
		draw_rect(Rect2(0, y_start, 1280, band_h), band_col)

	# === ATMOSPHERE — drifting red particles, paint droplets ===
	for i in range(14):
		var px := fmod(float(i) * 197.3 + _time * 5.0, 1280.0)
		var py := 80.0 + sin(_time * 0.5 + float(i) * 1.4) * 50.0 + float(i) * 15.0
		var p_alpha := clampf(sin(_time * 0.9 + float(i) * 0.8), 0.0, 1.0) * 0.12
		draw_circle(Vector2(px, py), 3.0 + sin(_time * 0.6 + float(i)) * 1.5, Color(0.8, 0.1, 0.15, p_alpha))

	# Falling paint droplets (red paint dripping from sky)
	for i in range(8):
		var dx := fmod(float(i) * 163.7, 1280.0)
		var fall_cycle := fmod(_time * 0.3 + float(i) * 1.2, 4.0)
		var dy := 60.0 + fall_cycle * 100.0
		var drop_alpha := clampf(0.25 - fall_cycle * 0.05, 0.0, 0.25)
		draw_circle(Vector2(dx, dy), 2.5, Color(0.85, 0.08, 0.12, drop_alpha))
		# Paint trail
		if fall_cycle > 0.5:
			draw_line(Vector2(dx, dy - 15.0), Vector2(dx, dy), Color(0.85, 0.08, 0.12, drop_alpha * 0.5), 1.0)

	# === LANDMARKS ===
	# --- Red palace walls (background, spanning width) ---
	var palace_y := 160.0
	var palace_h := 220.0
	# Main wall
	draw_rect(Rect2(80.0, palace_y, 1120.0, palace_h), Color(0.5, 0.08, 0.1, 0.3))
	# Crenellations along top
	for i in range(28):
		var cx := 80.0 + float(i) * 40.0
		if cx > 1200.0:
			break
		draw_rect(Rect2(cx, palace_y - 18.0, 28.0, 18.0), Color(0.5, 0.08, 0.1, 0.3))

	# Heart-shaped windows
	for i in range(6):
		var wx := 180.0 + float(i) * 170.0
		var wy := palace_y + 60.0 + sin(float(i) * 1.3) * 20.0
		# Heart shape from two circles + triangle
		var hr := 10.0
		draw_circle(Vector2(wx - hr * 0.55, wy - hr * 0.3), hr, Color(0.15, 0.02, 0.04, 0.5))
		draw_circle(Vector2(wx + hr * 0.55, wy - hr * 0.3), hr, Color(0.15, 0.02, 0.04, 0.5))
		# Bottom of heart (triangle approx with rect)
		draw_rect(Rect2(wx - hr, wy - hr * 0.3, hr * 2.0, hr * 1.2), Color(0.15, 0.02, 0.04, 0.5))
		# Inner glow
		var win_glow := clampf(sin(_time * 0.7 + float(i) * 1.1), 0.0, 1.0) * 0.15
		draw_circle(Vector2(wx, wy), hr * 0.6, Color(1.0, 0.8, 0.3, win_glow))

	# --- Palace towers at edges ---
	for side in range(2):
		var tx := 60.0 if side == 0 else 1180.0
		draw_rect(Rect2(tx, palace_y - 60.0, 50.0, palace_h + 60.0), Color(0.55, 0.1, 0.12, 0.35))
		# Tower top (pointed)
		draw_line(Vector2(tx, palace_y - 60.0), Vector2(tx + 25.0, palace_y - 100.0), Color(0.55, 0.1, 0.12, 0.35), 3.0)
		draw_line(Vector2(tx + 50.0, palace_y - 60.0), Vector2(tx + 25.0, palace_y - 100.0), Color(0.55, 0.1, 0.12, 0.35), 3.0)
		# Heart flag
		draw_line(Vector2(tx + 25.0, palace_y - 100.0), Vector2(tx + 25.0, palace_y - 125.0), Color(0.3, 0.05, 0.08, 0.4), 1.5)
		var flag_sway := sin(_time * 1.5 + float(side) * PI) * 4.0
		draw_circle(Vector2(tx + 25.0 + flag_sway, palace_y - 130.0), 6.0, Color(0.85, 0.1, 0.15, 0.4))

	# --- Queen's throne silhouette (center background) ---
	var throne_x := 640.0
	var throne_y := 200.0
	# Throne back (tall arch)
	draw_rect(Rect2(throne_x - 25.0, throne_y - 80.0, 50.0, 100.0), Color(0.2, 0.02, 0.05, 0.35))
	# Throne ornate top (crown-like)
	for i in range(5):
		var spike_x := throne_x - 20.0 + float(i) * 10.0
		var spike_h := 15.0 if (i % 2 == 0) else 10.0
		draw_rect(Rect2(spike_x - 2.0, throne_y - 80.0 - spike_h, 4.0, spike_h), Color(0.2, 0.02, 0.05, 0.35))
	# Heart on throne
	draw_circle(Vector2(throne_x, throne_y - 50.0), 8.0, Color(0.7, 0.05, 0.1, 0.3))
	# Seat
	draw_rect(Rect2(throne_x - 30.0, throne_y + 15.0, 60.0, 12.0), Color(0.2, 0.02, 0.05, 0.35))
	# Armrests
	draw_rect(Rect2(throne_x - 35.0, throne_y - 10.0, 8.0, 30.0), Color(0.2, 0.02, 0.05, 0.3))
	draw_rect(Rect2(throne_x + 27.0, throne_y - 10.0, 8.0, 30.0), Color(0.2, 0.02, 0.05, 0.3))

	# --- "OFF WITH THEIR HEADS" banner ---
	var banner_y := 130.0
	var banner_sway := sin(_time * 0.6) * 5.0
	draw_rect(Rect2(440.0, banner_y + banner_sway, 400.0, 28.0), Color(0.8, 0.08, 0.12, 0.35))
	# Banner end notches
	draw_line(Vector2(440.0, banner_y + banner_sway), Vector2(430.0, banner_y + banner_sway + 14.0), Color(0.8, 0.08, 0.12, 0.35), 3.0)
	draw_line(Vector2(840.0, banner_y + banner_sway), Vector2(850.0, banner_y + banner_sway + 14.0), Color(0.8, 0.08, 0.12, 0.35), 3.0)
	# Text approximation with small rectangles (block letters)
	var text_blocks := [0.0, 20.0, 40.0, 60.0, 100.0, 120.0, 140.0, 160.0, 200.0, 220.0, 240.0, 260.0, 280.0, 320.0, 340.0, 360.0, 380.0]
	for bx in text_blocks:
		draw_rect(Rect2(450.0 + bx, banner_y + 6.0 + banner_sway, 14.0, 4.0), Color(0.15, 0.02, 0.04, 0.5))
		draw_rect(Rect2(450.0 + bx, banner_y + 14.0 + banner_sway, 14.0, 4.0), Color(0.15, 0.02, 0.04, 0.5))

	# --- Card soldier formations (flanking path) ---
	for i in range(8):
		var sx := 100.0 + float(i) * 150.0
		var sy := 400.0 + sin(float(i) * 0.9) * 20.0
		var bob := sin(_time * 1.0 + float(i) * 0.7) * 2.0
		# Card body
		var is_heart := (i % 2 == 0)
		var card_col := Color(0.85, 0.1, 0.15, 0.35) if is_heart else Color(0.15, 0.15, 0.15, 0.3)
		draw_rect(Rect2(sx - 8.0, sy - 22.0 + bob, 16.0, 28.0), card_col)
		# Suit symbol
		var sym_col := Color(0.95, 0.2, 0.25, 0.45) if is_heart else Color(0.3, 0.3, 0.3, 0.4)
		draw_circle(Vector2(sx, sy - 12.0 + bob), 3.0, sym_col)
		# Spear
		draw_line(Vector2(sx + 10.0, sy - 20.0 + bob), Vector2(sx + 10.0, sy - 45.0 + bob), Color(0.5, 0.45, 0.3, 0.3), 1.5)
		# Spear tip
		draw_line(Vector2(sx + 10.0, sy - 45.0 + bob), Vector2(sx + 7.0, sy - 40.0 + bob), Color(0.6, 0.55, 0.5, 0.35), 1.5)
		draw_line(Vector2(sx + 10.0, sy - 45.0 + bob), Vector2(sx + 13.0, sy - 40.0 + bob), Color(0.6, 0.55, 0.5, 0.35), 1.5)

	# --- Rose garden — white roses being painted red ---
	for i in range(10):
		var rx := 60.0 + float(i) * 125.0
		var ry := 430.0 + sin(float(i) * 2.1) * 15.0
		# Stem
		var stem_sway := sin(_time * 0.9 + float(i) * 0.6) * 1.5
		draw_line(Vector2(rx + stem_sway, ry), Vector2(rx, ry + 25.0), Color(0.15, 0.35, 0.1, 0.4), 1.5)
		# Rose bloom — transition from white to red based on paint progress
		var paint_progress := clampf(sin(_time * 0.2 + float(i) * 0.8) * 0.5 + 0.5, 0.0, 1.0)
		var rose_white := Color(0.95, 0.92, 0.88, 0.5)
		var rose_red := Color(0.85, 0.1, 0.15, 0.55)
		var rose_col := rose_white.lerp(rose_red, paint_progress)
		draw_circle(Vector2(rx + stem_sway, ry), 6.0, rose_col)
		# Paint drip below partially-painted roses
		if paint_progress > 0.3:
			var drip_len := paint_progress * 12.0
			draw_line(Vector2(rx + stem_sway, ry + 5.0), Vector2(rx + stem_sway, ry + 5.0 + drip_len), Color(0.85, 0.08, 0.1, 0.3), 1.5)
			# Drip drop at bottom
			draw_circle(Vector2(rx + stem_sway, ry + 6.0 + drip_len), 1.5, Color(0.85, 0.08, 0.1, 0.25))

	# --- Heart motifs scattered ---
	for i in range(12):
		var hx := fmod(float(i) * 107.3, 1280.0)
		var hy := 100.0 + float(i) * 40.0 + sin(_time * 0.3 + float(i)) * 10.0
		var h_alpha := 0.08 + clampf(sin(_time * 0.6 + float(i) * 1.3), 0.0, 1.0) * 0.07
		var h_size := 4.0 + sin(float(i) * 1.5) * 2.0
		draw_circle(Vector2(hx - h_size * 0.4, hy), h_size, Color(0.8, 0.1, 0.15, h_alpha))
		draw_circle(Vector2(hx + h_size * 0.4, hy), h_size, Color(0.8, 0.1, 0.15, h_alpha))
		draw_rect(Rect2(hx - h_size, hy, h_size * 2.0, h_size * 1.0), Color(0.8, 0.1, 0.15, h_alpha))

	# === GROUND — red/black checkerboard courtyard ===
	var ground_y := 450.0
	draw_rect(Rect2(0, ground_y, 1280, 628.0 - ground_y), ground_color)
	var tile_size := 36.0
	var cols := int(1280.0 / tile_size) + 1
	var rows := int((628.0 - ground_y) / tile_size) + 1
	for row in range(rows):
		for col in range(cols):
			var is_red := (row + col) % 2 == 0
			var tile_col: Color
			if is_red:
				tile_col = Color(0.55, 0.08, 0.1, 0.3)
			else:
				tile_col = Color(0.08, 0.05, 0.05, 0.25)
			draw_rect(Rect2(float(col) * tile_size, ground_y + float(row) * tile_size, tile_size, tile_size), tile_col)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"giant_mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var glow_pulse = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 0.8, mp.y - ms * 4.0, ms * 1.6, ms * 4.0), Color(0.85, 0.8, 0.7, 0.5))
				var cap_center = mp + Vector2(0, -ms * 4.5)
				draw_circle(cap_center, ms * 3.0 + 4.0, Color(0.7, 0.2, 0.8, 0.1 + glow_pulse * 0.08))
				draw_circle(cap_center, ms * 3.0, Color(0.8, 0.25, 0.4, 0.5))
				draw_circle(cap_center + Vector2(-ms, -ms * 0.5), ms * 0.5, Color(1, 0.95, 0.85, 0.4))
			"floating_card":
				var cp = dec["pos"]
				var drift_y = sin(_time * 0.8 + dec["extra"]) * 15.0
				var drift_x = cos(_time * 0.5 + dec["extra"]) * 8.0
				var card_pos = cp + Vector2(drift_x, drift_y)
				draw_rect(Rect2(card_pos.x - 4, card_pos.y - 6, 8, 12), Color(1.0, 0.98, 0.9, 0.25))
				var suit_col = Color(0.8, 0.15, 0.15, 0.35) if dec["extra"] > 3.0 else Color(0.1, 0.1, 0.1, 0.35)
				draw_circle(card_pos, 2.0, suit_col)
			"rose":
				var rp = dec["pos"]
				var sway = sin(_time * 1.2 + dec["extra"]) * 2.0
				draw_line(rp, rp + Vector2(sway, -12), Color(0.15, 0.4, 0.1, 0.45), 1.5)
				var bloom = rp + Vector2(sway, -12)
				var rc = Color(0.85, 0.1, 0.15, 0.5) if dec["extra"] < 0.5 else Color(0.95, 0.9, 0.85, 0.5)
				draw_circle(bloom, dec["size"], rc)
			"teacup":
				var tp2 = dec["pos"]
				draw_rect(Rect2(tp2.x - 4, tp2.y - 5, 8, 6), Color(0.8, 0.75, 0.6, 0.4))
				draw_arc(Vector2(tp2.x + 5, tp2.y - 2), 3, -PI * 0.5, PI * 0.5, 6, Color(0.8, 0.75, 0.6, 0.35), 1.0)

	# === FOREGROUND ===
	# Scattered playing cards at bottom
	for i in range(7):
		var fc_x := fmod(float(i) * 187.0 + _time * 6.0, 1400.0) - 60.0
		var fc_y := 570.0 + sin(_time * 0.4 + float(i) * 0.9) * 12.0
		var fc_alpha := 0.15 + clampf(sin(_time * 0.5 + float(i)), 0.0, 1.0) * 0.08
		# Card rectangle
		draw_rect(Rect2(fc_x - 6.0, fc_y - 9.0, 12.0, 18.0), Color(0.95, 0.92, 0.85, fc_alpha))
		# Red or black suit
		var is_red_card := (i % 2 == 0)
		var suit_c := Color(0.8, 0.1, 0.15, fc_alpha * 1.2) if is_red_card else Color(0.1, 0.1, 0.1, fc_alpha * 1.2)
		draw_circle(Vector2(fc_x, fc_y - 2.0), 2.0, suit_c)

	# Red paint splatters on ground
	for i in range(5):
		var splat_x := 150.0 + float(i) * 240.0
		var splat_y := 600.0 + sin(float(i) * 2.7) * 10.0
		var splat_r := 8.0 + sin(float(i) * 1.3) * 4.0
		draw_circle(Vector2(splat_x, splat_y), splat_r, Color(0.75, 0.06, 0.1, 0.12))
		# Smaller satellite splatters
		for j in range(3):
			var angle := float(j) * TAU / 3.0 + float(i)
			var dist := splat_r + 5.0
			var sub_x := splat_x + cos(angle) * dist
			var sub_y := splat_y + sin(angle) * dist
			draw_circle(Vector2(sub_x, sub_y), 2.5, Color(0.75, 0.06, 0.1, 0.08))

	# Bottom crimson fog
	for i in range(8):
		var fog_t := float(i) / 8.0
		var fog_y := 600.0 + fog_t * 28.0
		draw_rect(Rect2(0, fog_y, 1280, 4.0), Color(0.35, 0.05, 0.08, 0.08 + fog_t * 0.06))
	_draw_alice_novel(3)
	_draw_shadow_author_effects()

func _draw_oz_ch2(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — dark green-black storm sky ===
	for i in range(40):
		var t = float(i) / 39.0
		var col = sky_color.lerp(Color(0.03, 0.08, 0.02, 1.0), t * 0.6)
		# Lightning flicker in storm clouds
		var lightning = clampf(sin(_time * 8.7 + t * 12.0) * sin(_time * 3.1), 0.0, 1.0)
		if lightning > 0.92:
			col = col.lerp(Color(0.6, 0.7, 0.5, 1.0), (lightning - 0.92) * 8.0)
		draw_rect(Rect2(0, 50 + t * 280, 1280, 8.5), col)

	# === STORM CLOUDS — roiling green-black masses ===
	for i in range(18):
		var cx = float(i) * 75.0 + sin(_time * 0.3 + float(i) * 0.9) * 30.0
		var cy = 70.0 + sin(float(i) * 1.7 + _time * 0.25) * 25.0
		var cr = 55.0 + sin(float(i) * 2.3) * 20.0
		var cloud_col = Color(0.04, 0.1, 0.03, 0.6 + sin(_time * 0.4 + float(i)) * 0.1)
		draw_circle(Vector2(cx, cy), cr, cloud_col)
		# Green-tinged underbelly
		draw_circle(Vector2(cx + 10.0, cy + 15.0), cr * 0.7, Color(0.08, 0.18, 0.05, 0.35))

	# === SICKLY GREEN MOON behind clouds ===
	var moon_x = 980.0
	var moon_y = 100.0
	draw_circle(Vector2(moon_x, moon_y), 42.0, Color(0.25, 0.45, 0.15, 0.35))
	draw_circle(Vector2(moon_x, moon_y), 34.0, Color(0.35, 0.55, 0.2, 0.5))
	draw_circle(Vector2(moon_x, moon_y), 26.0, Color(0.5, 0.7, 0.3, 0.6))
	# Moon craters
	draw_circle(Vector2(moon_x - 8.0, moon_y - 5.0), 6.0, Color(0.3, 0.5, 0.15, 0.3))
	draw_circle(Vector2(moon_x + 10.0, moon_y + 4.0), 4.0, Color(0.3, 0.5, 0.15, 0.25))

	# === BROOMSTICK SILHOUETTE crossing the moon (animated) ===
	var broom_phase = fmod(_time * 0.4, 2.0) - 1.0
	var broom_cx = moon_x + broom_phase * 80.0
	var broom_cy = moon_y + sin(broom_phase * 3.0) * 12.0
	if absf(broom_phase) < 0.8:
		# Rider silhouette
		var broom_pts = PackedVector2Array([
			Vector2(broom_cx - 18.0, broom_cy - 6.0),
			Vector2(broom_cx + 12.0, broom_cy - 2.0),
			Vector2(broom_cx + 22.0, broom_cy + 2.0),
			Vector2(broom_cx + 30.0, broom_cy + 6.0),
			Vector2(broom_cx + 30.0, broom_cy + 10.0),
			Vector2(broom_cx + 12.0, broom_cy + 4.0),
			Vector2(broom_cx - 8.0, broom_cy + 4.0),
			Vector2(broom_cx - 18.0, broom_cy)])
		draw_colored_polygon(broom_pts, Color(0.02, 0.02, 0.02, 0.85))
		# Pointy hat
		draw_colored_polygon(PackedVector2Array([
			Vector2(broom_cx - 12.0, broom_cy - 6.0),
			Vector2(broom_cx - 6.0, broom_cy - 22.0),
			Vector2(broom_cx - 2.0, broom_cy - 6.0)]), Color(0.02, 0.02, 0.02, 0.85))
		# Broom bristles
		for b in range(5):
			var boff = float(b) * 2.5 - 5.0
			draw_line(Vector2(broom_cx + 28.0, broom_cy + 6.0), Vector2(broom_cx + 40.0, broom_cy + 4.0 + boff), Color(0.02, 0.02, 0.02, 0.7), 1.0)

	# === DISTANT MOUNTAINS — dark jagged peaks ===
	for layer in range(3):
		var pts = PackedVector2Array()
		pts.append(Vector2(0, 330 - layer * 30))
		var lf = float(layer)
		for j in range(26):
			var mx = float(j) * 52.0
			var my = 210.0 - lf * 30.0 + sin(float(j) * 1.3 + lf * 2.0) * 45.0 + sin(float(j) * 0.4) * 30.0
			pts.append(Vector2(mx, my))
		pts.append(Vector2(1280, 330 - layer * 30))
		var dark = 0.03 + lf * 0.02
		draw_colored_polygon(pts, Color(dark, dark + 0.02, dark, 0.85 - lf * 0.1))

	# === WITCH'S CASTLE SILHOUETTE on tallest peak ===
	var castle_x = 350.0
	var castle_base = 165.0
	# Main tower
	draw_colored_polygon(PackedVector2Array([
		Vector2(castle_x - 25.0, castle_base), Vector2(castle_x - 20.0, castle_base - 80.0),
		Vector2(castle_x - 8.0, castle_base - 95.0), Vector2(castle_x, castle_base - 110.0),
		Vector2(castle_x + 8.0, castle_base - 95.0), Vector2(castle_x + 20.0, castle_base - 80.0),
		Vector2(castle_x + 25.0, castle_base)]), Color(0.02, 0.02, 0.02, 0.95))
	# Side towers
	for side in [-1.0, 1.0]:
		var sx = castle_x + side * 45.0
		draw_colored_polygon(PackedVector2Array([
			Vector2(sx - 12.0, castle_base), Vector2(sx - 10.0, castle_base - 50.0),
			Vector2(sx, castle_base - 65.0), Vector2(sx + 10.0, castle_base - 50.0),
			Vector2(sx + 12.0, castle_base)]), Color(0.02, 0.02, 0.02, 0.95))
	# Castle windows — eerie green glow
	var win_glow = 0.5 + sin(_time * 1.5) * 0.2
	draw_circle(Vector2(castle_x, castle_base - 70.0), 4.0, Color(0.2, 0.6 * win_glow, 0.1, 0.7))
	draw_circle(Vector2(castle_x - 45.0, castle_base - 35.0), 3.0, Color(0.2, 0.5 * win_glow, 0.1, 0.6))
	draw_circle(Vector2(castle_x + 45.0, castle_base - 35.0), 3.0, Color(0.2, 0.5 * win_glow, 0.1, 0.6))

	# === HOURGLASS MOTIF — ghostly outline in the sky ===
	var hg_x = 160.0
	var hg_y = 130.0
	var hg_alpha = 0.12 + sin(_time * 0.8) * 0.05
	draw_colored_polygon(PackedVector2Array([
		Vector2(hg_x - 14.0, hg_y - 28.0), Vector2(hg_x + 14.0, hg_y - 28.0),
		Vector2(hg_x + 3.0, hg_y), Vector2(hg_x + 14.0, hg_y + 28.0),
		Vector2(hg_x - 14.0, hg_y + 28.0), Vector2(hg_x - 3.0, hg_y)]),
		Color(0.3, 0.6, 0.2, hg_alpha))
	# Sand falling
	var sand_y = hg_y - 10.0 + fmod(_time * 12.0, 20.0)
	if sand_y < hg_y + 20.0:
		draw_circle(Vector2(hg_x, sand_y), 1.5, Color(0.5, 0.7, 0.2, hg_alpha * 2.0))

	# === GREEN SMOKE RISING from castle ===
	for s in range(8):
		var sf = float(s)
		var smoke_t = fmod(_time * 0.6 + sf * 0.4, 3.5)
		var smoke_x = castle_x + sin(smoke_t * 2.0 + sf) * 15.0
		var smoke_y = castle_base - 110.0 - smoke_t * 30.0
		var smoke_r = 6.0 + smoke_t * 8.0
		var smoke_a = clampf(0.3 - smoke_t * 0.08, 0.0, 0.3)
		draw_circle(Vector2(smoke_x, smoke_y), smoke_r, Color(0.15, 0.5, 0.1, smoke_a))

	# === WINKIE GUARD TOWERS — flanking the scene ===
	for gx in [80.0, 1200.0]:
		var gy = 300.0
		# Tower body
		draw_rect(Rect2(gx - 14.0, gy - 55.0, 28.0, 55.0), Color(0.12, 0.1, 0.05, 0.75))
		# Crenellations
		for c in range(4):
			draw_rect(Rect2(gx - 14.0 + float(c) * 9.0, gy - 62.0, 5.0, 7.0), Color(0.12, 0.1, 0.05, 0.75))
		# Torch glow
		var torch_flicker = 0.6 + sin(_time * 5.0 + gx) * 0.15
		draw_circle(Vector2(gx, gy - 40.0), 5.0, Color(0.6, 0.3, 0.05, torch_flicker * 0.5))
		draw_circle(Vector2(gx, gy - 40.0), 3.0, Color(0.8, 0.5, 0.1, torch_flicker * 0.7))

	# === FLYING MONKEYS — animated swooping ===
	for m in range(4):
		var mf = float(m)
		var monkey_t = fmod(_time * 0.7 + mf * 1.8, 6.0)
		var monkey_x = monkey_t * 220.0 - 40.0
		var monkey_y = 140.0 + sin(monkey_t * 3.0 + mf * 2.0) * 35.0 + mf * 25.0
		if monkey_x > -20.0 and monkey_x < 1300.0:
			# Body
			draw_circle(Vector2(monkey_x, monkey_y), 5.0, Color(0.08, 0.06, 0.04, 0.7))
			# Wings flapping
			var wing_angle = sin(_time * 8.0 + mf * 3.0) * 0.6
			var wing_up = -12.0 + wing_angle * 10.0
			draw_line(Vector2(monkey_x - 4.0, monkey_y), Vector2(monkey_x - 16.0, monkey_y + wing_up), Color(0.1, 0.08, 0.05, 0.6), 2.0)
			draw_line(Vector2(monkey_x + 4.0, monkey_y), Vector2(monkey_x + 16.0, monkey_y + wing_up), Color(0.1, 0.08, 0.05, 0.6), 2.0)

	# === DEAD GNARLED TREES ===
	for tx in [50.0, 220.0, 600.0, 850.0, 1100.0, 1230.0]:
		var tree_base = 340.0 + sin(tx * 0.7) * 15.0
		var tree_h = 50.0 + sin(tx * 1.3) * 15.0
		var tree_col = Color(0.08, 0.06, 0.03, 0.7)
		# Trunk
		draw_line(Vector2(tx, tree_base), Vector2(tx + sin(tx) * 5.0, tree_base - tree_h), tree_col, 3.0)
		# Twisted branches
		for br in range(4):
			var bf = float(br)
			var by = tree_base - tree_h * (0.4 + bf * 0.15)
			var bx_off = (15.0 + bf * 8.0) * (1.0 if fmod(bf, 2.0) < 1.0 else -1.0)
			var sway = sin(_time * 0.7 + tx + bf) * 3.0
			draw_line(Vector2(tx, by), Vector2(tx + bx_off + sway, by - 12.0 - bf * 3.0), tree_col, 1.5)
			# Sub-branches
			draw_line(Vector2(tx + bx_off * 0.7 + sway, by - 8.0), Vector2(tx + bx_off * 1.1 + sway, by - 20.0), tree_col, 1.0)

	# === GROUND — barren dark earth ===
	var ground_pts = PackedVector2Array()
	ground_pts.append(Vector2(0, 628))
	for g in range(65):
		var gx = float(g) * 20.0
		var gy = 340.0 + sin(gx * 0.03 + 1.5) * 12.0 + sin(gx * 0.07) * 5.0
		ground_pts.append(Vector2(gx, gy))
	ground_pts.append(Vector2(1280, 628))
	draw_colored_polygon(ground_pts, ground_color)

	# Ground texture — cracked dry earth
	for i in range(30):
		var cx = float(i) * 43.0 + sin(float(i) * 3.7) * 20.0
		var cy = 380.0 + sin(float(i) * 1.9) * 60.0 + float(i) * 5.0
		if cy < 620.0:
			var crack_len = 15.0 + sin(float(i) * 2.3) * 8.0
			var crack_angle = sin(float(i) * 4.1) * 0.8
			draw_line(Vector2(cx, cy), Vector2(cx + cos(crack_angle) * crack_len, cy + sin(crack_angle) * crack_len), Color(0.05, 0.04, 0.02, 0.3), 1.0)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"poppy":
				var pp = dec["pos"]
				var ps = dec["size"]
				var sway = sin(_time * 1.3 + dec["extra"]) * 2.0
				draw_line(pp, pp + Vector2(sway, -ps * 6.0), Color(0.15, 0.35, 0.1, 0.5), 1.0)
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 2.5, Color(0.85, 0.12, 0.1, 0.55))
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 0.7, Color(0.15, 0.1, 0.05, 0.5))
			"emerald_crystal":
				var ep = dec["pos"]
				var es = dec["size"]
				var sparkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				draw_colored_polygon(PackedVector2Array([ep + Vector2(0, -es * 2), ep + Vector2(es, 0), ep + Vector2(0, es), ep + Vector2(-es, 0)]), Color(0.2, 0.8, 0.3, 0.4 + sparkle * 0.15))
			"scarecrow":
				var sp = dec["pos"]
				var ss = dec["size"]
				draw_line(sp, sp + Vector2(0, -ss * 2), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_line(sp + Vector2(-ss, -ss * 1.5), sp + Vector2(ss, -ss * 1.5), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_circle(sp + Vector2(0, -ss * 2.2), ss * 0.5, Color(0.6, 0.5, 0.2, 0.45))

	# === FOREGROUND — dark mist and atmosphere ===
	for i in range(6):
		var fi = float(i)
		var fog_x = fmod(fi * 250.0 + _time * 15.0, 1400.0) - 60.0
		var fog_y = 560.0 + sin(fi * 2.0) * 30.0
		draw_circle(Vector2(fog_x, fog_y), 50.0 + fi * 8.0, Color(0.05, 0.12, 0.03, 0.08))

	# Vignette — dark edges
	for v in range(8):
		var vf = float(v)
		var va = 0.04 * (8.0 - vf)
		draw_rect(Rect2(0, 50, vf * 2.0, 578), Color(0.0, 0.0, 0.0, va))
		draw_rect(Rect2(1280.0 - vf * 2.0, 50, vf * 2.0, 578), Color(0.0, 0.0, 0.0, va))
	_draw_oz_novel(2)
	_draw_shadow_author_effects()


func _draw_oz_ch3(sky_color: Color, ground_color: Color) -> void:
	# === SKY / CEILING — emerald green crystalline glow ===
	for i in range(40):
		var t = float(i) / 39.0
		var col = sky_color.lerp(Color(0.05, 0.25, 0.08, 1.0), t * 0.7)
		# Pulsing emerald radiance
		var pulse = sin(_time * 0.6 + t * 4.0) * 0.04
		col = Color(col.r + pulse * 0.3, col.g + pulse, col.b + pulse * 0.3, 1.0)
		draw_rect(Rect2(0, 50 + t * 280, 1280, 8.5), col)

	# === JEWELED CEILING — faceted crystal pattern ===
	for i in range(22):
		var fi = float(i)
		var cx = fi * 62.0 + sin(fi * 1.7) * 15.0
		var cy = 65.0 + sin(fi * 2.3) * 12.0
		var jewel_size = 8.0 + sin(fi * 3.1) * 3.0
		var shimmer = (sin(_time * 1.8 + fi * 1.4) + 1.0) * 0.5
		# Emerald facet
		draw_colored_polygon(PackedVector2Array([
			Vector2(cx, cy - jewel_size), Vector2(cx + jewel_size * 0.7, cy),
			Vector2(cx, cy + jewel_size * 0.5), Vector2(cx - jewel_size * 0.7, cy)]),
			Color(0.15, 0.6 + shimmer * 0.2, 0.2, 0.35 + shimmer * 0.15))
		# Light refraction lines
		if shimmer > 0.7:
			draw_line(Vector2(cx, cy), Vector2(cx + sin(fi) * 30.0, cy + 40.0 + fi * 3.0),
				Color(0.3, 0.8, 0.4, 0.06), 1.0)

	# === GREEN CRYSTAL WALLS — left and right ===
	for side in [0.0, 1.0]:
		var wall_x = side * 1200.0 + 20.0
		# Crystal column structures
		for j in range(6):
			var jf = float(j)
			var col_x = wall_x + sin(jf * 2.0) * 10.0
			var col_top = 70.0 + jf * 8.0
			var col_bot = 600.0 - jf * 10.0
			var glow = 0.3 + sin(_time * 1.2 + jf + side * 3.0) * 0.1
			# Crystal column body
			draw_rect(Rect2(col_x, col_top, 10.0 + jf * 2.0, col_bot - col_top),
				Color(0.1, 0.35 + glow, 0.12, 0.2 - jf * 0.02))
			# Facet highlights
			draw_line(Vector2(col_x + 2.0, col_top), Vector2(col_x + 2.0, col_bot),
				Color(0.3, 0.7, 0.35, 0.1), 1.0)

	# === EMERALD GLOW — ambient light from walls ===
	for i in range(5):
		var fi = float(i)
		var glow_x = fi * 320.0 + 80.0
		var glow_y = 300.0 + sin(fi * 2.0) * 50.0
		var glow_pulse = 0.06 + sin(_time * 0.9 + fi * 1.5) * 0.02
		draw_circle(Vector2(glow_x, glow_y), 120.0, Color(0.1, 0.4, 0.12, glow_pulse))
		draw_circle(Vector2(glow_x, glow_y), 60.0, Color(0.15, 0.5, 0.18, glow_pulse * 1.5))

	# === THRONE at far end — tall emerald chair ===
	var throne_x = 640.0
	var throne_y = 150.0
	# Throne back — tall pointed emerald
	draw_colored_polygon(PackedVector2Array([
		Vector2(throne_x - 30.0, throne_y + 60.0), Vector2(throne_x - 20.0, throne_y - 40.0),
		Vector2(throne_x - 8.0, throne_y - 70.0), Vector2(throne_x, throne_y - 80.0),
		Vector2(throne_x + 8.0, throne_y - 70.0), Vector2(throne_x + 20.0, throne_y - 40.0),
		Vector2(throne_x + 30.0, throne_y + 60.0)]),
		Color(0.08, 0.35, 0.1, 0.6))
	# Throne glow
	var throne_glow = 0.3 + sin(_time * 0.7) * 0.1
	draw_circle(Vector2(throne_x, throne_y - 20.0), 18.0, Color(0.2, 0.6, 0.25, throne_glow * 0.4))
	# Emerald jewel on throne top
	draw_circle(Vector2(throne_x, throne_y - 72.0), 6.0, Color(0.3, 0.85, 0.35, 0.7))
	draw_circle(Vector2(throne_x, throne_y - 72.0), 3.0, Color(0.6, 1.0, 0.65, 0.5))
	# Throne seat
	draw_rect(Rect2(throne_x - 24.0, throne_y + 40.0, 48.0, 12.0), Color(0.06, 0.28, 0.08, 0.55))
	# Armrests
	draw_rect(Rect2(throne_x - 32.0, throne_y + 20.0, 8.0, 32.0), Color(0.07, 0.3, 0.09, 0.5))
	draw_rect(Rect2(throne_x + 24.0, throne_y + 20.0, 8.0, 32.0), Color(0.07, 0.3, 0.09, 0.5))

	# === RUBY SLIPPERS MOTIF — glowing on throne steps ===
	var slipper_x = 640.0
	var slipper_y = 240.0
	var ruby_sparkle = (sin(_time * 2.5) + 1.0) * 0.5
	# Left slipper
	draw_colored_polygon(PackedVector2Array([
		Vector2(slipper_x - 15.0, slipper_y), Vector2(slipper_x - 5.0, slipper_y - 5.0),
		Vector2(slipper_x - 2.0, slipper_y - 3.0), Vector2(slipper_x - 3.0, slipper_y + 2.0),
		Vector2(slipper_x - 10.0, slipper_y + 4.0)]),
		Color(0.8, 0.1, 0.1, 0.5 + ruby_sparkle * 0.2))
	# Right slipper
	draw_colored_polygon(PackedVector2Array([
		Vector2(slipper_x + 5.0, slipper_y), Vector2(slipper_x + 15.0, slipper_y - 4.0),
		Vector2(slipper_x + 18.0, slipper_y - 1.0), Vector2(slipper_x + 16.0, slipper_y + 3.0),
		Vector2(slipper_x + 8.0, slipper_y + 4.0)]),
		Color(0.8, 0.1, 0.1, 0.5 + ruby_sparkle * 0.2))
	# Ruby glow
	draw_circle(Vector2(slipper_x + 2.0, slipper_y), 12.0, Color(0.7, 0.1, 0.1, 0.08 + ruby_sparkle * 0.06))

	# === NOME KING'S ROCKS — emerging through floor ===
	for i in range(7):
		var fi = float(i)
		var rock_x = 100.0 + fi * 170.0 + sin(fi * 3.3) * 40.0
		var rock_base_y = 420.0 + sin(fi * 2.1) * 30.0
		var emerge_phase = sin(_time * 0.5 + fi * 1.2)
		var rock_height = 20.0 + clampf(emerge_phase, 0.0, 1.0) * 25.0
		var rock_w = 18.0 + sin(fi * 1.7) * 6.0
		# Jagged rock shape
		draw_colored_polygon(PackedVector2Array([
			Vector2(rock_x - rock_w, rock_base_y),
			Vector2(rock_x - rock_w * 0.6, rock_base_y - rock_height * 0.7),
			Vector2(rock_x - rock_w * 0.2, rock_base_y - rock_height),
			Vector2(rock_x + rock_w * 0.3, rock_base_y - rock_height * 0.85),
			Vector2(rock_x + rock_w * 0.7, rock_base_y - rock_height * 0.5),
			Vector2(rock_x + rock_w, rock_base_y)]),
			Color(0.25, 0.18, 0.1, 0.5 + clampf(emerge_phase, 0.0, 1.0) * 0.2))
		# Cracks in rock
		draw_line(Vector2(rock_x, rock_base_y - rock_height * 0.3),
			Vector2(rock_x + rock_w * 0.3, rock_base_y - rock_height * 0.8),
			Color(0.15, 0.1, 0.05, 0.3), 1.0)
		# Dust particles when emerging
		if emerge_phase > 0.3:
			for d in range(3):
				var df = float(d)
				var dust_x = rock_x + sin(_time * 3.0 + df * 2.0 + fi) * 12.0
				var dust_y = rock_base_y - sin(_time * 2.0 + df + fi) * 10.0
				draw_circle(Vector2(dust_x, dust_y), 2.0, Color(0.3, 0.22, 0.12, 0.15))

	# === CRACKING FLOOR — tile pattern with fractures ===
	for row in range(8):
		var rf = float(row)
		var ty = 380.0 + rf * 32.0
		for col in range(20):
			var cf = float(col)
			var tx = cf * 68.0 + fmod(rf, 2.0) * 34.0
			# Tile outline
			draw_rect(Rect2(tx, ty, 64.0, 28.0), Color(0.1, 0.32, 0.12, 0.15), false, 1.0)
			# Cracks across some tiles
			if sin(rf * 3.1 + cf * 2.7) > 0.2:
				var crack_start = Vector2(tx + 10.0, ty + 14.0)
				var crack_end = Vector2(tx + 50.0 + sin(cf * 4.0) * 10.0, ty + 8.0 + cos(rf * 2.0) * 8.0)
				draw_line(crack_start, crack_end, Color(0.15, 0.08, 0.04, 0.3), 1.0)
				# Branch crack
				var mid = (crack_start + crack_end) * 0.5
				draw_line(mid, mid + Vector2(sin(cf) * 12.0, 10.0), Color(0.15, 0.08, 0.04, 0.2), 1.0)

	# === SHATTERED GREEN GLASS — debris scattered ===
	for i in range(12):
		var fi = float(i)
		var gx = 80.0 + fi * 105.0 + sin(fi * 2.7) * 30.0
		var gy = 400.0 + sin(fi * 1.9) * 50.0
		var gs = 4.0 + sin(fi * 3.2) * 2.0
		var glass_alpha = 0.2 + sin(_time * 1.5 + fi * 0.8) * 0.08
		# Triangular glass shard
		draw_colored_polygon(PackedVector2Array([
			Vector2(gx, gy - gs * 2.0),
			Vector2(gx + gs * 1.5, gy + gs),
			Vector2(gx - gs, gy + gs * 0.5)]),
			Color(0.25, 0.75, 0.3, glass_alpha))
		# Glint
		draw_line(Vector2(gx - 1.0, gy - gs), Vector2(gx + 2.0, gy + gs * 0.5),
			Color(0.5, 0.9, 0.55, glass_alpha * 0.7), 1.0)

	# === GROUND — emerald tile floor ===
	var ground_pts = PackedVector2Array()
	ground_pts.append(Vector2(0, 628))
	for g in range(65):
		var gx = float(g) * 20.0
		var gy = 370.0 + sin(gx * 0.02 + 0.5) * 8.0
		ground_pts.append(Vector2(gx, gy))
	ground_pts.append(Vector2(1280, 628))
	draw_colored_polygon(ground_pts, ground_color)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"poppy":
				var pp = dec["pos"]
				var ps = dec["size"]
				var sway = sin(_time * 1.3 + dec["extra"]) * 2.0
				draw_line(pp, pp + Vector2(sway, -ps * 6.0), Color(0.15, 0.35, 0.1, 0.5), 1.0)
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 2.5, Color(0.85, 0.12, 0.1, 0.55))
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 0.7, Color(0.15, 0.1, 0.05, 0.5))
			"emerald_crystal":
				var ep = dec["pos"]
				var es = dec["size"]
				var sparkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				draw_colored_polygon(PackedVector2Array([ep + Vector2(0, -es * 2), ep + Vector2(es, 0), ep + Vector2(0, es), ep + Vector2(-es, 0)]), Color(0.2, 0.8, 0.3, 0.4 + sparkle * 0.15))
			"scarecrow":
				var sp = dec["pos"]
				var ss = dec["size"]
				draw_line(sp, sp + Vector2(0, -ss * 2), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_line(sp + Vector2(-ss, -ss * 1.5), sp + Vector2(ss, -ss * 1.5), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_circle(sp + Vector2(0, -ss * 2.2), ss * 0.5, Color(0.6, 0.5, 0.2, 0.45))

	# === FOREGROUND — emerald sparkle particles ===
	for i in range(10):
		var fi = float(i)
		var spark_t = fmod(_time * 0.8 + fi * 0.7, 4.0)
		var spark_x = fi * 130.0 + sin(spark_t * 2.0 + fi) * 40.0
		var spark_y = 500.0 + sin(spark_t * 1.5 + fi * 3.0) * 60.0 - spark_t * 20.0
		var spark_alpha = clampf(0.25 - absf(spark_t - 2.0) * 0.12, 0.0, 0.25)
		draw_circle(Vector2(spark_x, spark_y), 2.0, Color(0.3, 0.9, 0.4, spark_alpha))
		draw_circle(Vector2(spark_x, spark_y), 1.0, Color(0.6, 1.0, 0.65, spark_alpha * 1.5))

	# === Green ambient fog at base ===
	for i in range(8):
		var fi = float(i)
		var fog_x = fmod(fi * 180.0 + _time * 10.0, 1400.0) - 60.0
		var fog_y = 580.0 + sin(fi * 1.7) * 20.0
		draw_circle(Vector2(fog_x, fog_y), 55.0 + fi * 6.0, Color(0.1, 0.35, 0.12, 0.06))

	# === Ceiling light beams ===
	for i in range(4):
		var fi = float(i)
		var bx = 200.0 + fi * 280.0
		var bs = sin(_time * 0.3 + fi * 1.5) * 15.0
		var ba = 0.03 + sin(_time * 0.7 + fi * 2.0) * 0.01
		draw_colored_polygon(PackedVector2Array([
			Vector2(bx - 8.0 + bs * 0.3, 55.0), Vector2(bx + 8.0 + bs * 0.3, 55.0),
			Vector2(bx + 40.0 + bs, 620.0), Vector2(bx - 40.0 + bs, 620.0)]),
			Color(0.2, 0.7, 0.25, ba))
	_draw_oz_novel(3)
	_draw_shadow_author_effects()

func _draw_peter_ch2(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — Dark jungle night ===
	for i in range(32):
		var t = float(i) / 31.0
		var col = sky_color.lerp(Color(0.02, 0.06, 0.12), t)
		# Add faint green jungle haze in lower sky
		col = col.lerp(Color(0.03, 0.1, 0.06), t * t * 0.4)
		var y0 = int(t * 578.0) + 50
		var y1 = int((t + 1.0 / 31.0) * 578.0) + 50
		draw_rect(Rect2(0, y0, 1280, y1 - y0 + 1), col)

	# === STARS / ATMOSPHERE — Faint stars through canopy gaps ===
	var star_positions = [
		Vector2(120, 62), Vector2(340, 75), Vector2(580, 58), Vector2(790, 80),
		Vector2(950, 65), Vector2(1100, 72), Vector2(200, 90), Vector2(680, 68),
		Vector2(1020, 85), Vector2(440, 60), Vector2(860, 70), Vector2(1200, 78)
	]
	for sp in star_positions:
		var flicker = (sin(_time * 1.8 + sp.x * 0.03) + 1.0) * 0.5
		var blocked = sin(sp.x * 0.02 + sp.y * 0.05)
		if blocked > 0.1:
			draw_circle(sp, 0.8 + flicker * 0.5, Color(1.0, 0.97, 0.85, 0.15 + flicker * 0.2))

	# Moon glow behind canopy
	var moon_pos = Vector2(980, 90)
	draw_circle(moon_pos, 50.0, Color(0.6, 0.65, 0.8, 0.04))
	draw_circle(moon_pos, 30.0, Color(0.7, 0.75, 0.9, 0.07))
	draw_circle(moon_pos, 14.0, Color(0.85, 0.88, 0.95, 0.2))

	# Jungle mist layers
	for m in range(5):
		var my = 200.0 + float(m) * 70.0
		var mx_off = sin(_time * 0.15 + float(m) * 1.3) * 40.0
		var mist_alpha = 0.03 + float(m) * 0.008
		draw_rect(Rect2(mx_off - 50, my, 1380, 25), Color(0.15, 0.25, 0.18, mist_alpha))

	# === LANDMARKS ===

	# --- Skull Rock in distance (far right background) ---
	var skull_base = Vector2(1150, 200)
	var skull_pts: PackedVector2Array = PackedVector2Array([
		skull_base + Vector2(-60, 0), skull_base + Vector2(-55, -40),
		skull_base + Vector2(-40, -65), skull_base + Vector2(-15, -78),
		skull_base + Vector2(15, -78), skull_base + Vector2(40, -65),
		skull_base + Vector2(55, -40), skull_base + Vector2(60, 0)
	])
	draw_colored_polygon(skull_pts, Color(0.12, 0.1, 0.13, 0.6))
	# Skull eye sockets — faint red glow
	draw_circle(skull_base + Vector2(-18, -50), 9.0, Color(0.05, 0.03, 0.05, 0.7))
	draw_circle(skull_base + Vector2(18, -50), 9.0, Color(0.05, 0.03, 0.05, 0.7))
	var eye_pulse = (sin(_time * 1.5) + 1.0) * 0.5
	draw_circle(skull_base + Vector2(-18, -50), 4.0, Color(0.8, 0.1, 0.05, 0.2 + eye_pulse * 0.15))
	draw_circle(skull_base + Vector2(18, -50), 4.0, Color(0.8, 0.1, 0.05, 0.2 + eye_pulse * 0.15))
	# Nose cavity
	draw_circle(skull_base + Vector2(0, -38), 5.0, Color(0.04, 0.02, 0.04, 0.6))
	# Teeth
	for ti in range(5):
		var tx = skull_base.x - 12.0 + float(ti) * 6.0
		draw_line(Vector2(tx, skull_base.y - 25), Vector2(tx, skull_base.y - 19), Color(0.1, 0.08, 0.1, 0.5), 2.0)

	# --- Dense background canopy trees ---
	var bg_trees = [
		Vector2(50, 310), Vector2(180, 290), Vector2(350, 300), Vector2(500, 280),
		Vector2(650, 305), Vector2(800, 275), Vector2(960, 295), Vector2(1100, 285),
		Vector2(120, 320), Vector2(420, 315), Vector2(730, 310), Vector2(1030, 300)
	]
	for bt in bg_trees:
		var trunk_h = 120.0 + sin(bt.x * 0.01) * 30.0
		var canopy_r = 55.0 + cos(bt.x * 0.02) * 15.0
		# Trunk
		draw_line(bt, bt + Vector2(0, -trunk_h), Color(0.15, 0.1, 0.05, 0.7), 5.0)
		# Canopy mass
		var ct = bt + Vector2(0, -trunk_h)
		draw_circle(ct, canopy_r, Color(0.04, 0.18, 0.06, 0.6))
		draw_circle(ct + Vector2(-canopy_r * 0.4, canopy_r * 0.15), canopy_r * 0.7, Color(0.03, 0.15, 0.05, 0.55))
		draw_circle(ct + Vector2(canopy_r * 0.35, canopy_r * 0.1), canopy_r * 0.65, Color(0.05, 0.2, 0.07, 0.5))

	# --- Lost Boys' Treehouse Complex (center-left) ---
	# Main treehouse tree
	var th_base = Vector2(400, 480)
	var th_trunk_top = th_base + Vector2(0, -280)
	draw_line(th_base, th_trunk_top, Color(0.25, 0.16, 0.06), 14.0)
	# Branches
	var branches = [
		[th_base + Vector2(0, -180), Vector2(70, -40)],
		[th_base + Vector2(0, -220), Vector2(-80, -30)],
		[th_base + Vector2(0, -140), Vector2(-60, -50)],
		[th_base + Vector2(0, -250), Vector2(55, -25)]
	]
	for br in branches:
		draw_line(br[0], br[0] + br[1], Color(0.22, 0.14, 0.05), 5.0)

	# Treehouse platform
	var platform_y = th_base.y - 200.0
	draw_rect(Rect2(340, platform_y, 120, 8), Color(0.35, 0.22, 0.08))
	# Treehouse walls
	draw_rect(Rect2(350, platform_y - 55, 100, 55), Color(0.3, 0.2, 0.07, 0.85))
	# Roof (triangle)
	var roof_pts: PackedVector2Array = PackedVector2Array([
		Vector2(345, platform_y - 55), Vector2(400, platform_y - 90), Vector2(455, platform_y - 55)
	])
	draw_colored_polygon(roof_pts, Color(0.2, 0.35, 0.1, 0.9))
	# Window with warm light
	draw_rect(Rect2(375, platform_y - 45, 18, 16), Color(0.9, 0.7, 0.2, 0.6))
	draw_rect(Rect2(410, platform_y - 45, 18, 16), Color(0.9, 0.7, 0.2, 0.5))
	# Hidden door in trunk
	draw_rect(Rect2(391, th_base.y - 130, 18, 30), Color(0.18, 0.12, 0.04))
	var knob_pulse = (sin(_time * 2.2) + 1.0) * 0.5
	draw_circle(Vector2(405, th_base.y - 115), 2.5, Color(0.7, 0.6, 0.2, 0.5 + knob_pulse * 0.3))

	# Ladder from ground to platform
	var ladder_x = 355.0
	for li in range(8):
		var ly = th_base.y - 40.0 - float(li) * 20.0
		draw_line(Vector2(ladder_x, ly), Vector2(ladder_x + 16, ly), Color(0.4, 0.28, 0.1), 2.0)
	draw_line(Vector2(ladder_x, th_base.y - 40), Vector2(ladder_x, platform_y), Color(0.4, 0.28, 0.1), 2.0)
	draw_line(Vector2(ladder_x + 16, th_base.y - 40), Vector2(ladder_x + 16, platform_y), Color(0.4, 0.28, 0.1), 2.0)

	# Second treehouse (right side, smaller)
	var th2_base = Vector2(750, 460)
	draw_line(th2_base, th2_base + Vector2(0, -200), Color(0.22, 0.14, 0.05), 10.0)
	var plat2_y = th2_base.y - 160.0
	draw_rect(Rect2(710, plat2_y, 80, 6), Color(0.32, 0.2, 0.07))
	draw_rect(Rect2(718, plat2_y - 40, 64, 40), Color(0.28, 0.18, 0.06, 0.8))
	draw_rect(Rect2(738, plat2_y - 32, 14, 12), Color(0.85, 0.65, 0.15, 0.5))
	# Hidden door
	draw_rect(Rect2(742, th2_base.y - 100, 16, 26), Color(0.16, 0.1, 0.03))

	# --- Rope bridges between treehouses ---
	var rope_sag = sin(_time * 0.5) * 3.0
	for ri in range(20):
		var rt = float(ri) / 19.0
		var sag = sin(rt * PI) * (18.0 + rope_sag)
		var rp = Vector2(460, platform_y + 4).lerp(Vector2(710, plat2_y + 3), rt) + Vector2(0, sag)
		var rp_next_t = float(ri + 1) / 19.0
		var sag_next = sin(rp_next_t * PI) * (18.0 + rope_sag)
		var rp_next = Vector2(460, platform_y + 4).lerp(Vector2(710, plat2_y + 3), rp_next_t) + Vector2(0, sag_next)
		if ri < 19:
			draw_line(rp, rp_next, Color(0.45, 0.3, 0.1, 0.8), 2.0)
	# Rope rails
	for ri in range(20):
		var rt = float(ri) / 19.0
		var sag_top = sin(rt * PI) * (10.0 + rope_sag * 0.5)
		var rp_top = Vector2(460, platform_y - 15).lerp(Vector2(710, plat2_y - 15), rt) + Vector2(0, sag_top)
		var rp_top_next_t = float(ri + 1) / 19.0
		var sag_top_next = sin(rp_top_next_t * PI) * (10.0 + rope_sag * 0.5)
		var rp_top_next = Vector2(460, platform_y - 15).lerp(Vector2(710, plat2_y - 15), rp_top_next_t) + Vector2(0, sag_top_next)
		if ri < 19:
			draw_line(rp_top, rp_top_next, Color(0.45, 0.3, 0.1, 0.5), 1.5)

	# --- Fairy lanterns strung between trees ---
	var lantern_anchors = [
		[Vector2(180, 250), Vector2(350, 230)],
		[Vector2(500, 210), Vector2(650, 240)],
		[Vector2(800, 225), Vector2(960, 250)],
	]
	for la in lantern_anchors:
		for li in range(6):
			var lt = (float(li) + 0.5) / 6.0
			var lsag = sin(lt * PI) * 15.0
			var lp = la[0].lerp(la[1], lt) + Vector2(0, lsag)
			var lbob = sin(_time * 1.5 + float(li) * 0.8) * 2.0
			lp.y += lbob
			var lpulse = (sin(_time * 2.5 + float(li) * 1.1) + 1.0) * 0.5
			# Lantern body
			draw_circle(lp, 3.0, Color(1.0, 0.85, 0.2, 0.4 + lpulse * 0.3))
			# Glow
			draw_circle(lp, 10.0 + lpulse * 4.0, Color(1.0, 0.9, 0.3, 0.04 + lpulse * 0.03))

	# --- Pirate torchlight visible through trees (background right) ---
	var torch_positions = [Vector2(1050, 350), Vector2(1120, 380), Vector2(1000, 400)]
	for tp in torch_positions:
		var tflicker = (sin(_time * 4.0 + tp.x * 0.05) + 1.0) * 0.5
		draw_circle(tp, 5.0 + tflicker * 2.0, Color(1.0, 0.55, 0.1, 0.3 + tflicker * 0.2))
		draw_circle(tp, 18.0 + tflicker * 6.0, Color(1.0, 0.4, 0.05, 0.04 + tflicker * 0.03))
		# Torch stick
		draw_line(tp, tp + Vector2(0, 20), Color(0.3, 0.18, 0.05), 2.5)

	# --- Captain Hook's shadow looming (far left) ---
	var hook_shadow_base = Vector2(80, 380)
	var shadow_sway = sin(_time * 0.4) * 5.0
	# Tall menacing silhouette
	var hook_body: PackedVector2Array = PackedVector2Array([
		hook_shadow_base + Vector2(-15 + shadow_sway, 0),
		hook_shadow_base + Vector2(-20 + shadow_sway * 1.2, -60),
		hook_shadow_base + Vector2(-12 + shadow_sway * 1.4, -100),
		hook_shadow_base + Vector2(0 + shadow_sway * 1.5, -130),
		hook_shadow_base + Vector2(12 + shadow_sway * 1.4, -100),
		hook_shadow_base + Vector2(20 + shadow_sway * 1.2, -60),
		hook_shadow_base + Vector2(15 + shadow_sway, 0)
	])
	draw_colored_polygon(hook_body, Color(0.02, 0.02, 0.03, 0.6))
	# Hat silhouette
	var hat_center = hook_shadow_base + Vector2(shadow_sway * 1.5, -130)
	var hat_pts: PackedVector2Array = PackedVector2Array([
		hat_center + Vector2(-25, 0), hat_center + Vector2(-8, -25),
		hat_center + Vector2(8, -25), hat_center + Vector2(25, 0)
	])
	draw_colored_polygon(hat_pts, Color(0.02, 0.02, 0.03, 0.6))
	# Hook arm extending
	var hook_arm_end = hook_shadow_base + Vector2(35 + shadow_sway * 1.3, -80)
	draw_line(hook_shadow_base + Vector2(18 + shadow_sway * 1.3, -70), hook_arm_end, Color(0.02, 0.02, 0.03, 0.5), 3.0)
	# The hook curve
	var hook_tip = hook_arm_end + Vector2(8, 10)
	draw_line(hook_arm_end, hook_arm_end + Vector2(5, -8), Color(0.3, 0.3, 0.35, 0.5), 2.0)
	draw_line(hook_arm_end + Vector2(5, -8), hook_tip, Color(0.3, 0.3, 0.35, 0.5), 2.0)

	# === GROUND — Dense jungle floor ===
	var ground_y = 500.0
	# Ground gradient layers
	for gi in range(8):
		var gy = ground_y + float(gi) * 16.0
		var gt = float(gi) / 7.0
		var gc = ground_color.lerp(Color(0.05, 0.12, 0.04), gt * 0.5)
		draw_rect(Rect2(0, gy, 1280, 18), gc)

	# Leaf litter / undergrowth
	for ui in range(30):
		var ux = float(ui) * 44.0 + sin(float(ui) * 2.3) * 15.0
		var uy = ground_y - 5.0 + sin(float(ui) * 1.7) * 8.0
		var u_sway = sin(_time * 0.6 + float(ui) * 0.5) * 3.0
		var uh = 12.0 + sin(float(ui) * 3.1) * 6.0
		# Fern fronds
		draw_line(Vector2(ux + u_sway, uy), Vector2(ux - 6 + u_sway, uy - uh), Color(0.08, 0.25, 0.06, 0.6), 1.5)
		draw_line(Vector2(ux + u_sway, uy), Vector2(ux + 6 + u_sway, uy - uh * 0.8), Color(0.06, 0.22, 0.05, 0.5), 1.5)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var mh = dec["extra"]
				draw_line(mp, mp + Vector2(0, -ms * 1.5), Color(0.85, 0.82, 0.7), ms * 0.4)
				var cap_col = Color(0.8, 0.2, 0.15, 0.7) if mh < 0.33 else (Color(0.7, 0.5, 0.15, 0.7) if mh < 0.66 else Color(0.6, 0.2, 0.6, 0.7))
				draw_circle(mp + Vector2(0, -ms * 1.5), ms, cap_col)
				draw_circle(mp + Vector2(-ms * 0.3, -ms * 1.7), ms * 0.2, Color(1, 1, 1, 0.5))
			"jungle_tree":
				var tp = dec["pos"]
				var cr = dec["size"]
				var sh = dec["extra"]
				var th = cr * 0.8
				draw_line(tp, tp + Vector2(0, -th), Color(0.3 + sh, 0.2 + sh, 0.08), 3.0 + cr * 0.1)
				draw_circle(tp + Vector2(0, -th), cr, Color(0.1 + sh, 0.35 + sh, 0.08 + sh * 0.5, 0.55))
				draw_circle(tp + Vector2(-cr * 0.4, -th + cr * 0.2), cr * 0.6, Color(0.12 + sh, 0.37 + sh, 0.1, 0.5))
			"fairy":
				var fp = dec["pos"]
				var fo = dec["extra"]
				var drift = Vector2(sin(_time * 1.2 + fo) * 8.0, cos(_time * 0.9 + fo) * 5.0)
				var pulse = (sin(_time * 3.0 + fo) + 1.0) * 0.5
				draw_circle(fp + drift, 1.5 + pulse, Color(1.0, 0.92, 0.3, 0.5 + pulse * 0.3))
				draw_circle(fp + drift, 4.0 + pulse * 2.0, Color(1.0, 0.9, 0.3, 0.08 + pulse * 0.06))
			"star":
				var twinkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				var alpha = dec["size"] * (0.4 + twinkle * 0.6)
				draw_circle(dec["pos"], 1.0 + twinkle * 0.8, Color(1.0, 0.97, 0.8, alpha))

	# === FOREGROUND — Dense canopy overlay at top ===
	# Foreground canopy leaves draping down
	for fi in range(14):
		var fx = float(fi) * 95.0 + sin(float(fi) * 1.9) * 20.0
		var fy = 50.0 + sin(float(fi) * 2.7) * 15.0
		var f_sway = sin(_time * 0.35 + float(fi) * 0.7) * 4.0
		var leaf_len = 40.0 + sin(float(fi) * 1.3) * 15.0
		# Hanging vine
		draw_line(Vector2(fx + f_sway, fy), Vector2(fx + f_sway * 1.5, fy + leaf_len), Color(0.05, 0.2, 0.04, 0.5), 2.0)
		# Leaf cluster
		draw_circle(Vector2(fx + f_sway * 1.2, fy + leaf_len * 0.5), 18.0, Color(0.03, 0.14, 0.03, 0.4))
		draw_circle(Vector2(fx + f_sway * 0.8, fy + leaf_len * 0.3), 14.0, Color(0.04, 0.17, 0.05, 0.35))

	# Bottom foreground — thick underbrush
	for bi in range(20):
		var bx = float(bi) * 66.0 + sin(float(bi) * 3.3) * 10.0
		var by = 600.0 + sin(float(bi) * 1.5) * 15.0
		var b_sway = sin(_time * 0.4 + float(bi) * 0.6) * 3.0
		draw_circle(Vector2(bx + b_sway, by), 20.0 + sin(float(bi) * 2.1) * 8.0, Color(0.03, 0.12, 0.03, 0.5))

	# Foreground vines from top corners
	for vi in range(8):
		var vt = float(vi) / 7.0
		var vine_sway = sin(_time * 0.3 + vt * 2.0) * 6.0
		var v_left = Vector2(vine_sway, 50.0 + vt * 80.0)
		var v_right = Vector2(1280.0 + vine_sway, 50.0 + vt * 70.0)
		draw_circle(v_left, 10.0, Color(0.03, 0.15, 0.04, 0.25 - vt * 0.02))
		draw_circle(v_right, 10.0, Color(0.03, 0.15, 0.04, 0.25 - vt * 0.02))

	# Firefly particles in foreground
	for ffi in range(10):
		var ff_phase = float(ffi) * 1.7 + _time * 0.8
		var ffx = fmod(absf(sin(ff_phase * 0.3)) * 1280.0, 1280.0)
		var ffy = 400.0 + sin(ff_phase * 0.5) * 150.0
		var ff_drift = Vector2(sin(_time * 0.7 + float(ffi)) * 12.0, cos(_time * 0.5 + float(ffi)) * 8.0)
		var ff_bright = clampf((sin(_time * 3.5 + float(ffi) * 2.1) + 1.0) * 0.5, 0.0, 1.0)
		draw_circle(Vector2(ffx, ffy) + ff_drift, 1.5, Color(0.5, 1.0, 0.3, ff_bright * 0.5))
		draw_circle(Vector2(ffx, ffy) + ff_drift, 5.0, Color(0.4, 0.9, 0.2, ff_bright * 0.06))
	_draw_peter_novel(2)
	_draw_shadow_author_effects()


func _draw_peter_ch3(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — Sunset battle colors (orange/red/purple) ===
	for i in range(32):
		var t = float(i) / 31.0
		var col: Color
		if t < 0.3:
			col = sky_color.lerp(Color(0.85, 0.35, 0.08), t / 0.3)
		elif t < 0.6:
			var t2 = (t - 0.3) / 0.3
			col = Color(0.85, 0.35, 0.08).lerp(Color(0.65, 0.12, 0.15), t2)
		else:
			var t3 = (t - 0.6) / 0.4
			col = Color(0.65, 0.12, 0.15).lerp(Color(0.2, 0.05, 0.25), t3)
		var y0 = int(t * 578.0) + 50
		var y1 = int((t + 1.0 / 31.0) * 578.0) + 50
		draw_rect(Rect2(0, y0, 1280, y1 - y0 + 1), col)

	# === STARS / ATMOSPHERE — Battle-torn sunset sky ===
	# Dramatic cloud streaks
	for ci in range(8):
		var cx = float(ci) * 170.0 + sin(float(ci) * 2.1) * 40.0
		var cy = 70.0 + sin(float(ci) * 1.5) * 25.0
		var cw = 120.0 + sin(float(ci) * 3.2) * 40.0
		var cloud_drift = sin(_time * 0.1 + float(ci) * 0.8) * 10.0
		draw_rect(Rect2(cx + cloud_drift, cy, cw, 8), Color(0.95, 0.5, 0.15, 0.12))
		draw_rect(Rect2(cx + cloud_drift + 10, cy + 10, cw * 0.7, 5), Color(0.9, 0.3, 0.1, 0.08))

	# Sun on horizon (low, half-sunk)
	var sun_pos = Vector2(200, 170)
	draw_circle(sun_pos, 55.0, Color(1.0, 0.6, 0.1, 0.08))
	draw_circle(sun_pos, 35.0, Color(1.0, 0.5, 0.05, 0.15))
	draw_circle(sun_pos, 18.0, Color(1.0, 0.75, 0.2, 0.3))

	# Smoke / cannon haze
	for si in range(6):
		var sx = 300.0 + float(si) * 160.0
		var sy = 120.0 + sin(float(si) * 2.5) * 40.0
		var s_drift = sin(_time * 0.2 + float(si)) * 20.0
		var s_rise = -_time * 3.0 + float(si) * 50.0
		var sfy = sy + fmod(s_rise, 100.0) - 50.0
		draw_circle(Vector2(sx + s_drift, sfy), 25.0 + sin(float(si) * 1.8) * 10.0, Color(0.3, 0.25, 0.2, 0.06))

	# === LANDMARKS ===

	# --- Dark water below ship ---
	var water_y = 480.0
	for wi in range(10):
		var wy = water_y + float(wi) * 15.0
		var wt = float(wi) / 9.0
		var wc = Color(0.02, 0.05, 0.15).lerp(Color(0.01, 0.02, 0.08), wt)
		draw_rect(Rect2(0, wy, 1280, 17), wc)
	# Wave details
	for wvi in range(25):
		var wx = float(wvi) * 52.0
		var wy_off = sin(_time * 0.8 + float(wvi) * 0.6) * 3.0
		var wave_x2 = wx + 30.0 + sin(float(wvi) * 1.2) * 10.0
		draw_line(Vector2(wx, water_y + 5.0 + wy_off), Vector2(wave_x2, water_y + 5.0 + wy_off + sin(_time * 0.9 + float(wvi)) * 2.0), Color(0.15, 0.2, 0.35, 0.15), 1.5)

	# --- Ship hull ---
	var hull_pts: PackedVector2Array = PackedVector2Array([
		Vector2(100, water_y), Vector2(50, water_y - 40),
		Vector2(80, water_y - 80), Vector2(200, water_y - 110),
		Vector2(1080, water_y - 110), Vector2(1200, water_y - 80),
		Vector2(1230, water_y - 40), Vector2(1180, water_y)
	])
	draw_colored_polygon(hull_pts, Color(0.22, 0.12, 0.04))
	# Hull wood planking
	for hi in range(6):
		var hy = water_y - 20.0 - float(hi) * 15.0
		draw_line(Vector2(90, hy), Vector2(1190, hy), Color(0.18, 0.1, 0.03, 0.4), 1.0)

	# --- Cannon ports ---
	var cannon_ys = [water_y - 45.0, water_y - 70.0]
	for cy in cannon_ys:
		for ci in range(7):
			var cx = 180.0 + float(ci) * 130.0
			# Port hole
			draw_rect(Rect2(cx - 10, cy - 8, 20, 16), Color(0.08, 0.04, 0.02))
			# Cannon barrel poking out
			draw_rect(Rect2(cx - 4, cy - 3, 18, 6), Color(0.15, 0.15, 0.15, 0.8))
			# Flash on one random cannon
			if ci == 3 and cy == cannon_ys[0]:
				var flash = clampf(sin(_time * 5.0), 0.0, 1.0)
				if flash > 0.8:
					draw_circle(Vector2(cx + 16, cy), 8.0, Color(1.0, 0.8, 0.2, 0.4))

	# --- Ship deck (main play area) ---
	var deck_y = water_y - 110.0
	draw_rect(Rect2(140, deck_y, 1000, 12), Color(0.3, 0.18, 0.06))
	# Deck planks
	for di in range(22):
		var dx = 150.0 + float(di) * 48.0
		draw_line(Vector2(dx, deck_y), Vector2(dx, deck_y + 12), Color(0.2, 0.12, 0.04, 0.5), 1.0)

	# Deck railing
	draw_line(Vector2(140, deck_y - 35), Vector2(1140, deck_y - 35), Color(0.25, 0.15, 0.05), 3.0)
	for ri in range(18):
		var rx = 155.0 + float(ri) * 56.0
		draw_line(Vector2(rx, deck_y), Vector2(rx, deck_y - 35), Color(0.25, 0.15, 0.05), 2.0)

	# --- Masts and rigging ---
	# Main mast (center)
	var mast1_x = 640.0
	draw_line(Vector2(mast1_x, deck_y), Vector2(mast1_x, 60), Color(0.28, 0.16, 0.05), 8.0)
	# Crow's nest
	draw_rect(Rect2(mast1_x - 18, 75, 36, 10), Color(0.25, 0.14, 0.04))
	draw_line(Vector2(mast1_x - 18, 75), Vector2(mast1_x - 12, 85), Color(0.25, 0.14, 0.04), 2.0)
	draw_line(Vector2(mast1_x + 18, 75), Vector2(mast1_x + 12, 85), Color(0.25, 0.14, 0.04), 2.0)
	# Cross beam
	draw_line(Vector2(mast1_x - 80, 120), Vector2(mast1_x + 80, 120), Color(0.28, 0.16, 0.05), 5.0)
	draw_line(Vector2(mast1_x - 60, 190), Vector2(mast1_x + 60, 190), Color(0.28, 0.16, 0.05), 4.0)
	# Sail (partially furled)
	var sail1_pts: PackedVector2Array = PackedVector2Array([
		Vector2(mast1_x - 75, 122), Vector2(mast1_x + 75, 122),
		Vector2(mast1_x + 55, 185), Vector2(mast1_x - 55, 185)
	])
	var sail_billow = sin(_time * 0.4) * 5.0
	draw_colored_polygon(sail1_pts, Color(0.85, 0.8, 0.7, 0.6))
	# Sail tear/battle damage
	draw_line(Vector2(mast1_x - 20, 140), Vector2(mast1_x + 5, 170), Color(0.4, 0.2, 0.1, 0.3), 2.0)

	# Fore mast
	var mast2_x = 340.0
	draw_line(Vector2(mast2_x, deck_y), Vector2(mast2_x, 100), Color(0.28, 0.16, 0.05), 6.0)
	draw_line(Vector2(mast2_x - 55, 140), Vector2(mast2_x + 55, 140), Color(0.28, 0.16, 0.05), 4.0)
	var sail2_pts: PackedVector2Array = PackedVector2Array([
		Vector2(mast2_x - 50, 142), Vector2(mast2_x + 50, 142),
		Vector2(mast2_x + 40, 210), Vector2(mast2_x - 40, 210)
	])
	draw_colored_polygon(sail2_pts, Color(0.82, 0.77, 0.68, 0.55))

	# Rear mast
	var mast3_x = 940.0
	draw_line(Vector2(mast3_x, deck_y), Vector2(mast3_x, 120), Color(0.28, 0.16, 0.05), 6.0)
	draw_line(Vector2(mast3_x - 50, 160), Vector2(mast3_x + 50, 160), Color(0.28, 0.16, 0.05), 4.0)

	# --- Rigging ropes (mast to mast, mast to hull) ---
	var rigging_lines = [
		[Vector2(mast1_x, 70), Vector2(mast2_x, 105)],
		[Vector2(mast1_x, 70), Vector2(mast3_x, 125)],
		[Vector2(mast2_x, 105), Vector2(140, deck_y - 30)],
		[Vector2(mast3_x, 125), Vector2(1140, deck_y - 30)],
		[Vector2(mast1_x, 120), Vector2(140, deck_y - 20)],
		[Vector2(mast1_x, 120), Vector2(1140, deck_y - 20)],
	]
	for rl in rigging_lines:
		draw_line(rl[0], rl[1], Color(0.2, 0.15, 0.08, 0.4), 1.0)

	# Rope nets on sides
	for ni in range(6):
		for nj in range(4):
			var nx = 160.0 + float(ni) * 15.0
			var ny = deck_y - 30.0 + float(nj) * 12.0
			draw_line(Vector2(nx, ny), Vector2(nx + 15, ny), Color(0.3, 0.2, 0.1, 0.25), 1.0)
			draw_line(Vector2(nx, ny), Vector2(nx, ny + 12), Color(0.3, 0.2, 0.1, 0.25), 1.0)

	# --- Skull-and-crossbones flag (on main mast, flapping) ---
	var flag_base = Vector2(mast1_x, 62)
	var flag_w = 45.0
	var flag_h = 30.0
	var flag_pts: PackedVector2Array = PackedVector2Array()
	for fi in range(10):
		var fx = flag_base.x + float(fi) / 9.0 * flag_w
		var fy_top = flag_base.y + sin(_time * 3.0 + float(fi) * 0.5) * 3.0
		flag_pts.append(Vector2(fx, fy_top))
	for fi in range(9, -1, -1):
		var fx = flag_base.x + float(fi) / 9.0 * flag_w
		var fy_bot = flag_base.y + flag_h + sin(_time * 3.0 + float(fi) * 0.5 + 0.5) * 3.0
		flag_pts.append(Vector2(fx, fy_bot))
	draw_colored_polygon(flag_pts, Color(0.05, 0.05, 0.05, 0.9))
	# Skull on flag
	var flag_center = flag_base + Vector2(flag_w * 0.5, flag_h * 0.45)
	var fc_wave = sin(_time * 3.0 + 2.0) * 2.0
	draw_circle(flag_center + Vector2(fc_wave, 0), 7.0, Color(0.9, 0.85, 0.8, 0.7))
	draw_circle(flag_center + Vector2(-3 + fc_wave, -1), 1.5, Color(0.05, 0.05, 0.05, 0.7))
	draw_circle(flag_center + Vector2(3 + fc_wave, -1), 1.5, Color(0.05, 0.05, 0.05, 0.7))
	# Crossbones
	draw_line(flag_center + Vector2(-8 + fc_wave, 5), flag_center + Vector2(8 + fc_wave, 11), Color(0.9, 0.85, 0.8, 0.6), 1.5)
	draw_line(flag_center + Vector2(8 + fc_wave, 5), flag_center + Vector2(-8 + fc_wave, 11), Color(0.9, 0.85, 0.8, 0.6), 1.5)

	# --- Plank extending over water (right side) ---
	var plank_start = Vector2(1100, deck_y + 5)
	var plank_end = Vector2(1250, deck_y + 15)
	var plank_bob = sin(_time * 1.2) * 2.0
	draw_line(plank_start, plank_end + Vector2(0, plank_bob), Color(0.35, 0.22, 0.08), 8.0)
	# Plank wood grain
	draw_line(plank_start + Vector2(0, -2), plank_end + Vector2(0, -2 + plank_bob), Color(0.28, 0.18, 0.06, 0.5), 1.0)
	draw_line(plank_start + Vector2(0, 2), plank_end + Vector2(0, 2 + plank_bob), Color(0.28, 0.18, 0.06, 0.5), 1.0)

	# --- Ticking crocodile below (in water under plank) ---
	var croc_base = Vector2(1200, water_y + 20)
	var croc_bob = sin(_time * 0.7) * 4.0
	var croc_y = croc_base.y + croc_bob
	# Body
	var croc_body: PackedVector2Array = PackedVector2Array([
		Vector2(croc_base.x - 40, croc_y - 5),
		Vector2(croc_base.x - 30, croc_y - 12),
		Vector2(croc_base.x, croc_y - 14),
		Vector2(croc_base.x + 25, croc_y - 10),
		Vector2(croc_base.x + 40, croc_y - 5),
		Vector2(croc_base.x + 35, croc_y + 3),
		Vector2(croc_base.x, croc_y + 6),
		Vector2(croc_base.x - 35, croc_y + 3)
	])
	draw_colored_polygon(croc_body, Color(0.15, 0.3, 0.1, 0.7))
	# Snout
	draw_line(Vector2(croc_base.x + 35, croc_y - 3), Vector2(croc_base.x + 55, croc_y - 1), Color(0.15, 0.3, 0.1, 0.7), 6.0)
	# Eye
	draw_circle(Vector2(croc_base.x + 20, croc_y - 11), 3.0, Color(0.9, 0.8, 0.1, 0.7))
	draw_circle(Vector2(croc_base.x + 20, croc_y - 11), 1.2, Color(0.1, 0.1, 0.05, 0.8))
	# Teeth
	for ti in range(4):
		var tx = croc_base.x + 38.0 + float(ti) * 5.0
		draw_line(Vector2(tx, croc_y - 3), Vector2(tx, croc_y + 1), Color(0.9, 0.9, 0.8, 0.5), 1.0)
	# Clock visible in water (the ticking clock!)
	var clock_pos = Vector2(croc_base.x - 10, croc_y + 25)
	var clock_pulse = (sin(_time * 6.28) + 1.0) * 0.5  # Ticking once per second
	draw_circle(clock_pos, 12.0, Color(0.7, 0.6, 0.3, 0.15 + clock_pulse * 0.1))
	draw_circle(clock_pos, 10.0, Color(0.85, 0.8, 0.6, 0.2 + clock_pulse * 0.1))
	# Clock hands
	var minute_angle = _time * 0.5
	var hour_angle = _time * 0.04
	draw_line(clock_pos, clock_pos + Vector2(sin(minute_angle) * 7.0, -cos(minute_angle) * 7.0), Color(0.2, 0.15, 0.05, 0.3), 1.0)
	draw_line(clock_pos, clock_pos + Vector2(sin(hour_angle) * 5.0, -cos(hour_angle) * 5.0), Color(0.2, 0.15, 0.05, 0.3), 1.5)
	# Tick-tock ripple
	draw_arc(clock_pos, 14.0 + clock_pulse * 3.0, 0, TAU, 24, Color(0.5, 0.5, 0.4, 0.06 + clock_pulse * 0.04), 1.0)

	# --- Treasure chests on deck ---
	var chest_positions = [Vector2(250, deck_y - 5), Vector2(850, deck_y - 5), Vector2(550, deck_y - 5)]
	for chi in range(chest_positions.size()):
		var cp = chest_positions[chi]
		# Chest body
		draw_rect(Rect2(cp.x - 12, cp.y - 14, 24, 14), Color(0.35, 0.2, 0.05))
		# Chest lid (slightly open on middle one)
		var lid_open = 0.0
		if chi == 2:
			lid_open = 3.0
			# Gold glow
			var g_pulse = (sin(_time * 2.0 + 1.0) + 1.0) * 0.5
			draw_circle(cp + Vector2(0, -16), 8.0, Color(1.0, 0.85, 0.2, 0.08 + g_pulse * 0.06))
		draw_rect(Rect2(cp.x - 13, cp.y - 18 - lid_open, 26, 6), Color(0.4, 0.25, 0.08))
		# Lock / clasp
		draw_circle(cp + Vector2(0, -12), 2.0, Color(0.7, 0.6, 0.15, 0.6))
		# Metal bands
		draw_line(Vector2(cp.x - 12, cp.y - 7), Vector2(cp.x + 12, cp.y - 7), Color(0.5, 0.4, 0.1, 0.4), 1.0)

	# === GROUND — Wooden ship deck (lower portion) ===
	for gi in range(6):
		var gy = water_y + float(gi) * 25.0
		var gt = float(gi) / 5.0
		var gc = Color(0.02, 0.04, 0.12).lerp(Color(0.01, 0.02, 0.06), gt)
		draw_rect(Rect2(0, gy, 1280, 27), gc)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var mh = dec["extra"]
				draw_line(mp, mp + Vector2(0, -ms * 1.5), Color(0.85, 0.82, 0.7), ms * 0.4)
				var cap_col = Color(0.8, 0.2, 0.15, 0.7) if mh < 0.33 else (Color(0.7, 0.5, 0.15, 0.7) if mh < 0.66 else Color(0.6, 0.2, 0.6, 0.7))
				draw_circle(mp + Vector2(0, -ms * 1.5), ms, cap_col)
				draw_circle(mp + Vector2(-ms * 0.3, -ms * 1.7), ms * 0.2, Color(1, 1, 1, 0.5))
			"jungle_tree":
				var tp = dec["pos"]
				var cr = dec["size"]
				var sh = dec["extra"]
				var th = cr * 0.8
				draw_line(tp, tp + Vector2(0, -th), Color(0.3 + sh, 0.2 + sh, 0.08), 3.0 + cr * 0.1)
				draw_circle(tp + Vector2(0, -th), cr, Color(0.1 + sh, 0.35 + sh, 0.08 + sh * 0.5, 0.55))
				draw_circle(tp + Vector2(-cr * 0.4, -th + cr * 0.2), cr * 0.6, Color(0.12 + sh, 0.37 + sh, 0.1, 0.5))
			"fairy":
				var fp = dec["pos"]
				var fo = dec["extra"]
				var drift = Vector2(sin(_time * 1.2 + fo) * 8.0, cos(_time * 0.9 + fo) * 5.0)
				var pulse = (sin(_time * 3.0 + fo) + 1.0) * 0.5
				draw_circle(fp + drift, 1.5 + pulse, Color(1.0, 0.92, 0.3, 0.5 + pulse * 0.3))
				draw_circle(fp + drift, 4.0 + pulse * 2.0, Color(1.0, 0.9, 0.3, 0.08 + pulse * 0.06))
			"star":
				var twinkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				var alpha = dec["size"] * (0.4 + twinkle * 0.6)
				draw_circle(dec["pos"], 1.0 + twinkle * 0.8, Color(1.0, 0.97, 0.8, alpha))

	# === FOREGROUND ===
	# Rope and rigging in foreground (parallax feel)
	for fi in range(5):
		var rope_x = 50.0 + float(fi) * 300.0
		var rope_sway = sin(_time * 0.5 + float(fi) * 1.2) * 8.0
		draw_line(Vector2(rope_x + rope_sway, 50), Vector2(rope_x + rope_sway * 0.3, deck_y), Color(0.2, 0.14, 0.06, 0.15), 2.0)

	# Cannon smoke puffs drifting across foreground
	for si in range(4):
		var smoke_phase = _time * 0.3 + float(si) * 1.5
		var smoke_x = fmod(absf(smoke_phase) * 80.0, 1400.0) - 60.0
		var smoke_y = 200.0 + float(si) * 80.0 + sin(smoke_phase) * 20.0
		var smoke_alpha = 0.04 + sin(smoke_phase * 0.5) * 0.02
		smoke_alpha = clampf(smoke_alpha, 0.0, 0.1)
		draw_circle(Vector2(smoke_x, smoke_y), 35.0 + sin(float(si) * 2.1) * 10.0, Color(0.4, 0.35, 0.3, smoke_alpha))
		draw_circle(Vector2(smoke_x + 20, smoke_y - 10), 25.0, Color(0.45, 0.4, 0.35, smoke_alpha * 0.7))

	# Water splashes at hull line
	for wi in range(12):
		var wx = 100.0 + float(wi) * 95.0
		var splash_t = sin(_time * 1.5 + float(wi) * 0.9)
		if splash_t > 0.5:
			var splash_h = (splash_t - 0.5) * 8.0
			draw_circle(Vector2(wx, water_y - splash_h), 2.5, Color(0.4, 0.5, 0.7, 0.2))

	# Dark vignette at edges for dramatic battle atmosphere
	for vi in range(10):
		var v_alpha = 0.03 * float(10 - vi)
		# Left edge
		draw_rect(Rect2(0, 50, float(vi) * 8, 578), Color(0.02, 0.01, 0.03, v_alpha))
		# Right edge
		draw_rect(Rect2(1280.0 - float(vi) * 8.0, 50, float(vi) * 8, 578), Color(0.02, 0.01, 0.03, v_alpha))

	# Sparks from battle (foreground particles)
	for spi in range(6):
		var sp_phase = _time * 2.0 + float(spi) * 1.1
		var sp_x = 300.0 + float(spi) * 130.0 + sin(sp_phase * 0.7) * 50.0
		var sp_y = 150.0 + fmod(absf(sp_phase * 40.0), 300.0)
		var sp_bright = clampf(1.0 - fmod(absf(sp_phase * 40.0), 300.0) / 300.0, 0.0, 1.0)
		draw_circle(Vector2(sp_x, sp_y), 1.0, Color(1.0, 0.7, 0.2, sp_bright * 0.4))
	_draw_peter_novel(3)
	_draw_shadow_author_effects()

func _draw_phantom_ch2(sky_color: Color, ground_color: Color) -> void:
	# === CEILING / SKY — Dark underground brick tunnel ceiling ===
	for y_strip in range(0, 300, 4):
		var t = float(y_strip) / 300.0
		var ceiling_col = sky_color.lerp(Color(0.06, 0.04, 0.08, 1.0), t)
		# Subtle moisture shimmer on ceiling
		var moisture = sin(_time * 0.8 + float(y_strip) * 0.05) * 0.015
		ceiling_col = ceiling_col.lerp(Color(0.15, 0.18, 0.25), clampf(moisture, 0.0, 1.0))
		draw_rect(Rect2(0, 50 + y_strip, 1280, 4), ceiling_col)

	# === CEILING BRICKWORK — visible arched tunnel ceiling ===
	for bx in range(0, 1280, 48):
		for by in range(0, 5):
			var offset_x = 24.0 if by % 2 == 1 else 0.0
			var brick_y = 52.0 + float(by) * 18.0
			var brick_alpha = 0.12 - float(by) * 0.02
			draw_rect(Rect2(float(bx) + offset_x, brick_y, 46, 16), Color(0.25, 0.15, 0.1, brick_alpha))
			draw_line(Vector2(float(bx) + offset_x, brick_y), Vector2(float(bx) + offset_x + 46.0, brick_y), Color(0.1, 0.06, 0.04, brick_alpha * 0.7), 0.5)

	# === WATER DRIPPING FROM CEILING — animated droplets ===
	for i in range(18):
		var drip_x = 70.0 + float(i) * 68.0
		var drip_phase = fmod(_time * 0.7 + float(i) * 2.3, 3.0)
		var drip_start_y = 55.0 + sin(float(i) * 1.1) * 15.0
		if drip_phase < 2.0:
			# Droplet falling
			var drip_y = drip_start_y + drip_phase * 120.0
			var drop_alpha = 0.4 - drip_phase * 0.15
			draw_circle(Vector2(drip_x, drip_y), 1.5, Color(0.3, 0.4, 0.6, clampf(drop_alpha, 0.0, 1.0)))
			# Tiny trail
			draw_line(Vector2(drip_x, drip_y - 4.0), Vector2(drip_x, drip_y), Color(0.3, 0.4, 0.6, clampf(drop_alpha * 0.5, 0.0, 1.0)), 0.8)
		else:
			# Splash ripple at bottom
			var splash_t = (drip_phase - 2.0) * 3.0
			var splash_y = drip_start_y + 240.0
			var ripple_r = splash_t * 8.0
			draw_arc(Vector2(drip_x, splash_y), ripple_r, 0.0, TAU, 12, Color(0.3, 0.4, 0.6, clampf(0.3 - splash_t * 0.3, 0.0, 1.0)), 0.5)
		# Gathering droplet on ceiling
		var gather = sin(_time * 1.2 + float(i) * 3.0) * 0.3 + 0.5
		draw_circle(Vector2(drip_x, drip_start_y), 1.0 + gather, Color(0.3, 0.45, 0.65, 0.2))

	# === ATMOSPHERE — Underground haze and candlelight glow ===
	for i in range(8):
		var haze_x = 160.0 * float(i) + sin(_time * 0.15 + float(i)) * 30.0
		var haze_y = 250.0 + cos(_time * 0.2 + float(i) * 0.7) * 40.0
		draw_circle(Vector2(haze_x, haze_y), 90.0, Color(0.2, 0.15, 0.1, 0.025))
		draw_circle(Vector2(haze_x, haze_y), 55.0, Color(1.0, 0.7, 0.2, 0.015))

	# Candlelight pools on walls — flickering warm light
	for i in range(10):
		var cx = 60.0 + float(i) * 128.0
		var cy = 180.0 + sin(float(i) * 2.5) * 30.0
		var flicker = sin(_time * 4.5 + float(i) * 1.9) * 0.1 + 0.5
		draw_circle(Vector2(cx, cy), 45.0, Color(1.0, 0.65, 0.15, 0.02 * flicker))
		# Candle on wall sconce
		draw_line(Vector2(cx, cy + 10.0), Vector2(cx, cy - 8.0), Color(0.8, 0.75, 0.6, 0.35), 2.5)
		draw_circle(Vector2(cx, cy - 10.0), 2.5 + flicker * 2.0, Color(1.0, 0.8, 0.2, 0.5 + flicker * 0.3))
		draw_circle(Vector2(cx, cy - 10.0), 8.0, Color(1.0, 0.6, 0.1, 0.06))

	# === LANDMARKS ===
	# --- Descending stone stairs (left side) ---
	for step in range(8):
		var sx = 30.0 + float(step) * 22.0
		var sy = 350.0 + float(step) * 20.0
		var step_w = 24.0
		var step_h = 18.0
		draw_rect(Rect2(sx, sy, step_w, step_h), Color(0.22, 0.18, 0.16, 0.55))
		draw_line(Vector2(sx, sy), Vector2(sx + step_w, sy), Color(0.35, 0.3, 0.25, 0.4), 1.0)
		# Step shadow
		draw_rect(Rect2(sx, sy + step_h - 3.0, step_w, 3.0), Color(0.05, 0.03, 0.02, 0.3))

	# --- Iron gates (two locations) ---
	for gi in range(2):
		var gate_x = 320.0 + float(gi) * 600.0
		var gate_top = 140.0
		var gate_bot = 380.0
		# Gate frame
		draw_rect(Rect2(gate_x - 2, gate_top, 4, gate_bot - gate_top), Color(0.2, 0.18, 0.15, 0.5))
		draw_rect(Rect2(gate_x + 40, gate_top, 4, gate_bot - gate_top), Color(0.2, 0.18, 0.15, 0.5))
		draw_line(Vector2(gate_x, gate_top), Vector2(gate_x + 44, gate_top), Color(0.25, 0.2, 0.18, 0.5), 3.0)
		# Vertical bars
		for bar in range(5):
			var bar_x = gate_x + 6.0 + float(bar) * 8.0
			draw_line(Vector2(bar_x, gate_top + 4.0), Vector2(bar_x, gate_bot), Color(0.3, 0.25, 0.2, 0.4), 1.5)
		# Horizontal crossbar
		var mid_y = (gate_top + gate_bot) * 0.5
		draw_line(Vector2(gate_x + 2, mid_y), Vector2(gate_x + 42, mid_y), Color(0.3, 0.25, 0.2, 0.35), 1.5)

	# --- Mirror hall with reflections (center-right) ---
	for mi in range(4):
		var mx = 650.0 + float(mi) * 80.0
		var my = 160.0 + float(mi) * 15.0
		var mw = 30.0
		var mh = 50.0
		# Mirror frame (ornate gold)
		draw_rect(Rect2(mx - 3, my - 3, mw + 6, mh + 6), Color(0.7, 0.55, 0.1, 0.35))
		# Mirror surface — dark reflective
		draw_rect(Rect2(mx, my, mw, mh), Color(0.06, 0.04, 0.1, 0.65))
		# Reflection shimmer
		var shimmer_off = sin(_time * 1.8 + float(mi) * 1.2) * 0.08
		draw_rect(Rect2(mx + 4.0, my + 5.0, 6.0, mh - 10.0), Color(0.4, 0.35, 0.5, 0.08 + shimmer_off))

	# --- Phantom's white mask in center mirror ---
	var mask_x = 730.0
	var mask_y = 185.0
	var mask_pulse = sin(_time * 1.2) * 0.05 + 0.3
	# Half-mask shape (right side of face)
	draw_circle(Vector2(mask_x, mask_y), 10.0, Color(0.95, 0.92, 0.88, mask_pulse))
	draw_rect(Rect2(mask_x - 5, mask_y - 8, 10, 5), Color(0.95, 0.92, 0.88, mask_pulse))
	# Eye hole
	draw_circle(Vector2(mask_x + 2, mask_y - 3), 2.0, Color(0.02, 0.01, 0.05, mask_pulse + 0.1))
	# Eerie glow behind mask
	draw_circle(Vector2(mask_x, mask_y), 25.0, Color(0.5, 0.4, 0.6, 0.03))

	# --- Visual sound waves (echoing through tunnels) ---
	for sw in range(5):
		var wave_cx = 500.0 + float(sw) * 10.0
		var wave_cy = 280.0
		var wave_r = 20.0 + float(sw) * 18.0 + sin(_time * 2.5 + float(sw)) * 5.0
		var wave_alpha = 0.08 - float(sw) * 0.015
		draw_arc(Vector2(wave_cx, wave_cy), wave_r, -0.5, 0.5, 16, Color(0.6, 0.5, 0.8, clampf(wave_alpha, 0.0, 1.0)), 0.8)

	# --- Rats scurrying along the floor ---
	for ri in range(6):
		var rat_base_x = 100.0 + float(ri) * 190.0
		var rat_y = 510.0 + sin(float(ri) * 3.0) * 15.0
		var rat_run = fmod(_time * 1.5 + float(ri) * 4.0, 8.0)
		var rat_x = rat_base_x + rat_run * 20.0
		var rat_dir = 1.0 if ri % 2 == 0 else -1.0
		# Body
		draw_circle(Vector2(rat_x, rat_y), 3.0, Color(0.25, 0.2, 0.15, 0.4))
		# Head
		draw_circle(Vector2(rat_x + rat_dir * 4.0, rat_y - 1.0), 1.8, Color(0.28, 0.22, 0.16, 0.4))
		# Tail
		var tail_wave = sin(_time * 8.0 + float(ri) * 2.0) * 2.0
		draw_line(Vector2(rat_x - rat_dir * 3.0, rat_y), Vector2(rat_x - rat_dir * 9.0, rat_y - 2.0 + tail_wave), Color(0.3, 0.22, 0.15, 0.3), 0.7)

	# === TUNNEL WALLS — brick texture on sides ===
	for side in range(2):
		var wall_x = 0.0 if side == 0 else 1240.0
		var wall_w = 40.0
		for wy in range(0, 20):
			var brick_y2 = 140.0 + float(wy) * 25.0
			var off = 15.0 if wy % 2 == 1 else 0.0
			draw_rect(Rect2(wall_x + off, brick_y2, wall_w - 2, 23), Color(0.28, 0.16, 0.1, 0.25))
			draw_line(Vector2(wall_x, brick_y2), Vector2(wall_x + wall_w, brick_y2), Color(0.15, 0.08, 0.05, 0.15), 0.5)

	# === FLOOR — Wet stone tunnel floor with water reflections ===
	for y_strip in range(0, 148, 3):
		var t = float(y_strip) / 148.0
		var floor_col = ground_color.lerp(Color(0.12, 0.1, 0.13), t)
		# Water reflection ripples
		var water_ref = sin(_time * 1.5 + float(y_strip) * 0.15) * 0.02
		floor_col = floor_col.lerp(Color(0.2, 0.25, 0.35), clampf(absf(water_ref), 0.0, 1.0))
		draw_rect(Rect2(0, 480 + y_strip, 1280, 3), floor_col)

	# Wet stone floor — tile lines
	for fx in range(0, 1280, 64):
		for fy in range(0, 3):
			var tile_y = 485.0 + float(fy) * 48.0
			draw_line(Vector2(float(fx), tile_y), Vector2(float(fx) + 62.0, tile_y), Color(0.18, 0.14, 0.12, 0.12), 0.5)
		draw_line(Vector2(float(fx), 480.0), Vector2(float(fx), 628.0), Color(0.18, 0.14, 0.12, 0.08), 0.5)

	# Water puddle reflections on floor
	for pi in range(7):
		var px = 90.0 + float(pi) * 170.0
		var py = 530.0 + sin(float(pi) * 1.7) * 25.0
		var puddle_w = 30.0 + sin(float(pi) * 2.3) * 10.0
		var puddle_ripple = sin(_time * 2.0 + float(pi) * 1.5) * 0.03
		draw_rect(Rect2(px - puddle_w * 0.5, py - 3.0, puddle_w, 6.0), Color(0.15, 0.2, 0.3, 0.12 + puddle_ripple))

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"candelabra":
				var cp = dec["pos"]
				var cs = dec["size"]
				draw_line(cp, cp + Vector2(0, -cs * 12.0), Color(0.6, 0.45, 0.1, 0.5), 2.5)
				draw_line(cp + Vector2(-cs * 3, 0), cp + Vector2(cs * 3, 0), Color(0.6, 0.45, 0.1, 0.45), 2.0)
				var arm_top = cp + Vector2(0, -cs * 12.0)
				draw_line(arm_top, arm_top + Vector2(-cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				draw_line(arm_top, arm_top + Vector2(cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				var flames = [arm_top + Vector2(0, -cs * 2), arm_top + Vector2(-cs * 5, -cs * 5), arm_top + Vector2(cs * 5, -cs * 5)]
				for fi in range(flames.size()):
					var flicker = sin(_time * 5.5 + dec["extra"] + float(fi) * 1.7) * 0.2
					draw_circle(flames[fi], 2.5 + flicker, Color(1.0, 0.75, 0.15, 0.6 + flicker))
					draw_circle(flames[fi], 18.0, Color(1.0, 0.6, 0.1, 0.02))
			"mirror":
				var mp = dec["pos"]
				var ms = dec["size"]
				draw_rect(Rect2(mp.x - ms * 8 - 3, mp.y - ms * 12 - 3, ms * 16 + 6, ms * 24 + 6), Color(0.8, 0.6, 0.1, 0.45))
				draw_rect(Rect2(mp.x - ms * 8, mp.y - ms * 12, ms * 16, ms * 24), Color(0.08, 0.05, 0.12, 0.7))
				var shimmer = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 5, mp.y - ms * 8, ms * 3, ms * 16), Color(0.4, 0.35, 0.5, shimmer * 0.1))
			"rose":
				var rp = dec["pos"]
				draw_circle(rp, dec["size"], Color(0.85, 0.1, 0.1, 0.5))
				draw_circle(rp, dec["size"] * 0.5, Color(0.95, 0.2, 0.15, 0.4))
			"sheet_music":
				var smp = dec["pos"]
				var sms = dec["size"]
				var drift = sin(_time * 0.6 + dec["extra"]) * 5.0
				draw_rect(Rect2(smp.x - sms + drift, smp.y - sms * 1.5, sms * 2, sms * 3), Color(0.85, 0.82, 0.7, 0.2))
				for line_idx in range(5):
					draw_line(Vector2(smp.x - sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Vector2(smp.x + sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Color(0.2, 0.15, 0.1, 0.15), 0.5)

	# === FOREGROUND — Dripping stalactites, dust motes, cobwebs ===
	# Stalactites hanging from top
	for i in range(12):
		var st_x = 50.0 + float(i) * 105.0
		var st_len = 20.0 + sin(float(i) * 2.7) * 12.0
		var st_top = 50.0
		draw_line(Vector2(st_x, st_top), Vector2(st_x, st_top + st_len), Color(0.2, 0.15, 0.12, 0.25), 3.0)
		draw_line(Vector2(st_x, st_top), Vector2(st_x, st_top + st_len), Color(0.25, 0.2, 0.15, 0.15), 1.0)
		# Drip at tip
		var drip_pulse = sin(_time * 2.0 + float(i) * 1.3)
		if drip_pulse > 0.7:
			draw_circle(Vector2(st_x, st_top + st_len + 2.0), 1.2, Color(0.3, 0.4, 0.55, 0.3))

	# Floating dust motes
	for i in range(20):
		var dx = fmod(float(i) * 137.5 + _time * 8.0 + sin(_time * 0.3 + float(i)) * 30.0, 1280.0)
		var dy = 100.0 + float(i) * 25.0 + sin(_time * 0.5 + float(i) * 0.8) * 15.0
		var mote_alpha = sin(_time * 1.5 + float(i) * 0.7) * 0.06 + 0.06
		draw_circle(Vector2(dx, dy), 1.0, Color(0.9, 0.8, 0.5, clampf(mote_alpha, 0.0, 1.0)))

	# Cobwebs in corners
	for corner in range(2):
		var web_x = 5.0 if corner == 0 else 1275.0
		var web_dir = 1.0 if corner == 0 else -1.0
		for strand in range(5):
			var angle = float(strand) * 0.3
			var end_x = web_x + web_dir * cos(angle) * 50.0
			var end_y = 50.0 + sin(angle) * 50.0
			draw_line(Vector2(web_x, 50.0), Vector2(end_x, end_y), Color(0.6, 0.6, 0.55, 0.08), 0.5)

	# Vignette darkness at edges
	for v in range(40):
		var v_alpha = (1.0 - float(v) / 40.0) * 0.15
		draw_rect(Rect2(0, 50 + v, float(v) * 0.5, 1), Color(0.0, 0.0, 0.0, v_alpha))
		draw_rect(Rect2(1280.0 - float(v) * 0.5, 50 + v, float(v) * 0.5, 1), Color(0.0, 0.0, 0.0, v_alpha))
	_draw_phantom_novel(2)
	_draw_shadow_author_effects()


func _draw_phantom_ch3(sky_color: Color, ground_color: Color) -> void:
	# === CEILING / SKY — Deep purple-black cavern roof ===
	for y_strip in range(0, 200, 3):
		var t = float(y_strip) / 200.0
		var ceiling_col = sky_color.lerp(Color(0.05, 0.02, 0.08, 1.0), t)
		# Faint golden candlelight reflecting on ceiling
		var candle_glow = sin(_time * 0.6 + float(y_strip) * 0.04) * 0.01
		ceiling_col = ceiling_col.lerp(Color(0.4, 0.25, 0.05), clampf(candle_glow, 0.0, 1.0))
		draw_rect(Rect2(0, 50 + y_strip, 1280, 3), ceiling_col)

	# Cavern rock texture on ceiling
	for i in range(25):
		var rock_x = float(i) * 52.0 + sin(float(i) * 1.7) * 15.0
		var rock_y = 55.0 + sin(float(i) * 2.3) * 10.0
		var rock_r = 8.0 + sin(float(i) * 3.1) * 4.0
		draw_circle(Vector2(rock_x, rock_y), rock_r, Color(0.08, 0.04, 0.06, 0.2))

	# === ATMOSPHERE — Golden candlelight and purple haze ===
	# Large ambient glow zones
	for i in range(6):
		var glow_x = 100.0 + float(i) * 200.0 + sin(_time * 0.2 + float(i) * 1.5) * 20.0
		var glow_y = 300.0 + cos(_time * 0.15 + float(i)) * 30.0
		draw_circle(Vector2(glow_x, glow_y), 120.0, Color(1.0, 0.7, 0.15, 0.012))
		draw_circle(Vector2(glow_x, glow_y), 60.0, Color(1.0, 0.6, 0.1, 0.02))

	# Purple mist rising from water
	for i in range(14):
		var mist_x = float(i) * 95.0 + sin(_time * 0.25 + float(i) * 0.8) * 25.0
		var mist_y = 420.0 + sin(_time * 0.3 + float(i) * 1.2) * 20.0
		draw_circle(Vector2(mist_x, mist_y), 50.0, Color(0.2, 0.08, 0.25, 0.025))

	# === LANDMARKS ===
	# --- Massive organ pipes towering overhead (center-left) ---
	var organ_base_x = 200.0
	for pipe in range(14):
		var pipe_x = organ_base_x + float(pipe) * 18.0
		var pipe_h = 180.0 + sin(float(pipe) * 0.8) * 80.0 + cos(float(pipe) * 0.5) * 30.0
		var pipe_w = 10.0 + sin(float(pipe) * 1.3) * 3.0
		var pipe_top = 60.0
		# Pipe body — dark bronze/gold
		draw_rect(Rect2(pipe_x - pipe_w * 0.5, pipe_top, pipe_w, pipe_h), Color(0.35, 0.28, 0.12, 0.35))
		# Pipe highlight
		draw_rect(Rect2(pipe_x - pipe_w * 0.25, pipe_top, pipe_w * 0.3, pipe_h), Color(0.5, 0.4, 0.15, 0.12))
		# Pipe top cap
		draw_rect(Rect2(pipe_x - pipe_w * 0.6, pipe_top, pipe_w * 1.2, 4.0), Color(0.4, 0.32, 0.1, 0.4))
		# Sound vibration from pipes
		if pipe % 3 == 0:
			var vib = sin(_time * 3.0 + float(pipe) * 1.5) * 2.0
			draw_arc(Vector2(pipe_x, pipe_top - 5.0), 6.0 + absf(vib), -1.0, -2.1, 8, Color(0.5, 0.4, 0.7, 0.06), 0.5)

	# --- Underground lake — black water reflecting candles ---
	var lake_top = 430.0
	for y_strip in range(0, 198, 3):
		var t = float(y_strip) / 198.0
		var water_col = Color(0.03, 0.02, 0.06, 0.85).lerp(Color(0.02, 0.01, 0.04, 0.9), t)
		# Candle reflections rippling in water
		var ripple1 = sin(_time * 1.2 + float(y_strip) * 0.08) * 0.015
		var ripple2 = sin(_time * 0.9 + float(y_strip) * 0.12 + 2.0) * 0.01
		water_col = water_col.lerp(Color(1.0, 0.7, 0.15), clampf(ripple1 + ripple2, 0.0, 1.0))
		draw_rect(Rect2(0, lake_top + float(y_strip), 1280, 3), water_col)

	# Water surface ripples
	for i in range(10):
		var rip_x = 60.0 + float(i) * 125.0
		var rip_y = lake_top + 5.0 + sin(_time * 0.7 + float(i) * 1.3) * 3.0
		var rip_w = 30.0 + sin(float(i) * 2.1) * 10.0
		draw_line(Vector2(rip_x - rip_w, rip_y), Vector2(rip_x + rip_w, rip_y), Color(0.2, 0.15, 0.25, 0.12), 0.7)

	# Candle reflections in water — inverted/distorted golden streaks
	for i in range(8):
		var ref_x = 80.0 + float(i) * 155.0
		var ref_base = lake_top + 15.0
		var ref_len = 40.0 + sin(float(i) * 1.7) * 15.0
		var ref_wave = sin(_time * 1.5 + float(i) * 2.0) * 3.0
		draw_line(Vector2(ref_x + ref_wave, ref_base), Vector2(ref_x - ref_wave, ref_base + ref_len), Color(1.0, 0.7, 0.15, 0.06), 3.0)

	# --- Phantom's mask and cape center-stage ---
	var phantom_x = 640.0
	var phantom_y = 300.0
	var phantom_sway = sin(_time * 0.8) * 3.0

	# Cape — sweeping black fabric
	var cape_pts = PackedVector2Array()
	cape_pts.append(Vector2(phantom_x - 5.0 + phantom_sway, phantom_y - 30.0))
	cape_pts.append(Vector2(phantom_x - 40.0 + phantom_sway * 0.5, phantom_y + 60.0))
	cape_pts.append(Vector2(phantom_x - 25.0, phantom_y + 80.0))
	cape_pts.append(Vector2(phantom_x + 25.0, phantom_y + 80.0))
	cape_pts.append(Vector2(phantom_x + 40.0 + phantom_sway * 0.5, phantom_y + 60.0))
	cape_pts.append(Vector2(phantom_x + 5.0 + phantom_sway, phantom_y - 30.0))
	var cape_cols = PackedColorArray()
	for _ci in range(cape_pts.size()):
		cape_cols.append(Color(0.02, 0.01, 0.04, 0.5))
	draw_polygon(cape_pts, cape_cols)
	# Cape inner lining — dark red
	draw_line(Vector2(phantom_x - 35.0 + phantom_sway, phantom_y + 50.0), Vector2(phantom_x - 15.0, phantom_y + 75.0), Color(0.4, 0.05, 0.05, 0.25), 3.0)

	# Mask — white half-mask, iconic
	var mask_glow = sin(_time * 1.0) * 0.06 + 0.45
	draw_circle(Vector2(phantom_x + phantom_sway, phantom_y - 15.0), 14.0, Color(0.96, 0.93, 0.88, mask_glow))
	# Mask shaping — right half only
	draw_rect(Rect2(phantom_x + phantom_sway - 8, phantom_y - 28, 16, 8), Color(0.96, 0.93, 0.88, mask_glow))
	# Eye socket
	draw_circle(Vector2(phantom_x + phantom_sway + 3.0, phantom_y - 18.0), 3.0, Color(0.02, 0.01, 0.05, mask_glow + 0.15))
	# Eerie glow around phantom
	draw_circle(Vector2(phantom_x + phantom_sway, phantom_y), 50.0, Color(0.3, 0.15, 0.4, 0.025))

	# --- Monkey music box (right of phantom) ---
	var monkey_x = 850.0
	var monkey_y = 380.0
	# Box base
	draw_rect(Rect2(monkey_x - 15, monkey_y, 30, 20), Color(0.4, 0.25, 0.08, 0.4))
	draw_rect(Rect2(monkey_x - 13, monkey_y + 2, 26, 16), Color(0.5, 0.32, 0.1, 0.3))
	# Monkey figure
	draw_circle(Vector2(monkey_x, monkey_y - 6.0), 6.0, Color(0.35, 0.22, 0.1, 0.4))
	draw_circle(Vector2(monkey_x, monkey_y - 14.0), 4.5, Color(0.38, 0.25, 0.12, 0.4))
	# Cymbals — animated clapping
	var cymbal_angle = sin(_time * 4.0) * 0.4
	draw_circle(Vector2(monkey_x - 7.0 - cymbal_angle * 3.0, monkey_y - 10.0), 3.0, Color(0.7, 0.55, 0.1, 0.35))
	draw_circle(Vector2(monkey_x + 7.0 + cymbal_angle * 3.0, monkey_y - 10.0), 3.0, Color(0.7, 0.55, 0.1, 0.35))

	# --- Christine's wedding veil (left of phantom) ---
	var veil_x = 430.0
	var veil_y = 310.0
	var veil_drift = sin(_time * 0.5) * 4.0
	# Veil fabric — translucent white flowing
	for vi in range(6):
		var v_off_x = sin(_time * 0.7 + float(vi) * 0.9) * 5.0 + veil_drift
		var v_off_y = float(vi) * 12.0
		var v_width = 15.0 + float(vi) * 4.0
		var v_alpha = 0.15 - float(vi) * 0.02
		draw_line(Vector2(veil_x - v_width + v_off_x, veil_y + v_off_y), Vector2(veil_x + v_width + v_off_x, veil_y + v_off_y), Color(0.95, 0.93, 0.9, clampf(v_alpha, 0.0, 1.0)), 2.0)
	# Veil top crown/tiara
	draw_circle(Vector2(veil_x + veil_drift, veil_y - 5.0), 4.0, Color(0.85, 0.8, 0.75, 0.2))
	for ti in range(3):
		var tiara_x = veil_x + veil_drift + float(ti - 1) * 5.0
		draw_line(Vector2(tiara_x, veil_y - 5.0), Vector2(tiara_x, veil_y - 10.0 - float(1 - absi(ti - 1)) * 3.0), Color(0.8, 0.7, 0.4, 0.25), 1.0)

	# --- Roses scattered throughout ---
	for ri in range(12):
		var rose_x = 50.0 + float(ri) * 105.0 + sin(float(ri) * 3.7) * 30.0
		var rose_y = 400.0 + sin(float(ri) * 2.1) * 25.0
		var rose_size = 3.5 + sin(float(ri) * 1.9) * 1.5
		draw_circle(Vector2(rose_x, rose_y), rose_size, Color(0.85, 0.08, 0.08, 0.45))
		draw_circle(Vector2(rose_x, rose_y), rose_size * 0.5, Color(0.95, 0.15, 0.12, 0.35))
		# Stem
		draw_line(Vector2(rose_x, rose_y + rose_size), Vector2(rose_x + 3.0, rose_y + rose_size + 10.0), Color(0.15, 0.35, 0.1, 0.25), 0.8)

	# === FLOOR — Stone walkway over water ===
	# The walkway is a narrow stone bridge across the lake
	for y_strip in range(0, 30, 3):
		var t = float(y_strip) / 30.0
		var walkway_col = ground_color.lerp(Color(0.18, 0.14, 0.12), t)
		draw_rect(Rect2(200, 485 + y_strip, 880, 3), walkway_col)

	# Walkway stone texture
	for sx in range(0, 880, 44):
		var stone_x = 200.0 + float(sx)
		draw_line(Vector2(stone_x, 485.0), Vector2(stone_x, 515.0), Color(0.25, 0.2, 0.18, 0.12), 0.5)
	for sy in range(0, 2):
		draw_line(Vector2(200.0, 495.0 + float(sy) * 12.0), Vector2(1080.0, 495.0 + float(sy) * 12.0), Color(0.25, 0.2, 0.18, 0.1), 0.5)

	# Walkway edges — stone railing
	draw_line(Vector2(200.0, 485.0), Vector2(1080.0, 485.0), Color(0.3, 0.25, 0.2, 0.3), 2.0)
	draw_line(Vector2(200.0, 515.0), Vector2(1080.0, 515.0), Color(0.3, 0.25, 0.2, 0.3), 2.0)

	# Water visible on sides of walkway
	for side in range(2):
		var water_x = 0.0 if side == 0 else 1080.0
		var water_w = 200.0 if side == 0 else 200.0
		for wy in range(0, 50, 4):
			var ripple = sin(_time * 1.0 + float(wy) * 0.15 + float(side) * 2.0) * 0.01
			draw_rect(Rect2(water_x, 485.0 + float(wy), water_w, 4), Color(0.03, 0.02, 0.06, 0.5 + ripple))

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"candelabra":
				var cp = dec["pos"]
				var cs = dec["size"]
				draw_line(cp, cp + Vector2(0, -cs * 12.0), Color(0.6, 0.45, 0.1, 0.5), 2.5)
				draw_line(cp + Vector2(-cs * 3, 0), cp + Vector2(cs * 3, 0), Color(0.6, 0.45, 0.1, 0.45), 2.0)
				var arm_top = cp + Vector2(0, -cs * 12.0)
				draw_line(arm_top, arm_top + Vector2(-cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				draw_line(arm_top, arm_top + Vector2(cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				var flames = [arm_top + Vector2(0, -cs * 2), arm_top + Vector2(-cs * 5, -cs * 5), arm_top + Vector2(cs * 5, -cs * 5)]
				for fi in range(flames.size()):
					var flicker = sin(_time * 5.5 + dec["extra"] + float(fi) * 1.7) * 0.2
					draw_circle(flames[fi], 2.5 + flicker, Color(1.0, 0.75, 0.15, 0.6 + flicker))
					draw_circle(flames[fi], 18.0, Color(1.0, 0.6, 0.1, 0.02))
			"mirror":
				var mp = dec["pos"]
				var ms = dec["size"]
				draw_rect(Rect2(mp.x - ms * 8 - 3, mp.y - ms * 12 - 3, ms * 16 + 6, ms * 24 + 6), Color(0.8, 0.6, 0.1, 0.45))
				draw_rect(Rect2(mp.x - ms * 8, mp.y - ms * 12, ms * 16, ms * 24), Color(0.08, 0.05, 0.12, 0.7))
				var shimmer = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 5, mp.y - ms * 8, ms * 3, ms * 16), Color(0.4, 0.35, 0.5, shimmer * 0.1))
			"rose":
				var rp = dec["pos"]
				draw_circle(rp, dec["size"], Color(0.85, 0.1, 0.1, 0.5))
				draw_circle(rp, dec["size"] * 0.5, Color(0.95, 0.2, 0.15, 0.4))
			"sheet_music":
				var smp = dec["pos"]
				var sms = dec["size"]
				var drift = sin(_time * 0.6 + dec["extra"]) * 5.0
				draw_rect(Rect2(smp.x - sms + drift, smp.y - sms * 1.5, sms * 2, sms * 3), Color(0.85, 0.82, 0.7, 0.2))
				for line_idx in range(5):
					draw_line(Vector2(smp.x - sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Vector2(smp.x + sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Color(0.2, 0.15, 0.1, 0.15), 0.5)

	# === FOREGROUND — Floating candles, mist, rose petals falling ===
	# Floating candles on lake surface (foreground layer)
	for i in range(9):
		var fc_x = 70.0 + float(i) * 140.0 + sin(_time * 0.4 + float(i) * 1.7) * 15.0
		var fc_y = 540.0 + sin(_time * 0.6 + float(i) * 2.1) * 5.0
		# Candle body
		draw_rect(Rect2(fc_x - 2, fc_y - 10, 4, 10), Color(0.85, 0.8, 0.7, 0.35))
		# Flame
		var fc_flicker = sin(_time * 6.0 + float(i) * 2.3) * 1.5
		draw_circle(Vector2(fc_x, fc_y - 12.0 + fc_flicker), 2.5, Color(1.0, 0.8, 0.2, 0.55))
		draw_circle(Vector2(fc_x, fc_y - 12.0 + fc_flicker), 10.0, Color(1.0, 0.6, 0.1, 0.03))
		# Reflection in water below
		draw_line(Vector2(fc_x, fc_y + 2.0), Vector2(fc_x + sin(_time * 1.0 + float(i)) * 2.0, fc_y + 18.0), Color(1.0, 0.7, 0.15, 0.04), 2.0)

	# Falling rose petals
	for i in range(15):
		var petal_x = fmod(float(i) * 89.0 + _time * 12.0 + sin(_time * 0.4 + float(i) * 1.5) * 40.0, 1280.0)
		var petal_y = fmod(float(i) * 43.0 + _time * 18.0, 578.0) + 50.0
		var petal_rot = _time * 2.0 + float(i) * 1.3
		var petal_size = 2.0 + sin(float(i) * 2.5) * 0.8
		var px_off = cos(petal_rot) * petal_size
		var py_off = sin(petal_rot) * petal_size * 0.5
		draw_circle(Vector2(petal_x + px_off, petal_y + py_off), petal_size, Color(0.8, 0.1, 0.1, 0.18))

	# Low mist / fog across foreground
	for i in range(10):
		var fog_x = float(i) * 130.0 + sin(_time * 0.15 + float(i) * 0.6) * 40.0
		var fog_y = 580.0 + sin(_time * 0.3 + float(i) * 1.1) * 10.0
		draw_circle(Vector2(fog_x, fog_y), 70.0, Color(0.12, 0.06, 0.15, 0.03))
		draw_circle(Vector2(fog_x + 30.0, fog_y - 5.0), 45.0, Color(0.15, 0.08, 0.18, 0.025))

	# Musical notes floating up from the organ
	for i in range(7):
		var note_x = 220.0 + float(i) * 30.0 + sin(_time * 1.2 + float(i) * 1.8) * 15.0
		var note_y = 200.0 - fmod(_time * 15.0 + float(i) * 40.0, 180.0)
		var note_alpha = 0.12 - fmod(_time * 0.05 + float(i) * 0.15, 0.12)
		if note_y > 55.0:
			draw_circle(Vector2(note_x, note_y), 2.5, Color(0.7, 0.55, 0.9, clampf(note_alpha, 0.0, 1.0)))
			draw_line(Vector2(note_x + 2.5, note_y), Vector2(note_x + 2.5, note_y - 8.0), Color(0.7, 0.55, 0.9, clampf(note_alpha * 0.8, 0.0, 1.0)), 0.7)

	# Vignette — deep darkness at edges for dramatic framing (12 bands instead of 60)
	for v in range(12):
		var v_alpha = (1.0 - float(v) / 12.0) * 0.2
		var band_y = 50 + v * 5
		var band_w = float(v) * 4.0
		draw_rect(Rect2(0, band_y, band_w, 5), Color(0.0, 0.0, 0.0, v_alpha))
		draw_rect(Rect2(1280.0 - band_w, band_y, band_w, 5), Color(0.0, 0.0, 0.0, v_alpha))
		# Bottom vignette
		draw_rect(Rect2(0, 628 - v * 5, 1280, 5), Color(0.0, 0.0, 0.0, v_alpha * 0.5))
	_draw_phantom_novel(3)
	_draw_shadow_author_effects()

func _draw_scrooge_ch2(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — Midnight spectral blue ===
	var midnight_base := Color(0.03, 0.04, 0.08)
	var spectral_blue := Color(0.05, 0.12, 0.2)
	for i in range(30):
		var t := float(i) / 29.0
		var band_color := midnight_base.lerp(spectral_blue, t * t)
		# Pulsing spectral glow across the whole sky
		var spectral_pulse := sin(_time * 0.4 + t * 3.0) * 0.02
		band_color.g += spectral_pulse
		band_color.b += spectral_pulse * 1.5
		var y_start := t * 300.0
		var y_height := 300.0 / 29.0 + 2.0
		draw_rect(Rect2(0, y_start, 1280, y_height), band_color)

	# === ATMOSPHERE — Spectral green/blue mist ===
	for i in range(12):
		var mx := float(i) * 110.0 + sin(_time * 0.3 + float(i)) * 30.0
		var my := 250.0 + sin(_time * 0.2 + float(i) * 0.7) * 40.0
		var mrad := 80.0 + sin(_time * 0.5 + float(i) * 1.3) * 20.0
		var green_tint := 0.15 + sin(_time * 0.6 + float(i)) * 0.05
		draw_circle(Vector2(mx, my), mrad, Color(0.1, green_tint, 0.2, 0.03))

	# Spectral aurora ribbons in upper sky
	for i in range(5):
		var ribbon_y := 60.0 + float(i) * 35.0
		var pts := PackedVector2Array()
		for s in range(20):
			var sx := float(s) * 68.0
			var sy := ribbon_y + sin(_time * 0.3 + float(s) * 0.5 + float(i)) * 15.0
			pts.append(Vector2(sx, sy))
		for s in range(pts.size() - 1):
			var ribbon_alpha := 0.04 + sin(_time * 0.4 + float(s) * 0.3) * 0.02
			draw_line(pts[s], pts[s + 1], Color(0.15, 0.4, 0.3, ribbon_alpha), 2.0)

	# === MOON — Pale ghostly moon ===
	var moon_pos := Vector2(950, 80)
	draw_circle(moon_pos, 35.0, Color(0.6, 0.65, 0.75, 0.15))
	draw_circle(moon_pos, 22.0, Color(0.7, 0.75, 0.85, 0.25))
	draw_circle(moon_pos, 12.0, Color(0.85, 0.88, 0.95, 0.4))

	# === CHURCH STEEPLE AT MIDNIGHT — far background ===
	var church_x := 180.0
	var church_base_y := 320.0
	# Main church body
	draw_rect(Rect2(church_x - 40, church_base_y - 100, 80, 100), Color(0.06, 0.06, 0.1, 0.7))
	# Steeple
	var steeple_pts := PackedVector2Array([
		Vector2(church_x - 20, church_base_y - 100),
		Vector2(church_x, church_base_y - 180),
		Vector2(church_x + 20, church_base_y - 100)
	])
	draw_colored_polygon(steeple_pts, Color(0.05, 0.05, 0.09, 0.8))
	# Cross on top
	draw_line(Vector2(church_x, church_base_y - 180), Vector2(church_x, church_base_y - 200), Color(0.3, 0.3, 0.35, 0.6), 2.0)
	draw_line(Vector2(church_x - 8, church_base_y - 192), Vector2(church_x + 8, church_base_y - 192), Color(0.3, 0.3, 0.35, 0.6), 2.0)
	# Clock face — midnight
	draw_circle(Vector2(church_x, church_base_y - 70), 12.0, Color(0.15, 0.15, 0.2, 0.5))
	draw_circle(Vector2(church_x, church_base_y - 70), 10.0, Color(0.6, 0.6, 0.55, 0.3))
	draw_line(Vector2(church_x, church_base_y - 70), Vector2(church_x, church_base_y - 80), Color(0.1, 0.1, 0.1, 0.5), 1.5)
	# Arched window glow
	draw_circle(Vector2(church_x, church_base_y - 45), 8.0, Color(0.2, 0.5, 0.4, 0.15))

	# === GHOST OF CHRISTMAS PAST — Golden sphere, upper left ===
	var past_x := 300.0 + sin(_time * 0.7) * 20.0
	var past_y := 140.0 + sin(_time * 0.5) * 15.0
	var past_glow := 0.3 + sin(_time * 2.0) * 0.1
	draw_circle(Vector2(past_x, past_y), 30.0, Color(1.0, 0.85, 0.3, 0.05))
	draw_circle(Vector2(past_x, past_y), 18.0, Color(1.0, 0.8, 0.2, 0.1))
	draw_circle(Vector2(past_x, past_y), 10.0, Color(1.0, 0.9, 0.5, past_glow))
	# Rays emanating
	for r in range(8):
		var ray_angle := float(r) * PI * 0.25 + _time * 0.3
		var ray_end := Vector2(past_x, past_y) + Vector2.from_angle(ray_angle) * (25.0 + sin(_time * 3.0 + float(r)) * 5.0)
		draw_line(Vector2(past_x, past_y), ray_end, Color(1.0, 0.85, 0.3, 0.08), 1.0)

	# === GHOST OF CHRISTMAS PRESENT — Jolly silhouette with holly crown ===
	var present_x := 700.0 + sin(_time * 0.4) * 10.0
	var present_y := 200.0
	# Large robed body
	var robe_pts := PackedVector2Array([
		Vector2(present_x - 25, present_y + 60),
		Vector2(present_x - 30, present_y),
		Vector2(present_x - 15, present_y - 40),
		Vector2(present_x, present_y - 50),
		Vector2(present_x + 15, present_y - 40),
		Vector2(present_x + 30, present_y),
		Vector2(present_x + 25, present_y + 60)
	])
	draw_colored_polygon(robe_pts, Color(0.1, 0.35, 0.15, 0.2))
	# Holly crown
	for h in range(5):
		var holly_angle := -PI * 0.3 + float(h) * 0.3
		var hx := present_x + cos(holly_angle) * 18.0
		var hy := present_y - 50.0 + sin(holly_angle) * 5.0 - 5.0
		draw_circle(Vector2(hx, hy), 3.0, Color(0.15, 0.5, 0.1, 0.3))
	# Holly berries
	draw_circle(Vector2(present_x - 5, present_y - 56), 2.0, Color(0.7, 0.1, 0.1, 0.3))
	draw_circle(Vector2(present_x + 5, present_y - 56), 2.0, Color(0.7, 0.1, 0.1, 0.3))

	# === TOMBSTONES — Graveyard ===
	var tombstones := [
		{"x": 400.0, "h": 50.0, "w": 28.0}, {"x": 520.0, "h": 42.0, "w": 24.0},
		{"x": 640.0, "h": 55.0, "w": 30.0}, {"x": 780.0, "h": 38.0, "w": 22.0},
		{"x": 880.0, "h": 48.0, "w": 26.0}, {"x": 1020.0, "h": 44.0, "w": 25.0},
		{"x": 1140.0, "h": 40.0, "w": 23.0}, {"x": 340.0, "h": 36.0, "w": 20.0}
	]
	var grave_y := 420.0
	for ts_data in tombstones:
		var tx: float = ts_data["x"]
		var th: float = ts_data["h"]
		var tw: float = ts_data["w"]
		# Tombstone body
		draw_rect(Rect2(tx - tw * 0.5, grave_y - th, tw, th), Color(0.18, 0.17, 0.2, 0.5))
		# Rounded top
		draw_circle(Vector2(tx, grave_y - th), tw * 0.5, Color(0.18, 0.17, 0.2, 0.5))
		# Spectral glow behind each stone
		var ts_glow := sin(_time * 0.8 + tx * 0.01) * 0.03
		draw_circle(Vector2(tx, grave_y - th * 0.5), tw * 1.2, Color(0.15, 0.4, 0.3, 0.04 + ts_glow))

	# === "EBENEZER SCROOGE" TOMBSTONE — prominent center ===
	var eb_x := 640.0
	var eb_y := 380.0
	var eb_w := 50.0
	var eb_h := 75.0
	draw_rect(Rect2(eb_x - eb_w * 0.5, eb_y - eb_h, eb_w, eb_h), Color(0.2, 0.19, 0.22, 0.65))
	draw_circle(Vector2(eb_x, eb_y - eb_h), eb_w * 0.5, Color(0.2, 0.19, 0.22, 0.65))
	# Engraved text lines (small horizontal marks suggesting letters)
	for line_i in range(3):
		var line_y2 := eb_y - eb_h + 20.0 + float(line_i) * 12.0
		var line_w2 := eb_w * (0.7 - float(line_i) * 0.1)
		draw_line(Vector2(eb_x - line_w2 * 0.5, line_y2), Vector2(eb_x + line_w2 * 0.5, line_y2), Color(0.35, 0.33, 0.38, 0.4), 1.5)
	# Eerie glow around Scrooge's tombstone
	var eb_glow := 0.06 + sin(_time * 1.2) * 0.03
	draw_circle(Vector2(eb_x, eb_y - eb_h * 0.5), 60.0, Color(0.2, 0.6, 0.4, eb_glow))

	# === GHOSTLY FIGURES RISING FROM GRAVES ===
	for gi in range(4):
		var ghost_x := 420.0 + float(gi) * 200.0
		var rise_offset := sin(_time * 0.6 + float(gi) * 1.5) * 12.0
		var ghost_base_y := 400.0 + rise_offset
		var ghost_alpha := 0.08 + sin(_time * 0.9 + float(gi) * 2.0) * 0.04
		# Wispy body shape
		var ghost_pts := PackedVector2Array([
			Vector2(ghost_x - 10, ghost_base_y),
			Vector2(ghost_x - 14, ghost_base_y - 25),
			Vector2(ghost_x - 8, ghost_base_y - 45),
			Vector2(ghost_x, ghost_base_y - 55 + rise_offset * 0.3),
			Vector2(ghost_x + 8, ghost_base_y - 45),
			Vector2(ghost_x + 14, ghost_base_y - 25),
			Vector2(ghost_x + 10, ghost_base_y)
		])
		draw_colored_polygon(ghost_pts, Color(0.5, 0.7, 0.6, ghost_alpha))
		# Eyes
		draw_circle(Vector2(ghost_x - 3, ghost_base_y - 45), 1.5, Color(0.7, 0.9, 0.8, ghost_alpha * 2.0))
		draw_circle(Vector2(ghost_x + 3, ghost_base_y - 45), 1.5, Color(0.7, 0.9, 0.8, ghost_alpha * 2.0))

	# === FLOATING CHAINS (animated) ===
	for ci in range(6):
		var chain_start_x := 150.0 + float(ci) * 190.0
		var chain_y_base := 280.0 + sin(_time * 0.7 + float(ci) * 1.1) * 25.0
		var chain_sway := sin(_time * 1.2 + float(ci) * 0.8) * 15.0
		for link in range(6):
			var lx := chain_start_x + chain_sway * (float(link) / 5.0) + sin(_time + float(link)) * 3.0
			var ly := chain_y_base + float(link) * 14.0
			# Oval chain link
			draw_arc(Vector2(lx, ly), 5.0, 0, TAU, 12, Color(0.35, 0.3, 0.28, 0.15 + sin(_time * 0.5 + float(ci)) * 0.05), 1.5)

	# === GROUND — Frozen graveyard earth with snow ===
	var ground_top := 440.0
	for gi2 in range(20):
		var gt := float(gi2) / 19.0
		var gy := ground_top + gt * (628.0 - ground_top)
		var gc := Color(0.08, 0.1, 0.12).lerp(Color(0.06, 0.07, 0.1), gt)
		# Snow tint near surface
		if gt < 0.3:
			gc = gc.lerp(Color(0.4, 0.42, 0.5), (1.0 - gt / 0.3) * 0.15)
		draw_rect(Rect2(0, gy, 1280, (628.0 - ground_top) / 19.0 + 2.0), gc)

	# Snow drifts along ground
	for sd in range(10):
		var sdx := float(sd) * 135.0 + 30.0
		var sdy := ground_top + 5.0 + sin(float(sd) * 2.3) * 8.0
		draw_circle(Vector2(sdx, sdy), 25.0 + sin(float(sd) * 1.7) * 10.0, Color(0.6, 0.62, 0.7, 0.08))

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"lamp_post":
				var lp = dec["pos"]
				var ls = dec["size"]
				draw_line(lp, lp + Vector2(0, -ls * 1.4), Color(0.15, 0.12, 0.1, 0.6), 3.0)
				var lamp_top = lp + Vector2(0, -ls * 1.4)
				draw_rect(Rect2(lamp_top.x - ls * 0.2, lamp_top.y - ls * 0.4, ls * 0.4, ls * 0.4), Color(0.18, 0.14, 0.1, 0.5))
				var flicker = sin(_time * 6.0 + dec["extra"]) * 0.15
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.15 + flicker, Color(1.0, 0.75, 0.2, 0.55 + flicker))
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.8, Color(1.0, 0.7, 0.2, 0.04))
			"bare_tree":
				var tp = dec["pos"]
				var ts = dec["size"]
				var sh = dec["extra"]
				draw_line(tp, tp + Vector2(0, -ts * 1.4), Color(0.12, 0.1, 0.08, 0.5), 3.0)
				var branch_base = tp + Vector2(0, -ts * 1.4)
				for b in range(4):
					var b_angle = -PI * 0.6 + float(b) * 0.4 + sin(float(int(sh * 100) + b)) * 0.2
					var b_len = ts * (0.6 + float(b) * 0.2)
					draw_line(branch_base + Vector2(0, float(b) * ts * 0.2), branch_base + Vector2(0, float(b) * ts * 0.2) + Vector2.from_angle(b_angle) * b_len, Color(0.12, 0.1, 0.08, 0.4), 1.5)
			"snow_pile":
				draw_circle(dec["pos"], dec["size"], Color(0.85, 0.87, 0.9, 0.15))
				draw_circle(dec["pos"] + Vector2(dec["size"] * 0.3, -dec["size"] * 0.2), dec["size"] * 0.7, Color(0.88, 0.9, 0.92, 0.12))
			"chimney":
				var cp2 = dec["pos"]
				var cs2 = dec["size"]
				draw_rect(Rect2(cp2.x - cs2 * 0.4, cp2.y - cs2 * 2, cs2 * 0.8, cs2 * 2), Color(0.15, 0.12, 0.1, 0.4))
				var cf = sin(_time * 0.5 + dec["extra"]) * 4.0
				draw_circle(Vector2(cp2.x + cf, cp2.y - cs2 * 2.2), 4.0, Color(0.4, 0.4, 0.45, 0.06))

	# === FOREGROUND — Low mist and frost particles ===
	for fi in range(8):
		var fx := float(fi) * 170.0 + sin(_time * 0.3 + float(fi) * 0.9) * 40.0
		var fy := 550.0 + sin(_time * 0.4 + float(fi) * 1.2) * 20.0
		draw_circle(Vector2(fx, fy), 50.0 + sin(_time * 0.5 + float(fi)) * 15.0, Color(0.15, 0.25, 0.2, 0.04))

	# Frost sparkle particles drifting down
	for sp in range(15):
		var sp_x := fmod(float(sp) * 97.0 + _time * 8.0 + sin(float(sp) * 3.7) * 200.0, 1280.0)
		var sp_y := fmod(float(sp) * 53.0 + _time * 12.0, 578.0) + 50.0
		var sp_alpha := 0.1 + sin(_time * 3.0 + float(sp) * 2.1) * 0.06
		draw_circle(Vector2(sp_x, sp_y), 1.5, Color(0.7, 0.85, 0.95, sp_alpha))

	# Foreground iron fence silhouettes
	for fence_i in range(20):
		var fence_x := float(fence_i) * 68.0 + 10.0
		var fence_base_y := 590.0
		draw_line(Vector2(fence_x, fence_base_y), Vector2(fence_x, fence_base_y - 35.0), Color(0.08, 0.08, 0.1, 0.3), 2.0)
		# Pointed top
		draw_line(Vector2(fence_x - 3, fence_base_y - 35.0), Vector2(fence_x, fence_base_y - 42.0), Color(0.08, 0.08, 0.1, 0.3), 1.5)
		draw_line(Vector2(fence_x + 3, fence_base_y - 35.0), Vector2(fence_x, fence_base_y - 42.0), Color(0.08, 0.08, 0.1, 0.3), 1.5)
	# Horizontal fence bars
	draw_line(Vector2(10, 570.0), Vector2(1270, 570.0), Color(0.08, 0.08, 0.1, 0.2), 1.5)
	draw_line(Vector2(10, 580.0), Vector2(1270, 580.0), Color(0.08, 0.08, 0.1, 0.2), 1.5)
	_draw_scrooge_novel(2)
	_draw_shadow_author_effects()


func _draw_scrooge_ch3(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — Split dawn: warm gold left, cold gray right ===
	var warm_dawn := Color(0.45, 0.25, 0.08)
	var cold_gray := Color(0.12, 0.13, 0.18)
	var golden_top := Color(0.3, 0.18, 0.06)
	var pale_sky := Color(0.35, 0.3, 0.25)
	for i in range(30):
		var t := float(i) / 29.0
		var y_start := t * 300.0
		var y_height := 300.0 / 29.0 + 2.0
		# Draw sky in vertical strips blending left-warm to right-cold
		for sx in range(16):
			var xt := float(sx) / 15.0
			var left_color := golden_top.lerp(warm_dawn, t)
			var right_color := cold_gray.lerp(Color(0.15, 0.15, 0.2), t * 0.5)
			var band_color := left_color.lerp(right_color, xt)
			# Add golden sunrise glow near horizon on the left
			if t > 0.6 and xt < 0.4:
				var glow_strength := (t - 0.6) * 2.5 * (1.0 - xt / 0.4) * 0.3
				band_color = band_color.lerp(Color(0.8, 0.5, 0.15), glow_strength)
			draw_rect(Rect2(float(sx) * 80.0, y_start, 82.0, y_height), band_color)

	# === ATMOSPHERE — Golden light rays from left ===
	for ray in range(8):
		var ray_angle := -0.3 + float(ray) * 0.08
		var ray_length := 500.0 + sin(_time * 0.4 + float(ray)) * 50.0
		var ray_start := Vector2(0, 200.0 + float(ray) * 20.0)
		var ray_end := ray_start + Vector2.from_angle(ray_angle) * ray_length
		var ray_alpha := 0.03 + sin(_time * 0.5 + float(ray) * 0.7) * 0.015
		draw_line(ray_start, ray_end, Color(1.0, 0.8, 0.3, ray_alpha), 3.0 + float(ray) * 0.5)

	# Warm golden haze on left side
	for hz in range(6):
		var hx := 80.0 + float(hz) * 60.0 + sin(_time * 0.3 + float(hz)) * 15.0
		var hy := 200.0 + float(hz) * 30.0
		draw_circle(Vector2(hx, hy), 70.0 + sin(_time * 0.4 + float(hz) * 1.3) * 15.0, Color(0.9, 0.65, 0.2, 0.03))

	# Cold mist on right side
	for cm in range(5):
		var cx := 850.0 + float(cm) * 90.0 + sin(_time * 0.25 + float(cm)) * 20.0
		var cy := 180.0 + float(cm) * 40.0
		draw_circle(Vector2(cx, cy), 60.0, Color(0.2, 0.2, 0.25, 0.04))

	# === GHOST OF CHRISTMAS YET TO COME — Tall hooded shadow, right side ===
	var ghost_x := 1100.0 + sin(_time * 0.3) * 5.0
	var ghost_y := 180.0
	# Tall hooded cloak
	var cloak_pts := PackedVector2Array([
		Vector2(ghost_x - 20, ghost_y + 120),
		Vector2(ghost_x - 28, ghost_y + 40),
		Vector2(ghost_x - 22, ghost_y - 20),
		Vector2(ghost_x - 12, ghost_y - 60),
		Vector2(ghost_x, ghost_y - 75),
		Vector2(ghost_x + 12, ghost_y - 60),
		Vector2(ghost_x + 22, ghost_y - 20),
		Vector2(ghost_x + 28, ghost_y + 40),
		Vector2(ghost_x + 20, ghost_y + 120)
	])
	var cloak_alpha := 0.3 + sin(_time * 0.8) * 0.05
	draw_colored_polygon(cloak_pts, Color(0.02, 0.02, 0.04, cloak_alpha))
	# Hood darkness
	draw_circle(Vector2(ghost_x, ghost_y - 55), 14.0, Color(0.0, 0.0, 0.0, cloak_alpha * 0.8))
	# Pointing arm extending left
	var arm_sway := sin(_time * 0.6) * 3.0
	draw_line(Vector2(ghost_x - 20, ghost_y), Vector2(ghost_x - 55 + arm_sway, ghost_y - 10), Color(0.02, 0.02, 0.04, cloak_alpha * 0.7), 3.0)
	# Dark aura
	draw_circle(Vector2(ghost_x, ghost_y + 20), 50.0, Color(0.02, 0.02, 0.06, 0.06))

	# === LONDON ROOFTOPS — Snow-covered with chimneys ===
	var rooftop_data := [
		{"x": 100.0, "w": 120.0, "h": 80.0, "roof_h": 40.0},
		{"x": 250.0, "w": 100.0, "h": 95.0, "roof_h": 35.0},
		{"x": 380.0, "w": 140.0, "h": 70.0, "roof_h": 45.0},
		{"x": 560.0, "w": 110.0, "h": 85.0, "roof_h": 38.0},
		{"x": 700.0, "w": 130.0, "h": 75.0, "roof_h": 42.0},
		{"x": 860.0, "w": 105.0, "h": 90.0, "roof_h": 36.0},
		{"x": 1000.0, "w": 115.0, "h": 72.0, "roof_h": 40.0}
	]
	var rooftop_base_y := 360.0
	for rd in rooftop_data:
		var rx: float = rd["x"]
		var rw: float = rd["w"]
		var rh: float = rd["h"]
		var rrh: float = rd["roof_h"]
		var building_top := rooftop_base_y - rh
		# Building wall
		draw_rect(Rect2(rx, building_top, rw, rh), Color(0.12, 0.1, 0.1, 0.55))
		# Pitched roof
		var roof_pts := PackedVector2Array([
			Vector2(rx - 5, building_top),
			Vector2(rx + rw * 0.5, building_top - rrh),
			Vector2(rx + rw + 5, building_top)
		])
		draw_colored_polygon(roof_pts, Color(0.1, 0.08, 0.08, 0.6))
		# Snow on roof ridge
		draw_line(Vector2(rx - 2, building_top), Vector2(rx + rw * 0.5, building_top - rrh), Color(0.8, 0.82, 0.88, 0.2), 3.0)
		draw_line(Vector2(rx + rw * 0.5, building_top - rrh), Vector2(rx + rw + 2, building_top), Color(0.8, 0.82, 0.88, 0.2), 3.0)
		# Warm lit windows
		for wi in range(2):
			for wj in range(2):
				var win_x := rx + 15.0 + float(wi) * (rw - 30.0)
				var win_y := building_top + 15.0 + float(wj) * 25.0
				if win_y < rooftop_base_y - 10.0:
					draw_rect(Rect2(win_x - 5, win_y - 7, 10, 14), Color(0.9, 0.65, 0.2, 0.25))
					# Warm glow
					draw_circle(Vector2(win_x, win_y), 8.0, Color(0.95, 0.7, 0.25, 0.06))

	# === WREATHS AND HOLLY on buildings ===
	for wr_i in range(5):
		var wr_x := 160.0 + float(wr_i) * 220.0
		var wr_y := rooftop_base_y - 50.0
		# Wreath circle
		draw_arc(Vector2(wr_x, wr_y), 8.0, 0, TAU, 16, Color(0.1, 0.4, 0.12, 0.3), 2.5)
		# Red bow at bottom
		draw_circle(Vector2(wr_x, wr_y + 8.0), 2.5, Color(0.7, 0.1, 0.08, 0.3))
		# Holly leaves nearby
		draw_circle(Vector2(wr_x + 12.0, wr_y - 3.0), 3.0, Color(0.08, 0.35, 0.1, 0.2))
		draw_circle(Vector2(wr_x + 18.0, wr_y - 1.0), 2.5, Color(0.08, 0.35, 0.1, 0.2))
		draw_circle(Vector2(wr_x + 15.0, wr_y - 5.0), 1.5, Color(0.65, 0.08, 0.08, 0.25))

	# === CHURCH BELLS — Visual golden rings ===
	var bell_x := 200.0
	var bell_y := 160.0
	# Church tower in background
	draw_rect(Rect2(bell_x - 20, bell_y, 40, 100), Color(0.1, 0.09, 0.08, 0.5))
	var bell_steeple := PackedVector2Array([
		Vector2(bell_x - 15, bell_y),
		Vector2(bell_x, bell_y - 40),
		Vector2(bell_x + 15, bell_y)
	])
	draw_colored_polygon(bell_steeple, Color(0.1, 0.09, 0.08, 0.55))
	# Animated golden rings expanding outward
	for ring_i in range(4):
		var ring_radius := 15.0 + fmod(_time * 20.0 + float(ring_i) * 25.0, 100.0)
		var ring_alpha := clampf(0.12 - ring_radius * 0.001, 0.0, 0.12)
		draw_arc(Vector2(bell_x, bell_y - 20), ring_radius, 0, TAU, 24, Color(0.95, 0.8, 0.3, ring_alpha), 1.5)

	# === CHILDREN IN SNOW — Small figures on left side ===
	for chi in range(3):
		var child_x := 80.0 + float(chi) * 50.0
		var child_y := 430.0
		var bounce := absf(sin(_time * 2.0 + float(chi) * 1.5)) * 4.0
		# Simple body
		draw_circle(Vector2(child_x, child_y - 18.0 - bounce), 5.0, Color(0.5, 0.3, 0.15, 0.3))
		draw_rect(Rect2(child_x - 4, child_y - 13.0 - bounce, 8, 13), Color(0.4, 0.15, 0.1 + float(chi) * 0.08, 0.3))
		# Legs
		draw_line(Vector2(child_x - 2, child_y - bounce), Vector2(child_x - 3, child_y + 6.0), Color(0.25, 0.15, 0.1, 0.3), 1.5)
		draw_line(Vector2(child_x + 2, child_y - bounce), Vector2(child_x + 3, child_y + 6.0), Color(0.25, 0.15, 0.1, 0.3), 1.5)
		# Scarf
		var scarf_col := Color(0.7, 0.1, 0.1, 0.3) if chi != 1 else Color(0.1, 0.4, 0.1, 0.3)
		draw_line(Vector2(child_x - 3, child_y - 14.0 - bounce), Vector2(child_x - 8, child_y - 10.0 - bounce), scarf_col, 2.0)

	# === GROUND — Snow-covered cobblestone ===
	var ground_top := 440.0
	for gi in range(20):
		var gt := float(gi) / 19.0
		var gy := ground_top + gt * (628.0 - ground_top)
		# Transition: snow white on top, darker cobblestone beneath
		var gc := Color(0.55, 0.55, 0.6).lerp(Color(0.15, 0.13, 0.12), gt)
		# Warm golden reflection on left, cold on right
		if gt < 0.3:
			gc = gc.lerp(Color(0.7, 0.6, 0.45), (1.0 - gt / 0.3) * 0.1)
		draw_rect(Rect2(0, gy, 1280, (628.0 - ground_top) / 19.0 + 2.0), gc)

	# Snow accumulation patches
	for sp2 in range(14):
		var sx2 := float(sp2) * 95.0 + 20.0
		var sy2 := ground_top + 2.0 + sin(float(sp2) * 1.9) * 5.0
		draw_circle(Vector2(sx2, sy2), 20.0 + sin(float(sp2) * 2.7) * 8.0, Color(0.75, 0.77, 0.82, 0.1))

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"lamp_post":
				var lp = dec["pos"]
				var ls = dec["size"]
				draw_line(lp, lp + Vector2(0, -ls * 1.4), Color(0.15, 0.12, 0.1, 0.6), 3.0)
				var lamp_top = lp + Vector2(0, -ls * 1.4)
				draw_rect(Rect2(lamp_top.x - ls * 0.2, lamp_top.y - ls * 0.4, ls * 0.4, ls * 0.4), Color(0.18, 0.14, 0.1, 0.5))
				var flicker = sin(_time * 6.0 + dec["extra"]) * 0.15
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.15 + flicker, Color(1.0, 0.75, 0.2, 0.55 + flicker))
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.8, Color(1.0, 0.7, 0.2, 0.04))
			"bare_tree":
				var tp = dec["pos"]
				var ts = dec["size"]
				var sh = dec["extra"]
				draw_line(tp, tp + Vector2(0, -ts * 1.4), Color(0.12, 0.1, 0.08, 0.5), 3.0)
				var branch_base = tp + Vector2(0, -ts * 1.4)
				for b in range(4):
					var b_angle = -PI * 0.6 + float(b) * 0.4 + sin(float(int(sh * 100) + b)) * 0.2
					var b_len = ts * (0.6 + float(b) * 0.2)
					draw_line(branch_base + Vector2(0, float(b) * ts * 0.2), branch_base + Vector2(0, float(b) * ts * 0.2) + Vector2.from_angle(b_angle) * b_len, Color(0.12, 0.1, 0.08, 0.4), 1.5)
			"snow_pile":
				draw_circle(dec["pos"], dec["size"], Color(0.85, 0.87, 0.9, 0.15))
				draw_circle(dec["pos"] + Vector2(dec["size"] * 0.3, -dec["size"] * 0.2), dec["size"] * 0.7, Color(0.88, 0.9, 0.92, 0.12))
			"chimney":
				var cp2 = dec["pos"]
				var cs2 = dec["size"]
				draw_rect(Rect2(cp2.x - cs2 * 0.4, cp2.y - cs2 * 2, cs2 * 0.8, cs2 * 2), Color(0.15, 0.12, 0.1, 0.4))
				var cf = sin(_time * 0.5 + dec["extra"]) * 4.0
				draw_circle(Vector2(cp2.x + cf, cp2.y - cs2 * 2.2), 4.0, Color(0.4, 0.4, 0.45, 0.06))

	# === FOREGROUND — Falling snow and warm/cold atmosphere ===
	# Falling snowflakes
	for sf in range(25):
		var sway := sin(_time * 1.5 + float(sf) * 2.3) * 15.0
		var sf_x := fmod(float(sf) * 57.0 + sway + sin(float(sf) * 4.1) * 100.0, 1280.0)
		var sf_y := fmod(float(sf) * 37.0 + _time * (15.0 + float(sf) * 0.5), 578.0) + 50.0
		var sf_size := 1.0 + sin(float(sf) * 1.3) * 0.5
		var sf_alpha := 0.12 + sin(_time * 2.0 + float(sf)) * 0.04
		draw_circle(Vector2(sf_x, sf_y), sf_size, Color(0.9, 0.92, 0.95, sf_alpha))

	# Warm foreground glow on far left (dawn light hitting ground)
	draw_circle(Vector2(0, 500), 150.0, Color(0.8, 0.55, 0.15, 0.03))
	draw_circle(Vector2(50, 550), 100.0, Color(0.85, 0.6, 0.2, 0.025))

	# Cold shadow on right foreground
	draw_rect(Rect2(900, 500, 380, 128), Color(0.04, 0.04, 0.08, 0.06))

	# Foreground lamp post silhouette (closer, larger)
	var fg_lamp_x := 1200.0
	draw_line(Vector2(fg_lamp_x, 628), Vector2(fg_lamp_x, 520), Color(0.06, 0.05, 0.04, 0.4), 4.0)
	draw_rect(Rect2(fg_lamp_x - 8, 510, 16, 16), Color(0.08, 0.06, 0.05, 0.35))
	var fg_flicker := sin(_time * 5.0) * 0.1
	draw_circle(Vector2(fg_lamp_x, 508), 5.0 + fg_flicker, Color(1.0, 0.8, 0.3, 0.4 + fg_flicker))
	draw_circle(Vector2(fg_lamp_x, 508), 25.0, Color(1.0, 0.75, 0.25, 0.04))
	_draw_scrooge_novel(3)
	_draw_shadow_author_effects()

func _on_tower_pressed(tower_type: TowerType, desc: String) -> void:
	_play_sfx(_sfx_ui_click)
	_deselect_tower()
	if not _is_character_unlocked(tower_type):
		info_label.text = "%s is not yet unlocked!" % tower_info[tower_type]["name"]
		return
	if purchased_towers.has(tower_type):
		info_label.text = "%s is already placed!" % tower_info[tower_type]["name"]
		return
	var cost = _get_discounted_cost(tower_type)
	if gold < cost:
		info_label.text = "Need %dG for %s! (Have %dG)" % [cost, tower_info[tower_type]["name"], gold]
		_insufficient_gold_flash = 1.0
		return
	selected_tower = tower_type
	placing_tower = true
	cancel_button.visible = true
	# Add synergy hints to placement info
	var synergy_hints = ""
	for syn in synergy_definitions:
		if syn["tower_a"] == tower_type or syn["tower_b"] == tower_type:
			var partner = syn["tower_b"] if syn["tower_a"] == tower_type else syn["tower_a"]
			if purchased_towers.has(partner):
				synergy_hints += " ★ SYNERGY: %s" % syn["name"]
	info_label.text = desc + synergy_hints

func _on_cancel_placement() -> void:
	placing_tower = false
	cancel_button.visible = false
	info_label.text = "Placement cancelled."

func _find_tower_at(pos: Vector2) -> Node2D:
	var closest: Node2D = null
	var closest_dist: float = TOWER_SELECT_RADIUS
	for tower in get_tree().get_nodes_in_group("towers"):
		var dist = pos.distance_to(tower.global_position)
		if dist < closest_dist:
			closest = tower
			closest_dist = dist
	return closest

func _select_tower(tower: Node2D) -> void:
	_deselect_tower()
	selected_tower_node = tower
	tower.is_selected = true
	_update_upgrade_panel()

func _deselect_tower() -> void:
	if selected_tower_node and is_instance_valid(selected_tower_node):
		selected_tower_node.is_selected = false
	selected_tower_node = null
	_hide_upgrade_panel()

func _update_upgrade_panel() -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		_hide_upgrade_panel()
		return
	var tower = selected_tower_node
	var display_name = tower.get_tower_display_name() if tower.has_method("get_tower_display_name") else "Tower"
	upgrade_name_label.text = display_name

	# Update targeting priority button
	if tower.has_method("get_targeting_label"):
		targeting_button.text = "Target: %s" % tower.get_targeting_label()
		targeting_button.visible = true
	else:
		targeting_button.visible = false

	# Update all 4 upgrade slots
	for i in range(4):
		var btn = upgrade_buttons[i]
		var cost_lbl = upgrade_cost_labels[i]
		var status_rect = upgrade_status_rects[i]

		var tier_name = tower.TIER_NAMES[i] if i < tower.TIER_NAMES.size() else "?"
		var tier_cost = tower.TIER_COSTS[i] if i < tower.TIER_COSTS.size() else 0
		var tier_desc = tower.ABILITY_DESCRIPTIONS[i] if i < tower.ABILITY_DESCRIPTIONS.size() else ""

		var desc_lbl = upgrade_desc_labels[i]
		desc_lbl.text = tier_desc

		if i < tower.upgrade_tier:
			# Already purchased — green
			btn.text = "%s  ✔" % tier_name
			btn.disabled = true
			cost_lbl.text = "OWNED"
			cost_lbl.add_theme_color_override("font_color", Color(0.4, 0.8, 0.3))
			desc_lbl.add_theme_color_override("font_color", Color(0.6, 0.8, 0.5, 0.7))
			status_rect.color = Color(0.08, 0.18, 0.06, 0.85)
			# Green border
			status_rect.get_child(0).color = Color(0.3, 0.7, 0.2, 0.5)
		elif i == tower.upgrade_tier:
			# Next available — check if affordable
			btn.text = tier_name
			var can_afford = gold >= tier_cost
			btn.disabled = not can_afford
			cost_lbl.text = "%dG" % tier_cost
			desc_lbl.add_theme_color_override("font_color", Color(0.85, 0.82, 0.75, 0.9))
			if can_afford:
				# Affordable — gold border
				cost_lbl.add_theme_color_override("font_color", Color(1.0, 0.84, 0.0))
				status_rect.color = Color(0.14, 0.10, 0.06, 0.85)
				status_rect.get_child(0).color = Color(0.85, 0.65, 0.1, 0.6)
			else:
				# Too expensive — dark
				cost_lbl.add_theme_color_override("font_color", Color(0.6, 0.4, 0.3))
				status_rect.color = Color(0.10, 0.07, 0.12, 0.85)
				status_rect.get_child(0).color = Color(0.4, 0.3, 0.5, 0.3)
		else:
			# Locked — gray
			btn.text = tier_name
			btn.disabled = true
			cost_lbl.text = "%dG" % tier_cost
			cost_lbl.add_theme_color_override("font_color", Color(0.4, 0.35, 0.3))
			desc_lbl.add_theme_color_override("font_color", Color(0.5, 0.48, 0.55, 0.5))
			status_rect.color = Color(0.08, 0.06, 0.10, 0.7)
			status_rect.get_child(0).color = Color(0.25, 0.2, 0.3, 0.3)

	# Update sell button
	if tower.has_method("get_sell_value"):
		var sv = tower.get_sell_value()
		sell_value_label.text = "Refund: %dG" % sv
	else:
		sell_value_label.text = ""

	# Update hero ability button
	var hab = upgrade_panel.get_node_or_null("HeroAbilityBtn")
	if hab:
		if tower.has_method("activate_hero_ability"):
			hab.visible = true
			var ab_name = tower.get_active_ability_name() if tower.has_method("get_active_ability_name") else "ABILITY"
			if "active_ability_ready" in tower and tower.active_ability_ready:
				hab.text = ab_name
				hab.disabled = false
			else:
				var cd_left = tower.active_ability_cooldown if "active_ability_cooldown" in tower else 0.0
				hab.text = "%s (%ds)" % [ab_name, int(cd_left)]
				hab.disabled = true
		else:
			hab.visible = false

	# Trigger portrait redraw for the selected tower
	var portrait_ctrl = upgrade_panel.get_node_or_null("PortraitDraw")
	if portrait_ctrl:
		portrait_ctrl.queue_redraw()

	upgrade_panel.visible = true

func _hide_upgrade_panel() -> void:
	upgrade_panel.visible = false
	var hab = upgrade_panel.get_node_or_null("HeroAbilityBtn")
	if hab:
		hab.visible = false

func _on_upgrade_tier_pressed(tier_index: int) -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	# Only allow purchasing the next tier in sequence
	if tier_index != selected_tower_node.upgrade_tier:
		return
	if selected_tower_node.has_method("purchase_upgrade"):
		# Check cost before attempting purchase for feedback
		var upgrade_cost = 0
		if selected_tower_node.has_method("get_next_upgrade_info"):
			var info = selected_tower_node.get_next_upgrade_info()
			upgrade_cost = info.get("cost", 0)
		if selected_tower_node.purchase_upgrade():
			_update_upgrade_panel()
			_refresh_music_max_tier()  # Update tempo scaling cache
			var tier_name = selected_tower_node.TIER_NAMES[selected_tower_node.upgrade_tier - 1]
			info_label.text = "Upgraded: %s!" % tier_name
			spawn_floating_text(selected_tower_node.global_position + Vector2(0, -30), tier_name + "!", Color(0.4, 1.0, 0.5), 15.0, 1.2)
			# Achievement: max power (tier 4)
			if selected_tower_node.upgrade_tier >= 4:
				_check_achievement("max_power", 1)
				_update_quest_progress("max_upgrades", 1)
		else:
			# Can't afford or already maxed — flash gold label
			if upgrade_cost > gold:
				info_label.text = "Need %dG! (Have %dG)" % [upgrade_cost, gold]
				_insufficient_gold_flash = 1.0

func _on_targeting_pressed() -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	if selected_tower_node.has_method("cycle_targeting"):
		selected_tower_node.cycle_targeting()
	if selected_tower_node.has_method("get_targeting_label"):
		targeting_button.text = "Target: %s" % selected_tower_node.get_targeting_label()

func _on_hero_ability_pressed() -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	var tower = selected_tower_node
	if tower.has_method("activate_hero_ability"):
		if "active_ability_ready" in tower and tower.active_ability_ready:
			_play_sfx(_sfx_ui_click)
			tower.activate_hero_ability()
			_update_upgrade_panel()

func _on_sell_pressed() -> void:
	if selected_difficulty == PURE_MODE:
		info_label.text = "Selling disabled in Pure Mode!"
		return
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	var tower = selected_tower_node
	var sell_value = 0
	if tower.has_method("get_sell_value"):
		sell_value = tower.get_sell_value()
	# Include branch upgrade costs in sell refund (60% like base)
	if tower.has_meta("branch_upgrades"):
		var branch_ups = tower.get_meta("branch_upgrades")
		for bu in branch_ups:
			sell_value += int(bu.get("cost", 0) * 0.6)
	var tower_name = tower.get_tower_display_name() if tower.has_method("get_tower_display_name") else "Tower"
	var tower_pos = tower.global_position

	# Refund gold (tracked for achievements/quests)
	add_gold(sell_value)
	spawn_floating_text(tower_pos + Vector2(0, -20), "+%dG" % sell_value, Color(1.0, 0.85, 0.2), 16.0, 1.2)

	# Remove tower position from placement tracking
	for i in range(placed_tower_positions.size() - 1, -1, -1):
		if placed_tower_positions[i].distance_to(tower_pos) < 5.0:
			placed_tower_positions.remove_at(i)
			break

	# Re-enable the tower button for this type (with discounted cost)
	for tower_type in tower_info.keys():
		if tower_info[tower_type]["name"] == tower_name:
			purchased_towers.erase(tower_type)
			if tower_buttons.has(tower_type):
				var display_cost = _get_discounted_cost(tower_type)
				var short_name = tower_name.split(" ")[0] if tower_name.length() > 8 else tower_name
				tower_buttons[tower_type].text = "%s [%dG]" % [short_name, display_cost]
				tower_buttons[tower_type].disabled = false
			break

	# Deselect and destroy
	_deselect_tower()
	tower.queue_free()
	info_label.text = "%s sold for %dG!" % [tower_name, sell_value]
	# Layered music: fade out this character's instrument layer
	for tt in tower_info.keys():
		if tower_info[tt]["name"] == tower_name:
			_fade_out_tower_layer(tt)
			break

	# Re-check synergies after tower is freed (2-frame delay to ensure queue_free completes)
	get_tree().create_timer(0.05).timeout.connect(_check_synergies)

func _on_speed_pressed() -> void:
	_play_sfx(_sfx_ui_click)
	# Cycle through speeds: 1x → 2x → 3x → 1x
	if not fast_forward:
		fast_forward = true
		_game_speed_level = 2.0
		if not game_paused:
			Engine.time_scale = 2.0
		speed_button.text = "  [2x]  "
	elif _game_speed_level < 2.5:
		_game_speed_level = 3.0
		if not game_paused:
			Engine.time_scale = 3.0
		speed_button.text = "  [3x]  "
	else:
		fast_forward = false
		_game_speed_level = 1.0
		if not game_paused:
			Engine.time_scale = 1.0
		speed_button.text = "  >>  "
		current_game_fast_forward_only = false

func _on_sfx_mute_pressed() -> void:
	sfx_muted = not sfx_muted
	sfx_mute_button.text = " [SFX] " if sfx_muted else " SFX "

func _on_voice_mute_pressed() -> void:
	voices_muted = not voices_muted
	voice_mute_button.text = " [VOX] " if voices_muted else " VOX "

func _on_auto_wave_toggled() -> void:
	_play_sfx(_sfx_ui_click)
	if not auto_wave_enabled:
		# Turn auto on at current delay
		auto_wave_enabled = true
		auto_wave_delay = auto_wave_delay_options[auto_wave_delay_index]
	else:
		# Cycle delay, turn off after last option
		auto_wave_delay_index += 1
		if auto_wave_delay_index >= auto_wave_delay_options.size():
			auto_wave_delay_index = 0
			auto_wave_enabled = false
		else:
			auto_wave_delay = auto_wave_delay_options[auto_wave_delay_index]
	if auto_wave_enabled:
		auto_wave_btn.text = " AUTO %ds " % int(auto_wave_delay)
	else:
		auto_wave_btn.text = " AUTO OFF "
		wave_auto_timer = -1.0
		if not is_wave_active and wave < total_waves:
			start_button.text = "  START WAVE  "
	_save_game()

func _on_start_wave_pressed() -> void:
	_play_sfx(_sfx_ui_click)
	if is_wave_active:
		if game_paused:
			# Resume
			game_paused = false
			Engine.time_scale = _game_speed_level if fast_forward else 1.0
			start_button.text = "  ⏸ Pause  "
			queue_redraw()
		else:
			# Pause
			game_paused = true
			Engine.time_scale = 0.0
			start_button.text = "  ▶ Resume  "
			queue_redraw()
		return
	wave_auto_timer = -1.0
	_start_next_wave()

func _on_restart_pressed() -> void:
	if game_state != GameState.PLAYING:
		return
	if not is_wave_active and wave == 0:
		return
	# Kill all active enemies
	for enemy in get_tree().get_nodes_in_group("enemies"):
		enemy.queue_free()
	# Reset wave state
	enemies_alive = 0
	enemies_to_spawn = 0
	spawn_timer = 0.0
	is_wave_active = false
	game_paused = false
	wave_auto_timer = -1.0
	# Restore gold/lives to wave-start snapshot
	gold = wave_start_gold
	lives = wave_start_lives
	# Decrement wave so _start_next_wave replays the same wave
	wave -= 1
	# Reset tower cooldowns and abilities for fresh wave retry
	for tower in get_tree().get_nodes_in_group("towers"):
		if "fire_cooldown" in tower:
			tower.fire_cooldown = 0.0
		if "_attack_anim" in tower:
			tower._attack_anim = 0.0
		if "target" in tower:
			tower.target = null
	# Reset time scale
	Engine.time_scale = _game_speed_level if fast_forward else 1.0
	# Re-enable start button
	start_button.disabled = false
	start_button.text = "  START WAVE  "
	update_hud()
	info_label.text = "Wave %d restarted. Ready to go!" % (wave + 1)
	queue_redraw()

func _on_quick_restart_pressed() -> void:
	if game_state != GameState.PLAYING:
		return
	_play_sfx(_sfx_ui_click)
	_reset_game()
	if daily_challenge_active:
		_do_level_start(daily_challenge_level)
	elif boss_rush_mode:
		_start_boss_rush()
	elif endless_mode:
		_start_endless_mode()
	else:
		_do_level_start(current_level)

func _on_undo_placement() -> void:
	if undo_tower_data.is_empty():
		return
	_play_sfx(_sfx_ui_click)
	var tower_node = undo_tower_data.get("node")
	var refund = undo_tower_data.get("cost", 0)
	var tower_type = undo_tower_data.get("type", -1)
	var tower_pos = undo_tower_data.get("position", Vector2.ZERO)
	# Refund gold
	add_gold(refund)
	# Remove from placed positions
	var idx = placed_tower_positions.find(tower_pos)
	if idx >= 0:
		placed_tower_positions.remove_at(idx)
	# Re-enable purchase
	if purchased_towers.has(tower_type):
		purchased_towers.erase(tower_type)
		if tower_buttons.has(tower_type) and is_instance_valid(tower_buttons[tower_type]):
			tower_buttons[tower_type].disabled = false
	# Remove tower
	if is_instance_valid(tower_node):
		tower_node.queue_free()
	# Clear undo state
	undo_tower_data.clear()
	undo_button.visible = false
	spawn_floating_text(tower_pos, "UNDO +%dG" % refund, Color(0.4, 1.0, 0.6), 16.0, 1.2)
	update_hud()
	queue_redraw()

func _start_next_wave() -> void:
	_award_affinity_for_wave()
	_tick_relic_usage()
	if not fast_forward:
		current_game_fast_forward_only = false
	if is_wave_active or wave >= total_waves:
		return
	# BATTD: Early Wave Send Bonus (send while enemies alive for bonus gold)
	_early_send_bonus = 0
	if enemies_alive > 0:
		_early_send_bonus = 5 + enemies_alive * 3
		add_gold(_early_send_bonus)
		_income_breakdown["early_send"] = _income_breakdown.get("early_send", 0) + _early_send_bonus
		spawn_floating_text(Vector2(640, 260), "EARLY SEND +%dG!" % _early_send_bonus, Color(0.3, 1.0, 0.5), 16.0, 1.2)
	# BATTD: Reset kill counter for new wave
	_wave_enemies_killed = 0
	# BATTD: Wave rush timer
	_wave_start_time = _time
	# BATTD: Income breakdown reset
	_income_breakdown = {"kills": 0, "wave_bonus": 0, "combo": 0, "early_send": _early_send_bonus, "lucky": 0}
	wave += 1
	is_wave_active = true
	game_paused = false
	# Clear undo and wave preview on wave start
	undo_tower_data.clear()
	if is_instance_valid(undo_button):
		undo_button.visible = false
	wave_preview_active = false
	_play_sfx(_sfx_wave_start)
	music_beat_index = 0
	_music_beat_accum = 0.0
	enemies_to_spawn = _get_wave_enemy_count(wave)
	_wave_enemies_total = enemies_to_spawn
	spawn_interval = _get_wave_spawn_interval(wave)
	spawn_timer = 0.0
	wave_start_gold = gold
	wave_start_lives = lives
	start_button.disabled = false
	start_button.text = "  ⏸ Pause  "
	var wave_name = _get_wave_name(wave)
	var enemy_word = "enemy" if enemies_to_spawn == 1 else "enemies"
	info_label.text = "Wave %d — %s (%d %s)" % [wave, wave_name, enemies_to_spawn, enemy_word]
	# Wave number banner
	_wave_banner_timer = 2.5
	_wave_banner_num = wave
	_wave_banner_name = wave_name
	_wave_banner_is_boss = wave in [20, 25, 30, 35] or wave == total_waves
	# Boss wave alert
	if wave in [20, 25, 30, 35] or wave == total_waves or (wave >= 39 and selected_difficulty >= 2):
		_boss_alert_timer = 2.5
		if wave == total_waves:
			_boss_alert_text = "FINAL WAVE"
		elif wave >= 39 and selected_difficulty >= 2:
			_boss_alert_text = "FINAL VILLAIN"
		else:
			_boss_alert_text = "BOSS WAVE"
		_screen_shake_timer = 0.4
		_screen_shake_intensity = 5.0
		if _is_mobile:
			Input.vibrate_handheld(80)
	# Endless mode: mutate every 5 waves
	if endless_mode and wave > 0 and wave % 5 == 0:
		endless_mutation = ENDLESS_MUTATIONS[randi() % ENDLESS_MUTATIONS.size()]
		spawn_floating_text(Vector2(640, 200), "MUTATION: " + endless_mutation, Color(1.0, 0.3, 0.1), 22.0, 2.5)
		_screen_shake_timer = 0.3
		_screen_shake_intensity = 4.0
	# Boss rush: track wave
	if boss_rush_mode:
		boss_rush_wave = wave
		if boss_rush_wave > boss_rush_best_wave:
			boss_rush_best_wave = boss_rush_wave
	# Award wave survival XP to all placed towers (small bonus each wave)
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.has_method("register_damage"):
			var wave_xp = 5.0 + wave * 2.0  # Growing XP per wave
			tower.register_damage(wave_xp)
	# Notify towers that a wave started
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.has_method("on_wave_start"):
			tower.on_wave_start(wave)
	update_hud()

func update_hud() -> void:
	if wave_label:
		if endless_mode:
			wave_label.text = "Wave: %d (Endless)" % wave
		elif shadow_arena_active:
			wave_label.text = "Arena Wave: %d" % wave
		else:
			var diff_indicator = ["", " [M]", " [H]", " [P]"][mini(selected_difficulty, 3)]
			wave_label.text = "Wave: %d/%d%s" % [wave, total_waves, diff_indicator]
		# Show enemy count during active waves
		if is_wave_active:
			var remaining = enemies_alive + enemies_to_spawn
			wave_label.text += "  (%d left)" % remaining
	if gold_label:
		gold_label.text = "Gold: %s" % _format_gold(gold)
		if _insufficient_gold_flash > 0.0:
			var flash_a = clampf(_insufficient_gold_flash, 0.0, 1.0)
			gold_label.add_theme_color_override("font_color", Color(1.0, 0.3, 0.2).lerp(Color(1.0, 0.84, 0.0), 1.0 - flash_a))
		else:
			gold_label.add_theme_color_override("font_color", Color(1.0, 0.84, 0.0))
	if lives_label:
		lives_label.text = "Lives: %d" % lives
		var max_lives = difficulty_fixed_lives[mini(selected_difficulty, difficulty_fixed_lives.size() - 1)] if selected_difficulty < difficulty_fixed_lives.size() else 100
		var life_pct = float(lives) / float(max(1, max_lives))
		if life_pct <= 0.2:
			lives_label.add_theme_color_override("font_color", Color(1.0, 0.15, 0.1))
		elif life_pct <= 0.5:
			lives_label.add_theme_color_override("font_color", Color(1.0, 0.6, 0.2))
		else:
			lives_label.add_theme_color_override("font_color", Color(1.0, 0.39, 0.28))
	if selected_tower_node and is_instance_valid(selected_tower_node):
		_update_upgrade_panel()

func get_path_points() -> PackedVector2Array:
	return path_points

func add_gold(amount: int) -> void:
	# BATTD: Double Cash Mode doubles all gold income
	if double_cash_enabled and amount > 0:
		amount *= 2
	gold += amount
	total_gold_earned += amount
	_check_achievement("penny_pincher", amount)
	_update_quest_progress("earn_gold", amount)
	update_hud()

func spend_gold(amount: int) -> bool:
	if gold >= amount:
		gold -= amount
		total_gold_spent += amount
		_check_achievement("big_spender", amount)
		update_hud()
		return true
	return false

func lose_life() -> void:
	# Storybook Shield blocks life loss
	if storybook_shield_charges > 0:
		storybook_shield_charges -= 1
		spawn_floating_text(Vector2(640, 400), "Shield blocked!", Color(0.3, 0.8, 1.0), 14.0, 0.8)
		return
	lives -= 1
	if lives < 0:
		lives = 0
	current_game_lives_lost += 1
	# Red screen flash on life loss + warning sound + haptic
	_death_flash_timer = 0.15
	_play_sfx(_sfx_life_lost)
	if _is_mobile:
		Input.vibrate_handheld(100)
	spawn_floating_text(Vector2(420, 30), "-1 LIFE!", Color(1.0, 0.2, 0.15, 1.0), 18.0, 0.8)
	update_hud()
	if lives <= 0:
		if odyssey_active:
			_odyssey_defeat()
		game_over()

func _quest_track_kill(enemy_node = null) -> void:
	_update_quest_progress("kill", 1)
	if enemy_node and enemy_node.get("is_shadow_infested"):
		_update_quest_progress("kill_shadow", 1)

func enemy_died(enemy_node = null) -> void:
	enemies_alive = maxi(enemies_alive - 1, 0)
	total_enemies_killed += 1
	_check_achievement("first_blood", 1)
	_check_achievement("centurion", 1)
	_check_achievement("thousand_slayer", 1)
	_quest_track_kill(enemy_node)
	# BATTD: Kill counter
	_wave_enemies_killed += 1
	# BATTD: Lucky loot drops (5% chance for bonus shards/quills)
	if randf() < LUCKY_DROP_CHANCE:
		var lucky_amount = randi_range(1, 3)
		if randf() < 0.5:
			player_relic_shards += lucky_amount
			if enemy_node and is_instance_valid(enemy_node):
				spawn_floating_text(enemy_node.global_position + Vector2(0, -20), "+%d Shards!" % lucky_amount, Color(0.6, 0.4, 1.0), 14.0, 1.0)
		else:
			player_quills += lucky_amount
			if enemy_node and is_instance_valid(enemy_node):
				spawn_floating_text(enemy_node.global_position + Vector2(0, -20), "+%d Quills!" % lucky_amount, Color(0.2, 0.8, 0.6), 14.0, 1.0)
		_lucky_drops_this_game += 1
		_income_breakdown["lucky"] = _income_breakdown.get("lucky", 0) + lucky_amount
	# BATTD: Bounty tracking
	if _active_bounties.size() > 0 and enemy_node and is_instance_valid(enemy_node):
		var e_tier = enemy_node.enemy_tier if "enemy_tier" in enemy_node else 0
		var is_boss = enemy_node.boss_scale > 1.0 if "boss_scale" in enemy_node else false
		for bounty in _active_bounties:
			if bounty["progress"] >= bounty["target"]:
				continue
			var matched = false
			if bounty["kill_type"] == "any":
				matched = true
			elif bounty["kill_type"] == "boss" and is_boss:
				matched = true
			elif bounty["kill_type"] == "tier3" and e_tier >= 3:
				matched = true
			elif bounty["kill_type"] == "tier2" and e_tier >= 2:
				matched = true
			if matched:
				bounty["progress"] += 1
				if bounty["progress"] >= bounty["target"]:
					_bounties_completed_total += 1
					if bounty["reward_type"] == "gold":
						add_gold(bounty["reward_amount"])
					elif bounty["reward_type"] == "shards":
						player_relic_shards += bounty["reward_amount"]
					elif bounty["reward_type"] == "quills":
						player_quills += bounty["reward_amount"]
					spawn_floating_text(Vector2(640, 280), "BOUNTY COMPLETE! +%d %s" % [bounty["reward_amount"], bounty["reward_type"].capitalize()], Color(1.0, 0.7, 0.1), 18.0, 2.0)
	# Combo kill tracking
	combo_count += 1
	combo_timer = COMBO_WINDOW
	if enemy_node and is_instance_valid(enemy_node):
		combo_last_pos = enemy_node.global_position
	if combo_count >= COMBO_MIN:
		var bonus_gold = combo_count * 2
		add_gold(bonus_gold)
		spawn_floating_text(combo_last_pos + Vector2(0, -30), "COMBO x%d +%dG" % [combo_count, bonus_gold], Color(1.0, 0.5, 0.1), 18.0, 1.2)
		if combo_count > combo_best:
			combo_best = combo_count

# === FLOATING TEXTS ===
func spawn_floating_text(pos: Vector2, text: String, color: Color, size: float = 14.0, duration: float = 1.0) -> void:
	if _floating_texts.size() >= 100:
		_floating_texts.pop_front()
	_floating_texts.append({
		"pos": pos, "text": text, "color": color, "size": size,
		"duration": duration, "timer": duration, "vel_y": -60.0
	})

func spawn_damage_number(pos: Vector2, amount: float, is_boss: bool) -> void:
	var text = str(int(amount))
	var color = Color(1.0, 1.0, 1.0, 0.9)
	var size = 14.0
	if is_boss:
		color = Color(1.0, 0.3, 0.2, 1.0)
		size = 20.0
	elif amount > 500.0:
		color = Color(1.0, 0.85, 0.2, 1.0)
		text = str(int(amount)) + "!"
		size = 17.0
	spawn_floating_text(pos + Vector2(randf_range(-8, 8), randf_range(-12, -4)), text, color, size, 0.8)

func spawn_gold_text(pos: Vector2, amount: int) -> void:
	spawn_floating_text(pos + Vector2(0, -10), "+%dg" % amount, Color(1.0, 0.85, 0.2, 0.9), 13.0, 1.0)
	# Gold coin pickup arc animation
	_gold_pickups.append({
		"start": pos, "end": Vector2(310, 20), "pos": pos,
		"timer": 0.6, "max_timer": 0.6,
		"spin": randf() * TAU,
	})

# === ENVIRONMENTAL PARTICLES ===
func _init_env_particles() -> void:
	_env_particles.clear()
	for i in range(20):
		_env_particles.append({
			"x": randf_range(0, 1280),
			"y": randf_range(0, 720),
			"dx": randf_range(8.0, 25.0),
			"size": randf_range(1.5, 3.5),
			"phase": randf() * TAU,
			"freq": randf_range(0.5, 1.5),
		})

# === VISUAL POLISH REPORTS ===
func report_aoe_impact(pos: Vector2, radius: float, color: Color) -> void:
	_aoe_impacts.append({"pos": pos, "radius": radius, "color": color, "timer": 0.6, "max_timer": 0.6})

func report_crit_hit(pos: Vector2) -> void:
	_crit_flashes.append({"pos": pos, "timer": 0.4, "max_timer": 0.4})

# === DEATH EFFECTS ===
func report_enemy_death(pos: Vector2, is_boss: bool, scale: float) -> void:
	_play_sfx(_sfx_enemy_death)
	if is_boss:
		# Screen shake
		_screen_shake_timer = 0.5
		_screen_shake_intensity = 8.0 * scale
		# White flash
		_death_flash_timer = 0.1
		# Ink splatters
		for i in range(10 + int(scale * 5)):
			var angle = randf() * TAU
			var speed = randf_range(90.0, 240.0) * scale
			var boss_hue = randf_range(0.0, 0.2)
			_ink_splatters.append({
				"pos": pos, "vel": Vector2(cos(angle), sin(angle)) * speed,
				"radius": randf_range(4.0, 10.0) * scale, "timer": 1.5,
				"color": Color(0.12 + boss_hue, 0.04, 0.15 + boss_hue * 0.3, 0.85)
			})
	else:
		# Small ink puffs
		for i in range(4 + randi() % 3):
			var angle = randf() * TAU
			var speed = randf_range(40.0, 100.0)
			var ink_hue = randf_range(0.0, 0.15)
			_ink_splatters.append({
				"pos": pos, "vel": Vector2(cos(angle), sin(angle)) * speed,
				"radius": randf_range(3.0, 6.0), "timer": 0.5,
				"color": Color(0.1 + ink_hue, 0.06, 0.15 + ink_hue * 0.5, 0.7)
			})

# === ENEMY MODIFIERS ===
func _apply_enemy_modifiers(enemy, wave_num: int, is_boss: bool) -> void:
	if selected_difficulty == 0:
		return  # Easy: no modifiers
	var available = ["spectral", "ironbound", "hexed", "bound", "shadow_infested", "regrown", "fortified", "shielded", "cursed", "phantom", "arcane", "ironclad", "ethereal"]
	# Pure Mode: all modifiers enabled from wave 1, higher chance
	if selected_difficulty == PURE_MODE:
		var pure_chance = 0.35
		if is_boss:
			var mod = available[randi() % available.size()]
			_apply_single_modifier(enemy, mod)
			if randf() < 0.5:
				var mod2 = available[randi() % available.size()]
				if mod2 != mod:
					_apply_single_modifier(enemy, mod2)
		elif randf() < pure_chance:
			available.shuffle()
			_apply_single_modifier(enemy, available[0])
			if randf() < 0.3 and available.size() > 1:
				_apply_single_modifier(enemy, available[1])
		return
	# Shadow Arena may force specific modifiers
	if shadow_arena_active and shadow_arena_modifiers.size() > 0:
		if "shadow_infested" in shadow_arena_modifiers:
			enemy.is_shadow_infested = true
			enemy.max_health *= 1.3
			enemy.health = enemy.max_health
		if "regrow_only" in shadow_arena_modifiers:
			enemy.is_regrown = true
		if "fortified_all" in shadow_arena_modifiers:
			enemy.is_fortified = true
			enemy.max_health *= 1.5
			enemy.health = enemy.max_health
		if "double_hp" in shadow_arena_modifiers:
			enemy.max_health *= 2.0
			enemy.health = enemy.max_health
		if "fast_enemies" in shadow_arena_modifiers:
			enemy.speed *= 1.5
	var min_wave = 15 if selected_difficulty == 1 else 10
	var chance = 0.10 if selected_difficulty == 1 else 0.20
	var max_mods = 1 if selected_difficulty == 1 else 2
	# New modifiers unlock progressively
	if wave_num < 15:
		available = ["spectral", "ironbound", "hexed", "bound", "shadow_infested", "fortified"]
	elif wave_num < 20:
		available = ["spectral", "ironbound", "hexed", "bound", "shadow_infested", "fortified", "arcane"]
	elif wave_num < 25:
		available = ["spectral", "ironbound", "hexed", "bound", "shadow_infested", "regrown", "fortified", "shielded", "cursed", "phantom", "arcane", "ironclad"]
	if wave_num < min_wave and not is_boss:
		return
	if is_boss and selected_difficulty >= 2:
		# Bosses always get 1 modifier on Hard
		var mod = available[randi() % available.size()]
		_apply_single_modifier(enemy, mod)
	elif randf() < chance:
		var count = 1 + (randi() % max_mods if max_mods > 1 and randf() < 0.3 else 0)
		available.shuffle()
		for i in range(min(count, available.size())):
			_apply_single_modifier(enemy, available[i])

func _apply_single_modifier(enemy, mod: String) -> void:
	match mod:
		"ironbound":
			enemy.modifiers.append(mod)
			enemy.max_health *= 2.0
			enemy.health = enemy.max_health
		"bound":
			enemy.modifiers.append(mod)
			enemy.bound_shield = 200.0
		"shadow_infested":
			enemy.is_shadow_infested = true
			enemy.max_health *= 1.3
			enemy.health = enemy.max_health
		"regrown":
			enemy.is_regrown = true
		"fortified":
			enemy.is_fortified = true
			enemy.max_health *= 1.5
			enemy.health = enemy.max_health
		"shielded":
			enemy.is_shielded = true
			enemy.shield_hp = enemy.max_health * 0.3
		"cursed":
			enemy.is_cursed = true
			enemy.speed *= 0.85  # Cursed enemies move slower but debuff towers
		"phantom":
			enemy.is_phantom = true
			enemy.phantom_visible = true
			enemy.phantom_phase_timer = 0.0
		"hexed":
			enemy.modifiers.append(mod)
			enemy.speed *= 1.2
			enemy.max_health *= 0.8
			enemy.health = enemy.max_health
		"spectral":
			enemy.modifiers.append(mod)
			enemy.is_spectral = true
			enemy.max_health *= 0.7
			enemy.health = enemy.max_health
		"arcane":
			enemy.modifiers.append(mod)
			enemy.resistances["magic"] = 0.5
			enemy.max_health *= 0.85
			enemy.health = enemy.max_health
		"ironclad":
			enemy.modifiers.append(mod)
			enemy.immunities.append("magic")
			enemy.max_health *= 1.8
			enemy.health = enemy.max_health
		"ethereal":
			enemy.modifiers.append(mod)
			enemy.immunities.append("physical")
			enemy.max_health *= 0.6
			enemy.health = enemy.max_health
			enemy.speed *= 1.15
		_:
			enemy.modifiers.append(mod)

# === MOAB VILLAIN SPAWN ===
func spawn_moab_children(parent_progress: float, theme: int, child_tier: int, count: int) -> void:
	for i in range(count):
		var child = enemy_scene.instantiate()
		child.add_to_group("enemies")
		child.enemy_theme = theme
		child.enemy_tier = 3  # Always top-tier art
		child.progress = parent_progress + float(i) * 20.0
		if child_tier > 0:
			child.is_moab = true
			child.moab_tier = child_tier
			child.boss_scale = MOAB_TIER_SCALES[child_tier]
			child.max_health = (600.0 + wave * 40.0) * MOAB_TIER_HP_MULT[child_tier] * 0.5 * 1.25
			child.speed = 55.0 + wave * 1.5
			child.gold_reward = 15 + child_tier * 10
			child.boss_name = MOAB_VILLAIN_NAMES.get(theme, "Dark Overlord")
			child.moab_children_count = MOAB_TIER_CHILDREN[child_tier]
		else:
			# Tier 0 MOAB children are just strong regular enemies
			child.max_health = 400.0 + wave * 30.0
			child.speed = 70.0 + wave * 2.0
			child.gold_reward = 8
			child.boss_scale = 1.5
		child.health = child.max_health
		enemy_path.add_child(child)
		enemies_alive += 1

func spawn_regrow_children(parent_progress: float, theme: int, tier: int, generation: int, child_hp: float) -> void:
	for i in range(2):
		var child = enemy_scene.instantiate()
		child.add_to_group("enemies")
		child.enemy_theme = theme
		child.enemy_tier = max(0, tier - 1)
		child.progress = parent_progress + float(i) * 15.0
		child.is_regrown = true
		child.regrow_generation = generation
		child.max_health = child_hp
		child.health = child_hp
		child.speed = 90.0 + wave * 2.5
		child.gold_reward = 3
		child.boss_scale = 0.7 / float(generation)
		enemy_path.add_child(child)
		enemies_alive += 1

func spawn_boss_minions(parent_progress: float, theme: int, count: int) -> void:
	for i in range(count):
		var child = enemy_scene.instantiate()
		child.add_to_group("enemies")
		child.enemy_theme = theme
		child.enemy_tier = 1
		child.progress = parent_progress + float(i) * 25.0 - float(count) * 12.0
		child.max_health = 80.0 + wave * 12.0
		child.health = child.max_health
		child.speed = 90.0 + wave * 2.0
		child.gold_reward = 3
		child.boss_scale = 0.8
		enemy_path.add_child(child)
		enemies_alive += 1

var boss_danger_zones: Array = []

func add_boss_danger_zone(pos: Vector2) -> void:
	boss_danger_zones.append({"pos": pos, "timer": 8.0, "radius": 80.0})

func _spawn_moab_wave(theme: int, tier: int) -> void:
	# Spawn a MOAB villain enemy for special waves
	var moab = enemy_scene.instantiate()
	moab.add_to_group("enemies")
	moab.enemy_theme = theme
	moab.enemy_tier = 3
	moab.is_moab = true
	moab.moab_tier = tier
	moab.boss_scale = MOAB_TIER_SCALES[tier]
	moab.boss_name = MOAB_VILLAIN_NAMES.get(theme, "Dark Overlord")
	moab.moab_children_count = MOAB_TIER_CHILDREN[tier]
	var diff_mult = [0.85, 1.0, 1.2, 1.5][mini(selected_difficulty, 3)]
	moab.max_health = (600.0 + wave * 40.0) * MOAB_TIER_HP_MULT[tier] * diff_mult * 1.25
	moab.speed = (50.0 + wave * 1.0) * (0.9 + selected_difficulty * 0.05)
	moab.gold_reward = 20 + tier * 15
	moab.health = moab.max_health
	enemy_path.add_child(moab)
	enemies_alive += 1

# === TOME BINDING BONUSES ===
func _get_binding_bonuses(tower_type) -> Dictionary:
	var bonuses: Dictionary = {}
	var bindings = equipped_bindings.get(tower_type, [])
	var char_gear_count = 0
	var tower_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom", "scrooge", "sherlock", "tarzan", "dracula", "merlin", "frankenstein", "scheherazade"]
	var char_name = tower_names[tower_type] if tower_type >= 0 and tower_type < tower_names.size() else ""
	for bid in bindings:
		var binding = _find_binding(bid)
		if binding.is_empty():
			continue
		if binding.get("character", "") == char_name:
			char_gear_count += 1
		# Multi-effect relics use "effects" array
		if binding.has("effects"):
			for fx in binding["effects"]:
				_apply_binding_effect(bonuses, fx.get("effect", ""), fx.get("value", 0.0))
		else:
			# Single-effect relics use "effect"/"value"
			_apply_binding_effect(bonuses, binding.get("effect", ""), binding.get("value", 0.0))
	# Set bonus: 3+ character-specific gear gives +5% all stats per piece
	if char_gear_count >= 3:
		var set_bonus = float(char_gear_count) * 0.05
		for k in ["damage", "range", "attack_speed", "crit"]:
			bonuses[k] = bonuses.get(k, 0.0) + set_bonus
	return bonuses

func _apply_binding_effect(bonuses: Dictionary, eff: String, val: float) -> void:
	match eff:
		"attack_speed", "damage", "range", "crit", "gold_bonus", "slow", "dodge", "splash_radius", "armor_pierce", "crit_damage", "cooldown_reduction", "first_blood", "execute", "wave_gold", "poison", "burn", "chain", "multi_shot", "aura_range", "debuff_amp", "xp_gain", "boss_damage", "lifesteal", "bloodstained", "kill_gold", "absorb_hit", "heal_nearby", "stun", "pierce", "defense", "aura_speed":
			bonuses[eff] = bonuses.get(eff, 0.0) + val
		"raven":
			bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
			bonuses["damage"] = bonuses.get("damage", 0.0) - 0.05
		"candelabra":
			bonuses["range"] = bonuses.get("range", 0.0) + val
			bonuses["damage"] = bonuses.get("damage", 0.0) + 0.05
		"excalibur":
			bonuses["damage"] = bonuses.get("damage", 0.0) + val
			bonuses["crit"] = bonuses.get("crit", 0.0) + 0.05
		"ruby":
			bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
			bonuses["range"] = bonuses.get("range", 0.0) + 0.10
		"all":
			for k in ["damage", "range", "attack_speed", "crit"]:
				bonuses[k] = bonuses.get(k, 0.0) + val

func _pick_weighted_relic(rarity: String, level_character: int) -> Dictionary:
	var char_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom",
		"scrooge", "sherlock", "tarzan", "dracula", "merlin", "frankenstein", "scheherazade"]
	var char_name = char_names[level_character] if level_character >= 0 and level_character < char_names.size() else ""
	var candidates: Array = []
	var weights: Array = []
	for b in TOME_BINDINGS:
		if b["rarity"] != rarity:
			continue
		var w = 1.0
		# Character weighting: 60% chance to prefer current world's character
		if char_name != "" and b.get("character", "") == char_name:
			w = 3.0  # 3x weight for matching character (~60% when 4 char + 6 universal)
		# Duplicate protection: 50% weight reduction for items owned 3+
		var count = owned_bindings.get(b["id"], 0)
		if count >= 3:
			w *= 0.5
		candidates.append(b)
		weights.append(w)
	if candidates.size() == 0:
		return {}
	# Weighted random selection
	var total_w = 0.0
	for ww in weights:
		total_w += ww
	var roll = randf() * total_w
	var accum = 0.0
	for i in range(candidates.size()):
		accum += weights[i]
		if roll <= accum:
			return candidates[i]
	return candidates[candidates.size() - 1]

func _get_highest_completed_level() -> int:
	if completed_levels.size() == 0:
		return -1
	var highest = -1
	for lv in completed_levels:
		if lv > highest:
			highest = lv
	return highest

func _get_binding_slots(tower_type) -> int:
	# Level-based slots: start with 3, unlock more at levels 2,4,6,7,8,9,10 (max 10)
	var level = survivor_progress.get(tower_type, {}).get("level", 1)
	var level_slots = 3
	if level >= 10: level_slots = 10
	elif level >= 9: level_slots = 9
	elif level >= 8: level_slots = 8
	elif level >= 7: level_slots = 7
	elif level >= 6: level_slots = 6
	elif level >= 4: level_slots = 5
	elif level >= 2: level_slots = 4
	# Also factor in golden shield progression
	var shield_slots = _get_binding_slot_count(tower_type)
	return maxi(level_slots, shield_slots)


func _get_ally_slots(tower_type) -> int:
	# BATTD-style: 1 ally slot at start, unlock at levels 3, 5, 10 (max 4)
	var level = survivor_progress.get(tower_type, {}).get("level", 1)
	if level >= 10: return 4
	elif level >= 5: return 3
	elif level >= 3: return 2
	return 1

func _get_level_stat_boosts(tower_type) -> Dictionary:
	# BATTD-style: permanent stat boosts at levels 2,4,6,8,9,10
	var level = survivor_progress.get(tower_type, {}).get("level", 1)
	var boosts = {"damage": 0.0, "range": 0.0, "attack_speed": 0.0}
	if level >= 2: boosts["damage"] += 0.05; boosts["range"] += 0.03
	if level >= 4: boosts["attack_speed"] += 0.08; boosts["damage"] += 0.05
	if level >= 6: boosts["range"] += 0.05; boosts["attack_speed"] += 0.05
	if level >= 8: boosts["damage"] += 0.08; boosts["range"] += 0.05
	if level >= 9: boosts["attack_speed"] += 0.08; boosts["damage"] += 0.05
	if level >= 10: boosts["damage"] += 0.10; boosts["range"] += 0.08; boosts["attack_speed"] += 0.10
	return boosts
func _build_binding_lookup() -> void:
	_binding_lookup.clear()
	for b in TOME_BINDINGS:
		_binding_lookup[b["id"]] = b

func _find_binding(binding_id: String) -> Dictionary:
	return _binding_lookup.get(binding_id, {})

func _tower_type_to_name(tt) -> String:
	match tt:
		TowerType.ROBIN_HOOD: return "robin_hood"
		TowerType.ALICE: return "alice"
		TowerType.WICKED_WITCH: return "wicked_witch"
		TowerType.PETER_PAN: return "peter_pan"
		TowerType.PHANTOM: return "phantom"
		TowerType.SCROOGE: return "scrooge"
		TowerType.SHERLOCK: return "sherlock"
		TowerType.TARZAN: return "tarzan"
		TowerType.DRACULA: return "dracula"
		TowerType.MERLIN: return "merlin"
		TowerType.FRANKENSTEIN: return "frankenstein"
		TowerType.SHADOW_AUTHOR: return "shadow_author"
	return ""

func game_over() -> void:
	game_state = GameState.GAME_OVER_STATE
	_update_career_stats_post_game(false)
	Engine.time_scale = 1.0
	fast_forward = false
	game_paused = false
	_stop_layered_music()
	_play_sfx(_sfx_defeat)
	_death_flash_timer = 0.3  # Dramatic red flash on game over
	# Defeat dramatic effect — screen cracks
	_defeat_timer = 3.0
	_defeat_cracks.clear()
	var center = Vector2(640, 360)
	for ci in range(10):
		var ca = randf() * TAU
		var cl = randf_range(80.0, 250.0)
		_defeat_cracks.append({"from": center, "to": center + Vector2(cos(ca), sin(ca)) * cl})
	speed_button.text = "  >>  "
	_collect_session_damage()
	# BATTD: XP Sharing — unused characters get 25% of avg XP earned
	if xp_sharing_enabled:
		var total_xp_earned = 0.0
		var used_types: Array = []
		for tower in get_tree().get_nodes_in_group("towers"):
			if tower.get("damage_dealt") != null and tower.damage_dealt > 0:
				total_xp_earned += tower.damage_dealt
				var sp = tower.get_script().resource_path.get_file() if tower.get_script() else ""
				var type_map = {"robin_hood.gd": TowerType.ROBIN_HOOD, "alice.gd": TowerType.ALICE, "wicked_witch.gd": TowerType.WICKED_WITCH, "peter_pan.gd": TowerType.PETER_PAN, "phantom.gd": TowerType.PHANTOM, "scrooge.gd": TowerType.SCROOGE, "sherlock.gd": TowerType.SHERLOCK, "tarzan.gd": TowerType.TARZAN, "dracula.gd": TowerType.DRACULA, "merlin.gd": TowerType.MERLIN, "frankenstein.gd": TowerType.FRANKENSTEIN, "shadow_author.gd": TowerType.SHADOW_AUTHOR}
				if type_map.has(sp) and not type_map[sp] in used_types:
					used_types.append(type_map[sp])
		if used_types.size() > 0 and total_xp_earned > 0:
			var avg_xp = total_xp_earned / float(used_types.size())
			var shared_xp = avg_xp * XP_SHARE_RATIO
			for tt in survivor_progress:
				if not tt in used_types and survivor_progress[tt]["level"] < MAX_SURVIVOR_LEVEL:
					var xp_mult = 1.0 + _get_knowledge_bonus("xp_gain")
					survivor_progress[tt]["xp"] += shared_xp * xp_mult
					while survivor_progress[tt]["xp"] >= survivor_progress[tt]["xp_next"] and survivor_progress[tt]["level"] < MAX_SURVIVOR_LEVEL:
						survivor_progress[tt]["xp"] -= survivor_progress[tt]["xp_next"]
						survivor_progress[tt]["level"] += 1
						survivor_progress[tt]["xp_next"] = _get_xp_for_level(survivor_progress[tt]["level"])
						_on_survivor_level_up(tt, survivor_progress[tt]["level"])
	# BATTD: Collect post-victory stats
	_session_stats.clear()
	_session_stats["total_gold_earned"] = total_gold_earned
	_session_stats["total_kills"] = _wave_enemies_killed
	_session_stats["waves_cleared"] = wave
	_session_stats["lucky_drops"] = _lucky_drops_this_game
	_session_stats["bounties_done"] = 0
	for b in _active_bounties:
		if b["progress"] >= b["target"]:
			_session_stats["bounties_done"] += 1
	_session_stats["early_send_total"] = _income_breakdown.get("early_send", 0)
	_session_stats["combo_best"] = combo_count if combo_count > combo_best else combo_best
	if shadow_arena_active:
		_end_shadow_arena()
		game_over_label.text = "SHADOW ARENA - Wave %d\nBest: Wave %d\n+%d Arena Crystals" % [wave, shadow_arena_high_score, wave / 5]
		shadow_arena_active = false
	elif endless_mode:
		if wave > endless_high_wave:
			endless_high_wave = wave
		# Track top 5 endless runs
		var today = Time.get_date_string_from_system()
		endless_top_runs.append({"wave": wave, "date": today})
		endless_top_runs.sort_custom(func(a, b): return a["wave"] > b["wave"])
		if endless_top_runs.size() > 5:
			endless_top_runs.resize(5)
		game_over_label.text = "Reached Wave %d\nBest: Wave %d" % [wave, endless_high_wave]
		endless_mode = false
		_save_game()
	elif boss_rush_mode:
		if wave > boss_rush_best_wave:
			boss_rush_best_wave = wave
		game_over_label.text = "BOSS RUSH — Wave %d/10\nBest: Wave %d" % [wave, boss_rush_best_wave]
		boss_rush_mode = false
		_save_game()
	elif daily_challenge_active:
		game_over_label.text = "DAILY CHALLENGE FAILED\n%s" % daily_challenge_modifier
		daily_challenge_active = false
	else:
		game_over_label.text = "GAME OVER"
		# BATTD2: Reset victory streak on defeat
		victory_streak = 0
		# BATTD: Enable revenge retry with bonus gold
		_revenge_available = true
		var base_gold = levels[current_level]["gold"] if current_level >= 0 and current_level < levels.size() else 150
		_revenge_bonus_pct = 0.20
	game_over_label.add_theme_color_override("font_color", Color.RED)
	game_over_label.add_theme_constant_override("shadow_offset_x", 2)
	game_over_label.add_theme_constant_override("shadow_offset_y", 3)
	game_over_label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.7))
	game_over_label.visible = true
	return_button.visible = true
	retry_button.visible = true
	start_button.disabled = true
	# Save progress (currencies, achievements, etc.) even on defeat
	_save_game()

# === BOSS RESCUE ANIMATION ===
func start_boss_rescue(pos: Vector2, boss_node: Node2D) -> void:
	boss_rescue_active = true
	boss_rescue_pos = pos
	boss_rescue_boss_ref = boss_node
	boss_rescue_timer = 0.0
	boss_rescue_phase = 0
	is_wave_active = false  # Prevent wave complete check during animation
	# Generate smoke particles
	_rescue_smoke_particles.clear()
	for i in range(30):
		_rescue_smoke_particles.append({
			"angle": randf() * TAU,
			"dist": randf_range(40.0, 120.0),
			"speed": randf_range(1.5, 3.5),
			"size": randf_range(4.0, 12.0),
			"offset_y": randf_range(-30.0, 10.0),
		})
	# Play Shadow Author voice if available
	if shadow_author_fight_clips.size() > 0 and not catchphrase_player.playing:
		var clip = shadow_author_fight_clips[randi() % shadow_author_fight_clips.size()]
		catchphrase_player.stream = clip
		catchphrase_player.play()

func _process_boss_rescue(delta: float) -> void:
	if not boss_rescue_active:
		return
	boss_rescue_timer += delta
	# Phase transitions
	if boss_rescue_phase == 0 and boss_rescue_timer >= 1.2:
		boss_rescue_phase = 1
	elif boss_rescue_phase == 1 and boss_rescue_timer >= 2.5:
		boss_rescue_phase = 2
	elif boss_rescue_phase == 2 and boss_rescue_timer >= 3.5:
		boss_rescue_phase = 3
		# Screen shake on flash
		_screen_shake_timer = 0.6
		_screen_shake_intensity = 12.0
	elif boss_rescue_phase == 3 and boss_rescue_timer >= 4.2:
		boss_rescue_phase = 4
	elif boss_rescue_phase == 4 and boss_rescue_timer >= 5.0:
		# Cleanup — remove boss, trigger victory
		if is_instance_valid(boss_rescue_boss_ref):
			boss_rescue_boss_ref.queue_free()
		enemies_alive = max(0, enemies_alive - 1)
		boss_rescue_active = false
		boss_rescue_boss_ref = null
		_rescue_smoke_particles.clear()
		_victory()

func _draw_boss_rescue() -> void:
	if not boss_rescue_active:
		return
	var t = boss_rescue_timer
	var pos = boss_rescue_pos
	var font = game_font

	# Phase 0: Black smoke particles swirl and gather
	if boss_rescue_phase >= 0:
		var smoke_progress = clampf(t / 1.2, 0.0, 1.0)
		for p in _rescue_smoke_particles:
			var angle = p["angle"] + t * p["speed"]
			var target_dist = p["dist"] * (1.0 - smoke_progress * 0.7)
			var px = pos.x + cos(angle) * target_dist
			var py = pos.y + sin(angle) * target_dist * 0.5 + p["offset_y"]
			var smoke_alpha = 0.15 + smoke_progress * 0.4
			var smoke_size = p["size"] * (0.5 + smoke_progress * 0.5)
			if boss_rescue_phase >= 3:
				smoke_alpha *= clampf(1.0 - (t - 3.5) / 0.7, 0.0, 1.0)
			draw_circle(Vector2(px, py), smoke_size, Color(0.08, 0.02, 0.12, smoke_alpha))

	# Phase 1+: Shadow Author materializes
	if boss_rescue_phase >= 1:
		var appear_t = clampf((t - 1.2) / 1.3, 0.0, 1.0)
		var author_alpha = appear_t
		if boss_rescue_phase >= 3:
			author_alpha *= clampf(1.0 - (t - 3.5) / 0.7, 0.0, 1.0)
		var author_pos = Vector2(pos.x + 60.0, pos.y - 20.0)
		# Float upward as appearing
		author_pos.y -= appear_t * 15.0
		_draw_shadow_author_figure(author_pos, 1.8, author_alpha, t)
		# "I'll take it from here..." text
		if boss_rescue_phase == 1:
			var text_alpha = clampf((t - 1.8) / 0.5, 0.0, 1.0)
			_udraw(font, Vector2(pos.x, pos.y - 90), "I'll take it from here...", HORIZONTAL_ALIGNMENT_CENTER, 300, 15, Color(0.7, 0.3, 0.9, text_alpha * 0.9))

	# Phase 2: Grab — villain shrinks/fades toward Shadow Author
	if boss_rescue_phase == 2:
		var grab_t = clampf((t - 2.5) / 1.0, 0.0, 1.0)
		# Draw energy tendrils from author to villain
		for i in range(5):
			var offset = float(i) * 0.3
			var tendril_x = lerp(pos.x + 60.0, pos.x, grab_t) + sin(t * 8.0 + offset) * 8.0
			var tendril_y = lerp(pos.y - 35.0, pos.y, grab_t) + cos(t * 6.0 + offset) * 5.0
			draw_circle(Vector2(tendril_x, tendril_y), 3.0, Color(0.5, 0.2, 0.8, 0.5 * (1.0 - grab_t * 0.5)))

	# Phase 3: Bright white flash
	if boss_rescue_phase == 3:
		var flash_t = clampf((t - 3.5) / 0.7, 0.0, 1.0)
		var flash_radius = 40.0 + flash_t * 400.0
		var flash_alpha = (1.0 - flash_t) * 0.8
		draw_circle(pos, flash_radius, Color(1.0, 0.95, 0.85, flash_alpha))
		# Inner bright core
		var core_alpha = (1.0 - flash_t) * 0.95
		draw_circle(pos, 30.0 * (1.0 - flash_t * 0.5), Color(1.0, 1.0, 1.0, core_alpha))

	# Phase 4: Fade out — lingering wisps
	if boss_rescue_phase == 4:
		var fade_t = clampf((t - 4.2) / 0.8, 0.0, 1.0)
		for i in range(8):
			var angle = TAU * float(i) / 8.0 + t * 2.0
			var dist = 20.0 + fade_t * 60.0
			var wisp_x = pos.x + cos(angle) * dist
			var wisp_y = pos.y + sin(angle) * dist * 0.6 - fade_t * 30.0
			draw_circle(Vector2(wisp_x, wisp_y), 4.0 * (1.0 - fade_t), Color(0.3, 0.1, 0.4, 0.3 * (1.0 - fade_t)))

func _draw_shadow_author_figure(pos: Vector2, scale: float, alpha: float, time: float) -> void:
	if alpha <= 0.01:
		return
	var s = scale
	# All-black pyramidal hooded figure with glowing red wand
	# Cloak body (main shape) — pure black
	var cloak_pts = PackedVector2Array()
	cloak_pts.append(pos + Vector2(-18 * s, -60 * s))
	cloak_pts.append(pos + Vector2(-22 * s, -20 * s))
	cloak_pts.append(pos + Vector2(-25 * s, 20 * s))
	cloak_pts.append(pos + Vector2(-20 * s, 50 * s + sin(time * 2.0) * 5.0))
	cloak_pts.append(pos + Vector2(-8 * s, 55 * s + sin(time * 2.5 + 1.0) * 4.0))
	cloak_pts.append(pos + Vector2(0, 52 * s + sin(time * 3.0) * 3.0))
	cloak_pts.append(pos + Vector2(8 * s, 55 * s + sin(time * 2.5 + 2.0) * 4.0))
	cloak_pts.append(pos + Vector2(20 * s, 50 * s + sin(time * 2.0 + 1.5) * 5.0))
	cloak_pts.append(pos + Vector2(25 * s, 20 * s))
	cloak_pts.append(pos + Vector2(22 * s, -20 * s))
	cloak_pts.append(pos + Vector2(18 * s, -60 * s))
	draw_colored_polygon(cloak_pts, Color(0.02, 0.01, 0.02, alpha * 0.95))
	for i in range(cloak_pts.size() - 1):
		draw_line(cloak_pts[i], cloak_pts[i + 1], Color(0.15, 0.06, 0.2, alpha * 0.3), 1.5)

	# Hood (pointed pyramidal)
	var hood_pts = PackedVector2Array()
	hood_pts.append(pos + Vector2(-20 * s, -58 * s))
	hood_pts.append(pos + Vector2(0, -95 * s))
	hood_pts.append(pos + Vector2(20 * s, -58 * s))
	hood_pts.append(pos + Vector2(12 * s, -50 * s))
	hood_pts.append(pos + Vector2(-12 * s, -50 * s))
	draw_colored_polygon(hood_pts, Color(0.025, 0.012, 0.03, alpha * 0.95))
	draw_line(hood_pts[0], hood_pts[1], Color(0.2, 0.08, 0.3, alpha * 0.4), 1.5)
	draw_line(hood_pts[1], hood_pts[2], Color(0.2, 0.08, 0.3, alpha * 0.4), 1.5)

	# Hood interior — pure black void, no face
	draw_colored_polygon(PackedVector2Array([
		pos + Vector2(-12 * s, -50 * s), pos + Vector2(0, -80 * s),
		pos + Vector2(12 * s, -50 * s)
	]), Color(0.0, 0.0, 0.0, alpha))

	# Single glowing red dot deep in the hood
	var red_pulse = 0.6 + sin(time * 2.5) * 0.4
	draw_circle(Vector2(pos.x, pos.y - 62 * s), 2.0 * s, Color(0.9, 0.08, 0.02, alpha * red_pulse))
	draw_circle(Vector2(pos.x, pos.y - 62 * s), 4.5 * s, Color(0.7, 0.04, 0.01, alpha * red_pulse * 0.2))

	# Sleeve voids (no visible hands)
	var hand_sway = sin(time * 1.8) * 4.0 * s
	draw_circle(pos + Vector2(-20 * s + hand_sway, -15 * s), 4.0 * s, Color(0.0, 0.0, 0.0, alpha * 0.8))
	draw_circle(pos + Vector2(20 * s - hand_sway, -15 * s), 4.0 * s, Color(0.0, 0.0, 0.0, alpha * 0.8))

	# Glowing red wand — held from right sleeve
	var w_base = pos + Vector2(20 * s - hand_sway, -15 * s)
	var w_top = pos + Vector2(28 * s, -70 * s)
	draw_line(w_base, w_top, Color(0.7, 0.06, 0.03, alpha * red_pulse), 2.5 * s)
	draw_line(w_base, w_top, Color(0.9, 0.12, 0.05, alpha * red_pulse * 0.4), 4.0 * s)
	# Zigzag lightning pattern
	var wd = (w_top - w_base).normalized()
	var wp = Vector2(-wd.y, wd.x)
	for zi in range(5):
		var zt = 0.12 + float(zi) * 0.16
		var zp = w_base.lerp(w_top, zt)
		var zag = (4.0 if zi % 2 == 0 else -4.0) * s
		var zp2 = w_base.lerp(w_top, zt + 0.08)
		draw_line(zp + wp * zag, zp2 + wp * (-zag), Color(0.95, 0.2, 0.08, alpha * red_pulse * 0.7), 1.5 * s)
	# Wand tip glow
	draw_circle(w_top, 3.0 * s, Color(0.95, 0.12, 0.02, alpha * red_pulse))
	draw_circle(w_top, 6.0 * s, Color(0.8, 0.06, 0.01, alpha * red_pulse * 0.3))

	# Shadow tendrils at base
	for i in range(6):
		var ta = TAU * float(i) / 6.0 + time * 1.2
		var td = 15.0 * s + sin(time * 3.0 + float(i)) * 5.0 * s
		var tx = pos.x + cos(ta) * td
		var ty = pos.y + 50 * s + sin(ta) * 8.0 * s
		draw_circle(Vector2(tx, ty), 3.0 * s, Color(0.05, 0.02, 0.08, alpha * 0.35))

func _victory() -> void:
	game_state = GameState.GAME_OVER_STATE
	_build_session_stats()
	_update_career_stats_post_game(true)
	Engine.time_scale = 1.0
	fast_forward = false
	game_paused = false
	_stop_layered_music()
	_play_sfx(_sfx_victory)
	speed_button.text = "  >>  "
	# Victory burst effect
	_victory_burst_timer = 2.0
	_victory_particles.clear()
	for vi in range(35):
		var va = randf() * TAU
		var vspd = randf_range(100.0, 300.0)
		_victory_particles.append({
			"pos": Vector2(640, 360),
			"vel": Vector2(cos(va), sin(va)) * vspd,
			"timer": randf_range(1.2, 2.0),
			"size": randf_range(2.0, 5.0),
		})
	_collect_session_damage()
	var level_name = levels[current_level]["name"] if current_level >= 0 else "Level"
	var max_lives = difficulty_fixed_lives[mini(selected_difficulty, difficulty_fixed_lives.size() - 1)]
	var stars = 1
	if lives >= max_lives:
		stars = 3
	elif lives >= int(max_lives * 0.5):
		stars = 2
	if current_level >= 0 and not current_level in completed_levels:
		completed_levels.append(current_level)
	var old_stars = level_stars.get(current_level, 0)
	level_stars[current_level] = max(old_stars, stars)
	# Per-difficulty medal and star tracking
	if not level_difficulty_medals.has(current_level):
		level_difficulty_medals[current_level] = [false, false, false, false]
	while level_difficulty_medals[current_level].size() < 4:
		level_difficulty_medals[current_level].append(false)
	level_difficulty_medals[current_level][selected_difficulty] = true
	if not level_difficulty_stars.has(current_level):
		level_difficulty_stars[current_level] = [0, 0, 0, 0]
	while level_difficulty_stars[current_level].size() < 4:
		level_difficulty_stars[current_level].append(0)
	var old_diff_stars = level_difficulty_stars[current_level][selected_difficulty]
	level_difficulty_stars[current_level][selected_difficulty] = max(old_diff_stars, stars)
	# Award +1 Knowledge Ink for first 3-star completion of a level
	if stars >= 3 and old_stars < 3:
		knowledge_ink += 1
	var star_str = ""
	for i in range(stars):
		star_str += "â˜…"
	for i in range(3 - stars):
		star_str += "â˜†"
	var diff_name = ["Easy", "Medium", "Hard", "Pure"][mini(selected_difficulty, 3)]
	# Pure Mode: 3x XP multiplier + bonus Cosmic Ink
	if selected_difficulty == PURE_MODE:
		if stars >= 3 and old_stars < 3:
			knowledge_ink += 2  # Extra 2 Cosmic Ink (total 3 with the base +1 above)
	# Generate treasure chest loot (awarded when chest animation plays)
	_generate_chest_loot(stars)
	# Hide the old text label — chest overlay handles all victory display now
	game_over_label.visible = false
	start_button.disabled = true
	# Start victory chest opening overlay (tier = difficulty)
	_start_victory_chest(selected_difficulty, stars)
	# Quest tracking on victory
	_update_quest_progress("complete_levels", 1)
	_update_quest_progress("earn_stars", stars)
	# Shadow Arena handling
	if shadow_arena_active:
		_end_shadow_arena()
	# Boss Rush completion
	if boss_rush_mode:
		boss_rush_completed = true
		spawn_floating_text(Vector2(640, 250), "BOSS RUSH COMPLETE!", Color(1.0, 0.85, 0.2), 24.0, 3.0)
	# Daily Challenge completion
	if daily_challenge_active:
		var today = Time.get_date_string_from_system()
		daily_challenge_completed_today = true
		var prev_date = daily_challenge_last_date
		daily_challenge_last_date = today
		if prev_date == "" or prev_date == today:
			if prev_date == "":
				daily_challenge_streak = 1
		else:
			var prev_unix = Time.get_unix_time_from_datetime_string(prev_date + "T12:00:00")
			var today_unix = Time.get_unix_time_from_datetime_string(today + "T12:00:00")
			if today_unix - prev_unix < 172800:
				daily_challenge_streak += 1
			else:
				daily_challenge_streak = 1
		# Reward: storybook stars + shards
		player_storybook_stars += 1
		player_relic_shards += 15
		spawn_floating_text(Vector2(640, 250), "DAILY COMPLETE! +1 Star +15 Shards", Color(0.4, 1.0, 0.5), 18.0, 2.5)
	# Track total damage for milestones
	for tower in get_tree().get_nodes_in_group("towers"):
		if "damage_dealt" in tower:
			total_damage += int(tower.damage_dealt)
	# Check milestones
	_check_milestones()
	# BATTD2: Victory Streak tracking
	victory_streak += 1
	if victory_streak > victory_streak_best:
		victory_streak_best = victory_streak
	if victory_streak >= 3:
		var streak_bonus = int(float(gold) * STREAK_GOLD_BONUS * float(victory_streak))
		if streak_bonus > 0:
			add_gold(streak_bonus)
			spawn_floating_text(Vector2(640, 220), "STREAK x%d +%dG!" % [victory_streak, streak_bonus], Color(1.0, 0.6, 0.1), 18.0, 2.0)
	# Achievement checks on victory
	_check_achievement("first_steps", 1)
	_check_achievement("halfway_there", 1)
	_check_achievement("campaign_complete", 1)
	_check_achievement("wave_master", total_waves)
	if stars >= 3:
		_check_achievement("flawless", 1)
	# Check perfect campaign (all 18 levels with 3 stars)
	var three_star_count = 0
	for ls_key in level_stars:
		if level_stars[ls_key] >= 3:
			three_star_count += 1
	_check_achievement("perfect_campaign", three_star_count)
	if current_game_lives_lost == 0:
		_check_achievement("untouchable", 1)
	if current_game_fast_forward_only:
		_check_achievement("speed_demon", 1)
	# Odyssey handling
	if odyssey_active:
		_odyssey_map_victory()
		return
	# Check for character unlocks
	_check_character_unlocks()
	# Post-victory dialog is queued after chest closing (in _on_chest_overlay_clicked)
	_save_game()

func _check_character_unlocks() -> void:
	for char_id in character_unlock_map:
		if char_id in unlocked_characters:
			continue
		var required_levels = character_unlock_map[char_id]
		var all_complete = true
		for lvl in required_levels:
			if not lvl in completed_levels:
				all_complete = false
				break
		if all_complete:
			unlocked_characters.append(char_id)
			_refresh_unlocked_survivors()
			# Queue unlock dialog
			var unlock_key = "unlock_" + char_id
			if story_dialogs.has(unlock_key) and not unlock_key in story_seen:
				story_state.queued_dialog = unlock_key
			# Check if all 5 are unlocked
			if unlocked_characters.size() >= 5:
				if not "all_unlocked" in story_seen:
					if story_state.queued_dialog != "":
						# Will need to chain — handled by queued dialog system
						pass
					else:
						story_state.queued_dialog = "all_unlocked"

func _queue_post_victory_dialog() -> void:
	var post_key = "post_level_" + str(current_level)
	if not story_dialogs.has(post_key):
		return
	if post_key in story_seen:
		return
	# Check for act transitions that should play after this post-level dialog
	var act_key = ""
	if current_level == 15:
		# Just completed all rescue arcs — check if levels 0-15 done
		var rescue_done = true
		for i in range(16):
			if not i in completed_levels:
				rescue_done = false
				break
		if rescue_done and not "act2_intro" in story_seen:
			act_key = "act2_intro"
	elif current_level == 33:
		# Just completed all original arcs — check if levels 0-33 done
		var all_arcs_done = true
		for i in range(34):
			if not i in completed_levels:
				all_arcs_done = false
				break
		if all_arcs_done and not "act3_intro" in story_seen:
			act_key = "act3_intro"
	# Chain dialogs: post_level -> act transition (if any), or post_level -> unlock (if any)
	# Act transitions take priority over unlock dialogs in the queue
	if act_key != "":
		story_state.queued_dialog = act_key
	# If no act_key, the existing queued_dialog (unlock from _check_character_unlocks) stays as-is
	_start_story_dialog(post_key)

func _generate_chest_loot(stars: int) -> void:
	chest_loot.clear()
	var chapter = levels[current_level]["chapter"] if current_level >= 0 and current_level < levels.size() else 0
	# Tier based on difficulty: Easy=1, Medium=2, Hard=3
	var tier = selected_difficulty + 1
	# Chapter progression multiplier (later chapters = better base loot)
	var chapter_mult = 1.0 + chapter * 0.5  # Ch1=1.0, Ch2=1.5, Ch3=2.0
	# Stars bonus (more stars = more loot)
	var star_mult = 0.7 + float(stars) * 0.2  # 1star=0.9, 2star=1.1, 3star=1.3
	# Knowledge tree currency earn bonus
	var currency_mult = 1.0 + _get_knowledge_bonus("currency_earn")

	# === GOLD COINS ===
	var loot_diff = mini(selected_difficulty, 2)  # Pure mode uses Hard loot tables
	var gold_base = [8, 18, 30][loot_diff]
	var gold_amount = int(float(gold_base) * chapter_mult * star_mult * currency_mult)
	chest_loot.append({"type": "gold", "amount": gold_amount, "name": "Gold"})

	# === RELIC SHARDS (always drop, more on higher tiers) ===
	var shard_base = [2, 5, 10][loot_diff]
	var shard_amount = int(float(shard_base) * chapter_mult * star_mult * currency_mult)
	chest_loot.append({"type": "shards", "amount": shard_amount, "name": "Relic Shards"})

	# === QUILLS (chance increases with tier) ===
	var quill_chance = [0.3, 0.6, 0.9][loot_diff]
	if randf() < quill_chance * star_mult:
		var quill_amount = [1, 2, 4][loot_diff]
		quill_amount = int(float(quill_amount) * chapter_mult * currency_mult)
		chest_loot.append({"type": "quills", "amount": quill_amount, "name": "Quills"})

	# === STORYBOOK STARS (more generous — guaranteed on Medium+, boosted on Hard) ===
	var star_chance = [0.25, 0.6, 1.0][loot_diff]
	if randf() < star_chance * chapter_mult * 0.5:
		var sb_amount = max(1, int(float([1, 2, 3][loot_diff]) * currency_mult))
		chest_loot.append({"type": "stars", "amount": sb_amount, "name": "Storybook Stars"})

	# === GEAR DROP — Difficulty-exclusive, progression-gated ===
	var prog_chapter = current_level / 3  # World index for drop rate scaling
	var level_char = levels[current_level]["character"] if current_level >= 0 and current_level < levels.size() else -1
	var highest_lv = _get_highest_completed_level()
	var trinket_rarity = ["tattered", "bound", "gilded"][loot_diff]
	var tier_ok = true
	if selected_difficulty == 1 and highest_lv < 12:
		tier_ok = false  # Bound requires Act 1 complete
	elif selected_difficulty >= 2 and highest_lv < 24:
		tier_ok = false  # Gilded requires Act 2 complete
	# Mythic/Forbidden upgrade chance on hard difficulty
	if selected_difficulty >= 2 and tier_ok:
		var upgrade_roll = randf()
		if upgrade_roll < 0.02:  # 2% forbidden
			trinket_rarity = "forbidden"
		elif upgrade_roll < 0.10:  # 8% mythic
			trinket_rarity = "mythic"
	var relic_chance = [0.08, 0.12, 0.18][loot_diff]
	relic_chance += [0.01, 0.015, 0.02][loot_diff] * prog_chapter
	if stars >= 3:
		relic_chance += 0.05
	if tier_ok and randf() < relic_chance:
		var chosen_b = _pick_weighted_relic(trinket_rarity, level_char)
		if not chosen_b.is_empty():
			owned_bindings[chosen_b["id"]] = owned_bindings.get(chosen_b["id"], 0) + 1
			_mark_binding_discovered(chosen_b["id"])
			_add_recent_item(chosen_b["name"], chosen_b.get("rarity", "tattered"))
			chest_loot.append({"type": "relic", "amount": 1, "name": chosen_b["name"]})

func _award_chest_loot() -> void:
	# Credit the guaranteed base loot currencies to the player
	for item in chest_loot:
		match item["type"]:
			"gold": player_gold += item["amount"]
			"shards": player_relic_shards += item["amount"]
			"quills": player_quills += item["amount"]
			"stars": player_storybook_stars += item["amount"]
			# Relics already awarded directly in _generate_chest_loot

func _collect_session_damage() -> void:
	# Map script filenames to TowerType
	var script_to_type = {
		"robin_hood.gd": TowerType.ROBIN_HOOD,
		"alice.gd": TowerType.ALICE,
		"wicked_witch.gd": TowerType.WICKED_WITCH,
		"peter_pan.gd": TowerType.PETER_PAN,
		"phantom.gd": TowerType.PHANTOM,
		"scrooge.gd": TowerType.SCROOGE,
		"sherlock.gd": TowerType.SHERLOCK,
		"tarzan.gd": TowerType.TARZAN,
		"dracula.gd": TowerType.DRACULA,
		"merlin.gd": TowerType.MERLIN,
		"frankenstein.gd": TowerType.FRANKENSTEIN,
		"shadow_author.gd": TowerType.SHADOW_AUTHOR,
	}
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.get("damage_dealt") != null:
			var dmg = tower.damage_dealt
			var script_path = tower.get_script().resource_path if tower.get_script() else ""
			var fname = script_path.get_file()
			if script_to_type.has(fname):
				var tt = script_to_type[fname]
				session_damage[tt] = session_damage.get(tt, 0.0) + dmg
				# Apply to persistent progression
				if survivor_progress.has(tt):
					var xp_mult = 1.0 + _get_knowledge_bonus("xp_gain")
					if selected_difficulty == PURE_MODE:
						xp_mult *= 3.0
					survivor_progress[tt]["xp"] += dmg * xp_mult
					# Accumulate total_damage for progressive abilities
					survivor_progress[tt]["total_damage"] = survivor_progress[tt].get("total_damage", 0.0) + dmg
					_check_ability_unlocks(tt)
					# Check for level ups (cap at MAX_SURVIVOR_LEVEL)
					while survivor_progress[tt]["xp"] >= survivor_progress[tt]["xp_next"] and survivor_progress[tt]["level"] < MAX_SURVIVOR_LEVEL:
						survivor_progress[tt]["xp"] -= survivor_progress[tt]["xp_next"]
						survivor_progress[tt]["level"] += 1
						survivor_progress[tt]["xp_next"] = _get_xp_for_level(survivor_progress[tt]["level"])
						_on_survivor_level_up(tt, survivor_progress[tt]["level"])

func _on_survivor_level_up(tower_type, new_level: int) -> void:
	# Unlock gear at level 2, sidekicks at 3/5/8
	# Relics: 0,2,4 auto-earned at levels 2,6,10; relics 1,3,5 purchasable at levels 4,8,12
	if not survivor_progress.has(tower_type):
		return
	_trigger_levelup_fanfare(tower_type, new_level)
	var p = survivor_progress[tower_type]
	if new_level >= 2:
		p["gear_unlocked"] = true
	var sk_levels = [3, 5, 8]
	for i in range(3):
		if new_level >= sk_levels[i]:
			p["sidekicks_unlocked"][i] = true
	# Level-earned relics (indices 0, 2, 4) auto-unlock
	var earned_levels = {0: 2, 2: 6, 4: 10}
	for relic_idx in earned_levels:
		if new_level >= earned_levels[relic_idx]:
			p["relics_unlocked"][relic_idx] = true
	# Purchasable relics (indices 1, 3, 5) become available but NOT auto-unlocked
	# They are unlocked via gold purchase in _on_relic_clicked()
	# Award Knowledge Ink on level-up (+1 base, +2 bonus on milestone levels)
	knowledge_ink += 1
	if new_level in [5, 10, 15, 20]:
		knowledge_ink += 2
	# Achievement checks for survivor levels
	if new_level >= 5:
		_check_achievement("veteran_survivor", 1)
	if new_level >= 10:
		_check_achievement("master_survivor", 1)
	# Refresh meta buffs on all placed towers of this type (level-up mid-game)
	for tower in get_tree().get_nodes_in_group("towers"):
		var tower_tt = tower.get_meta("tower_type_enum") if tower.has_meta("tower_type_enum") else -1
		if tower_tt == tower_type:
			_apply_meta_buffs(tower, tower_type)

# === PROGRESSIVE ABILITY SYSTEM ===

func register_tower_damage(tower_type: int, amount: float) -> void:
	if not survivor_progress.has(tower_type):
		return
	var p = survivor_progress[tower_type]
	p["total_damage"] = p.get("total_damage", 0.0) + amount
	_check_ability_unlocks(tower_type)

func _check_ability_unlocks(tower_type: int) -> void:
	if not survivor_progress.has(tower_type):
		return
	var p = survivor_progress[tower_type]
	var total = p.get("total_damage", 0.0)
	var unlocked = p.get("abilities_unlocked", [])
	if unlocked.size() < 9:
		unlocked.resize(9)
		for i in range(unlocked.size()):
			if unlocked[i] == null:
				unlocked[i] = false
		p["abilities_unlocked"] = unlocked
	for i in range(9):
		if not unlocked[i] and total >= PROGRESSIVE_ABILITY_THRESHOLDS[i]:
			unlocked[i] = true
			_show_ability_unlock_popup(tower_type, i)
			_notify_tower_ability_unlocked(tower_type, i)

func _show_ability_unlock_popup(tower_type: int, ability_index: int) -> void:
	_ability_popup_tower_type = tower_type
	_ability_popup_index = ability_index
	# Get ability name from tower scripts
	var script_to_type = {
		TowerType.ROBIN_HOOD: "robin_hood.gd",
		TowerType.ALICE: "alice.gd",
		TowerType.WICKED_WITCH: "wicked_witch.gd",
		TowerType.PETER_PAN: "peter_pan.gd",
		TowerType.PHANTOM: "phantom.gd",
		TowerType.SCROOGE: "scrooge.gd",
	}
	_ability_popup_name = "Ability %d" % (ability_index + 1)
	_ability_popup_desc = ""
	for tower in get_tree().get_nodes_in_group("towers"):
		var tower_tt = tower.get_meta("tower_type_enum") if tower.has_meta("tower_type_enum") else -1
		if tower_tt == tower_type:
			if tower.has_method("get_progressive_ability_name"):
				_ability_popup_name = tower.get_progressive_ability_name(ability_index)
			if tower.has_method("get_progressive_ability_desc"):
				_ability_popup_desc = tower.get_progressive_ability_desc(ability_index)
			break
	_ability_popup_timer = 5.0
	_ability_popup_freeze = 1.5
	queue_redraw()

func _notify_tower_ability_unlocked(tower_type: int, ability_index: int) -> void:
	for tower in get_tree().get_nodes_in_group("towers"):
		var tower_tt = tower.get_meta("tower_type_enum") if tower.has_meta("tower_type_enum") else -1
		if tower_tt == tower_type:
			if tower.has_method("activate_progressive_ability"):
				tower.activate_progressive_ability(ability_index)

func restore_life(amount: int = 1) -> void:
	lives = mini(lives + amount, 99)
	update_hud()

func _update_spawn_debuffs() -> void:
	# Reset spawn debuffs each frame based on active towers
	spawn_hp_reduction = 0.0
	spawn_permanent_slow = 1.0
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.has_method("get_spawn_debuffs"):
			var debuffs = tower.get_spawn_debuffs()
			spawn_hp_reduction = max(spawn_hp_reduction, debuffs.get("hp_reduction", 0.0))
			spawn_permanent_slow = min(spawn_permanent_slow, debuffs.get("permanent_slow", 1.0))

func show_ability_choice(tower: Node2D) -> void:
	_ability_tower = tower
	ability_title.text = "CHOOSE AN ABILITY"
	for i in range(4):
		if i < tower.TIER_NAMES.size():
			var desc = ""
			if tower.has("ABILITY_DESCRIPTIONS") and i < tower.ABILITY_DESCRIPTIONS.size():
				desc = " — " + tower.ABILITY_DESCRIPTIONS[i]
			ability_buttons[i].text = tower.TIER_NAMES[i] + desc
			ability_buttons[i].visible = true
		else:
			ability_buttons[i].visible = false
	ability_panel.visible = true
	info_label.text = "Choose a special ability for your tower!"

func _on_ability_chosen(index: int) -> void:
	if _ability_tower and _ability_tower.has_method("choose_ability"):
		_ability_tower.choose_ability(index)
	ability_panel.visible = false
	var name = ""
	if _ability_tower and index < _ability_tower.TIER_NAMES.size():
		name = _ability_tower.TIER_NAMES[index]
	info_label.text = "Ability unlocked: %s!" % name
	if _is_mobile:
		Input.vibrate_handheld(40)
	_ability_tower = null

# === BATTLE POWER HANDLERS ===
func _on_battle_power_pressed(index: int) -> void:
	if index >= selected_powers.size():
		return
	var power_id = selected_powers[index]
	_activate_power(power_id)

func _open_power_selection() -> void:
	power_selection_open = true
	selected_powers.clear()
	queue_redraw()

func _close_power_selection_and_start() -> void:
	power_selection_open = false
	_update_power_buttons()
	# Now actually start the level
	if odyssey_active:
		pass  # Already started
	queue_redraw()

func _toggle_power_selection(power_id: String) -> void:
	if power_id in selected_powers:
		selected_powers.erase(power_id)
	elif selected_powers.size() < 3 and owned_powers.get(power_id, 0) > 0:
		selected_powers.append(power_id)
	queue_redraw()

# === ACHIEVEMENT DRAWING ===
func _draw_achievements_tab() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), col)
	# Gold border
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	# Title
	_udraw(font, Vector2(panel_x + panel_w * 0.5 - 60, panel_y + 28), "ACHIEVEMENTS", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.9))
	draw_rect(Rect2(panel_x + panel_w * 0.5 - 80, panel_y + 34, 160, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.4))
	# Count unlocked
	var unlocked_count = 0
	for ach in achievement_definitions:
		if achievements_unlocked.get(ach["id"], false):
			unlocked_count += 1
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "%d / %d" % [unlocked_count, achievement_definitions.size()], HORIZONTAL_ALIGNMENT_RIGHT, -1, 16, menu_text_muted)

	# === Total completion percentage with progress bar (Enhancement #46) ===
	var total_ratio = float(unlocked_count) / float(max(1, achievement_definitions.size()))
	draw_rect(Rect2(panel_x + 40, panel_y + 36, panel_w - 80, 4), Color(0.1, 0.1, 0.15, 0.4))
	draw_rect(Rect2(panel_x + 40, panel_y + 36, (panel_w - 80) * total_ratio, 4), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6))
	_udraw(font, Vector2(panel_x + panel_w * 0.5 + 90, panel_y + 28), "%d%% COMPLETE" % int(total_ratio * 100), HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.5))

	# === Recently unlocked section at top (Enhancement #47) ===
	var recent_achievements: Array = []
	for ach_r in achievement_definitions:
		if achievements_unlocked.get(ach_r["id"], false):
			recent_achievements.append(ach_r)
	# Show up to 4 most recently unlocked (last 4 in the list)
	var recent_display: Array = []
	if recent_achievements.size() > 0:
		var recent_start = max(0, recent_achievements.size() - 4)
		for ri in range(recent_start, recent_achievements.size()):
			recent_display.append(recent_achievements[ri])

	# Draw achievement cards in a grid (5 columns, scrollable via categories)
	var categories = ["Combat", "Tower", "Economy", "Progression"]
	var cat_colors = [Color(0.8, 0.3, 0.2), Color(0.3, 0.7, 0.4), Color(0.85, 0.7, 0.2), Color(0.4, 0.5, 0.85)]
	var card_w = 260.0
	var card_h = 52.0
	var gap_x = 12.0
	var gap_y = 6.0
	var start_y = panel_y + 48.0
	var cols = 4
	for ci in range(categories.size()):
		var cat = categories[ci]
		var cat_col = cat_colors[ci]
		var cat_achievements: Array = []
		for ach in achievement_definitions:
			if ach["category"] == cat:
				cat_achievements.append(ach)
		# Category header
		var hdr_y = start_y
		draw_rect(Rect2(panel_x + 10, hdr_y, panel_w - 20, 18), Color(cat_col.r, cat_col.g, cat_col.b, 0.12))
		_udraw(font, Vector2(panel_x + 20, hdr_y + 13), cat, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(cat_col.r, cat_col.g, cat_col.b, 0.9))

		# === Category completion progress bar (Enhancement #44) ===
		var cat_unlocked = 0
		for ach_c in cat_achievements:
			if achievements_unlocked.get(ach_c["id"], false):
				cat_unlocked += 1
		var cat_ratio = float(cat_unlocked) / float(max(1, cat_achievements.size()))
		draw_rect(Rect2(panel_x + panel_w - 210, hdr_y + 6, 140, 6), Color(0.1, 0.1, 0.15, 0.5))
		draw_rect(Rect2(panel_x + panel_w - 210, hdr_y + 6, 140 * cat_ratio, 6), Color(cat_col.r, cat_col.g, cat_col.b, 0.7))
		_udraw(font, Vector2(panel_x + panel_w - 60, hdr_y + 13), "%d%%" % int(cat_ratio * 100), HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(cat_col.r, cat_col.g, cat_col.b, 0.6))

		start_y += 22.0
		# Cards
		for ai in range(cat_achievements.size()):
			var ach = cat_achievements[ai]
			var col_i = ai % cols
			var row_i = ai / cols
			var cx = panel_x + 10 + float(col_i) * (card_w + gap_x)
			var cy = start_y + float(row_i) * (card_h + gap_y)
			var is_done = achievements_unlocked.get(ach["id"], false)
			var prog = achievement_progress.get(ach["id"], 0)

			# === Achievement unlock glow (Enhancement #43) ===
			if is_done:
				draw_rect(Rect2(cx - 2, cy - 2, card_w + 4, card_h + 4), Color(cat_col.r, cat_col.g, cat_col.b, 0.08 + sin(_time * 2.0 + float(ai)) * 0.03))

			# Card background
			var bg = Color(0.10, 0.08, 0.22, 0.8) if is_done else Color(0.05, 0.05, 0.14, 0.8)
			draw_rect(Rect2(cx, cy, card_w, card_h), bg)
			# Border
			var bc = Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6) if is_done else Color(0.25, 0.25, 0.40, 0.3)
			draw_rect(Rect2(cx, cy, card_w, 1), bc)
			draw_rect(Rect2(cx, cy + card_h - 1, card_w, 1), bc)
			draw_rect(Rect2(cx, cy, 1, card_h), bc)
			draw_rect(Rect2(cx + card_w - 1, cy, 1, card_h), bc)

			# === Achievement rarity badge (Enhancement #45) ===
			# Color based on target difficulty: low=bronze, mid=silver, high=gold
			var ach_target = ach["target"]
			var rarity_badge_col = Color(0.72, 0.50, 0.25, 0.7)  # Bronze
			if ach_target >= 100:
				rarity_badge_col = Color(0.85, 0.65, 0.1, 0.8)  # Gold
			elif ach_target >= 10:
				rarity_badge_col = Color(0.75, 0.75, 0.80, 0.7)  # Silver
			draw_circle(Vector2(cx + card_w - 10, cy + 10), 5, rarity_badge_col)
			draw_arc(Vector2(cx + card_w - 10, cy + 10), 5, 0, TAU, 12, Color(rarity_badge_col.r, rarity_badge_col.g, rarity_badge_col.b, 0.4), 1.0)

			# Check mark or progress
			if is_done:
				draw_circle(Vector2(cx + 16, cy + card_h * 0.5), 8, Color(0.3, 0.7, 0.2, 0.7))
				_udraw(font, Vector2(cx + 11, cy + card_h * 0.5 + 5), "V", HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color.WHITE)
			else:
				# Progress bar
				var pct = clampf(float(prog) / float(max(1, ach["target"])), 0.0, 1.0)
				draw_rect(Rect2(cx + 4, cy + card_h - 8, (card_w - 8) * pct, 4), Color(cat_col.r, cat_col.g, cat_col.b, 0.5))
				draw_rect(Rect2(cx + 4, cy + card_h - 8, card_w - 8, 4), Color(0.3, 0.3, 0.4, 0.2), false, 1.0)
			# Name and desc
			var nx = cx + 30.0
			var nc = Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 1.0) if is_done else Color(0.55, 0.52, 0.60)
			_udraw(font, Vector2(nx, cy + 16), ach["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 36), 15, nc)
			_udraw(font, Vector2(nx, cy + 31), ach["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 36), 15, Color(0.5, 0.45, 0.4))
			if not is_done:
				_udraw(font, Vector2(nx, cy + 42), "%d / %d" % [prog, ach["target"]], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, menu_text_muted)

			# === "RECENT" indicator for recently unlocked (Enhancement #47) ===
			if is_done:
				var is_recent = false
				for rd in recent_display:
					if rd["id"] == ach["id"]:
						is_recent = true
						break
				if is_recent:
					var recent_pulse = 0.6 + sin(_time * 3.0 + float(ai)) * 0.3
					_udraw(font, Vector2(cx + card_w - 50, cy + card_h - 12), "RECENT", HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.3, 0.85, 0.3, recent_pulse))

		var rows_for_cat = (cat_achievements.size() + cols - 1) / cols
		start_y += float(rows_for_cat) * (card_h + gap_y) + 8.0

# === POWER SELECTION OVERLAY ===
func _draw_power_selection() -> void:
	var font = game_font
	# Dark overlay
	draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.75))
	# Panel
	var pw = 700.0
	var ph = 480.0
	var px = (1280 - pw) / 2
	var py = (720 - ph) / 2
	draw_rect(Rect2(px, py, pw, ph), Color(0.06, 0.04, 0.10, 0.95))
	draw_rect(Rect2(px, py, pw, ph), Color(0.85, 0.65, 0.1, 0.5), false, 2.0)
	_udraw(font, Vector2(px + pw * 0.5 - 80, py + 30), "SELECT BATTLE POWERS", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.85, 0.75, 0.4))
	_udraw(font, Vector2(px + pw * 0.5 - 100, py + 54), "Choose up to 3 powers for this battle", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.6, 0.5, 0.4))
	# Cancel/Back button (top-right)
	draw_rect(Rect2(px + pw - 112, py + 10, 100, 40), Color(0.4, 0.15, 0.15, 0.8))
	draw_rect(Rect2(px + pw - 112, py + 10, 100, 40), Color(0.8, 0.3, 0.3, 0.5), false, 1.0)
	_udraw(font, Vector2(px + pw - 62, py + 35), "CANCEL", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.9, 0.7, 0.7))
	# Draw each power
	for i in range(battle_power_definitions.size()):
		var bp = battle_power_definitions[i]
		var bx = px + 30
		var by = py + 70 + i * 60
		var owned = owned_powers.get(bp["id"], 0)
		var is_selected_p = bp["id"] in selected_powers
		# Background
		var bg_c = Color(0.15, 0.12, 0.06, 0.8) if is_selected_p else Color(0.08, 0.06, 0.10, 0.8)
		draw_rect(Rect2(bx, by, pw - 60, 48), bg_c)
		# Border
		var bdr = Color(0.85, 0.7, 0.2, 0.6) if is_selected_p else Color(0.3, 0.25, 0.2, 0.3)
		draw_rect(Rect2(bx, by, pw - 60, 48), bdr, false, 1.0)
		# Name & desc
		_udraw(font, Vector2(bx + 12, by + 18), bp["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.75, 0.5))
		_udraw(font, Vector2(bx + 12, by + 34), bp["desc"], HORIZONTAL_ALIGNMENT_LEFT, 350, 14, Color(0.55, 0.48, 0.38))
		# Count
		_udraw(font, Vector2(bx + pw - 120, by + 18), "Owned: %d" % owned, HORIZONTAL_ALIGNMENT_RIGHT, -1, 15, Color(0.7, 0.6, 0.4) if owned > 0 else Color(0.4, 0.35, 0.3))
		if is_selected_p:
			_udraw(font, Vector2(bx + pw - 120, by + 34), "SELECTED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 15, Color(0.3, 0.8, 0.3))
	# Start button — large and prominent
	var sb_w = 260.0
	var sb_h = 50.0
	var sbx = px + (pw - sb_w) * 0.5
	var sby = py + ph - sb_h - 16
	var sb_pulse = (sin(_time * 3.0) + 1.0) * 0.5
	# Glow behind button
	draw_rect(Rect2(sbx - 4, sby - 4, sb_w + 8, sb_h + 8), Color(0.2, 0.7, 0.2, 0.08 + sb_pulse * 0.06))
	# Button background
	draw_rect(Rect2(sbx, sby, sb_w, sb_h), Color(0.15, 0.55, 0.15, 0.9))
	# Top highlight
	draw_rect(Rect2(sbx, sby, sb_w, sb_h * 0.4), Color(0.3, 0.7, 0.3, 0.2))
	# Border
	draw_rect(Rect2(sbx, sby, sb_w, sb_h), Color(0.4, 0.9, 0.3, 0.7 + sb_pulse * 0.3), false, 2.5)
	# Text
	var sb_text = "START BATTLE"
	var sb_tw = font.get_string_size(sb_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 20).x
	_udraw(font, Vector2(sbx + (sb_w - sb_tw) * 0.5 + 1, sby + 33), sb_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 20, Color(0, 0, 0, 0.3))
	_udraw(font, Vector2(sbx + (sb_w - sb_tw) * 0.5, sby + 32), sb_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 20, Color.WHITE)
	# Cancel button (top-right corner of panel)
	var cancel_w = 100.0
	var cancel_h = 40.0
	var cancel_x = px + pw - cancel_w - 12
	var cancel_y = py + 10
	draw_rect(Rect2(cancel_x, cancel_y, cancel_w, cancel_h), Color(0.5, 0.15, 0.15, 0.8))
	draw_rect(Rect2(cancel_x, cancel_y, cancel_w, cancel_h), Color(0.8, 0.3, 0.3, 0.5), false, 1.0)
	var cancel_text = "CANCEL"
	var ctw = font.get_string_size(cancel_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14).x
	_udraw(font, Vector2(cancel_x + (cancel_w - ctw) * 0.5, cancel_y + 26), cancel_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(1.0, 0.8, 0.8))

# === ODYSSEY DRAWING ===
func _draw_odyssey_panel() -> void:
	var font = game_font
	# Odyssey panel in bottom bar (left third)
	var ox = 38.0
	var oy = 520.0
	var pw = 385.0
	var ph = 82.0
	# Panel background
	draw_rect(Rect2(ox, oy, pw, ph), Color(0.10, 0.06, 0.14, 0.85))
	draw_rect(Rect2(ox, oy, pw, ph), Color(0.55, 0.28, 0.75, 0.35), false, 1.5)
	# Purple accent line at top
	draw_rect(Rect2(ox, oy, pw, 2), Color(0.6, 0.3, 0.8, 0.6))
	_udraw(font, Vector2(ox + 12, oy + 20), "ODYSSEY MODE", HORIZONTAL_ALIGNMENT_LEFT, pw - 100, 14, Color(0.82, 0.62, 0.92))
	if odyssey_completed_this_week:
		_udraw(font, Vector2(ox + 12, oy + 40), "Completed this week!", HORIZONTAL_ALIGNMENT_LEFT, pw - 20, 15, Color(0.5, 0.8, 0.3))
		_udraw(font, Vector2(ox + 12, oy + 56), "Resets Monday", HORIZONTAL_ALIGNMENT_LEFT, pw - 20, 14, Color(0.4, 0.6, 0.3))
	else:
		var map_names = ""
		for mi in range(odyssey_maps.size()):
			if mi > 0: map_names += " > "
			if odyssey_maps[mi] < levels.size():
				map_names += levels[odyssey_maps[mi]]["name"]
		_udraw(font, Vector2(ox + 12, oy + 40), map_names, HORIZONTAL_ALIGNMENT_LEFT, pw - 110, 14, Color(0.6, 0.5, 0.4))
		_udraw(font, Vector2(ox + 12, oy + 56), "Trophies: %d | Reward: 10-30" % trophy_currency, HORIZONTAL_ALIGNMENT_LEFT, pw - 110, 14, Color(0.85, 0.7, 0.2))
		# Start button
		draw_rect(Rect2(ox + pw - 88, oy + 18, 78, 46), Color(0.30, 0.15, 0.50, 0.75))
		draw_rect(Rect2(ox + pw - 88, oy + 18, 78, 2), Color(0.5, 0.3, 0.7, 0.5))
		_udraw(font, Vector2(ox + pw - 50, oy + 48), "START", HORIZONTAL_ALIGNMENT_CENTER, 66, 14, Color(0.88, 0.78, 0.98))

# === ENDLESS MODE PANEL ===
func _draw_endless_panel() -> void:
	var font = game_font
	# Endless panel in bottom bar (center third)
	var ox = 432.0
	var oy = 520.0
	var pw = 385.0
	var ph = 82.0
	# Panel background
	draw_rect(Rect2(ox, oy, pw, ph), Color(0.06, 0.08, 0.14, 0.85))
	draw_rect(Rect2(ox, oy, pw, ph), Color(0.28, 0.38, 0.75, 0.35), false, 1.5)
	# Blue accent line at top
	draw_rect(Rect2(ox, oy, pw, 2), Color(0.3, 0.4, 0.8, 0.6))
	_udraw(font, Vector2(ox + 12, oy + 20), "THE ETERNAL CHAPTER", HORIZONTAL_ALIGNMENT_LEFT, pw - 100, 14, Color(0.52, 0.62, 0.92))
	if endless_high_wave > 0:
		_udraw(font, Vector2(ox + 12, oy + 40), "Best: Wave %d" % endless_high_wave, HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.7, 0.7, 0.85))
	else:
		_udraw(font, Vector2(ox + 12, oy + 40), "Infinite scaling waves. How far can you go?", HORIZONTAL_ALIGNMENT_LEFT, pw - 110, 14, Color(0.50, 0.52, 0.65))
	_udraw(font, Vector2(ox + 12, oy + 56), "Hard difficulty | Random themes", HORIZONTAL_ALIGNMENT_LEFT, pw - 110, 14, Color(0.40, 0.42, 0.52))
	# Start button
	draw_rect(Rect2(ox + pw - 88, oy + 18, 78, 46), Color(0.15, 0.20, 0.48, 0.75))
	draw_rect(Rect2(ox + pw - 88, oy + 18, 78, 2), Color(0.3, 0.4, 0.7, 0.5))
	_udraw(font, Vector2(ox + pw - 50, oy + 48), "START", HORIZONTAL_ALIGNMENT_CENTER, 66, 14, Color(0.72, 0.82, 0.98))

func _start_endless_mode() -> void:
	_remove_survivor_preview()
	# Pick a random level for the background
	endless_background_level = randi() % levels.size()
	current_level = endless_background_level
	_reset_game()
	endless_mode = true
	endless_mutation = ""
	gold = 150
	lives = 20
	selected_difficulty = 2  # Hard
	total_waves = 999999
	_setup_path_for_level(current_level)
	_generate_decorations_for_level(current_level)
	_stop_music()
	menu_overlay.visible = false
	top_bar.visible = true
	bottom_panel.visible = true
	game_over_label.visible = false
	return_button.visible = false
	game_state = GameState.PLAYING
	start_button.text = "  START WAVE  "
	# Setup tower buttons (same as _do_level_start)
	tower_buttons[TowerType.ROBIN_HOOD].text = "Robin [%dG]" % _get_discounted_cost(TowerType.ROBIN_HOOD)
	tower_buttons[TowerType.ROBIN_HOOD].disabled = false
	tower_buttons[TowerType.ALICE].text = "Alice [%dG]" % _get_discounted_cost(TowerType.ALICE)
	tower_buttons[TowerType.ALICE].disabled = false
	tower_buttons[TowerType.WICKED_WITCH].text = "Witch [%dG]" % _get_discounted_cost(TowerType.WICKED_WITCH)
	tower_buttons[TowerType.WICKED_WITCH].disabled = false
	tower_buttons[TowerType.PETER_PAN].text = "Peter [%dG]" % _get_discounted_cost(TowerType.PETER_PAN)
	tower_buttons[TowerType.PETER_PAN].disabled = false
	tower_buttons[TowerType.PHANTOM].text = "Phantom [%dG]" % _get_discounted_cost(TowerType.PHANTOM)
	tower_buttons[TowerType.PHANTOM].disabled = false
	tower_buttons[TowerType.SCROOGE].text = "Scrooge [%dG]" % _get_discounted_cost(TowerType.SCROOGE)
	tower_buttons[TowerType.SCROOGE].disabled = false
	var new_char_order = [TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA, TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR]
	var new_char_labels = {
		TowerType.SHERLOCK: "Holmes [%dG]" % _get_discounted_cost(TowerType.SHERLOCK),
		TowerType.TARZAN: "Tarzan [%dG]" % _get_discounted_cost(TowerType.TARZAN),
		TowerType.DRACULA: "Dracula [%dG]" % _get_discounted_cost(TowerType.DRACULA),
		TowerType.MERLIN: "Merlin [%dG]" % _get_discounted_cost(TowerType.MERLIN),
		TowerType.FRANKENSTEIN: "Monster [%dG]" % _get_discounted_cost(TowerType.FRANKENSTEIN),
		TowerType.SHADOW_AUTHOR: "Author [%dG]" % _get_discounted_cost(TowerType.SHADOW_AUTHOR),
	}
	var new_visible_count := 0
	for tt in new_char_order:
		if tower_buttons.has(tt):
			if tt in survivor_types and _is_character_unlocked(tt):
				var bx = 8 + new_visible_count * 158
				tower_buttons[tt].position = Vector2(bx, 42)
				tower_buttons[tt].visible = true
				tower_buttons[tt].text = new_char_labels[tt]
				tower_buttons[tt].disabled = false
				new_visible_count += 1
			else:
				tower_buttons[tt].visible = false
	if new_visible_count > 0:
		bottom_panel.size.y = 80
		bottom_panel.position.y = 720 - 80
	else:
		bottom_panel.size.y = 42
		bottom_panel.position.y = 720 - 42
	start_button.visible = true
	start_button.disabled = false
	speed_button.visible = true
	update_hud()
	info_label.text = "The Eternal Chapter (Endless) — Place your towers!"
	wave_auto_timer = -1.0

func _start_boss_rush() -> void:
	_remove_survivor_preview()
	var bg_level = randi() % levels.size()
	current_level = bg_level
	_reset_game()
	boss_rush_mode = true
	boss_rush_wave = 0
	gold = 500
	lives = 10
	selected_difficulty = 2  # Hard
	total_waves = 10
	_setup_path_for_level(current_level)
	_generate_decorations_for_level(current_level)
	_stop_music()
	menu_overlay.visible = false
	top_bar.visible = true
	bottom_panel.visible = true
	game_over_label.visible = false
	return_button.visible = false
	game_state = GameState.PLAYING
	start_button.text = "  START WAVE  "
	# Setup tower buttons (same as _do_level_start / _start_endless_mode)
	tower_buttons[TowerType.ROBIN_HOOD].text = "Robin [%dG]" % _get_discounted_cost(TowerType.ROBIN_HOOD)
	tower_buttons[TowerType.ROBIN_HOOD].disabled = false
	tower_buttons[TowerType.ALICE].text = "Alice [%dG]" % _get_discounted_cost(TowerType.ALICE)
	tower_buttons[TowerType.ALICE].disabled = false
	tower_buttons[TowerType.WICKED_WITCH].text = "Witch [%dG]" % _get_discounted_cost(TowerType.WICKED_WITCH)
	tower_buttons[TowerType.WICKED_WITCH].disabled = false
	tower_buttons[TowerType.PETER_PAN].text = "Peter [%dG]" % _get_discounted_cost(TowerType.PETER_PAN)
	tower_buttons[TowerType.PETER_PAN].disabled = false
	tower_buttons[TowerType.PHANTOM].text = "Phantom [%dG]" % _get_discounted_cost(TowerType.PHANTOM)
	tower_buttons[TowerType.PHANTOM].disabled = false
	tower_buttons[TowerType.SCROOGE].text = "Scrooge [%dG]" % _get_discounted_cost(TowerType.SCROOGE)
	tower_buttons[TowerType.SCROOGE].disabled = false
	var new_char_order = [TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA, TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR]
	var new_char_labels = {
		TowerType.SHERLOCK: "Holmes [%dG]" % _get_discounted_cost(TowerType.SHERLOCK),
		TowerType.TARZAN: "Tarzan [%dG]" % _get_discounted_cost(TowerType.TARZAN),
		TowerType.DRACULA: "Dracula [%dG]" % _get_discounted_cost(TowerType.DRACULA),
		TowerType.MERLIN: "Merlin [%dG]" % _get_discounted_cost(TowerType.MERLIN),
		TowerType.FRANKENSTEIN: "Monster [%dG]" % _get_discounted_cost(TowerType.FRANKENSTEIN),
		TowerType.SHADOW_AUTHOR: "Author [%dG]" % _get_discounted_cost(TowerType.SHADOW_AUTHOR),
	}
	var new_visible_count := 0
	for tt in new_char_order:
		if tower_buttons.has(tt):
			if tt in survivor_types and _is_character_unlocked(tt):
				var bx = 8 + new_visible_count * 158
				tower_buttons[tt].position = Vector2(bx, 42)
				tower_buttons[tt].visible = true
				tower_buttons[tt].text = new_char_labels[tt]
				tower_buttons[tt].disabled = false
				new_visible_count += 1
			else:
				tower_buttons[tt].visible = false
	if new_visible_count > 0:
		bottom_panel.size.y = 80
		bottom_panel.position.y = 720 - 80
	else:
		bottom_panel.size.y = 42
		bottom_panel.position.y = 720 - 42
	start_button.visible = true
	start_button.disabled = false
	speed_button.visible = true
	update_hud()
	info_label.text = "BOSS RUSH — 10 Bosses, 500G, 10 Lives. Survive!"
	wave_auto_timer = -1.0

const DAILY_MODIFIERS: Array = [
	{"name": "Costly Towers", "effect": "cost_mult", "value": 1.5},
	{"name": "Fragile", "effect": "lives", "value": 10},
	{"name": "Speed Demons", "effect": "speed_mult", "value": 1.3},
	{"name": "Iron Skin", "effect": "hp_mult", "value": 1.4},
	{"name": "Poverty", "effect": "gold", "value": 50},
	{"name": "Marathon", "effect": "extra_waves", "value": 10},
]

func _generate_daily_challenge() -> Dictionary:
	var today = Time.get_date_string_from_system()
	var seed_val = today.hash()
	var rng = RandomNumberGenerator.new()
	rng.seed = seed_val
	var level_idx = rng.randi() % levels.size()
	var mod_idx = rng.randi() % DAILY_MODIFIERS.size()
	return {"level": level_idx, "modifier": DAILY_MODIFIERS[mod_idx], "date": today}

func _start_daily_challenge() -> void:
	var challenge = _generate_daily_challenge()
	var today = Time.get_date_string_from_system()
	if daily_challenge_completed_today and daily_challenge_last_date == today:
		info_label.text = "Already completed today's challenge!"
		return
	daily_challenge_active = true
	daily_challenge_level = challenge["level"]
	daily_challenge_modifier = challenge["modifier"]["name"]
	current_level = daily_challenge_level
	_reset_game()
	var mod = challenge["modifier"]
	# Apply modifier
	match mod["effect"]:
		"lives":
			lives = int(mod["value"])
		"gold":
			gold = int(mod["value"])
		"extra_waves":
			total_waves += int(mod["value"])
	_do_level_start(daily_challenge_level)
	# Override after _do_level_start if needed
	if mod["effect"] == "lives":
		lives = int(mod["value"])
	elif mod["effect"] == "gold":
		gold = int(mod["value"])
	elif mod["effect"] == "extra_waves":
		total_waves += int(mod["value"])
	daily_challenge_active = true
	update_hud()
	info_label.text = "DAILY CHALLENGE: %s — %s" % [levels[daily_challenge_level]["name"], daily_challenge_modifier]

# === PRESTIGE SYSTEM ("New Story") ===
func _do_prestige() -> void:
	prestige_level += 1
	completed_levels.clear()
	level_stars.clear()
	level_difficulty_medals.clear()
	level_difficulty_stars.clear()
	# Keep: currencies, characters, relics, cosmetics, knowledge, chests, bindings
	spawn_floating_text(Vector2(640, 300), "NEW STORY! Prestige %d" % prestige_level, Color(1.0, 0.85, 0.2), 28.0, 3.0)
	_save_game()

func _can_prestige() -> bool:
	return completed_levels.size() >= levels.size()

# === MILESTONE REWARDS ===
const MILESTONE_DEFS: Array = [
	{"id": "kills_100", "stat": "kills", "target": 100, "reward_type": "gold", "reward_amount": 50, "name": "100 Kills"},
	{"id": "kills_1k", "stat": "kills", "target": 1000, "reward_type": "shards", "reward_amount": 20, "name": "1,000 Kills"},
	{"id": "kills_5k", "stat": "kills", "target": 5000, "reward_type": "quills", "reward_amount": 15, "name": "5,000 Kills"},
	{"id": "kills_10k", "stat": "kills", "target": 10000, "reward_type": "gold", "reward_amount": 200, "name": "10,000 Kills"},
	{"id": "damage_50k", "stat": "damage", "target": 50000, "reward_type": "shards", "reward_amount": 15, "name": "50k Damage"},
	{"id": "damage_500k", "stat": "damage", "target": 500000, "reward_type": "quills", "reward_amount": 20, "name": "500k Damage"},
	{"id": "gold_1k", "stat": "gold_earned", "target": 1000, "reward_type": "shards", "reward_amount": 10, "name": "1k Gold Earned"},
	{"id": "gold_10k", "stat": "gold_earned", "target": 10000, "reward_type": "gold", "reward_amount": 100, "name": "10k Gold Earned"},
	{"id": "levels_10", "stat": "levels", "target": 10, "reward_type": "quills", "reward_amount": 10, "name": "10 Levels"},
	{"id": "levels_all", "stat": "levels", "target": 37, "reward_type": "gold_chest", "reward_amount": 1, "name": "All Levels"},
	{"id": "stars_30", "stat": "stars", "target": 30, "reward_type": "shards", "reward_amount": 25, "name": "30 Stars"},
	{"id": "stars_111", "stat": "stars", "target": 111, "reward_type": "gold_chest", "reward_amount": 1, "name": "111 Stars"},
	{"id": "combo_10", "stat": "combo", "target": 10, "reward_type": "quills", "reward_amount": 10, "name": "10x Combo"},
]

func _check_milestones() -> void:
	for m in MILESTONE_DEFS:
		if milestone_claimed.get(m["id"], false):
			continue
		var current = 0
		match m["stat"]:
			"kills": current = total_enemies_killed
			"damage": current = total_damage
			"gold_earned": current = total_gold_earned
			"levels": current = completed_levels.size()
			"stars":
				var s = 0
				for k in level_stars:
					s += level_stars[k]
				current = s
			"combo": current = combo_best
		if current >= m["target"]:
			milestone_claimed[m["id"]] = true
			# Grant reward
			match m["reward_type"]:
				"gold": player_gold += m["reward_amount"]
				"shards": player_relic_shards += m["reward_amount"]
				"quills": player_quills += m["reward_amount"]
				"gold_chest": treasure_chests_owned["gold"] += m["reward_amount"]
			spawn_floating_text(Vector2(640, 280), "MILESTONE: %s!" % m["name"], Color(1.0, 0.85, 0.2), 20.0, 2.5)
			_save_game()

# === CHARACTER MASTERY CHALLENGES ===
const MASTERY_CHALLENGE_DEFS: Array = [
	{"id": "kills_5000", "name": "Veteran Slayer", "desc": "Kill 5,000 enemies", "stat": "kills", "target": 5000},
	{"id": "damage_500k", "name": "Damage Dealer", "desc": "Deal 500k damage", "stat": "damage", "target": 500000},
	{"id": "hard_wins_10", "name": "Hardened", "desc": "Win 10 Hard levels", "stat": "hard_wins", "target": 10},
	{"id": "three_star_all", "name": "Perfectionist", "desc": "3-star all character levels", "stat": "three_stars", "target": 3},
	{"id": "all_abilities", "name": "Master of All", "desc": "Use all abilities in one level", "stat": "abilities_used", "target": 9},
]

func _check_mastery_for_character(tower_type: int) -> void:
	if not survivor_progress.has(tower_type):
		return
	var lvl = survivor_progress[tower_type].get("level", 1)
	if lvl < 20:
		return  # Must be level 20 to track mastery
	if not mastery_challenges.has(str(tower_type)):
		mastery_challenges[str(tower_type)] = {}
	var mc = mastery_challenges[str(tower_type)]
	var total_dmg = survivor_progress[tower_type].get("total_damage", 0.0)
	# Check each challenge
	if not mc.get("kills_5000", false) and total_enemies_killed >= 5000:
		mc["kills_5000"] = true
	if not mc.get("damage_500k", false) and total_dmg >= 500000.0:
		mc["damage_500k"] = true
	mastery_challenges[str(tower_type)] = mc

# === TROPHY STORE DRAWING (as Emporium sub-category) ===
func _draw_trophy_store() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), col)
	# Gold border
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	# Title
	_udraw(font, Vector2(panel_x + panel_w * 0.5 - 60, panel_y + 28), "TROPHY STORE", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.85, 0.7, 0.2, 0.9))
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Trophies: %d" % trophy_currency, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.85, 0.7, 0.2))
	draw_rect(Rect2(panel_x + panel_w * 0.5 - 80, panel_y + 34, 160, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.4))
	# Categories
	var store_cats = ["auras", "trails", "fanfares", "themes"]
	var store_cat_names = ["Tower Auras", "Projectile Trails", "Victory Fanfares", "Menu Themes"]
	var card_w = 260.0
	var card_h = 50.0
	var start_y = panel_y + 48.0
	for ci in range(store_cats.size()):
		var cat_key = store_cats[ci]
		var items = trophy_store_items.get(cat_key, [])
		# Category header
		draw_rect(Rect2(panel_x + 10, start_y, panel_w - 20, 18), Color(0.6, 0.3, 0.8, 0.10))
		_udraw(font, Vector2(panel_x + 20, start_y + 13), store_cat_names[ci], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.7, 0.5, 0.85))
		start_y += 22.0
		for ii in range(items.size()):
			var item = items[ii]
			var col_i = ii % 4
			var row_i = ii / 4
			var ix = panel_x + 10 + float(col_i) * (card_w + 10)
			var iy = start_y + float(row_i) * (card_h + 6)
			var is_owned = item["id"] in owned_cosmetics
			var is_equipped = equipped_cosmetics.get(cat_key, "") == item["id"]
			# Background
			var bg = Color(0.12, 0.08, 0.14, 0.8) if is_owned else Color(0.06, 0.05, 0.08, 0.8)
			if is_equipped:
				bg = Color(0.14, 0.12, 0.06, 0.8)
			draw_rect(Rect2(ix, iy, card_w, card_h), bg)
			var bdr = Color(0.85, 0.7, 0.2, 0.5) if is_owned else Color(0.3, 0.25, 0.3, 0.3)
			draw_rect(Rect2(ix, iy, card_w, card_h), bdr, false, 1.0)
			# Color swatch for auras/trails
			if item.has("color"):
				var swatch_col = item["color"]
				if cat_key == "auras" and item["id"] == "aura_prismatic":
					swatch_col = Color.from_hsv(fmod(_time * 0.3, 1.0), 0.7, 0.9, 0.5)
				draw_circle(Vector2(ix + 18, iy + card_h * 0.5), 10, swatch_col)
			# Name
			_udraw(font, Vector2(ix + 34, iy + 18), item["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 40), 15, Color(0.8, 0.7, 0.5))
			_udraw(font, Vector2(ix + 34, iy + 32), item["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 40), 14, Color(0.5, 0.45, 0.38))
			if is_equipped:
				_udraw(font, Vector2(ix + card_w - 65, iy + 18), "EQUIPPED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.3, 0.8, 0.3))
			elif is_owned:
				_udraw(font, Vector2(ix + card_w - 50, iy + 18), "OWNED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.5, 0.7, 0.9))
			else:
				_udraw(font, Vector2(ix + card_w - 60, iy + 18), "%d T" % item["cost"], HORIZONTAL_ALIGNMENT_RIGHT, -1, 15, Color(0.85, 0.7, 0.2))
		var rows_in_cat = (items.size() + 3) / 4
		start_y += float(rows_in_cat) * (card_h + 6) + 8.0
	# Back button
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.7, 0.4))

# === CLICK HANDLERS FOR NEW FEATURES ===
func _on_chapters_odyssey_clicked(mouse_pos: Vector2) -> void:
	# Check if clicking the odyssey start button (bottom bar left)
	var opw = 385.0
	var ox = 38.0 + opw - 88.0
	var oy = 520.0 + 18.0
	if mouse_pos.x >= ox and mouse_pos.x <= ox + 78 and mouse_pos.y >= oy and mouse_pos.y <= oy + 46:
		if not odyssey_completed_this_week:
			_start_odyssey()
	# Check if clicking the endless mode start button (bottom bar center)
	var epw = 385.0
	var ex = 432.0 + epw - 88.0
	var ey = 520.0 + 18.0
	if mouse_pos.x >= ex and mouse_pos.x <= ex + 78 and mouse_pos.y >= ey and mouse_pos.y <= ey + 46:
		_start_endless_mode()

func _on_trophy_store_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button (bottom-left)
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		queue_redraw()
		return
	var store_cats = ["auras", "trails", "fanfares", "themes"]
	var card_w = 260.0
	var card_h = 50.0
	var start_y = panel_y + 48.0
	for ci in range(store_cats.size()):
		var cat_key = store_cats[ci]
		var items = trophy_store_items.get(cat_key, [])
		start_y += 22.0  # category header
		for ii in range(items.size()):
			var item = items[ii]
			var col_i = ii % 4
			var row_i = ii / 4
			var ix = panel_x + 10 + float(col_i) * (card_w + 10)
			var iy = start_y + float(row_i) * (card_h + 6)
			if mouse_pos.x >= ix and mouse_pos.x <= ix + card_w and mouse_pos.y >= iy and mouse_pos.y <= iy + card_h:
				var is_owned = item["id"] in owned_cosmetics
				if is_owned:
					# Toggle equip/unequip
					if equipped_cosmetics.get(cat_key, "") == item["id"]:
						equipped_cosmetics.erase(cat_key)
					else:
						equipped_cosmetics[cat_key] = item["id"]
					_save_game()
				elif trophy_currency >= item["cost"]:
					# Purchase
					trophy_currency -= item["cost"]
					owned_cosmetics.append(item["id"])
					equipped_cosmetics[cat_key] = item["id"]
					_save_game()
				queue_redraw()
				return
		var rows_in_cat = (items.size() + 3) / 4
		start_y += float(rows_in_cat) * (card_h + 6) + 8.0

# === TOME BINDINGS SHOP ===
func _draw_binding_shop() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var content_top = panel_y + 48.0
	var content_bottom = panel_y + panel_h - 50.0
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), col)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "TOME BINDINGS", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.85, 0.7, 0.2, 0.9))
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Shards: %d" % player_relic_shards, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.85, 0.7, 0.2))
	var card_w = 260.0
	var card_h = 48.0
	var rarity_order = ["tattered", "bound", "gilded", "mythic", "forbidden"]
	var rarity_names = {"tattered": "Tattered", "bound": "Bound", "gilded": "Gilded", "mythic": "Mythic", "forbidden": "Forbidden"}
	var rarity_costs = {"tattered": 15, "bound": 35, "gilded": 80, "mythic": 200, "forbidden": 500}
	var rarity_colors = RARITY_COLORS
	var start_y = content_top - binding_shop_scroll
	var total_content_h = 0.0
	for ri in range(rarity_order.size()):
		var rarity = rarity_order[ri]
		# Category header
		if start_y + 18 > content_top and start_y < content_bottom:
			draw_rect(Rect2(panel_x + 10, start_y, panel_w - 20, 18), Color(0.6, 0.3, 0.8, 0.10))
			_udraw(font, Vector2(panel_x + 20, start_y + 13), rarity_names[rarity] + " (%d shards)" % rarity_costs[rarity], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, rarity_colors[rarity])
		start_y += 22.0
		total_content_h += 22.0
		var bindings_in_rarity: Array = []
		for b in TOME_BINDINGS:
			if b["rarity"] == rarity:
				bindings_in_rarity.append(b)
		for ii in range(bindings_in_rarity.size()):
			var b = bindings_in_rarity[ii]
			var col_i = ii % 4
			var row_i = ii / 4
			var ix = panel_x + 10 + float(col_i) * (card_w + 10)
			var iy = start_y + float(row_i) * (card_h + 6)
			if iy + card_h < content_top or iy > content_bottom:
				continue
			var count = owned_bindings.get(b["id"], 0)
			var bg = Color(0.12, 0.08, 0.14, 0.8) if count > 0 else Color(0.06, 0.05, 0.08, 0.8)
			draw_rect(Rect2(ix, iy, card_w, card_h), bg)
			draw_rect(Rect2(ix, iy, card_w, card_h), Color(rarity_colors[rarity].r, rarity_colors[rarity].g, rarity_colors[rarity].b, 0.3), false, 1.0)
			_udraw(font, Vector2(ix + 8, iy + 16), b["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 80), 15, Color(0.8, 0.7, 0.5))
			_udraw(font, Vector2(ix + 8, iy + 30), b["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 16), 14, Color(0.5, 0.45, 0.38))
			if count > 0:
				_udraw(font, Vector2(ix + card_w - 35, iy + 16), "x%d" % count, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.3, 0.8, 0.3))
			_udraw(font, Vector2(ix + card_w - 55, iy + 30), "%d S" % rarity_costs[rarity], HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.85, 0.7, 0.2))
		var rows_in_rarity = (bindings_in_rarity.size() + 3) / 4
		var section_h = float(rows_in_rarity) * (card_h + 6) + 8.0
		start_y += section_h
		total_content_h += section_h
	# Clamp scroll
	var max_scroll = maxf(0.0, total_content_h - (content_bottom - content_top))
	binding_shop_scroll = clampf(binding_shop_scroll, 0.0, max_scroll)
	# Scroll indicator
	if max_scroll > 0:
		var bar_x = panel_x + panel_w - 10
		var bar_h = content_bottom - content_top
		var thumb_h = maxf(30.0, bar_h * bar_h / (bar_h + max_scroll))
		var thumb_y = content_top + (binding_shop_scroll / max_scroll) * (bar_h - thumb_h)
		draw_rect(Rect2(bar_x, content_top, 4, bar_h), Color(0.2, 0.2, 0.25, 0.3))
		draw_rect(Rect2(bar_x, thumb_y, 4, thumb_h), Color(0.85, 0.7, 0.2, 0.5))
	# Back button (always visible at bottom)
	draw_rect(Rect2(panel_x + 2, panel_y + panel_h - 50, panel_w - 4, 48), Color(0.03, 0.03, 0.06, 0.95))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.7, 0.4))

func _on_binding_shop_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var content_top = panel_y + 48.0
	var content_bottom = panel_y + panel_h - 50.0
	# Back button
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		binding_shop_scroll = 0.0
		queue_redraw()
		return
	# Don't process clicks outside content area
	if mouse_pos.y < content_top or mouse_pos.y > content_bottom:
		return
	var card_w = 260.0
	var card_h = 48.0
	var rarity_order = ["tattered", "bound", "gilded", "mythic", "forbidden"]
	var rarity_costs = {"tattered": 15, "bound": 35, "gilded": 80, "mythic": 200, "forbidden": 500}
	var start_y = content_top - binding_shop_scroll
	for ri in range(rarity_order.size()):
		var rarity = rarity_order[ri]
		start_y += 22.0
		var bindings_in_rarity: Array = []
		for b in TOME_BINDINGS:
			if b["rarity"] == rarity:
				bindings_in_rarity.append(b)
		for ii in range(bindings_in_rarity.size()):
			var b = bindings_in_rarity[ii]
			var col_i = ii % 4
			var row_i = ii / 4
			var ix = panel_x + 10 + float(col_i) * (card_w + 10)
			var iy = start_y + float(row_i) * (card_h + 6)
			if iy + card_h < content_top or iy > content_bottom:
				continue
			if mouse_pos.x >= ix and mouse_pos.x <= ix + card_w and mouse_pos.y >= iy and mouse_pos.y <= iy + card_h:
				var cost = rarity_costs[rarity]
				if player_relic_shards >= cost:
					player_relic_shards -= cost
					owned_bindings[b["id"]] = owned_bindings.get(b["id"], 0) + 1
					_mark_binding_discovered(b["id"])
					_add_recent_item(b["name"], b.get("rarity", "tattered"))
					emporium_sub_message = "Purchased %s!" % b["name"]
					emporium_sub_message_timer = 2.0
					_save_game()
				else:
					emporium_sub_message = "Not enough Relic Shards!"
					emporium_sub_message_timer = 2.0
				queue_redraw()
				return
		var rows_in_rarity = (bindings_in_rarity.size() + 3) / 4
		start_y += float(rows_in_rarity) * (card_h + 6) + 8.0

func _on_power_selection_clicked(mouse_pos: Vector2) -> void:
	var pw = 700.0
	var ph = 480.0
	var px = (1280.0 - pw) / 2.0
	var py = (720.0 - ph) / 2.0
	# Cancel button (top-right corner of panel)
	if Rect2(px + pw - 112, py + 10, 100, 40).has_point(mouse_pos):
		power_selection_open = false
		queue_redraw()
		return
	# Check power item clicks
	for i in range(battle_power_definitions.size()):
		var bp = battle_power_definitions[i]
		var bx = px + 30
		var by = py + 70 + i * 55
		if mouse_pos.x >= bx and mouse_pos.x <= bx + pw - 60 and mouse_pos.y >= by and mouse_pos.y <= by + 48:
			_toggle_power_selection(bp["id"])
			return
	# Check start button
	var sb_w = 260.0
	var sb_h = 50.0
	var sbx = px + (pw - sb_w) * 0.5
	var sby = py + ph - sb_h - 16
	if mouse_pos.x >= sbx and mouse_pos.x <= sbx + sb_w and mouse_pos.y >= sby and mouse_pos.y <= sby + sb_h:
		_close_power_selection_and_start()
		return

func _on_emporium_tile_clicked_extended(index: int) -> void:
	if index == 6:
		# Trophy Store — switch to trophy store view
		emporium_sub_category = 6
		queue_redraw()
	else:
		_on_emporium_tile_clicked(index)

# =====================================================================================
# === FEATURE 3: ITEM DISMANTLING / SALVAGING ==========================================
# =====================================================================================

func _salvage_binding(binding_id: String) -> void:
	var count = owned_bindings.get(binding_id, 0)
	if count <= 0:
		return
	var binding = _find_binding(binding_id)
	if binding.is_empty():
		return
	var rarity = binding.get("rarity", "tattered")
	var shards_gained = salvage_rates.get(rarity, 5)
	owned_bindings[binding_id] = count - 1
	if owned_bindings[binding_id] <= 0:
		owned_bindings.erase(binding_id)
	# Remove from equipped if was equipped
	for t in equipped_bindings:
		if binding_id in equipped_bindings[t]:
			equipped_bindings[t].erase(binding_id)
	player_relic_shards += shards_gained
	_check_achievement("salvage_master", 1)
	_save_game()

func _draw_salvage_panel() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Background
	for i in range(56):
		var t = float(i) / 55.0
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), menu_bg_section.lerp(menu_bg_dark, t))
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4), false, 1.5)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "SALVAGE WORKSHOP", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Shards: %d" % player_relic_shards, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 46), "Dismantle unwanted gear into Relic Shards", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, menu_text_muted)
	var card_w = 260.0
	var card_h = 52.0
	var col_count = 4
	var row = 0
	var col = 0
	var content_y = panel_y + 60.0
	for bid in owned_bindings:
		if owned_bindings[bid] <= 0:
			continue
		var binding = _find_binding(bid)
		if binding.is_empty():
			continue
		var rarity = binding.get("rarity", "tattered")
		var shards_val = salvage_rates.get(rarity, 5)
		var ix = panel_x + 10 + float(col) * (card_w + 10)
		var iy = content_y + float(row) * (card_h + 6)
		if iy + card_h > panel_y + panel_h - 50:
			break
		var rarity_col = RARITY_COLORS.get(rarity, Color(0.6, 0.6, 0.65))
		draw_rect(Rect2(ix, iy, card_w, card_h), Color(0.08, 0.06, 0.10, 0.85))
		draw_rect(Rect2(ix, iy, card_w, card_h), Color(rarity_col.r, rarity_col.g, rarity_col.b, 0.3), false, 1.0)
		_udraw(font, Vector2(ix + 8, iy + 16), binding.get("name", "?"), HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 90), 15, Color(0.8, 0.7, 0.5))
		_udraw(font, Vector2(ix + 8, iy + 32), "x%d" % owned_bindings[bid], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.5, 0.8, 0.5))
		# Salvage button
		draw_rect(Rect2(ix + card_w - 75, iy + 8, 65, 34), Color(0.5, 0.15, 0.1, 0.7))
		draw_rect(Rect2(ix + card_w - 75, iy + 8, 65, 34), Color(0.8, 0.3, 0.2, 0.4), false, 1.0)
		_udraw(font, Vector2(ix + card_w - 42, iy + 22), "SALVAGE", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(1.0, 0.8, 0.6))
		_udraw(font, Vector2(ix + card_w - 42, iy + 36), "+%d S" % shards_val, HORIZONTAL_ALIGNMENT_CENTER, -1, 14, menu_gold)
		col += 1
		if col >= col_count:
			col = 0
			row += 1
	# Back button
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.7, 0.4))

func _on_salvage_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		queue_redraw()
		return
	var card_w = 260.0
	var card_h = 52.0
	var content_y = panel_y + 60.0
	var col = 0
	var row = 0
	for bid in owned_bindings:
		if owned_bindings[bid] <= 0:
			continue
		var ix = panel_x + 10 + float(col) * (card_w + 10)
		var iy = content_y + float(row) * (card_h + 6)
		# Salvage button hitbox
		if mouse_pos.x >= ix + card_w - 75 and mouse_pos.x <= ix + card_w - 10 and mouse_pos.y >= iy + 8 and mouse_pos.y <= iy + 42:
			_salvage_binding(bid)
			queue_redraw()
			return
		col += 1
		if col >= 4:
			col = 0
			row += 1

# =====================================================================================
# === FEATURE 4: GOLDEN TREASURE CHEST CRAFTING ========================================
# =====================================================================================

func _draw_chest_crafting() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	for i in range(56):
		var t = float(i) / 55.0
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), menu_bg_section.lerp(menu_bg_dark, t))
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4), false, 1.5)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "CHEST FORGE", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Shards: %d" % player_relic_shards, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 46), "Forge Golden Treasure Chests from Relic Shards", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, menu_text_muted)
	var tier_colors = [Color(0.7, 0.5, 0.25), Color(0.7, 0.7, 0.75), Color(0.95, 0.8, 0.2)]
	var tier_names = ["Bronze", "Silver", "Golden"]
	var chest_keys = ["bronze", "silver", "gold"]
	for i in range(3):
		var craft = golden_chest_craft_costs[i]
		var cx = panel_x + 80 + float(i) * 360.0
		var cy = panel_y + 100.0
		var cw = 320.0
		var ch = 300.0
		draw_rect(Rect2(cx, cy, cw, ch), Color(0.06, 0.05, 0.08, 0.9))
		draw_rect(Rect2(cx, cy, cw, ch), Color(tier_colors[i].r, tier_colors[i].g, tier_colors[i].b, 0.4), false, 2.0)
		# Chest icon (simple rectangle chest)
		var icon_y = cy + 40
		draw_rect(Rect2(cx + cw * 0.5 - 30, icon_y, 60, 45), tier_colors[i])
		draw_rect(Rect2(cx + cw * 0.5 - 32, icon_y, 64, 5), Color(tier_colors[i].r * 0.7, tier_colors[i].g * 0.7, tier_colors[i].b * 0.7))
		draw_rect(Rect2(cx + cw * 0.5 - 5, icon_y + 15, 10, 15), Color(0.2, 0.15, 0.1))
		_udraw(font, Vector2(cx + cw * 0.5, icon_y + 70), tier_names[i] + " Treasure Chest", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, tier_colors[i])
		_udraw(font, Vector2(cx + cw * 0.5, icon_y + 92), "Owned: %d" % treasure_chests_owned.get(chest_keys[i], 0), HORIZONTAL_ALIGNMENT_CENTER, -1, 15, menu_text)
		_udraw(font, Vector2(cx + cw * 0.5, icon_y + 115), "Cost: %d Shards" % craft["shard_cost"], HORIZONTAL_ALIGNMENT_CENTER, -1, 16, menu_gold)
		# Craft button
		var can_afford = player_relic_shards >= craft["shard_cost"]
		var btn_col = Color(0.15, 0.35, 0.15, 0.8) if can_afford else Color(0.12, 0.1, 0.1, 0.6)
		draw_rect(Rect2(cx + cw * 0.5 - 55, icon_y + 140, 110, 40), btn_col)
		draw_rect(Rect2(cx + cw * 0.5 - 55, icon_y + 140, 110, 40), Color(0.4, 0.8, 0.3, 0.4) if can_afford else Color(0.3, 0.3, 0.3, 0.3), false, 1.0)
		_udraw(font, Vector2(cx + cw * 0.5, icon_y + 165), "FORGE", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.9, 0.85, 0.6) if can_afford else Color(0.4, 0.4, 0.4))
	# Back button
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.7, 0.4))

func _on_chest_crafting_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		queue_redraw()
		return
	var chest_keys = ["bronze", "silver", "gold"]
	for i in range(3):
		var craft = golden_chest_craft_costs[i]
		var cx = panel_x + 80 + float(i) * 360.0
		var icon_y = panel_y + 100.0 + 40
		var btn_x = cx + 160.0 - 55
		var btn_y = icon_y + 140
		if mouse_pos.x >= btn_x and mouse_pos.x <= btn_x + 110 and mouse_pos.y >= btn_y and mouse_pos.y <= btn_y + 40:
			if player_relic_shards >= craft["shard_cost"]:
				player_relic_shards -= craft["shard_cost"]
				treasure_chests_owned[chest_keys[i]] = treasure_chests_owned.get(chest_keys[i], 0) + 1
				_save_game()
			queue_redraw()
			return

# =====================================================================================
# === FEATURE 5: ROTATING DAILY DEALS SHOP ============================================
# =====================================================================================

func _generate_daily_deals() -> void:
	var today = Time.get_date_string_from_system()
	if daily_deals_date == today and daily_deals.size() == 3:
		return
	# Seed based on date for consistent deals per day
	var date = Time.get_date_dict_from_system()
	var day_seed = date["year"] * 366 + date["month"] * 31 + date["day"]
	var rng = RandomNumberGenerator.new()
	rng.seed = day_seed
	daily_deals.clear()
	daily_deals_purchased = [false, false, false]
	# Deal types: bindings, battle powers, currency packs, chests
	var deal_pool = []
	# Add some random bindings
	for b in TOME_BINDINGS:
		deal_pool.append({"type": "binding", "item": b, "cost_type": "quills", "cost": rng.randi_range(5, 20), "name": b["name"], "desc": b["desc"]})
	# Add power deals
	for bp in battle_power_definitions:
		deal_pool.append({"type": "power", "power_id": bp["id"], "cost_type": "shards", "cost": rng.randi_range(8, 18), "name": bp["name"] + " x2", "desc": bp["desc"], "amount": 2})
	# Add currency deals
	deal_pool.append({"type": "currency", "currency": "shards", "amount": rng.randi_range(20, 50), "cost_type": "quills", "cost": rng.randi_range(5, 12), "name": "Shard Pouch", "desc": "A pouch of Relic Shards"})
	deal_pool.append({"type": "currency", "currency": "quills", "amount": rng.randi_range(5, 15), "cost_type": "shards", "cost": rng.randi_range(15, 30), "name": "Quill Bundle", "desc": "A bundle of Enchanted Quills"})
	deal_pool.append({"type": "chest", "chest_tier": "silver", "cost_type": "quills", "cost": rng.randi_range(15, 25), "name": "Silver Chest", "desc": "Uncommon treasures await"})
	# Pick 3 random deals
	deal_pool.shuffle()
	for i in range(min(3, deal_pool.size())):
		daily_deals.append(deal_pool[i])
	daily_deals_date = today

func _draw_daily_deals() -> void:
	var font = game_font
	# Small panel at top of chapters view
	var dx = 830.0
	var dy = 50.0
	var dw = 420.0
	var dh = 220.0
	draw_rect(Rect2(dx, dy, dw, dh), Color(0.06, 0.05, 0.10, 0.9))
	draw_rect(Rect2(dx, dy, dw, dh), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.35), false, 1.5)
	_udraw(font, Vector2(dx + dw * 0.5, dy + 18), "DAILY DEALS", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, menu_gold)
	_udraw(font, Vector2(dx + dw * 0.5, dy + 36), "Refreshes at midnight", HORIZONTAL_ALIGNMENT_CENTER, -1, 12, menu_text_muted)
	for i in range(min(3, daily_deals.size())):
		var deal = daily_deals[i]
		var ix = dx + 10
		var iy = dy + 42 + float(i) * 58.0
		var iw = dw - 20
		var ih = 52.0
		var purchased = daily_deals_purchased[i] if i < daily_deals_purchased.size() else false
		var bg_col = Color(0.05, 0.15, 0.05, 0.6) if purchased else Color(0.08, 0.06, 0.12, 0.7)
		draw_rect(Rect2(ix, iy, iw, ih), bg_col)
		draw_rect(Rect2(ix, iy, iw, ih), Color(0.4, 0.35, 0.2, 0.3), false, 1.0)
		_udraw(font, Vector2(ix + 10, iy + 18), deal.get("name", "Deal"), HORIZONTAL_ALIGNMENT_LEFT, int(iw - 120), 15, Color(0.85, 0.75, 0.5))
		_udraw(font, Vector2(ix + 10, iy + 36), deal.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(iw - 120), 14, menu_text_muted)
		if purchased:
			_udraw(font, Vector2(ix + iw - 60, iy + 28), "SOLD", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.4, 0.7, 0.3))
		else:
			if _deal_confirm_index == i and _deal_confirm_timer > 0.0:
				draw_rect(Rect2(ix + iw - 100, iy + 8, 88, 34), Color(0.25, 0.18, 0.05, 0.9))
				draw_rect(Rect2(ix + iw - 100, iy + 8, 88, 34), Color(1.0, 0.8, 0.2, 0.7), false, 2.0)
				_udraw(font, Vector2(ix + iw - 56, iy + 24), "CONFIRM", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(1.0, 0.9, 0.4))
				var bar_fill = clampf(_deal_confirm_timer / 3.0, 0.0, 1.0)
				draw_rect(Rect2(ix + iw - 98, iy + 38, 84 * bar_fill, 3), Color(1.0, 0.85, 0.2, 0.7))
			else:
				var cost_str = "%d %s" % [deal.get("cost", 0), deal.get("cost_type", "").capitalize()]
				draw_rect(Rect2(ix + iw - 100, iy + 8, 88, 34), Color(0.15, 0.12, 0.08, 0.8))
				_udraw(font, Vector2(ix + iw - 56, iy + 30), cost_str, HORIZONTAL_ALIGNMENT_CENTER, -1, 15, menu_gold)

func _on_daily_deals_clicked(mouse_pos: Vector2) -> void:
	var dx = 830.0
	var dy = 50.0
	var dw = 420.0
	for i in range(min(3, daily_deals.size())):
		if daily_deals_purchased[i]:
			continue
		var deal = daily_deals[i]
		var ix = dx + 10
		var iy = dy + 42 + float(i) * 58.0
		var iw = dw - 20
		if mouse_pos.x >= ix + iw - 100 and mouse_pos.x <= ix + iw - 12 and mouse_pos.y >= iy + 8 and mouse_pos.y <= iy + 42:
			if _deal_confirm_index != i:
				_deal_confirm_index = i
				_deal_confirm_timer = 3.0
				queue_redraw()
				return
			_deal_confirm_index = -1
			_deal_confirm_timer = 0.0
			var cost = deal.get("cost", 0)
			var cost_type = deal.get("cost_type", "")
			var can_afford = false
			match cost_type:
				"quills": can_afford = player_quills >= cost
				"shards": can_afford = player_relic_shards >= cost
				"stars": can_afford = player_storybook_stars >= cost
				"gold": can_afford = player_gold >= cost
			if not can_afford:
				return
			# Deduct cost
			match cost_type:
				"quills": player_quills -= cost
				"shards": player_relic_shards -= cost
				"stars": player_storybook_stars -= cost
				"gold": player_gold -= cost
			# Grant reward
			match deal.get("type", ""):
				"binding":
					var b = deal.get("item", {})
					if b.has("id"):
						owned_bindings[b["id"]] = owned_bindings.get(b["id"], 0) + 1
						_mark_binding_discovered(b["id"])
						_add_recent_item(b.get("name", "Binding"), b.get("rarity", "tattered"))
				"power":
					var pid = deal.get("power_id", "")
					var amt = deal.get("amount", 1)
					if pid != "":
						owned_powers[pid] = owned_powers.get(pid, 0) + amt
				"currency":
					var curr = deal.get("currency", "")
					var amt = deal.get("amount", 0)
					match curr:
						"shards": player_relic_shards += amt
						"quills": player_quills += amt
						"stars": player_storybook_stars += amt
						"gold": player_gold += amt
				"chest":
					var tier = deal.get("chest_tier", "bronze")
					treasure_chests_owned[tier] = treasure_chests_owned.get(tier, 0) + 1
			daily_deals_purchased[i] = true
			_save_game()
			queue_redraw()
			return

# =====================================================================================
# === FEATURE 6: SHADOW ARENA (Competitive Leaderboard Mode) ==========================
# =====================================================================================

func _init_shadow_arena() -> void:
	var date = Time.get_date_dict_from_system()
	shadow_arena_weekly_seed = int(Time.get_unix_time_from_system() / 604800)
	# Generate simulated leaderboard
	var rng = RandomNumberGenerator.new()
	rng.seed = shadow_arena_weekly_seed
	arena_leaderboard.clear()
	var bot_names = ["BookWorm_42", "InkSlinger", "PageTurner", "QuillMaster", "ShadowHunter",
		"StoryKeeper", "ChapterOne", "DarkReader", "TaleSpinner", "LibraryGhost",
		"PenFighter", "NovelKnight", "ScrollWarden", "FableHero", "MythBreaker"]
	for i in range(15):
		arena_leaderboard.append({"name": bot_names[i], "score": rng.randi_range(15, 60 - i * 2)})
	arena_leaderboard.sort_custom(func(a, b): return a["score"] > b["score"])
	# Weekly modifiers (2 random)
	var all_mods = ["shadow_infested", "regrow_only", "no_powers", "fast_enemies", "fortified_all", "double_hp"]
	all_mods.shuffle()
	shadow_arena_modifiers = [all_mods[0], all_mods[1]]

func _start_shadow_arena() -> void:
	shadow_arena_active = true
	shadow_arena_wave = 0
	# Pick a level from mid-to-late game (avoid beginner maps)
	var rng = RandomNumberGenerator.new()
	rng.seed = shadow_arena_weekly_seed + 99
	var min_level = mini(9, levels.size() - 1)  # At least world 4
	var arena_level = rng.randi_range(min_level, levels.size() - 1)
	selected_difficulty = 2  # Arena always plays on Hard
	_do_level_start(arena_level)

func _end_shadow_arena() -> void:
	shadow_arena_active = false
	var score = wave
	if score > shadow_arena_high_score:
		shadow_arena_high_score = score
	# Award arena crystals based on performance
	var crystals = score / 5
	arena_crystals += crystals
	# Insert into leaderboard
	arena_leaderboard.append({"name": "YOU", "score": score})
	arena_leaderboard.sort_custom(func(a, b): return a["score"] > b["score"])
	if arena_leaderboard.size() > 16:
		arena_leaderboard.resize(16)
	_save_game()

func _get_arena_shop_items() -> Array:
	return [
		{"name": "50 Relic Shards", "cost": 5, "type": "shards", "amount": 50},
		{"name": "10 Quills", "cost": 8, "type": "quills", "amount": 10},
		{"name": "5 Storybook Stars", "cost": 12, "type": "stars", "amount": 5},
		{"name": "200 Gold", "cost": 10, "type": "gold", "amount": 200},
		{"name": "3 Knowledge Ink", "cost": 15, "type": "ink", "amount": 3},
	]

# =====================================================================================
# === FEATURE 7: BRANCHING UPGRADE PATHS ===============================================
# =====================================================================================

# Branch data per tower type — 2 branches (A/B), each with 2 tiers
const UPGRADE_BRANCHES: Dictionary = {
	# Robin Hood
	0: {
		"A": {"name": "Sherwood Marksman", "tiers": [
			{"name": "Piercing Shot", "desc": "+40% pierce damage", "cost": 200, "effect": "pierce_damage", "value": 0.40},
			{"name": "Storm of Arrows", "desc": "Fires 3 arrows at once", "cost": 400, "effect": "multi_shot", "value": 3.0},
			{"name": "Unerring Aim", "desc": "Homing arrows never miss targets", "cost": 700, "effect": "homing", "value": 1.0},
		]},
		"B": {"name": "Merry Benefactor", "tiers": [
			{"name": "Golden Arrow", "desc": "+50% gold per kill", "cost": 160, "effect": "gold_bonus", "value": 0.50},
			{"name": "Robin's Bounty", "desc": "Enemies drop gold on hit", "cost": 350, "effect": "gold_on_hit", "value": 2.0},
			{"name": "Gold Rain", "desc": "+2 gold/kill for all nearby towers", "cost": 650, "effect": "gold_aura", "value": 2.0},
		]},
	},
	# Alice
	1: {
		"A": {"name": "Wonderland Chaos", "tiers": [
			{"name": "Mad Tea Storm", "desc": "+50% AoE radius", "cost": 200, "effect": "aoe_radius", "value": 0.50},
			{"name": "Jabberwocky Rage", "desc": "Cake explodes for 3x damage", "cost": 400, "effect": "damage", "value": 2.0},
			{"name": "Unbirthday Party", "desc": "Every 10s, random AoE explosion on path", "cost": 700, "effect": "random_explode", "value": 1.0},
		]},
		"B": {"name": "Curiosity Control", "tiers": [
			{"name": "Shrink Ray", "desc": "Shrunk enemies take +30% damage", "cost": 180, "effect": "shrink_damage", "value": 0.30},
			{"name": "Looking Glass", "desc": "Reveals all shadow-infested enemies", "cost": 350, "effect": "reveal_shadow", "value": 1.0},
			{"name": "Wonderland Logic", "desc": "20% chance enemy takes double damage", "cost": 650, "effect": "chaos_damage", "value": 0.20},
		]},
	},
	# Wicked Witch
	2: {
		"A": {"name": "Dark Summoner", "tiers": [
			{"name": "Monkey Army", "desc": "Summons 3 flying monkeys", "cost": 220, "effect": "extra_summon", "value": 2.0},
			{"name": "Tornado Strike", "desc": "Periodically launches a tornado", "cost": 400, "effect": "tornado", "value": 1.0},
			{"name": "Flying Terror", "desc": "Monkeys carry enemies backward on path", "cost": 700, "effect": "monkey_carry", "value": 1.0},
		]},
		"B": {"name": "Hex Weaver", "tiers": [
			{"name": "Poppy Curse", "desc": "Attacks have 20% chance to sleep", "cost": 190, "effect": "sleep_chance", "value": 0.20},
			{"name": "Witch's Doom", "desc": "Cursed enemies explode on death", "cost": 400, "effect": "death_explode", "value": 1.0},
			{"name": "Eternal Hex", "desc": "Sleep duration doubled, spreads to nearby", "cost": 680, "effect": "hex_spread", "value": 1.0},
		]},
	},
	# Peter Pan
	3: {
		"A": {"name": "Shadow Assassin", "tiers": [
			{"name": "Shadow Strike", "desc": "+60% crit damage", "cost": 200, "effect": "crit_damage", "value": 0.60},
			{"name": "Lost Boys Ambush", "desc": "Shadow clones attack independently", "cost": 400, "effect": "clone_attack", "value": 2.0},
			{"name": "Never Grow Up", "desc": "Permanent +5% damage per kill (caps 100%)", "cost": 700, "effect": "scaling_damage", "value": 0.05},
		]},
		"B": {"name": "Fairy Guardian", "tiers": [
			{"name": "Pixie Shield", "desc": "Nearby towers gain +15% attack speed", "cost": 180, "effect": "attack_speed_aura", "value": 0.15},
			{"name": "Neverland Blessing", "desc": "+25% attack speed to all nearby", "cost": 350, "effect": "attack_speed_aura", "value": 0.25},
			{"name": "Second Star", "desc": "Fairy dust heals 1 life every 30 seconds", "cost": 680, "effect": "life_regen", "value": 1.0},
		]},
	},
	# Phantom
	4: {
		"A": {"name": "Maestro of Doom", "tiers": [
			{"name": "Crescendo", "desc": "Damage increases with consecutive hits", "cost": 210, "effect": "ramp_damage", "value": 0.10},
			{"name": "Requiem", "desc": "Devastating AoE blast every 10 attacks", "cost": 400, "effect": "charged_blast", "value": 10.0},
			{"name": "Grand Finale", "desc": "Requiem blast also stuns for 3 seconds", "cost": 720, "effect": "charged_stun", "value": 3.0},
		]},
		"B": {"name": "Opera Phantom", "tiers": [
			{"name": "Chandelier Drop", "desc": "Stuns all enemies in range every 8s", "cost": 200, "effect": "periodic_stun", "value": 8.0},
			{"name": "Masquerade", "desc": "Enemies confused, attack each other", "cost": 400, "effect": "confuse_aura", "value": 1.0},
			{"name": "Angel of Music", "desc": "Nearby towers gain +30% all stats", "cost": 700, "effect": "all_stats_aura", "value": 0.30},
		]},
	},
	# Scrooge
	5: {
		"A": {"name": "Golden Miser", "tiers": [
			{"name": "Interest Rate", "desc": "+5 gold per wave passively", "cost": 150, "effect": "passive_gold", "value": 5.0},
			{"name": "Counting House", "desc": "All towers earn +15% gold", "cost": 350, "effect": "global_gold", "value": 0.15},
			{"name": "Midas Touch", "desc": "Gold coins deal 2x damage to marked", "cost": 650, "effect": "marked_gold_damage", "value": 2.0},
		]},
		"B": {"name": "Spirit Channeler", "tiers": [
			{"name": "Ghost Chill", "desc": "Attacks slow enemies by 40%", "cost": 170, "effect": "slow", "value": 0.40},
			{"name": "Three Spirits", "desc": "Summons 3 ghosts that deal AoE damage", "cost": 380, "effect": "ghost_summon", "value": 3.0},
			{"name": "Christmas Miracle", "desc": "Ghosts permanently slow and weaken enemies", "cost": 680, "effect": "ghost_debuff", "value": 1.0},
		]},
	},
	# Sherlock
	6: {
		"A": {"name": "Master Detective", "tiers": [
			{"name": "Deduction", "desc": "Marks reveal enemy weaknesses (+40% dmg)", "cost": 230, "effect": "mark_damage", "value": 0.40},
			{"name": "Case Closed", "desc": "Marked enemies die instantly below 10% HP", "cost": 420, "effect": "execute", "value": 0.10},
			{"name": "Final Problem", "desc": "Execute threshold raised to 20% HP", "cost": 720, "effect": "execute", "value": 0.20},
		]},
		"B": {"name": "Baker Street Intel", "tiers": [
			{"name": "Network", "desc": "All towers gain +10% range", "cost": 200, "effect": "global_range", "value": 0.10},
			{"name": "Elementary", "desc": "Reveals all invisible/phantom enemies", "cost": 380, "effect": "reveal_all", "value": 1.0},
			{"name": "221B Protocol", "desc": "+20% damage to all revealed enemies", "cost": 680, "effect": "reveal_damage", "value": 0.20},
		]},
	},
	# Tarzan
	7: {
		"A": {"name": "King of the Jungle", "tiers": [
			{"name": "Primal Fury", "desc": "+80% damage below 50% map progress", "cost": 200, "effect": "early_damage", "value": 0.80},
			{"name": "Jungle Stampede", "desc": "Summons elephant charge every 15s", "cost": 400, "effect": "stampede", "value": 1.0},
			{"name": "Alpha Predator", "desc": "Stampede also knocks back all enemies", "cost": 700, "effect": "stampede_knockback", "value": 1.0},
		]},
		"B": {"name": "Vine Lord", "tiers": [
			{"name": "Entangle", "desc": "Vine snares hold enemies for 2s", "cost": 190, "effect": "snare", "value": 2.0},
			{"name": "Living Jungle", "desc": "Vines grow across path, slowing all by 25%", "cost": 380, "effect": "path_slow", "value": 0.25},
			{"name": "Nature's Wrath", "desc": "Snared enemies take 50% more damage", "cost": 680, "effect": "snare_damage", "value": 0.50},
		]},
	},
	# Dracula
	8: {
		"A": {"name": "Lord of Darkness", "tiers": [
			{"name": "Blood Feast", "desc": "Life steal heals all nearby towers", "cost": 220, "effect": "aoe_heal", "value": 1.0},
			{"name": "Vampire Lord", "desc": "Charmed enemies fight for you permanently", "cost": 420, "effect": "permanent_charm", "value": 1.0},
			{"name": "Nosferatu", "desc": "Life drain also damages nearby enemies", "cost": 720, "effect": "drain_aoe", "value": 1.0},
		]},
		"B": {"name": "Bat Master", "tiers": [
			{"name": "Bat Swarm", "desc": "Sends bat swarm dealing AoE damage", "cost": 200, "effect": "bat_swarm", "value": 1.0},
			{"name": "Eclipse", "desc": "All enemies on screen take 5% HP/s for 5s", "cost": 420, "effect": "eclipse", "value": 1.0},
			{"name": "Blood Moon", "desc": "Eclipse also heals all towers to full", "cost": 700, "effect": "blood_moon", "value": 1.0},
		]},
	},
	# Merlin
	9: {
		"A": {"name": "Archmage Supreme", "tiers": [
			{"name": "Meteor Storm", "desc": "Rains meteors every 12 seconds", "cost": 240, "effect": "meteor", "value": 1.0},
			{"name": "Time Warp", "desc": "Slows all enemies by 50% for 5s periodically", "cost": 440, "effect": "time_warp", "value": 1.0},
			{"name": "Chrono Mastery", "desc": "Time Warp also boosts all tower speed 50%", "cost": 740, "effect": "time_boost", "value": 0.50},
		]},
		"B": {"name": "Enchanter", "tiers": [
			{"name": "Enchant Weapons", "desc": "Nearby towers deal magic damage", "cost": 200, "effect": "magic_aura", "value": 1.0},
			{"name": "Excalibur's Call", "desc": "Summons Excalibur to strike strongest enemy", "cost": 400, "effect": "excalibur", "value": 1.0},
			{"name": "Spell Weaver", "desc": "All magic towers gain +25% damage", "cost": 700, "effect": "magic_damage_aura", "value": 0.25},
		]},
	},
	# Frankenstein
	10: {
		"A": {"name": "Lightning Engine", "tiers": [
			{"name": "Overcharge", "desc": "Chain lightning hits 5 additional targets", "cost": 220, "effect": "chain_count", "value": 5.0},
			{"name": "Tesla Coil", "desc": "Passive lightning field damages all nearby", "cost": 420, "effect": "tesla", "value": 1.0},
			{"name": "Storm Lord", "desc": "Lightning chains deal increasing damage", "cost": 720, "effect": "chain_ramp", "value": 1.0},
		]},
		"B": {"name": "Unstoppable Monster", "tiers": [
			{"name": "Rage", "desc": "Damage increases as HP drops", "cost": 190, "effect": "rage", "value": 1.0},
			{"name": "Rampage", "desc": "AoE ground slam stuns for 3s", "cost": 400, "effect": "ground_slam", "value": 3.0},
			{"name": "Reanimation", "desc": "Killed enemies rise as allied zombies", "cost": 700, "effect": "reanimate", "value": 1.0},
		]},
	},
	# Shadow Author
	11: {
		"A": {"name": "Story Rewriter", "tiers": [
			{"name": "Plot Twist", "desc": "Random enemy instantly dies every 10s", "cost": 300, "effect": "plot_twist", "value": 1.0},
			{"name": "The End", "desc": "All enemies below 15% HP are erased", "cost": 500, "effect": "erase", "value": 0.15},
			{"name": "Rewrite Reality", "desc": "Erase threshold 25%, erased give 2x gold", "cost": 800, "effect": "erase_gold", "value": 0.25},
		]},
		"B": {"name": "Ink Overlord", "tiers": [
			{"name": "Ink Flood", "desc": "Path covered in ink, 30% slow to all", "cost": 280, "effect": "ink_slow", "value": 0.30},
			{"name": "Dark Chapter", "desc": "Spawns shadow clones of your towers", "cost": 500, "effect": "shadow_clone", "value": 1.0},
			{"name": "Narrative Control", "desc": "Shadow clones gain your upgrades", "cost": 780, "effect": "clone_upgrades", "value": 1.0},
		]},
	},
}

func _get_branch_for_tower(tower_node) -> String:
	if tower_node == null:
		return ""
	var iid = tower_node.get_instance_id()
	return tower_branch_choice.get(iid, "")

func _choose_branch(tower_node, branch: String) -> void:
	if tower_node == null:
		return
	var iid = tower_node.get_instance_id()
	tower_branch_choice[iid] = branch

func _purchase_branch_upgrade(tower_node, tower_type_int: int, branch: String, tier_idx: int) -> bool:
	if not UPGRADE_BRANCHES.has(tower_type_int):
		return false
	var branch_data = UPGRADE_BRANCHES[tower_type_int].get(branch, {})
	if branch_data.is_empty():
		return false
	var tiers = branch_data.get("tiers", [])
	if tier_idx >= tiers.size():
		return false
	var tier = tiers[tier_idx]
	var cost = tier.get("cost", 0)
	if gold < cost:
		return false
	gold -= cost
	total_gold_spent += cost
	# Apply branch upgrade effect via meta buffs
	var iid = tower_node.get_instance_id()
	if not tower_node.has_meta("branch_upgrades"):
		tower_node.set_meta("branch_upgrades", [])
	var upgrades = tower_node.get_meta("branch_upgrades")
	upgrades.append({"branch": branch, "tier": tier_idx, "effect": tier["effect"], "value": tier["value"]})
	tower_node.set_meta("branch_upgrades", upgrades)
	tower_node.set_meta("branch_tier_" + branch, tier_idx + 1)
	# Refresh meta buffs so the new branch upgrade takes effect immediately
	var tt_enum = tower_node.get_meta("tower_type_enum") if tower_node.has_meta("tower_type_enum") else tower_type_int
	_apply_meta_buffs(tower_node, tt_enum)
	update_hud()
	queue_redraw()
	return true

func _on_portrait_draw(ctrl: Control) -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	# Local coordinates within 100x80 Control
	var cx = 50.0
	var cy = 40.0
	var s = 0.8

	var tower_type_int: int = -1
	if selected_tower_node.has_meta("tower_type_enum"):
		tower_type_int = int(selected_tower_node.get_meta("tower_type_enum"))

	match tower_type_int:
		TowerType.ROBIN_HOOD:
			var skin = Color(0.91, 0.74, 0.58)
			var tunic = Color(0.15, 0.55, 0.12)
			ctrl.draw_rect(Rect2(cx - 15 * s, cy + 5 * s, 30 * s, 25 * s), tunic)
			ctrl.draw_circle(Vector2(cx, cy - 5 * s), 12 * s, skin)
			var hat = PackedVector2Array([Vector2(cx - 14 * s, cy - 10 * s), Vector2(cx, cy - 30 * s), Vector2(cx + 14 * s, cy - 10 * s)])
			ctrl.draw_colored_polygon(hat, tunic)
			ctrl.draw_line(Vector2(cx + 5 * s, cy - 22 * s), Vector2(cx + 14 * s, cy - 32 * s), Color(0.85, 0.15, 0.1), 2.0)
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 7 * s), 1.5 * s, Color(0.25, 0.45, 0.2))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 7 * s), 1.5 * s, Color(0.25, 0.45, 0.2))
		TowerType.ALICE:
			var skin = Color(0.95, 0.84, 0.73)
			var dress = Color(0.45, 0.72, 0.95)
			ctrl.draw_rect(Rect2(cx - 14 * s, cy + 5 * s, 28 * s, 25 * s), Color(0.92, 0.93, 0.98))
			ctrl.draw_rect(Rect2(cx - 12 * s, cy + 5 * s, 24 * s, 10 * s), dress)
			ctrl.draw_circle(Vector2(cx, cy - 5 * s), 12 * s, skin)
			ctrl.draw_arc(Vector2(cx, cy - 8 * s), 13 * s, PI + 0.3, TAU - 0.3, 16, Color(0.92, 0.82, 0.45), 4 * s)
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 7 * s), 1.5 * s, Color(0.3, 0.5, 0.85))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 7 * s), 1.5 * s, Color(0.3, 0.5, 0.85))
			ctrl.draw_circle(Vector2(cx, cy + 7 * s), 3 * s, dress)
		TowerType.WICKED_WITCH:
			var skin = Color(0.38, 0.55, 0.28)
			var dress = Color(0.08, 0.06, 0.10)
			ctrl.draw_rect(Rect2(cx - 14 * s, cy + 5 * s, 28 * s, 25 * s), dress)
			ctrl.draw_circle(Vector2(cx, cy - 5 * s), 12 * s, skin)
			var wh = PackedVector2Array([Vector2(cx - 16 * s, cy - 10 * s), Vector2(cx, cy - 38 * s), Vector2(cx + 16 * s, cy - 10 * s)])
			ctrl.draw_colored_polygon(wh, dress)
			ctrl.draw_line(Vector2(cx - 18 * s, cy - 10 * s), Vector2(cx + 18 * s, cy - 10 * s), dress, 3 * s)
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 7 * s), 2 * s, Color(0.7, 0.85, 0.15))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 7 * s), 2 * s, Color(0.7, 0.85, 0.15))
		TowerType.PETER_PAN:
			var skin = Color(0.93, 0.78, 0.62)
			var tunic = Color(0.18, 0.60, 0.15)
			ctrl.draw_rect(Rect2(cx - 13 * s, cy + 5 * s, 26 * s, 25 * s), tunic)
			ctrl.draw_circle(Vector2(cx, cy - 5 * s), 11 * s, skin)
			for hi in range(5):
				var hx = cx + (-8.0 + float(hi) * 4.0) * s
				ctrl.draw_line(Vector2(hx, cy - 14 * s), Vector2(hx + 2 * s, cy - 22 * s), Color(0.55, 0.28, 0.12), 2.0)
			var pp = PackedVector2Array([Vector2(cx - 12 * s, cy - 12 * s), Vector2(cx + 4 * s, cy - 28 * s), Vector2(cx + 12 * s, cy - 12 * s)])
			ctrl.draw_colored_polygon(pp, tunic)
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 7 * s), 1.5 * s, Color(0.3, 0.55, 0.25))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 7 * s), 1.5 * s, Color(0.3, 0.55, 0.25))
		TowerType.PHANTOM:
			var tux = Color(0.05, 0.05, 0.08)
			var cape_red = Color(0.85, 0.08, 0.12)
			ctrl.draw_rect(Rect2(cx - 16 * s, cy + 2 * s, 32 * s, 28 * s), cape_red)
			ctrl.draw_rect(Rect2(cx - 13 * s, cy + 5 * s, 26 * s, 25 * s), tux)
			ctrl.draw_circle(Vector2(cx, cy - 5 * s), 11 * s, Color(0.92, 0.88, 0.85))
			ctrl.draw_arc(Vector2(cx, cy - 5 * s), 11 * s, PI, TAU, 16, Color(0.98, 0.97, 0.96), 3 * s)
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 7 * s), 1.5 * s, Color(0.2, 0.2, 0.25))
		TowerType.SCROOGE:
			var coat = Color(0.12, 0.10, 0.08)
			var skin = Color(0.88, 0.76, 0.62)
			ctrl.draw_rect(Rect2(cx - 14 * s, cy + 5 * s, 28 * s, 25 * s), coat)
			ctrl.draw_rect(Rect2(cx - 8 * s, cy + 5 * s, 16 * s, 18 * s), Color(0.78, 0.65, 0.15))
			ctrl.draw_circle(Vector2(cx, cy - 5 * s), 11 * s, skin)
			ctrl.draw_rect(Rect2(cx - 8 * s, cy - 30 * s, 16 * s, 18 * s), coat)
			ctrl.draw_rect(Rect2(cx - 12 * s, cy - 14 * s, 24 * s, 4 * s), coat)
			ctrl.draw_circle(Vector2(cx - 3 * s, cy - 7 * s), 1.2 * s, Color(0.2, 0.15, 0.1))
			ctrl.draw_circle(Vector2(cx + 3 * s, cy - 7 * s), 1.2 * s, Color(0.2, 0.15, 0.1))
		TowerType.SHERLOCK:
			var cape = Color(0.35, 0.25, 0.15)
			var skin = Color(0.90, 0.78, 0.65)
			ctrl.draw_rect(Rect2(cx - 16 * s, cy + 2 * s, 32 * s, 28 * s), cape)
			ctrl.draw_rect(Rect2(cx - 13 * s, cy + 5 * s, 26 * s, 25 * s), Color(0.30, 0.22, 0.12))
			ctrl.draw_circle(Vector2(cx, cy - 5 * s), 11 * s, skin)
			ctrl.draw_rect(Rect2(cx - 10 * s, cy - 20 * s, 20 * s, 10 * s), Color(0.35, 0.25, 0.15))
			ctrl.draw_rect(Rect2(cx - 14 * s, cy - 12 * s, 8 * s, 5 * s), Color(0.35, 0.25, 0.15))
			ctrl.draw_rect(Rect2(cx + 6 * s, cy - 12 * s, 8 * s, 5 * s), Color(0.35, 0.25, 0.15))
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 7 * s), 1.5 * s, Color(0.35, 0.45, 0.35))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 7 * s), 1.5 * s, Color(0.35, 0.45, 0.35))
			ctrl.draw_line(Vector2(cx + 6 * s, cy - 1 * s), Vector2(cx + 16 * s, cy + 5 * s), Color(0.4, 0.25, 0.12), 2.0)
		TowerType.TARZAN:
			var skin = Color(0.72, 0.52, 0.35)
			ctrl.draw_circle(Vector2(cx, cy + 5 * s), 14 * s, skin)
			ctrl.draw_circle(Vector2(cx, cy - 10 * s), 11 * s, skin)
			for hi in range(7):
				var hx = cx + (-9.0 + float(hi) * 3.0) * s
				ctrl.draw_line(Vector2(hx, cy - 18 * s), Vector2(hx + randf_range(-3, 3) * s, cy - 28 * s), Color(0.25, 0.15, 0.08), 2.0)
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 12 * s), 1.5 * s, Color(0.35, 0.25, 0.12))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 12 * s), 1.5 * s, Color(0.35, 0.25, 0.12))
			ctrl.draw_line(Vector2(cx - 10 * s, cy + 2 * s), Vector2(cx + 10 * s, cy + 15 * s), Color(0.45, 0.30, 0.15), 3.0)
		TowerType.DRACULA:
			var skin = Color(0.88, 0.85, 0.82)
			var cape = Color(0.08, 0.05, 0.12)
			ctrl.draw_rect(Rect2(cx - 17 * s, cy - 5 * s, 34 * s, 35 * s), cape)
			ctrl.draw_rect(Rect2(cx - 15 * s, cy + 5 * s, 6 * s, 25 * s), Color(0.70, 0.08, 0.08))
			ctrl.draw_rect(Rect2(cx + 9 * s, cy + 5 * s, 6 * s, 25 * s), Color(0.70, 0.08, 0.08))
			ctrl.draw_line(Vector2(cx - 12 * s, cy - 5 * s), Vector2(cx - 8 * s, cy - 18 * s), cape, 3.0)
			ctrl.draw_line(Vector2(cx + 12 * s, cy - 5 * s), Vector2(cx + 8 * s, cy - 18 * s), cape, 3.0)
			ctrl.draw_circle(Vector2(cx, cy - 8 * s), 10 * s, skin)
			ctrl.draw_arc(Vector2(cx, cy - 10 * s), 11 * s, PI + 0.4, TAU - 0.4, 12, Color(0.05, 0.02, 0.08), 3 * s)
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 10 * s), 1.8 * s, Color(0.80, 0.10, 0.10))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 10 * s), 1.8 * s, Color(0.80, 0.10, 0.10))
			ctrl.draw_line(Vector2(cx - 2 * s, cy - 3 * s), Vector2(cx - 2 * s, cy + 1 * s), Color(0.95, 0.95, 0.9), 1.0)
			ctrl.draw_line(Vector2(cx + 2 * s, cy - 3 * s), Vector2(cx + 2 * s, cy + 1 * s), Color(0.95, 0.95, 0.9), 1.0)
		TowerType.MERLIN:
			var robe = Color(0.22, 0.10, 0.55)
			var mgold = Color(0.92, 0.78, 0.18)
			ctrl.draw_rect(Rect2(cx - 14 * s, cy + 2 * s, 28 * s, 28 * s), robe)
			ctrl.draw_rect(Rect2(cx - 3 * s, cy + 2 * s, 6 * s, 28 * s), mgold)
			ctrl.draw_circle(Vector2(cx, cy - 5 * s), 11 * s, Color(0.90, 0.82, 0.72))
			var beard = PackedVector2Array([Vector2(cx - 8 * s, cy - 1 * s), Vector2(cx, cy + 18 * s), Vector2(cx + 8 * s, cy - 1 * s)])
			ctrl.draw_colored_polygon(beard, Color(0.92, 0.90, 0.88))
			var wiz = PackedVector2Array([Vector2(cx - 12 * s, cy - 12 * s), Vector2(cx + 2 * s, cy - 40 * s), Vector2(cx + 12 * s, cy - 12 * s)])
			ctrl.draw_colored_polygon(wiz, robe)
			ctrl.draw_circle(Vector2(cx + 1 * s, cy - 25 * s), 2 * s, mgold)
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 7 * s), 1.3 * s, Color(0.3, 0.4, 0.7))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 7 * s), 1.3 * s, Color(0.3, 0.4, 0.7))
		TowerType.FRANKENSTEIN:
			var skin = Color(0.55, 0.70, 0.45)
			var clothes = Color(0.15, 0.12, 0.10)
			ctrl.draw_rect(Rect2(cx - 16 * s, cy + 2 * s, 32 * s, 28 * s), clothes)
			ctrl.draw_rect(Rect2(cx - 11 * s, cy - 20 * s, 22 * s, 22 * s), skin)
			ctrl.draw_rect(Rect2(cx - 11 * s, cy - 22 * s, 22 * s, 4 * s), Color(0.12, 0.10, 0.08))
			ctrl.draw_circle(Vector2(cx - 12 * s, cy - 5 * s), 2.5 * s, Color(0.58, 0.58, 0.63))
			ctrl.draw_circle(Vector2(cx + 12 * s, cy - 5 * s), 2.5 * s, Color(0.58, 0.58, 0.63))
			ctrl.draw_line(Vector2(cx - 6 * s, cy - 16 * s), Vector2(cx + 6 * s, cy - 16 * s), Color(0.3, 0.2, 0.15), 1.5)
			for sti in range(4):
				var stx = cx + (-4.0 + float(sti) * 3.0) * s
				ctrl.draw_line(Vector2(stx, cy - 18 * s), Vector2(stx, cy - 14 * s), Color(0.3, 0.2, 0.15), 1.0)
			ctrl.draw_circle(Vector2(cx - 4 * s, cy - 10 * s), 2 * s, Color(0.35, 0.45, 0.30))
			ctrl.draw_circle(Vector2(cx + 4 * s, cy - 10 * s), 2 * s, Color(0.35, 0.45, 0.30))
		TowerType.SHADOW_AUTHOR:
			var cloak = Color(0.06, 0.02, 0.1, 0.9)
			var sa_pts = PackedVector2Array()
			sa_pts.append(Vector2(cx - 12 * s, cy - 15 * s))
			sa_pts.append(Vector2(cx - 15 * s, cy + 5 * s))
			sa_pts.append(Vector2(cx - 10 * s, cy + 22 * s))
			sa_pts.append(Vector2(cx, cy + 24 * s))
			sa_pts.append(Vector2(cx + 10 * s, cy + 22 * s))
			sa_pts.append(Vector2(cx + 15 * s, cy + 5 * s))
			sa_pts.append(Vector2(cx + 12 * s, cy - 15 * s))
			ctrl.draw_colored_polygon(sa_pts, cloak)
			var hood = PackedVector2Array([Vector2(cx - 12 * s, cy - 14 * s), Vector2(cx, cy - 32 * s), Vector2(cx + 12 * s, cy - 14 * s)])
			ctrl.draw_colored_polygon(hood, Color(0.04, 0.01, 0.08, 0.95))
			var void_pts = PackedVector2Array([Vector2(cx - 7 * s, cy - 14 * s), Vector2(cx, cy - 26 * s), Vector2(cx + 7 * s, cy - 14 * s)])
			ctrl.draw_colored_polygon(void_pts, Color(0.0, 0.0, 0.0))
			ctrl.draw_circle(Vector2(cx, cy - 18 * s), 1.5 * s, Color(0.9, 0.08, 0.02, 0.85))
			ctrl.draw_circle(Vector2(cx, cy - 18 * s), 3 * s, Color(0.7, 0.04, 0.01, 0.2))
			ctrl.draw_line(Vector2(cx + 12 * s, cy), Vector2(cx + 16 * s, cy - 25 * s), Color(0.7, 0.06, 0.03, 0.8), 2.0)
			ctrl.draw_circle(Vector2(cx + 16 * s, cy - 25 * s), 2 * s, Color(0.95, 0.12, 0.02, 0.85))
		_:
			ctrl.draw_circle(Vector2(cx, cy), 15 * s, Color(0.5, 0.4, 0.6, 0.5))
			ctrl.draw_circle(Vector2(cx, cy - 15 * s), 10 * s, Color(0.6, 0.5, 0.7, 0.5))

func _draw_branch_upgrade_panel() -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	if selected_tower_node.upgrade_tier < 2:
		return
	var tower_type_int: int = -1
	if selected_tower_node.has_meta("tower_type_enum"):
		tower_type_int = int(selected_tower_node.get_meta("tower_type_enum"))
	else:
		return
	if not UPGRADE_BRANCHES.has(tower_type_int):
		return
	var font = game_font
	var branches = UPGRADE_BRANCHES[tower_type_int]
	var chosen = _get_branch_for_tower(selected_tower_node)
	# Panel position — draw below the upgrade panel (right side)
	var px = 1080.0
	var py = 660.0
	var pw = 200.0
	if chosen == "":
		# Show branch selection (A vs B)
		var ph = 160.0
		py = 540.0
		draw_rect(Rect2(px, py, pw, ph), Color(0.06, 0.03, 0.10, 0.95))
		draw_rect(Rect2(px, py, pw, ph), Color(0.6, 0.3, 0.8, 0.5), false, 1.5)
		_udraw(font, Vector2(px + pw * 0.5, py + 16), "CHOOSE PATH", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.8, 0.6, 1.0))
		draw_rect(Rect2(px + 10, py + 22, pw - 20, 1), Color(0.6, 0.3, 0.8, 0.3))
		for bi in range(2):
			var bkey = "A" if bi == 0 else "B"
			var bdata = branches.get(bkey, {})
			var bname = bdata.get("name", "Path " + bkey)
			var by = py + 28 + float(bi) * 64.0
			var is_hover = _branch_hover == bkey
			var bg_col = Color(0.15, 0.08, 0.22, 0.9) if is_hover else Color(0.08, 0.05, 0.14, 0.8)
			draw_rect(Rect2(px + 6, by, pw - 12, 58), bg_col)
			draw_rect(Rect2(px + 6, by, pw - 12, 58), Color(0.7, 0.4, 0.9, 0.4) if is_hover else Color(0.5, 0.3, 0.6, 0.25), false, 1.0)
			_udraw(font, Vector2(px + 14, by + 16), bkey + ": " + bname, HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 15, Color(0.9, 0.8, 0.5) if is_hover else Color(0.8, 0.7, 0.4))
			# Show tier 1 preview
			var tiers = bdata.get("tiers", [])
			if tiers.size() > 0:
				_udraw(font, Vector2(px + 14, by + 34), tiers[0].get("name", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 14, Color(0.7, 0.65, 0.6))
				_udraw(font, Vector2(px + 14, by + 48), tiers[0].get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 14, Color(0.55, 0.5, 0.5))
	else:
		# Show branch upgrade tiers
		var bdata = branches.get(chosen, {})
		var bname = bdata.get("name", "Path " + chosen)
		var tiers = bdata.get("tiers", [])
		var current_tier = 0
		if selected_tower_node.has_meta("branch_tier_" + chosen):
			current_tier = selected_tower_node.get_meta("branch_tier_" + chosen)
		var ph = 30.0 + float(tiers.size()) * 68.0
		py = 540.0
		draw_rect(Rect2(px, py, pw, ph), Color(0.06, 0.03, 0.10, 0.95))
		draw_rect(Rect2(px, py, pw, ph), Color(0.6, 0.3, 0.8, 0.5), false, 1.5)
		_udraw(font, Vector2(px + pw * 0.5, py + 16), chosen + ": " + bname, HORIZONTAL_ALIGNMENT_CENTER, int(pw - 10), 15, Color(0.8, 0.6, 1.0))
		draw_rect(Rect2(px + 10, py + 22, pw - 20, 1), Color(0.6, 0.3, 0.8, 0.3))
		for ti in range(tiers.size()):
			var tier = tiers[ti]
			var ty = py + 28 + float(ti) * 68.0
			var is_hover = (_branch_tier_hover == ti)
			if ti < current_tier:
				# Purchased
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), Color(0.06, 0.15, 0.06, 0.85))
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), Color(0.3, 0.7, 0.2, 0.4), false, 1.0)
				_udraw(font, Vector2(px + 14, ty + 16), tier.get("name", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 15, Color(0.5, 0.8, 0.4))
				_udraw(font, Vector2(px + 14, ty + 32), tier.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 14, Color(0.5, 0.65, 0.4))
				_udraw(font, Vector2(px + pw - 14, ty + 52), "OWNED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.4, 0.7, 0.3))
			elif ti == current_tier:
				# Available
				var cost = tier.get("cost", 0)
				var can_afford = gold >= cost
				var bg_c = Color(0.14, 0.10, 0.06, 0.9) if is_hover else Color(0.10, 0.07, 0.12, 0.85)
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), bg_c)
				var bdr_c = Color(0.85, 0.65, 0.1, 0.6) if (can_afford and is_hover) else Color(0.5, 0.35, 0.6, 0.3)
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), bdr_c, false, 1.0)
				_udraw(font, Vector2(px + 14, ty + 16), tier.get("name", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 15, Color(0.9, 0.8, 0.5))
				_udraw(font, Vector2(px + 14, ty + 32), tier.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 14, Color(0.75, 0.7, 0.65))
				var cost_col = Color(1.0, 0.84, 0.0) if can_afford else Color(0.6, 0.4, 0.3)
				_udraw(font, Vector2(px + pw - 14, ty + 52), "%dG" % cost, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, cost_col)
			else:
				# Locked
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), Color(0.06, 0.04, 0.08, 0.7))
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), Color(0.3, 0.25, 0.35, 0.25), false, 1.0)
				_udraw(font, Vector2(px + 14, ty + 16), tier.get("name", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 15, Color(0.45, 0.4, 0.4))
				_udraw(font, Vector2(px + 14, ty + 32), tier.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 14, Color(0.4, 0.35, 0.35))
				_udraw(font, Vector2(px + pw - 14, ty + 52), "%dG" % tier.get("cost", 0), HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.4, 0.35, 0.3))

func _handle_branch_panel_click(mouse_pos: Vector2) -> bool:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return false
	if selected_tower_node.upgrade_tier < 2 or not upgrade_panel.visible:
		return false
	var tower_type_int: int = -1
	if selected_tower_node.has_meta("tower_type_enum"):
		tower_type_int = int(selected_tower_node.get_meta("tower_type_enum"))
	else:
		return false
	if not UPGRADE_BRANCHES.has(tower_type_int):
		return false
	var branches = UPGRADE_BRANCHES[tower_type_int]
	var chosen = _get_branch_for_tower(selected_tower_node)
	var px = 1080.0
	var pw = 200.0
	if chosen == "":
		var py = 540.0
		for bi in range(2):
			var bkey = "A" if bi == 0 else "B"
			var by = py + 28 + float(bi) * 64.0
			if Rect2(px + 6, by, pw - 12, 58).has_point(mouse_pos):
				_choose_branch(selected_tower_node, bkey)
				queue_redraw()
				return true
	else:
		var py = 540.0
		var bdata = branches.get(chosen, {})
		var tiers = bdata.get("tiers", [])
		var current_tier = 0
		if selected_tower_node.has_meta("branch_tier_" + chosen):
			current_tier = selected_tower_node.get_meta("branch_tier_" + chosen)
		for ti in range(tiers.size()):
			var ty = py + 28 + float(ti) * 68.0
			if ti == current_tier and Rect2(px + 6, ty, pw - 12, 62).has_point(mouse_pos):
				if _purchase_branch_upgrade(selected_tower_node, tower_type_int, chosen, ti):
					_update_upgrade_panel()
					queue_redraw()
				return true
	return false

func _update_branch_hover(mouse_pos: Vector2) -> void:
	_branch_hover = ""
	_branch_tier_hover = -1
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	if selected_tower_node.upgrade_tier < 2 or not upgrade_panel.visible:
		return
	var tower_type_int: int = -1
	if selected_tower_node.has_meta("tower_type_enum"):
		tower_type_int = int(selected_tower_node.get_meta("tower_type_enum"))
	else:
		return
	if not UPGRADE_BRANCHES.has(tower_type_int):
		return
	var chosen = _get_branch_for_tower(selected_tower_node)
	var px = 1080.0
	var pw = 200.0
	if chosen == "":
		var py = 540.0
		for bi in range(2):
			var bkey = "A" if bi == 0 else "B"
			var by = py + 28 + float(bi) * 64.0
			if Rect2(px + 6, by, pw - 12, 58).has_point(mouse_pos):
				_branch_hover = bkey
				return
	else:
		var py = 540.0
		var branches = UPGRADE_BRANCHES[tower_type_int]
		var bdata = branches.get(chosen, {})
		var tiers = bdata.get("tiers", [])
		for ti in range(tiers.size()):
			var ty = py + 28 + float(ti) * 68.0
			if Rect2(px + 6, ty, pw - 12, 62).has_point(mouse_pos):
				_branch_tier_hover = ti
				return

# =====================================================================================
# === FEATURE 8: GOLDEN SHIELDS (Expandable Gear Slots) ================================
# =====================================================================================

func _upgrade_golden_shield(tower_type) -> bool:
	var progress = survivor_progress.get(tower_type, {})
	var current_shields = progress.get("golden_shields", 0)
	if current_shields >= MAX_GOLDEN_SHIELD:
		return false
	var cost = GOLDEN_SHIELD_COSTS[current_shields]
	if player_relic_shards < cost:
		return false
	player_relic_shards -= cost
	survivor_progress[tower_type]["golden_shields"] = current_shields + 1
	_save_game()
	return true

func _draw_golden_shield_indicator(center: Vector2, level: int, font: Font) -> void:
	# Draw a golden shield icon with level number
	var sz = 14.0
	# Shield shape
	var points = PackedVector2Array([
		center + Vector2(0, -sz),
		center + Vector2(sz * 0.8, -sz * 0.4),
		center + Vector2(sz * 0.8, sz * 0.3),
		center + Vector2(0, sz),
		center + Vector2(-sz * 0.8, sz * 0.3),
		center + Vector2(-sz * 0.8, -sz * 0.4),
	])
	draw_colored_polygon(points, Color(0.85, 0.7, 0.2, 0.8))
	# Border
	for i in range(points.size()):
		draw_line(points[i], points[(i + 1) % points.size()], Color(0.95, 0.85, 0.3, 0.9), 1.5)
	# Level number
	draw_string(font, center + Vector2(-4, 5), str(level), HORIZONTAL_ALIGNMENT_CENTER, -1, 10, Color(0.15, 0.1, 0.05))

# =====================================================================================
# === FEATURE 9: QUEST / MISSION SYSTEM ================================================
# =====================================================================================

func _init_quests() -> void:
	_refresh_quests_if_needed()

func _refresh_quests_if_needed() -> void:
	var today = Time.get_date_string_from_system()
	if quest_last_refresh == today and active_quests.size() > 0:
		return
	# Generate 3 daily quests
	active_quests.clear()
	var rng = RandomNumberGenerator.new()
	var date = Time.get_date_dict_from_system()
	rng.seed = date["year"] * 366 + date["month"] * 31 + date["day"] + 7777
	var templates = QUEST_TEMPLATES.duplicate()
	templates.shuffle()
	for i in range(min(3, templates.size())):
		var tmpl = templates[i]
		var diff_idx = rng.randi_range(0, 2)
		var target = tmpl["targets"][diff_idx]
		var reward_amount = tmpl["amounts"][diff_idx]
		active_quests.append({
			"id": "quest_%d_%s" % [i, today],
			"desc": tmpl["desc"] % target,
			"type": tmpl["type"],
			"target": target,
			"progress": 0,
			"reward_type": tmpl["reward_type"],
			"reward_amount": reward_amount,
			"completed": false,
		})
	quest_last_refresh = today

func _update_quest_progress(quest_type: String, amount: int = 1) -> void:
	for q in active_quests:
		if q["completed"]:
			continue
		if q["type"] == quest_type:
			q["progress"] = mini(q["progress"] + amount, q["target"])
			if q["progress"] >= q["target"]:
				_complete_quest(q)

func _complete_quest(quest: Dictionary) -> void:
	quest["completed"] = true
	total_quests_completed += 1
	match quest["reward_type"]:
		"shards": player_relic_shards += quest["reward_amount"]
		"quills": player_quills += quest["reward_amount"]
		"stars": player_storybook_stars += quest["reward_amount"]
		"gold": player_gold += quest["reward_amount"]
	_save_game()

func _draw_quest_panel() -> void:
	var font = game_font
	var qx = 830.0
	var qy = 280.0
	var qw = 420.0
	var qh = 195.0
	draw_rect(Rect2(qx, qy, qw, qh), Color(0.04, 0.06, 0.04, 0.85))
	draw_rect(Rect2(qx, qy, qw, qh), Color(0.3, 0.7, 0.3, 0.3), false, 1.5)
	_udraw(font, Vector2(qx + qw * 0.5, qy + 18), "DAILY QUESTS", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.4, 0.8, 0.3))
	_udraw(font, Vector2(qx + qw * 0.5, qy + 34), "Complete for rewards!", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, menu_text_muted)
	for i in range(min(3, active_quests.size())):
		var q = active_quests[i]
		var iy = qy + 44 + float(i) * 48.0
		var completed = q.get("completed", false)
		var bg = Color(0.05, 0.12, 0.05, 0.6) if completed else Color(0.06, 0.06, 0.08, 0.6)
		draw_rect(Rect2(qx + 8, iy, qw - 16, 42), bg)
		draw_rect(Rect2(qx + 8, iy, qw - 16, 42), Color(0.3, 0.6, 0.3, 0.25), false, 1.0)
		_udraw(font, Vector2(qx + 16, iy + 16), q.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(qw - 130), 15, Color(0.8, 0.75, 0.6))
		# Progress bar
		var pct = float(q.get("progress", 0)) / float(max(1, q.get("target", 1)))
		var bar_w = 80.0
		draw_rect(Rect2(qx + qw - 100, iy + 6, bar_w, 10), Color(0.15, 0.15, 0.15))
		draw_rect(Rect2(qx + qw - 100, iy + 6, bar_w * pct, 10), Color(0.3, 0.8, 0.3) if not completed else Color(0.2, 0.6, 0.2))
		_udraw(font, Vector2(qx + qw - 60, iy + 14), "%d/%d" % [q.get("progress", 0), q.get("target", 1)], HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.8, 0.8, 0.8))
		# Reward
		var reward_str = "+%d %s" % [q.get("reward_amount", 0), q.get("reward_type", "").capitalize()]
		if completed:
			_udraw(font, Vector2(qx + qw - 60, iy + 34), "DONE!", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.4, 0.8, 0.3))
		else:
			_udraw(font, Vector2(qx + qw - 60, iy + 34), reward_str, HORIZONTAL_ALIGNMENT_CENTER, -1, 14, menu_gold)

# =====================================================================================
# === FEATURE 10: LITERARY INSTRUMENTS (Aura Support Gear) =============================
# =====================================================================================

func _draw_instrument_shop() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	for i in range(56):
		var t = float(i) / 55.0
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), menu_bg_section.lerp(menu_bg_dark, t))
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4), false, 1.5)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "LITERARY INSTRUMENTS", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Quills: %d" % player_quills, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 46), "Place instruments to buff nearby towers with aura effects", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, menu_text_muted)
	for i in range(literary_instruments.size()):
		var inst = literary_instruments[i]
		var col_i = i % 3
		var row_i = i / 3
		var cw = 350.0
		var ch = 110.0
		var ix = panel_x + 20 + float(col_i) * (cw + 15)
		var iy = panel_y + 65 + float(row_i) * (ch + 10)
		var owned = owned_instruments.get(inst["id"], 0)
		draw_rect(Rect2(ix, iy, cw, ch), Color(0.07, 0.06, 0.10, 0.85))
		draw_rect(Rect2(ix, iy, cw, ch), Color(0.6, 0.4, 0.2, 0.3), false, 1.0)
		# Instrument icon (music note)
		draw_circle(Vector2(ix + 30, iy + 40), 10, Color(0.85, 0.7, 0.2, 0.7))
		draw_line(Vector2(ix + 38, iy + 40), Vector2(ix + 38, iy + 18), Color(0.85, 0.7, 0.2, 0.7), 2.0)
		_udraw(font, Vector2(ix + 55, iy + 22), inst["name"], HORIZONTAL_ALIGNMENT_LEFT, int(cw - 65), 16, Color(0.9, 0.8, 0.5))
		_udraw(font, Vector2(ix + 55, iy + 40), inst["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(cw - 65), 14, menu_text_muted)
		_udraw(font, Vector2(ix + 55, iy + 58), "Radius: %d  |  Owned: %d" % [int(inst["radius"]), owned], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, menu_text)
		# Buy button
		var btn_x = ix + cw - 95
		var btn_y = iy + ch - 38
		var can_buy = player_quills >= inst["cost"]
		draw_rect(Rect2(btn_x, btn_y, 82, 30), Color(0.15, 0.3, 0.15, 0.7) if can_buy else Color(0.1, 0.1, 0.1, 0.5))
		draw_rect(Rect2(btn_x, btn_y, 82, 30), Color(0.4, 0.7, 0.3, 0.4) if can_buy else Color(0.3, 0.3, 0.3, 0.3), false, 1.0)
		_udraw(font, Vector2(btn_x + 41, btn_y + 20), "%dQ" % inst["cost"], HORIZONTAL_ALIGNMENT_CENTER, -1, 15, menu_gold if can_buy else Color(0.4, 0.4, 0.4))
	# Back button
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.7, 0.4))

func _on_instrument_shop_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		queue_redraw()
		return
	for i in range(literary_instruments.size()):
		var inst = literary_instruments[i]
		var col_i = i % 3
		var row_i = i / 3
		var cw = 350.0
		var ch = 110.0
		var ix = panel_x + 20 + float(col_i) * (cw + 15)
		var iy = panel_y + 65 + float(row_i) * (ch + 10)
		var btn_x = ix + cw - 95
		var btn_y = iy + ch - 38
		if mouse_pos.x >= btn_x and mouse_pos.x <= btn_x + 82 and mouse_pos.y >= btn_y and mouse_pos.y <= btn_y + 30:
			if player_quills >= inst["cost"]:
				player_quills -= inst["cost"]
				owned_instruments[inst["id"]] = owned_instruments.get(inst["id"], 0) + 1
				_save_game()
			queue_redraw()
			return

func _place_instrument(inst_id: String, pos: Vector2) -> bool:
	var inst_data = null
	for inst in literary_instruments:
		if inst["id"] == inst_id:
			inst_data = inst
			break
	if inst_data == null:
		return false
	if owned_instruments.get(inst_id, 0) <= 0:
		return false
	if not _is_valid_placement(pos):
		return false
	owned_instruments[inst_id] -= 1
	placed_instruments.append({
		"id": inst_id, "position": pos,
		"radius": inst_data["radius"], "effect": inst_data["effect"],
		"value": inst_data["value"], "name": inst_data["name"]
	})
	return true

func _get_instrument_buffs_at(pos: Vector2) -> Dictionary:
	var buffs: Dictionary = {}
	for inst in placed_instruments:
		var dist = pos.distance_to(inst["position"])
		if dist <= inst["radius"]:
			var eff = inst["effect"]
			var val = inst["value"]
			buffs[eff] = buffs.get(eff, 0.0) + val
	return buffs

func _draw_placed_instruments() -> void:
	for inst in placed_instruments:
		var pos = inst["position"]
		var radius = inst["radius"]
		# Aura circle
		draw_arc(pos, radius, 0, TAU, 32, Color(0.85, 0.7, 0.2, 0.12), 1.5)
		# Instrument body (small harp shape)
		draw_circle(pos, 12.0, Color(0.6, 0.45, 0.15, 0.8))
		draw_circle(pos, 8.0, Color(0.8, 0.65, 0.2, 0.9))
		draw_line(pos + Vector2(0, -8), pos + Vector2(0, -18), Color(0.85, 0.7, 0.2), 2.0)
		draw_line(pos + Vector2(-3, -16), pos + Vector2(3, -16), Color(0.85, 0.7, 0.2), 1.5)
		# Pulsing glow
		var t = fmod(Time.get_ticks_msec() / 1000.0, TAU)
		var pulse = 0.15 + sin(t * 2.0) * 0.08
		draw_circle(pos, 16.0, Color(0.9, 0.8, 0.3, pulse))

func _draw_instrument_hud() -> void:
	# Check if player has any owned instruments
	var has_any = false
	for iid in owned_instruments:
		if owned_instruments[iid] > 0:
			has_any = true
			break
	if not has_any and _placing_instrument == "":
		return
	var font = game_font
	# Instrument button (bottom-left — mobile-friendly size)
	var btn_x = 8.0
	var btn_y = 48.0
	var btn_w = 110.0
	var btn_h = 38.0
	var is_placing = _placing_instrument != ""
	var bg_col = Color(0.3, 0.2, 0.08, 0.85) if is_placing else Color(0.12, 0.08, 0.04, 0.75)
	draw_rect(Rect2(btn_x, btn_y, btn_w, btn_h), bg_col)
	draw_rect(Rect2(btn_x, btn_y, btn_w, btn_h), Color(0.85, 0.65, 0.1, 0.5), false, 1.5)
	draw_circle(Vector2(btn_x + 16, btn_y + 19), 8, Color(0.85, 0.7, 0.2, 0.7))
	_udraw(font, Vector2(btn_x + 28, btn_y + 24), "INSTRUMENTS", HORIZONTAL_ALIGNMENT_LEFT, int(btn_w - 32), 15, Color(0.85, 0.7, 0.2))
	# If placing, show placement cursor
	if is_placing:
		var inst_data = null
		for inst in literary_instruments:
			if inst["id"] == _placing_instrument:
				inst_data = inst
				break
		if inst_data:
			var gpos = ghost_position
			var valid = _is_valid_placement(gpos)
			var cursor_col = Color(0.85, 0.7, 0.2, 0.3) if valid else Color(0.8, 0.2, 0.2, 0.3)
			draw_arc(gpos, inst_data["radius"], 0, TAU, 32, cursor_col, 1.5)
			draw_circle(gpos, 10, Color(0.85, 0.7, 0.2, 0.6) if valid else Color(0.8, 0.2, 0.2, 0.6))
			_udraw(font, Vector2(gpos.x, gpos.y - 18), inst_data["name"], HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.9, 0.8, 0.5))
			_udraw(font, Vector2(gpos.x, gpos.y + 24), "CLICK TO PLACE" if valid else "INVALID SPOT", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.7, 0.6, 0.4))
		# Cancel hint
		_udraw(font, Vector2(btn_x + btn_w + 8, btn_y + 19), "RIGHT-CLICK TO CANCEL", HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.6, 0.5, 0.4))
		return
	# Instrument picker (small overlay listing owned instruments)
	if _instrument_picker_open:
		var px = btn_x
		var py = btn_y + btn_h + 4
		var pw = 220.0
		var items: Array = []
		for inst in literary_instruments:
			var count = owned_instruments.get(inst["id"], 0)
			if count > 0:
				items.append(inst)
		var ph = 8.0 + float(items.size()) * 32.0
		draw_rect(Rect2(px, py, pw, ph), Color(0.06, 0.04, 0.08, 0.92))
		draw_rect(Rect2(px, py, pw, ph), Color(0.85, 0.65, 0.1, 0.4), false, 1.0)
		for i in range(items.size()):
			var inst = items[i]
			var iy = py + 4 + float(i) * 32.0
			var ih = _instrument_picker_hover == i
			draw_rect(Rect2(px + 4, iy, pw - 8, 28), Color(0.15, 0.12, 0.06, 0.7) if ih else Color(0.08, 0.06, 0.04, 0.5))
			draw_circle(Vector2(px + 18, iy + 14), 5, Color(0.85, 0.7, 0.2, 0.6))
			var count = owned_instruments.get(inst["id"], 0)
			_udraw(font, Vector2(px + 28, iy + 18), "%s (x%d)" % [inst["name"], count], HORIZONTAL_ALIGNMENT_LEFT, int(pw - 40), 14, Color(0.9, 0.8, 0.5) if ih else Color(0.75, 0.65, 0.4))

func _handle_instrument_placement_click(mouse_pos: Vector2) -> bool:
	# Check instrument button click
	var btn_x = 8.0
	var btn_y = 48.0
	var btn_w = 110.0
	var btn_h = 38.0
	if _placing_instrument != "":
		# Currently placing — place the instrument or cancel
		if Rect2(btn_x, btn_y, btn_w, btn_h).has_point(mouse_pos):
			_placing_instrument = ""
			_instrument_picker_open = false
			queue_redraw()
			return true
		if _place_instrument(_placing_instrument, mouse_pos):
			_placing_instrument = ""
			_instrument_picker_open = false
			# Re-apply meta buffs to nearby towers
			for tower in get_tree().get_nodes_in_group("towers"):
				if tower.has_meta("tower_type_enum"):
					_apply_meta_buffs(tower, tower.get_meta("tower_type_enum"))
			queue_redraw()
			return true
		return false
	if Rect2(btn_x, btn_y, btn_w, btn_h).has_point(mouse_pos):
		_instrument_picker_open = not _instrument_picker_open
		queue_redraw()
		return true
	if _instrument_picker_open:
		var px = btn_x
		var py = btn_y + btn_h + 4
		var pw = 220.0
		var items: Array = []
		for inst in literary_instruments:
			var count = owned_instruments.get(inst["id"], 0)
			if count > 0:
				items.append(inst)
		var ph = 8.0 + float(items.size()) * 32.0
		if Rect2(px, py, pw, ph).has_point(mouse_pos):
			for i in range(items.size()):
				var iy = py + 4 + float(i) * 32.0
				if Rect2(px + 4, iy, pw - 8, 28).has_point(mouse_pos):
					_placing_instrument = items[i]["id"]
					_instrument_picker_open = false
					queue_redraw()
					return true
			return true
		else:
			_instrument_picker_open = false
			queue_redraw()
	return false


# ============================================================================
# === BATTD3: CHARACTER AFFINITY ===
# ============================================================================
func _get_character_title(tower_type) -> Dictionary:
	var total_dmg = survivor_progress.get(tower_type, {}).get("total_damage", 0.0)
	var result = MILESTONE_TITLES[0]
	for mt in MILESTONE_TITLES:
		if total_dmg >= mt["threshold"]:
			result = mt
	return result

func _get_affinity_level(tower_type) -> int:
	var aff = character_affinity.get(tower_type, 0.0)
	var level = 0
	for threshold in AFFINITY_MILESTONES:
		if aff >= threshold:
			level += 1
	return level

func _get_affinity_bonuses(tower_type, level_index: int) -> Dictionary:
	var bonuses: Dictionary = {}
	var aff_level = _get_affinity_level(tower_type)
	# Only apply if currently on home map
	var home_levels = CHARACTER_HOME_LEVELS.get(tower_type, [])
	if current_level < 0 or not current_level in home_levels:
		return bonuses
	for i in range(mini(aff_level, AFFINITY_BONUSES.size())):
		var bonus = AFFINITY_BONUSES[i]
		var eff = bonus["effect"]
		var val = bonus["value"]
		if eff == "all":
			bonuses["damage"] = bonuses.get("damage", 0.0) + val
			bonuses["range"] = bonuses.get("range", 0.0) + val
			bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
		else:
			bonuses[eff] = bonuses.get(eff, 0.0) + val
	return bonuses

func _award_affinity_for_wave() -> void:
	if current_level < 0:
		return
	for tower in towers_node.get_children():
		if not tower.has_method("get_tower_type"):
			continue
		var tt = tower.get_tower_type()
		var home_levels = CHARACTER_HOME_LEVELS.get(tt, [])
		if current_level in home_levels:
			var old_aff = character_affinity.get(tt, 0.0)
			character_affinity[tt] = minf(old_aff + AFFINITY_PER_WAVE, 100.0)

# ============================================================================
# === BATTD3: AWAKENING SYSTEM ===
# ============================================================================
func _can_awaken(tower_type) -> bool:
	var progress = survivor_progress.get(tower_type, {})
	if progress.get("level", 1) < MAX_SURVIVOR_LEVEL:
		return false
	if awakened_characters.get(tower_type, false):
		return false
	if player_relic_shards < AWAKENING_SHARD_COST:
		return false
	if player_quills < AWAKENING_QUILL_COST:
		return false
	return true

func _awaken_character(tower_type) -> bool:
	if not _can_awaken(tower_type):
		return false
	player_relic_shards -= AWAKENING_SHARD_COST
	player_quills -= AWAKENING_QUILL_COST
	awakened_characters[tower_type] = true
	# Trigger fanfare
	levelup_fanfare_active = true
	levelup_fanfare_timer = 0.0
	levelup_fanfare_tower_type = tower_type
	levelup_fanfare_new_level = -1  # -1 = awakening, not level up
	levelup_fanfare_particles.clear()
	var rng = RandomNumberGenerator.new()
	rng.seed = int(Time.get_ticks_msec())
	for _i in range(40):
		var angle = rng.randf() * TAU
		var speed = rng.randf_range(80, 250)
		levelup_fanfare_particles.append({
			"pos": Vector2(640, 360),
			"vel": Vector2(cos(angle) * speed, sin(angle) * speed),
			"color": Color(1.0, 0.85, 0.2, 1.0),
			"life": rng.randf_range(1.0, 2.5),
		})
	_save_game()
	queue_redraw()
	return true

func _get_awakening_passive(tower_type) -> Dictionary:
	return AWAKENING_PASSIVES.get(tower_type, {})

func _is_awakened(tower_type) -> bool:
	return awakened_characters.get(tower_type, false)

# ============================================================================
# === BATTD3: COSMIC INK CONVERSION ===
# ============================================================================
func _convert_cosmic_ink(tower_type, amount: int) -> bool:
	if cosmic_ink < amount:
		return false
	cosmic_ink -= amount
	var xp_gain = float(amount) * COSMIC_INK_TO_XP
	var progress = survivor_progress.get(tower_type, {})
	progress["xp"] = progress.get("xp", 0.0) + xp_gain
	# Check level-ups
	while progress["xp"] >= progress["xp_next"] and progress.get("level", 1) < MAX_SURVIVOR_LEVEL:
		progress["xp"] -= progress["xp_next"]
		progress["level"] = progress.get("level", 1) + 1
		progress["xp_next"] = _get_xp_for_level(progress["level"])
		_on_survivor_level_up(tower_type, progress["level"])
	_save_game()
	queue_redraw()
	return true

# ============================================================================
# === BATTD3: STAT RESPEC ===
# ============================================================================
func _get_respec_cost() -> int:
	return int(float(RESPEC_BASE_COST) * pow(RESPEC_COST_MULT, float(respec_count)))

func _respec_knowledge_tree() -> bool:
	var cost = _get_respec_cost()
	if player_relic_shards < cost:
		return false
	# Count total ink invested
	var ink_refund = 0
	for key in knowledge_tree:
		if knowledge_tree[key]:
			# Find the node cost
			var parts = key.split("_")
			if parts.size() == 2:
				var bi = int(parts[0])
				var ni = int(parts[1])
				if bi < knowledge_branches.size():
					var branch = knowledge_branches[bi]
					if ni < branch["nodes"].size():
						ink_refund += branch["nodes"][ni].get("cost", 1)
	player_relic_shards -= cost
	knowledge_ink += ink_refund
	knowledge_tree.clear()
	respec_count += 1
	_save_game()
	queue_redraw()
	return true

# ============================================================================
# === BATTD3: GEAR LOADOUT PRESETS ===
# ============================================================================
func _save_loadout(tower_type, slot: int) -> void:
	if slot < 0 or slot >= MAX_LOADOUTS:
		return
	var eq_bindings = equipped_bindings.get(tower_type, []).duplicate()
	var eq_relics = equipped_relics.get(tower_type, []).duplicate()
	gear_loadouts[tower_type][slot] = {"bindings": eq_bindings, "relics": eq_relics}
	_save_game()

func _load_loadout(tower_type, slot: int) -> void:
	if slot < 0 or slot >= MAX_LOADOUTS:
		return
	var loadout = gear_loadouts.get(tower_type, [{}])[slot] if slot < gear_loadouts.get(tower_type, []).size() else {}
	if loadout.is_empty():
		return
	equipped_bindings[tower_type] = loadout.get("bindings", []).duplicate()
	equipped_relics[tower_type] = loadout.get("relics", []).duplicate()
	_save_game()
	queue_redraw()

# ============================================================================
# === BATTD3: TRINKET LOCKING ===
# ============================================================================
func _toggle_binding_lock(binding_id: String) -> void:
	if locked_bindings.get(binding_id, false):
		locked_bindings.erase(binding_id)
	else:
		locked_bindings[binding_id] = true
	_save_game()

func _is_binding_locked(binding_id: String) -> bool:
	return locked_bindings.get(binding_id, false)

# ============================================================================
# === BATTD3: RELIC MASTERY ===
# ============================================================================
func _get_relic_mastery_level(tower_type, relic_idx: int) -> int:
	var key = "%d_%d" % [tower_type, relic_idx]
	var waves = relic_usage_tracker.get(key, 0)
	var level = 0
	for threshold in RELIC_MASTERY_THRESHOLDS:
		if waves >= threshold:
			level += 1
	return level

func _tick_relic_usage() -> void:
	# Called each wave — increment usage for all equipped relics on all placed towers
	for tower in towers_node.get_children():
		if not tower.has_method("get_tower_type"):
			continue
		var tt = tower.get_tower_type()
		var eq_list = equipped_relics.get(tt, [])
		for ri in eq_list:
			var key = "%d_%d" % [tt, ri]
			relic_usage_tracker[key] = relic_usage_tracker.get(key, 0) + 1

# ============================================================================
# === BATTD3: GEAR COLLECTION CODEX ===
# ============================================================================
func _mark_binding_discovered(binding_id: String) -> void:
	if not discovered_bindings.has(binding_id):
		discovered_bindings[binding_id] = true

func _get_codex_completion() -> Dictionary:
	var total = TOME_BINDINGS.size()
	var discovered = discovered_bindings.size()
	var owned = 0
	for b in TOME_BINDINGS:
		if owned_bindings.get(b["id"], 0) > 0:
			owned += 1
	return {"total": total, "discovered": discovered, "owned": owned}

# ============================================================================
# === BATTD3: PARTY POWER RATING ===
# ============================================================================
func _calculate_power_rating(tower_type) -> int:
	var rating = 0
	var progress = survivor_progress.get(tower_type, {})
	var level = progress.get("level", 1)
	# Level contribution (0-100)
	rating += level * 5
	# Gear contribution
	var eq_bindings = equipped_bindings.get(tower_type, [])
	for bid in eq_bindings:
		var binding = _find_binding(bid)
		if binding.is_empty():
			continue
		var rar = binding.get("rarity", "tattered")
		match rar:
			"tattered": rating += 2
			"bound": rating += 5
			"gilded": rating += 12
			"mythic": rating += 25
			"forbidden": rating += 50
	# Relic contribution
	var eq_relics = equipped_relics.get(tower_type, [])
	rating += eq_relics.size() * 8
	# Golden shields
	var shields = progress.get("golden_shields", 0)
	rating += shields * 10
	# Awakened bonus
	if _is_awakened(tower_type):
		rating += 50
	# Affinity bonus
	rating += _get_affinity_level(tower_type) * 5
	return rating

func _refresh_power_ratings() -> void:
	for t in survivor_progress:
		_cached_power_ratings[t] = _calculate_power_rating(t)
	_power_rating_dirty = false

# ============================================================================
# === BATTD3: LEVEL-UP FANFARE ===
# ============================================================================
func _trigger_levelup_fanfare(tower_type, new_level: int) -> void:
	levelup_fanfare_active = true
	levelup_fanfare_timer = 0.0
	levelup_fanfare_tower_type = tower_type
	levelup_fanfare_new_level = new_level
	levelup_fanfare_particles.clear()
	var rng = RandomNumberGenerator.new()
	rng.seed = int(Time.get_ticks_msec())
	for _i in range(30):
		var angle = rng.randf() * TAU
		var speed = rng.randf_range(60, 200)
		var hue = rng.randf_range(0.08, 0.17)  # Gold range
		levelup_fanfare_particles.append({
			"pos": Vector2(640, 300),
			"vel": Vector2(cos(angle) * speed, sin(angle) * speed - 50),
			"color": Color.from_hsv(hue, 0.8, 1.0, 1.0),
			"life": rng.randf_range(0.8, 2.2),
		})

func _update_levelup_fanfare(delta: float) -> void:
	if not levelup_fanfare_active:
		return
	levelup_fanfare_timer += delta
	for p in levelup_fanfare_particles:
		p["pos"] += p["vel"] * delta
		p["vel"].y += 120.0 * delta  # Gravity
		p["life"] -= delta
	if levelup_fanfare_timer >= LEVELUP_FANFARE_DURATION:
		levelup_fanfare_active = false
	queue_redraw()

func _draw_levelup_fanfare() -> void:
	if not levelup_fanfare_active:
		return
	var alpha = clamp(1.0 - levelup_fanfare_timer / LEVELUP_FANFARE_DURATION, 0.0, 1.0)
	# Draw particles
	for p in levelup_fanfare_particles:
		if p["life"] <= 0:
			continue
		var pa = clamp(p["life"], 0.0, 1.0) * alpha
		var col = p["color"]
		draw_circle(p["pos"], 3.0, Color(col.r, col.g, col.b, pa))
		draw_circle(p["pos"], 1.5, Color(1, 1, 1, pa * 0.5))
	# Center text
	var text_alpha = clamp(1.0 - (levelup_fanfare_timer - 0.5) / 1.5, 0.0, 1.0) if levelup_fanfare_timer > 0.5 else clamp(levelup_fanfare_timer / 0.5, 0.0, 1.0)
	var name_str = ""
	if levelup_fanfare_tower_type >= 0 and levelup_fanfare_tower_type < character_names.size():
		name_str = character_names[levelup_fanfare_tower_type]
	var label = ""
	if levelup_fanfare_new_level == -1:
		label = "%s AWAKENED!" % name_str.to_upper()
	else:
		label = "%s LEVEL %d!" % [name_str.to_upper(), levelup_fanfare_new_level]
	var font = game_font
	var tw = font.get_string_size(label, HORIZONTAL_ALIGNMENT_LEFT, -1, 28).x
	var cx = 640.0 - tw * 0.5
	var cy = 280.0 - levelup_fanfare_timer * 15.0
	_udraw(font, Vector2(cx + 2, cy + 2), label, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(0, 0, 0, text_alpha * 0.5))
	_udraw(font, Vector2(cx, cy), label, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(1.0, 0.85, 0.2, text_alpha))

# ============================================================================
# === BATTD3: SESSION STATS RECAP ===
# ============================================================================
func _build_session_stats() -> void:
	session_stats.clear()
	session_stats["towers_placed"] = total_towers_placed
	session_stats["gold_earned"] = total_gold_earned
	session_stats["gold_spent"] = total_gold_spent
	session_stats["enemies_killed"] = total_enemies_killed
	session_stats["waves_survived"] = wave
	session_stats["lives_lost"] = current_game_lives_lost
	# Per-tower DPS
	var tower_dps: Array = []
	for tower in towers_node.get_children():
		if not tower.has_method("get_tower_type"):
			continue
		var tt = tower.get_tower_type()
		var dmg = tower.damage_dealt if "damage_dealt" in tower else 0.0
		var name_str = character_names[tt] if tt < character_names.size() else "Unknown"
		tower_dps.append({"name": name_str, "damage": dmg})
	tower_dps.sort_custom(func(a, b): return a["damage"] > b["damage"])
	session_stats["tower_breakdown"] = tower_dps

func _draw_session_recap() -> void:
	if not session_recap_open:
		return
	var font = game_font
	# Dark overlay
	draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.75))
	var px = 240.0
	var py = 60.0
	var pw = 800.0
	var ph = 600.0
	draw_rect(Rect2(px, py, pw, ph), Color(0.04, 0.04, 0.10))
	draw_rect(Rect2(px, py, pw, ph), Color(0.85, 0.65, 0.1, 0.5), false, 2.0)
	# Title
	_udraw(font, Vector2(px + 20, py + 30), "SESSION STATS", HORIZONTAL_ALIGNMENT_LEFT, -1, 22, Color(0.85, 0.65, 0.1))
	draw_rect(Rect2(px + 20, py + 38, 150, 1), Color(0.85, 0.65, 0.1, 0.3))
	# Stats
	var sy = py + 60.0
	var stat_items = [
		["Waves Survived", str(session_stats.get("waves_survived", 0))],
		["Enemies Killed", str(session_stats.get("enemies_killed", 0))],
		["Gold Earned", str(session_stats.get("gold_earned", 0))],
		["Gold Spent", str(session_stats.get("gold_spent", 0))],
		["Towers Placed", str(session_stats.get("towers_placed", 0))],
		["Lives Lost", str(session_stats.get("lives_lost", 0))],
	]
	for item in stat_items:
		_udraw(font, Vector2(px + 40, sy + 14), item[0], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, Color(0.77, 0.73, 0.66))
		_udraw(font, Vector2(px + pw - 100, sy + 14), item[1], HORIZONTAL_ALIGNMENT_LEFT, -1, 15, menu_parchment)
		sy += 26.0
	# Tower Breakdown
	sy += 10.0
	_udraw(font, Vector2(px + 40, sy + 14), "TOWER DAMAGE BREAKDOWN", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.65, 0.1, 0.8))
	draw_rect(Rect2(px + 40, sy + 20, 200, 1), Color(0.85, 0.65, 0.1, 0.2))
	sy += 30.0
	var breakdown = session_stats.get("tower_breakdown", [])
	var max_dmg = 1.0
	for entry in breakdown:
		if entry["damage"] > max_dmg:
			max_dmg = entry["damage"]
	for i in range(mini(breakdown.size(), 8)):
		var entry = breakdown[i]
		var bar_w = 350.0 * (entry["damage"] / max_dmg)
		draw_rect(Rect2(px + 200, sy + 2, bar_w, 14), Color(0.85, 0.65, 0.1, 0.3))
		_udraw(font, Vector2(px + 40, sy + 14), entry["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, menu_parchment)
		var dmg_str = _format_number(entry["damage"])
		_udraw(font, Vector2(px + 200 + bar_w + 8, sy + 14), dmg_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1))
		sy += 22.0
	# Close button
	var close_x = px + pw - 40.0
	var close_y = py + 10.0
	_udraw(font, Vector2(close_x, close_y + 16), "X", HORIZONTAL_ALIGNMENT_LEFT, -1, 18, Color(0.9, 0.3, 0.2, 0.8))

# ============================================================================
# === BATTD3: CAREER STATS ===
# ============================================================================
func _update_career_stats_post_game(won: bool) -> void:
	career_stats["total_games_played"] = career_stats.get("total_games_played", 0) + 1
	if won:
		career_stats["total_games_won"] = career_stats.get("total_games_won", 0) + 1
	else:
		career_stats["total_games_lost"] = career_stats.get("total_games_lost", 0) + 1
	career_stats["total_waves_survived"] = career_stats.get("total_waves_survived", 0) + wave
	career_stats["total_gold_earned_lifetime"] = career_stats.get("total_gold_earned_lifetime", 0) + total_gold_earned
	career_stats["total_gold_spent_lifetime"] = career_stats.get("total_gold_spent_lifetime", 0) + total_gold_spent
	career_stats["total_towers_placed_lifetime"] = career_stats.get("total_towers_placed_lifetime", 0) + total_towers_placed
	career_stats["total_enemies_killed_lifetime"] = career_stats.get("total_enemies_killed_lifetime", 0) + total_enemies_killed
	# Find most-used tower
	var tower_counts: Dictionary = {}
	for tower in towers_node.get_children():
		if tower.has_method("get_tower_type"):
			var tt = tower.get_tower_type()
			tower_counts[tt] = tower_counts.get(tt, 0) + 1
	var best_tt = -1
	var best_count = 0
	for tt in tower_counts:
		if tower_counts[tt] > best_count:
			best_count = tower_counts[tt]
			best_tt = tt
	if best_tt >= 0:
		career_stats["favorite_tower"] = best_tt
	var tc = towers_node.get_child_count()
	if tc > career_stats.get("most_towers_in_game", 0):
		career_stats["most_towers_in_game"] = tc
	if won and victory_streak > career_stats.get("longest_victory_streak", 0):
		career_stats["longest_victory_streak"] = victory_streak

func _draw_career_stats() -> void:
	if not career_stats_open:
		return
	var font = game_font
	draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.75))
	var px = 200.0
	var py = 40.0
	var pw = 880.0
	var ph = 640.0
	draw_rect(Rect2(px, py, pw, ph), Color(0.04, 0.04, 0.10))
	draw_rect(Rect2(px, py, pw, ph), Color(0.85, 0.65, 0.1, 0.5), false, 2.0)
	_udraw(font, Vector2(px + 30, py + 35), "CAREER STATISTICS", HORIZONTAL_ALIGNMENT_LEFT, -1, 24, Color(0.85, 0.65, 0.1))
	draw_rect(Rect2(px + 30, py + 44, 200, 2), Color(0.85, 0.65, 0.1, 0.3))
	var sy = py + 70.0
	var stats = [
		["Games Played", str(career_stats.get("total_games_played", 0))],
		["Games Won", str(career_stats.get("total_games_won", 0))],
		["Games Lost", str(career_stats.get("total_games_lost", 0))],
		["Win Rate", "%d%%" % (int(float(career_stats.get("total_games_won", 0)) / maxf(float(career_stats.get("total_games_played", 1)), 1.0) * 100.0))],
		["", ""],
		["Total Waves Survived", str(career_stats.get("total_waves_survived", 0))],
		["Total Enemies Killed", _format_number(float(career_stats.get("total_enemies_killed_lifetime", 0)))],
		["Total Damage Dealt", _format_number(career_stats.get("total_damage_dealt_lifetime", 0.0))],
		["Highest Single Hit", _format_number(career_stats.get("highest_single_hit", 0.0))],
		["", ""],
		["Total Gold Earned", _format_number(float(career_stats.get("total_gold_earned_lifetime", 0)))],
		["Total Gold Spent", _format_number(float(career_stats.get("total_gold_spent_lifetime", 0)))],
		["Total Towers Placed", str(career_stats.get("total_towers_placed_lifetime", 0))],
		["Most Towers in Game", str(career_stats.get("most_towers_in_game", 0))],
		["", ""],
		["Best Victory Streak", str(career_stats.get("longest_victory_streak", 0))],
	]
	# Two columns
	var col1_x = px + 50.0
	var col2_x = px + pw * 0.5 + 30.0
	var col = 0
	var col1_y = sy
	var col2_y = sy
	for item in stats:
		if item[0] == "":
			if col == 0:
				col1_y += 10.0
			else:
				col2_y += 10.0
			continue
		var cx = col1_x if col == 0 else col2_x
		var cy = col1_y if col == 0 else col2_y
		_udraw(font, Vector2(cx, cy + 14), item[0], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.77, 0.73, 0.66))
		_udraw(font, Vector2(cx + 250, cy + 14), item[1], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, menu_parchment)
		if col == 0:
			col1_y += 24.0
		else:
			col2_y += 24.0
		if col1_y > py + ph * 0.55 and col == 0:
			col = 1
	# Favorite tower
	var fav = career_stats.get("favorite_tower", -1)
	if fav >= 0 and fav < character_names.size():
		var fav_y = py + ph - 90.0
		_udraw(font, Vector2(px + 50, fav_y + 14), "FAVORITE TOWER", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.65, 0.1, 0.7))
		_udraw(font, Vector2(px + 50, fav_y + 34), character_names[fav], HORIZONTAL_ALIGNMENT_LEFT, -1, 20, menu_parchment)
	# Close button
	_udraw(font, Vector2(px + pw - 40, py + 22), "X", HORIZONTAL_ALIGNMENT_LEFT, -1, 18, Color(0.9, 0.3, 0.2, 0.8))

# ============================================================================
# === BATTD3: NEXT GOAL TRACKER ===
# ============================================================================
func _refresh_next_goals() -> void:
	_next_goals.clear()
	# Check closest achievements
	for ach in achievement_definitions:
		var id = ach.get("id", "")
		if achievements_unlocked.get(id, false):
			continue
		var prog = achievement_progress.get(id, 0)
		var target = ach.get("target", 1)
		var pct = float(prog) / float(target)
		if pct > 0.0:
			_next_goals.append({
				"type": "achievement",
				"desc": ach.get("name", "Achievement"),
				"progress": prog,
				"target": target,
				"pct": pct,
			})
	# Check quest progress
	for q in active_quests:
		var pct = float(q.get("progress", 0)) / float(q.get("target", 1))
		if pct > 0.0:
			_next_goals.append({
				"type": "quest",
				"desc": q.get("desc", "Quest"),
				"progress": q.get("progress", 0),
				"target": q.get("target", 1),
				"pct": pct,
			})
	# Sort by completion percentage (closest to done first)
	_next_goals.sort_custom(func(a, b): return a["pct"] > b["pct"])
	# Keep top 3
	if _next_goals.size() > 3:
		_next_goals.resize(3)
	_goals_dirty = false

func _draw_next_goals_widget() -> void:
	if _goals_dirty:
		_refresh_next_goals()
	if _next_goals.is_empty():
		return
	var font = game_font
	var wx = 70.0
	var wy = 575.0
	var ww = 300.0
	_udraw(font, Vector2(wx, wy + 12), "NEAREST GOALS", HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1, 0.5))
	var gy = wy + 18.0
	for goal in _next_goals:
		var pct = goal["pct"]
		var bar_w = ww - 20.0
		# Progress bar
		draw_rect(Rect2(wx, gy + 4, bar_w, 8), Color(0.1, 0.1, 0.15))
		draw_rect(Rect2(wx, gy + 4, bar_w * pct, 8), Color(0.85, 0.65, 0.1, 0.6))
		# Label
		var type_icon = "[Q]" if goal["type"] == "quest" else "[A]"
		var desc = "%s %s (%d/%d)" % [type_icon, goal["desc"], goal["progress"], goal["target"]]
		if desc.length() > 40:
			desc = desc.substr(0, 39) + ".."
		_udraw(font, Vector2(wx, gy + 24), desc, HORIZONTAL_ALIGNMENT_LEFT, int(ww), 14, Color(0.77, 0.73, 0.66, 0.7))
		gy += 30.0

# ============================================================================
# === BATTD3: CHARACTER RANK BADGES ===
# ============================================================================
func _get_character_rank(tower_type) -> Dictionary:
	var score = _calculate_power_rating(tower_type)
	var result = RANK_BADGE_TIERS[0]
	for tier in RANK_BADGE_TIERS:
		if score >= tier["min_score"]:
			result = tier
	return result

func _draw_rank_badge(center: Vector2, tower_type, size: float) -> void:
	var rank = _get_character_rank(tower_type)
	var col = Color(rank["color_r"], rank["color_g"], rank["color_b"])
	# Shield shape
	var pts = PackedVector2Array()
	var hw = size * 0.45
	var hh = size * 0.55
	pts.append(center + Vector2(-hw, -hh * 0.4))
	pts.append(center + Vector2(0, -hh))
	pts.append(center + Vector2(hw, -hh * 0.4))
	pts.append(center + Vector2(hw, hh * 0.3))
	pts.append(center + Vector2(0, hh))
	pts.append(center + Vector2(-hw, hh * 0.3))
	draw_colored_polygon(pts, Color(col.r, col.g, col.b, 0.7))
	draw_polyline(pts, Color(col.r, col.g, col.b, 0.9), 1.5)
	# Rank initial
	var font = game_font
	var initial = rank["name"].substr(0, 1)
	var iw = font.get_string_size(initial, HORIZONTAL_ALIGNMENT_LEFT, -1, int(size * 0.55)).x
	_udraw(font, Vector2(center.x - iw * 0.5, center.y + size * 0.15), initial, HORIZONTAL_ALIGNMENT_LEFT, -1, int(size * 0.55), Color.WHITE)

# ============================================================================
# === BATTD3: RECENT ITEMS FEED ===
# ============================================================================
func _add_recent_item(item_name: String, rarity: String) -> void:
	recent_items.push_front({"name": item_name, "rarity": rarity, "time": Time.get_ticks_msec()})
	if recent_items.size() > MAX_RECENT_ITEMS:
		recent_items.resize(MAX_RECENT_ITEMS)

func _draw_recent_items_widget() -> void:
	if recent_items.is_empty():
		return
	var font = game_font
	var wx = 900.0
	var wy = 575.0
	_udraw(font, Vector2(wx, wy + 12), "RECENT ITEMS", HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1, 0.5))
	var iy = wy + 18.0
	for item in recent_items:
		var rc = RARITY_COLORS.get(item.get("rarity", "tattered"), Color(0.6, 0.6, 0.65))
		draw_rect(Rect2(wx, iy, 3, 14), rc)
		var name_str = item.get("name", "Unknown")
		if name_str.length() > 25:
			name_str = name_str.substr(0, 24) + ".."
		_udraw(font, Vector2(wx + 8, iy + 12), name_str, HORIZONTAL_ALIGNMENT_LEFT, 280, 14, Color(0.77, 0.73, 0.66, 0.7))
		iy += 18.0

# ============================================================================
# === BATTD3: FAVORITE CHARACTERS ===
# ============================================================================
func _toggle_favorite(tower_type) -> void:
	if tower_type in favorite_characters:
		favorite_characters.erase(tower_type)
	else:
		if favorite_characters.size() >= 3:
			favorite_characters.pop_front()
		favorite_characters.append(tower_type)
	_save_game()
	queue_redraw()

func _is_favorite(tower_type) -> bool:
	return tower_type in favorite_characters