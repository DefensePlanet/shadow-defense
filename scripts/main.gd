extends Node2D

# Game state
var gold: int = 150
var lives: int = 20
var wave: int = 0
var is_wave_active: bool = false
var placing_tower: bool = false
var ghost_position: Vector2 = Vector2.ZERO

# Tower selection
enum TowerType { ROBIN_HOOD, ALICE, WICKED_WITCH, PETER_PAN, PHANTOM, SCROOGE, SHERLOCK, TARZAN, DRACULA, MERLIN, FRANKENSTEIN, SHADOW_AUTHOR }
var selected_tower: TowerType = TowerType.ROBIN_HOOD

const BOSS_VILLAIN_NAMES: Dictionary = {
	0: "Sheriff of Nottingham",
	1: "Queen of Hearts",
	2: "Dark Witch",
	3: "Captain Hook",
	4: "Dark Phantom",
	5: "Ghost of Christmas",
	6: "Shadow Lord",
	7: "Professor Moriarty",
	8: "Morgan le Fay",
	9: "Clayton",
	10: "Dark Dracula",
	11: "The Creature",
	12: "The Shadow Author"
}

# Purchase tracking — each tower can only be bought once
var purchased_towers: Dictionary = {}
var tower_buttons: Dictionary = {}

var tower_info = {
	TowerType.ROBIN_HOOD: {"name": "Robin Hood", "cost": 75, "range": 200.0},
	TowerType.ALICE: {"name": "Alice", "cost": 85, "range": 85.0},
	TowerType.WICKED_WITCH: {"name": "Wicked Witch", "cost": 100, "range": 154.0},
	TowerType.PETER_PAN: {"name": "Peter Pan", "cost": 90, "range": 85.0},
	TowerType.PHANTOM: {"name": "The Phantom", "cost": 95, "range": 180.0},
	TowerType.SCROOGE: {"name": "Scrooge", "cost": 60, "range": 70.0},
	TowerType.SHERLOCK: {"name": "Sherlock Holmes", "cost": 110, "range": 188.0},
	TowerType.TARZAN: {"name": "Tarzan", "cost": 100, "range": 120.0},
	TowerType.DRACULA: {"name": "Count Dracula", "cost": 105, "range": 190.0},
	TowerType.MERLIN: {"name": "Merlin", "cost": 115, "range": 132.0},
	TowerType.FRANKENSTEIN: {"name": "The Monster", "cost": 130, "range": 140.0},
	TowerType.SHADOW_AUTHOR: {"name": "Shadow Author", "cost": 250, "range": 170.0},
}

# Constants
var total_waves: int = 20
const MIN_PATH_DIST: float = 40.0
const MIN_TOWER_DIST: float = 48.0
const MAX_SURVIVOR_LEVEL: int = 20
# BTD6-inspired sub-exponential XP curve (19 entries, index = current_level - 1)
const HERO_XP_TABLE: Array = [180, 460, 1000, 1860, 3280, 5180, 8320, 9380, 13620, 16380, 18200, 20100, 22100, 24200, 26400, 28800, 31400, 34200, 37200]

# Preloads
var tower_scenes = {
	TowerType.ROBIN_HOOD: preload("res://scenes/robin_hood.tscn"),
	TowerType.ALICE: preload("res://scenes/alice.tscn"),
	TowerType.WICKED_WITCH: preload("res://scenes/wicked_witch.tscn"),
	TowerType.PETER_PAN: preload("res://scenes/peter_pan.tscn"),
	TowerType.PHANTOM: preload("res://scenes/phantom.tscn"),
	TowerType.SCROOGE: preload("res://scenes/scrooge.tscn"),
}
var new_tower_scenes: Dictionary = {}  # Loaded at runtime after unlock

var enemy_scene = preload("res://scenes/enemy.tscn")

@onready var enemy_path: Path2D = $EnemyPath
@onready var towers_node: Node2D = $Towers

# UI references
var wave_label: Label
var gold_label: Label
var lives_label: Label
var start_button: Button
var game_over_label: Label
var info_label: Label
var top_bar: ColorRect
var bottom_panel: ColorRect
var cancel_button: Button

# Ability choice UI
var ability_panel: ColorRect
var ability_title: Label
var ability_buttons: Array = []
var _ability_tower: Node2D = null

# Tower upgrade selection
var selected_tower_node: Node2D = null
const TOWER_SELECT_RADIUS: float = 28.0
var upgrade_panel: ColorRect
var upgrade_name_label: Label
var upgrade_buttons: Array = []  # 4 upgrade tier buttons
var upgrade_cost_labels: Array = []  # 4 cost labels
var upgrade_desc_labels: Array = []  # 4 description labels
var upgrade_status_rects: Array = []  # 4 background rects for status coloring
var sell_button: Button
var sell_value_label: Label

# Game state & levels
enum GameState { MENU, PLAYING, GAME_OVER_STATE }
var game_state: int = GameState.MENU
var game_font: Font
var current_level: int = -1

# Menu UI
var menu_overlay: ColorRect
var menu_title: Label
var menu_subtitle: Label
var level_cards: Array = []
var return_button: Button
var retry_button: Button
var menu_exit_button: Button
var completed_levels: Array = []
var level_stars: Dictionary = {}

# Storybook menu - character page showcase
var menu_character_index: int = 0
var menu_level_name_label: Label
var menu_level_desc_label: Label
var menu_level_stats_label: Label
var menu_level_stars_label: Label
var menu_play_button: Button
var menu_left_arrow: Button
var menu_right_arrow: Button
var menu_showcase_panel: ColorRect
# Chapter card UI elements
var chapter_buttons: Array = []  # 3 PLAY buttons for chapters
var chapter_title_labels: Array = []  # 3 chapter title labels
var chapter_desc_labels: Array = []  # 3 chapter description labels
var chapter_star_labels: Array = []  # 3 star display labels
var chapter_stat_labels: Array = []  # 3 stat labels (waves/gold/lives)
var chapter_lock_labels: Array = []  # 3 lock/difficulty labels

# Gothic menu - bottom nav
var menu_nav_buttons: Array = []
var menu_nav_labels: Array = []
var menu_current_view: String = "chapters"
var menu_transition_alpha: float = 1.0  # For fade transitions between views
var menu_star_total_label: Label

# Survivors tab
var survivor_types = [
	TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH,
	TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE,
	TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA,
	TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR
]
var survivor_descriptions = {
	TowerType.ROBIN_HOOD: "The legendary outlaw of Sherwood Forest.\nLong-range archer with piercing arrows and gold bonus.",
	TowerType.ALICE: "The curious girl from Wonderland.\nThrows cake that slows and shrinks all nearby enemies.",
	TowerType.WICKED_WITCH: "The Wicked Witch of the West.\nSwoops to strike enemies, summons wolves and monkeys.",
	TowerType.PETER_PAN: "The boy who never grew up.\nFast dagger attacks with shadow and fairy dust.",
	TowerType.PHANTOM: "The masked genius beneath the Opera.\nHeavy music note attacks with stun and AoE.",
	TowerType.SCROOGE: "The miserly old man visited by ghosts.\nRings his bell to blast enemies backwards and earn gold.",
	TowerType.SHERLOCK: "The world's greatest detective.\nMagnifying glass beam burns enemies. Marks targets for team damage.",
	TowerType.TARZAN: "The lord of the jungle.\nDevastating melee attacks, vine swings, and animal allies.",
	TowerType.DRACULA: "The immortal count from Transylvania.\nDrains life from enemies, summons bats, turns foes to minions.",
	TowerType.MERLIN: "The legendary wizard of Camelot.\nBuffs allies, curses enemies, summons Excalibur strikes.",
	TowerType.FRANKENSTEIN: "The tragic creature brought to life.\nLightning-charged fist smash with devastating area damage.",
}
# Survivor grid UI
var survivor_grid_cards: Array = []  # Array of Button nodes for each character
var survivor_grid_container: Control = null  # Container for the grid
var survivor_grid_previews: Array = []  # Tower preview nodes for each card
var survivor_selected_index: int = -1  # Currently selected survivor (-1 = none)
var survivor_preview_node: Node2D = null  # Preview of selected survivor

# Character detail page
var survivor_detail_open: bool = false
var survivor_detail_index: int = -1
var survivor_detail_container: Control = null
var survivor_detail_back_btn: Button = null
var survivor_detail_preview: Node2D = null
var survivor_detail_abilities: Array = []  # [{name, desc, cost}] from tower TIER_NAMES/ABILITY_DESCRIPTIONS/TIER_COSTS
var detail_hover_type: String = ""  # "ability", "sidekick", "relic", "weapon", "levelup", ""
var detail_hover_index: int = -1
var detail_levelup_hover: bool = false
var detail_info_overlay_open: bool = false
var detail_info_close_hover: bool = false

# Character progression — levels, gear, sidekicks, relics
var survivor_progress: Dictionary = {}  # TowerType -> {level, xp, gear, sidekicks, relics}
var session_damage: Dictionary = {}  # TowerType -> float, damage dealt this game session

# Gear definitions per character
var survivor_gear = {
	TowerType.ROBIN_HOOD: {"name": "Longbow", "desc": "Increases arrow range and pierce"},
	TowerType.ALICE: {"name": "Looking Glass", "desc": "Cake affects wider area"},
	TowerType.WICKED_WITCH: {"name": "Broomstick", "desc": "Faster swoop attacks"},
	TowerType.PETER_PAN: {"name": "Shadow Blade", "desc": "Shadow clone deals more damage"},
	TowerType.PHANTOM: {"name": "Pipe Organ", "desc": "Music notes stun longer"},
	TowerType.SCROOGE: {"name": "Counting Ledger", "desc": "Bell rings generate bonus gold"},
	TowerType.SHERLOCK: {"name": "Magnifying Glass", "desc": "Focus beam burns hotter and wider"},
	TowerType.TARZAN: {"name": "Jungle Vine", "desc": "Longer swing range and grab distance"},
	TowerType.DRACULA: {"name": "Blood Chalice", "desc": "Life drain heals more and chains to nearby"},
	TowerType.MERLIN: {"name": "Crystal Staff", "desc": "Spells affect larger area"},
	TowerType.FRANKENSTEIN: {"name": "Lightning Rod", "desc": "Chain lightning arcs to more targets"},
}

# Sidekick definitions (3 per character)
var survivor_sidekicks = {
	TowerType.ROBIN_HOOD: [{"name": "Little John", "desc": "Slows nearby enemies"}, {"name": "Friar Tuck", "desc": "Heals nearby towers"}, {"name": "Maid Marian", "desc": "Bonus gold on kill"}],
	TowerType.ALICE: [{"name": "Cheshire Cat", "desc": "Reveals hidden enemies"}, {"name": "White Rabbit", "desc": "Speeds up attack rate"}, {"name": "Mad Hatter", "desc": "Random debuffs on hit"}],
	TowerType.WICKED_WITCH: [{"name": "Winged Monkey", "desc": "Flies to attack distant foes"}, {"name": "Toto", "desc": "Detects hidden enemies"}, {"name": "Tin Woodman", "desc": "Blocks enemies briefly"}],
	TowerType.PETER_PAN: [{"name": "Tinker Bell", "desc": "AoE fairy dust heal"}, {"name": "Lost Boys", "desc": "Extra dagger throws"}, {"name": "Tiger Lily", "desc": "Poisons enemies on hit"}],
	TowerType.PHANTOM: [{"name": "Christine", "desc": "Sings to slow enemies"}, {"name": "Madame Giry", "desc": "Reveals enemy paths"}, {"name": "Raoul", "desc": "Blocks strongest enemy"}],
	TowerType.SCROOGE: [{"name": "Bob Cratchit", "desc": "Collects extra gold"}, {"name": "Tiny Tim", "desc": "Inspires nearby towers"}, {"name": "Ghost of Marley", "desc": "Chains slow enemies"}],
	TowerType.SHERLOCK: [{"name": "Dr. Watson", "desc": "Backup shots at marked targets"}, {"name": "Mrs. Hudson", "desc": "Gradually restores nearby tower health"}, {"name": "Inspector Lestrade", "desc": "Slows fastest enemy"}],
	TowerType.TARZAN: [{"name": "Cheeta", "desc": "Throws fruit to slow enemies"}, {"name": "Tantor", "desc": "Stomps to stun nearby enemies"}, {"name": "Jane", "desc": "Boosts Tarzan's attack speed"}],
	TowerType.DRACULA: [{"name": "Renfield", "desc": "Collects blood from kills for power"}, {"name": "Bat Swarm", "desc": "Attacks enemies in a cloud"}, {"name": "Bride of Dracula", "desc": "Charms enemies to fight each other"}],
	TowerType.MERLIN: [{"name": "Archimedes", "desc": "Owl spots hidden enemies"}, {"name": "Lady of the Lake", "desc": "Heals and buffs nearest tower"}, {"name": "Young Arthur", "desc": "Extra sword strikes on enemies"}],
	TowerType.FRANKENSTEIN: [{"name": "Igor", "desc": "Repairs and buffs the Monster"}, {"name": "Lightning Coil", "desc": "Passive chain lightning"}, {"name": "Victor's Notes", "desc": "Kill stacks build faster"}],
}

# Character-specific relic definitions (6 per character, 36 total)
var survivor_relics = {
	TowerType.ROBIN_HOOD: [
		{"name": "Lincoln Green Cloak", "desc": "Blend with Sherwood — enemies sometimes miss", "effect": "dodge", "value": 0.12, "cost": 0, "icon": "green_cloak"},
		{"name": "Silver Arrow", "desc": "Legendary arrow that pierces the toughest armor", "effect": "pierce_damage", "value": 0.20, "cost": 100, "icon": "silver_arrow"},
		{"name": "Sherwood Longbow", "desc": "Yew bow carved from the oldest oak in Sherwood", "effect": "range", "value": 0.15, "cost": 0, "icon": "longbow"},
		{"name": "Friar Tuck's Flask", "desc": "A sip of mead restores the weariest fighter", "effect": "heal_nearby", "value": 2.0, "cost": 250, "icon": "flask"},
		{"name": "Merry Men's Horn", "desc": "The call to arms rallies all who hear it", "effect": "atk_speed_aura", "value": 0.10, "cost": 0, "icon": "horn"},
		{"name": "Prince John's Crown", "desc": "Stolen from the tyrant — riches for the poor", "effect": "bonus_gold", "value": 0.25, "cost": 500, "icon": "gold_crown"},
	],
	TowerType.ALICE: [
		{"name": "Drink Me Potion", "desc": "One sip and everything changes size", "effect": "slow", "value": 0.15, "cost": 0, "icon": "drink_me"},
		{"name": "Eat Me Cake", "desc": "Grow larger than life itself", "effect": "aoe_radius", "value": 0.20, "cost": 100, "icon": "eat_me_cake"},
		{"name": "Vorpal Sword", "desc": "One, two! One, two! And through and through!", "effect": "crit_chance", "value": 0.10, "cost": 0, "icon": "vorpal_sword"},
		{"name": "Queen's Scepter", "desc": "Off with their heads!", "effect": "instant_kill", "value": 0.08, "cost": 250, "icon": "heart_scepter"},
		{"name": "White Rabbit's Watch", "desc": "I'm late! I'm late! No time to waste!", "effect": "cooldown", "value": 0.15, "cost": 0, "icon": "pocket_watch"},
		{"name": "Cheshire Grin", "desc": "We're all mad here", "effect": "confuse", "value": 0.12, "cost": 500, "icon": "cheshire_grin"},
	],
	TowerType.WICKED_WITCH: [
		{"name": "Ruby Slippers", "desc": "There's no place like home", "effect": "reposition", "value": 1.0, "cost": 0, "icon": "ruby_slippers"},
		{"name": "Crystal Ball", "desc": "I see everything, my pretty", "effect": "reveal_camo", "value": 1.0, "cost": 100, "icon": "crystal_ball"},
		{"name": "Winged Monkey Fez", "desc": "Fly! Fly! Bring them to me!", "effect": "extra_projectile", "value": 1.0, "cost": 0, "icon": "monkey_fez"},
		{"name": "Poppy Dust", "desc": "Poppies will put them to sleep", "effect": "aoe_sleep", "value": 0.10, "cost": 250, "icon": "poppy_dust"},
		{"name": "Golden Cap", "desc": "The enchanted cap commands dark magic", "effect": "spell_damage", "value": 0.18, "cost": 0, "icon": "golden_cap"},
		{"name": "Hourglass of Doom", "desc": "Your time is running out, my dear", "effect": "hp_drain", "value": 0.03, "cost": 500, "icon": "hourglass"},
	],
	TowerType.PETER_PAN: [
		{"name": "Fairy Dust Vial", "desc": "Think happy thoughts and you can fly", "effect": "atk_speed_aura", "value": 0.12, "cost": 0, "icon": "fairy_vial"},
		{"name": "Captain Hook's Hook", "desc": "The hook gleams with cruel promise", "effect": "bleed", "value": 0.02, "cost": 100, "icon": "iron_hook"},
		{"name": "Neverland Star Map", "desc": "Second star to the right, straight on til morning", "effect": "range", "value": 0.15, "cost": 0, "icon": "star_map"},
		{"name": "Crocodile's Tooth", "desc": "Tick-tock, tick-tock — the croc comes calling", "effect": "fear", "value": 0.08, "cost": 250, "icon": "croc_tooth"},
		{"name": "Wendy's Thimble", "desc": "A thimble kiss to mend your wounds", "effect": "heal_self", "value": 3.0, "cost": 0, "icon": "thimble"},
		{"name": "Shadow Thread", "desc": "His shadow has a mind of its own", "effect": "clone_attack", "value": 5.0, "cost": 500, "icon": "shadow_thread"},
	],
	TowerType.PHANTOM: [
		{"name": "Red Rose", "desc": "A token of dark devotion", "effect": "charm", "value": 0.10, "cost": 0, "icon": "red_rose"},
		{"name": "Punjab Lasso", "desc": "The noose tightens from the shadows", "effect": "snare", "value": 2.0, "cost": 100, "icon": "punjab_lasso"},
		{"name": "Opera Score", "desc": "The music of the night is devastating", "effect": "aoe_damage", "value": 0.15, "cost": 0, "icon": "opera_score"},
		{"name": "Chandelier Chain", "desc": "When the chandelier falls, all tremble", "effect": "stun", "value": 0.12, "cost": 250, "icon": "chandelier_chain"},
		{"name": "Lake Gondola Key", "desc": "The key to the lair beneath the opera", "effect": "boss_damage", "value": 0.30, "cost": 0, "icon": "gondola_key"},
		{"name": "Christine's Mirror", "desc": "The mirror reveals what lies behind the mask", "effect": "reflect", "value": 0.08, "cost": 500, "icon": "hand_mirror"},
	],
	TowerType.SCROOGE: [
		{"name": "Marley's Chains", "desc": "Forged in life, link by link, yard by yard", "effect": "slow_aura", "value": 0.20, "cost": 0, "icon": "heavy_chains"},
		{"name": "Ghost Lantern", "desc": "The spirits illuminate all hidden truths", "effect": "reveal_weaken", "value": 0.10, "cost": 100, "icon": "ghost_lantern"},
		{"name": "Counting House Key", "desc": "Every penny pinched is a penny earned", "effect": "gold_gen", "value": 0.15, "cost": 0, "icon": "brass_key"},
		{"name": "Christmas Pudding", "desc": "God bless us, every one!", "effect": "heal_nearby", "value": 2.0, "cost": 250, "icon": "xmas_pudding"},
		{"name": "Fezziwig's Fiddle", "desc": "The old fiddle sets every foot to dancing", "effect": "atk_speed_aura", "value": 0.10, "cost": 0, "icon": "fiddle"},
		{"name": "Redemption Bell", "desc": "The bell tolls for a changed heart", "effect": "wave_start_buff", "value": 0.08, "cost": 500, "icon": "church_bell"},
	],
	TowerType.SHERLOCK: [
		{"name": "Deerstalker Cap", "desc": "The iconic hat sharpens the mind", "effect": "crit_chance", "value": 0.12, "cost": 0, "icon": "deerstalker"},
		{"name": "Watson's Revolver", "desc": "The good doctor always packs heat", "effect": "extra_projectile", "value": 1.0, "cost": 100, "icon": "revolver"},
		{"name": "Violin of Thought", "desc": "Music aids the deductive process", "effect": "cooldown", "value": 0.15, "cost": 0, "icon": "violin"},
		{"name": "Cocaine Solution", "desc": "Seven percent solution heightens senses", "effect": "atk_speed_aura", "value": 0.12, "cost": 250, "icon": "vial"},
		{"name": "Reichenbach Stone", "desc": "A stone from the falls where he cheated death", "effect": "dodge", "value": 0.10, "cost": 0, "icon": "dark_stone"},
		{"name": "Moriarty's Cipher", "desc": "Know thy enemy as thyself", "effect": "boss_damage", "value": 0.25, "cost": 500, "icon": "cipher"},
	],
	TowerType.TARZAN: [
		{"name": "Mangani Fang", "desc": "A great ape's tooth, symbol of strength", "effect": "pierce_damage", "value": 0.20, "cost": 0, "icon": "ape_tooth"},
		{"name": "Jungle Crown", "desc": "Vines woven into the mark of the king", "effect": "aoe_radius", "value": 0.18, "cost": 100, "icon": "vine_crown"},
		{"name": "Father's Knife", "desc": "The blade that saved his life as a babe", "effect": "bleed", "value": 0.03, "cost": 0, "icon": "hunting_knife"},
		{"name": "Elephant Tusk", "desc": "Tantor's gift — unstoppable force", "effect": "stun", "value": 0.10, "cost": 250, "icon": "ivory_tusk"},
		{"name": "Jane's Locket", "desc": "Love tames the wildest heart", "effect": "heal_self", "value": 3.0, "cost": 0, "icon": "gold_locket"},
		{"name": "Kerchak's Roar", "desc": "The alpha's challenge echoes through the jungle", "effect": "fear", "value": 0.10, "cost": 500, "icon": "ape_mask"},
	],
	TowerType.DRACULA: [
		{"name": "Transylvanian Earth", "desc": "Soil from his homeland sustains him", "effect": "heal_self", "value": 4.0, "cost": 0, "icon": "dark_soil"},
		{"name": "Crucifix Shard", "desc": "Turned against its purpose — burns foes", "effect": "spell_damage", "value": 0.18, "cost": 100, "icon": "broken_cross"},
		{"name": "Wolf Pelt Cape", "desc": "The wolves answer to the count", "effect": "slow_aura", "value": 0.15, "cost": 0, "icon": "wolf_pelt"},
		{"name": "Mirror of Absence", "desc": "No reflection, no weakness", "effect": "dodge", "value": 0.12, "cost": 250, "icon": "dark_mirror"},
		{"name": "Renfield's Offering", "desc": "The faithful servant's gift of life force", "effect": "hp_drain", "value": 0.04, "cost": 0, "icon": "blood_vial"},
		{"name": "Brides' Chalice", "desc": "Three brides, three powers, one vessel", "effect": "charm", "value": 0.15, "cost": 500, "icon": "ornate_chalice"},
	],
	TowerType.MERLIN: [
		{"name": "Crystal Ball", "desc": "Foresee the enemy's every move", "effect": "reveal_camo", "value": 1.0, "cost": 0, "icon": "crystal_orb"},
		{"name": "Excalibur Shard", "desc": "A fragment of the legendary blade", "effect": "pierce_damage", "value": 0.22, "cost": 100, "icon": "sword_shard"},
		{"name": "Druidic Circlet", "desc": "Ancient power flows through the stones", "effect": "aoe_damage", "value": 0.15, "cost": 0, "icon": "stone_circlet"},
		{"name": "Holy Grail Replica", "desc": "A reflection of the cup that heals all wounds", "effect": "heal_nearby", "value": 3.0, "cost": 250, "icon": "golden_cup"},
		{"name": "Nimue's Tear", "desc": "The Lady of the Lake's sorrow made manifest", "effect": "slow", "value": 0.20, "cost": 0, "icon": "blue_tear"},
		{"name": "Stonehenge Fragment", "desc": "Cosmic power channeled through ancient rock", "effect": "wave_start_buff", "value": 0.12, "cost": 500, "icon": "stone_frag"},
	],
	TowerType.FRANKENSTEIN: [
		{"name": "Galvanic Cell", "desc": "Raw electrical power courses through", "effect": "aoe_damage", "value": 0.20, "cost": 0, "icon": "battery"},
		{"name": "Stitched Heart", "desc": "Beating despite all odds", "effect": "heal_self", "value": 5.0, "cost": 100, "icon": "sewn_heart"},
		{"name": "Victor's Journal", "desc": "The secrets of reanimation", "effect": "atk_speed_aura", "value": 0.10, "cost": 0, "icon": "old_journal"},
		{"name": "Arctic Ice Shard", "desc": "From the frozen wastes where the tale ended", "effect": "slow", "value": 0.18, "cost": 250, "icon": "ice_crystal"},
		{"name": "Blind Man's Fiddle", "desc": "The only kindness ever shown to the creature", "effect": "charm", "value": 0.10, "cost": 0, "icon": "old_fiddle"},
		{"name": "Promethean Spark", "desc": "The fire of creation itself", "effect": "boss_damage", "value": 0.30, "cost": 500, "icon": "lightning_spark"},
	],
}
# Track which relic slot is hovered/selected for tooltip
var relic_hover_index: int = -1
var relic_tooltip_visible: bool = false

# Emporium (in-game store)
var emporium_categories = [
	{"name": "Gold Exchange", "desc": "Spend gold from chests on other currencies", "icon": "emp_gold", "badge": ""},
	{"name": "Enchanted Quills", "desc": "Trade Quills for rare treasures", "icon": "emp_quills", "badge": ""},
	{"name": "Relic Shards", "desc": "Collect Shards to forge powerful Relics", "icon": "emp_shards", "badge": ""},
	{"name": "Relic Chests", "desc": "Chests contain powerful Relics!", "icon": "emp_chests", "badge": "AVAILABLE!"},
	{"name": "Survivor Packs", "desc": "Bundles of literary might", "icon": "emp_packs", "badge": "SALE!"},
	{"name": "Storybook Stars", "desc": "Empower and level up your Survivors", "icon": "emp_stars", "badge": ""},
	{"name": "Trophy Store", "desc": "Spend Trophies on cosmetic upgrades", "icon": "emp_trophy", "badge": "NEW!"},
	{"name": "Battle Powers", "desc": "Stock up on consumable battle abilities", "icon": "emp_powers", "badge": ""},
	{"name": "Tome Bindings", "desc": "Relics to empower your towers", "icon": "emp_bindings", "badge": "NEW!"},
	{"name": "Salvage Workshop", "desc": "Dismantle items into Relic Shards", "icon": "emp_salvage", "badge": ""},
	{"name": "Chest Forge", "desc": "Craft Golden Treasure Chests", "icon": "emp_forge", "badge": "NEW!"},
	{"name": "Instruments", "desc": "Literary aura items for battle", "icon": "emp_instruments", "badge": "NEW!"},
]
var emporium_hover_index: int = -1

# Menu color palette — deep navy-purple + gold (matches defenseplanet.org)
var menu_bg_dark = Color(0.04, 0.04, 0.10)        # #0a0a1a deep navy
var menu_bg_section = Color(0.055, 0.055, 0.14)    # #0e0e24
var menu_bg_card = Color(0.08, 0.08, 0.20)         # #141432
var menu_bg_card_hover = Color(0.10, 0.10, 0.25)   # #1a1a40
var menu_gold = Color(0.79, 0.66, 0.30)            # #c9a84c (unchanged)
var menu_gold_light = Color(0.91, 0.83, 0.55)      # #e8d48b (unchanged)
var menu_gold_dim = Color(0.54, 0.45, 0.20)        # #8a7433 (unchanged)
var menu_parchment = Color(0.94, 0.90, 0.83)       # #f0e6d3 warm white
var menu_text = Color(0.77, 0.73, 0.66)            # #c4baa8
var menu_text_muted = Color(0.54, 0.51, 0.47)      # #8a8278
var menu_accent_purple = Color(0.16, 0.04, 0.23)   # #2a0a3a deep purple accent
var menu_accent_glow = Color(0.30, 0.10, 0.50, 0.3) # soft purple glow

# Storybook menu - animation (particles, lanterns, decorations)
var _dust_positions: Array = []
var _book_candle_positions: Array = []
var _floating_pages: Array = []
var _menu_ink_splatters: Array = []
var _quill_positions: Array = []
var _bookshelf_heights: Array = []

# World map data
var world_map_hover_index: int = -1
var world_map_zone_centers: Array = [
	Vector2(200, 310), Vector2(500, 260), Vector2(1060, 300),
	Vector2(200, 490), Vector2(640, 460), Vector2(1060, 490)
]
var _world_map_stars: Array = []
var _world_map_clouds: Array = []
var _world_map_smoke: Array = []

var character_names: Array = ["Robin Hood", "Alice", "Wicked Witch", "Peter Pan", "The Phantom", "Scrooge", "Sherlock Holmes", "Tarzan", "Count Dracula", "Merlin", "Frankenstein's Monster"]
var character_novels: Array = ["The Merry Adventures of Robin Hood", "Alice's Adventures in Wonderland", "The Wonderful Wizard of Oz", "Peter and Wendy", "The Phantom of the Opera", "A Christmas Carol", "The Adventures of Sherlock Holmes", "Tarzan of the Apes", "Dracula", "Le Morte d'Arthur", "Frankenstein"]
var character_quotes: Array = [
	"Steal from the rich, defend the path!",
	"Curiouser and curiouser!",
	"I'll get you, my pretties!",
	"To live will be an awfully big adventure!",
	"The Music of the Night!",
	"Bah! Humbug!",
	"The game is afoot!",
	"The jungle provides!",
	"I never drink... wine.",
	"Knowledge is the greatest power!",
	"I am not what you think I am!",
]

# =====================================================================================
# === FEATURE SYSTEMS (10 BATTD-inspired) ===============================================
# =====================================================================================

# --- Feature 1: Enemy Modifiers (Shadow-Infested, Regrown, Fortified, Shielded, Cursed, Phantom) ---
# Extended modifiers handled in _apply_enemy_modifiers and enemy.gd

# --- Feature 2: MOAB Villain Super-Enemies ---
# Maps enemy_theme to the MOAB villain name (the big boss of that world)
const MOAB_VILLAIN_NAMES: Dictionary = {
	0: "Sheriff's Wrath", 1: "Queen's Fury", 2: "Witch's Tempest",
	3: "Hook's Armada", 4: "Phantom's Crescendo", 5: "Marley's Chains",
	6: "Shadow Colossus", 7: "Moriarty's Machine", 8: "Fay's Corruption",
	9: "Clayton's Juggernaut", 10: "Dracula's Dominion", 11: "Creature's Rage",
	12: "Author's Apocalypse"
}
const MOAB_TIER_NAMES: Array = ["Overlord", "Tyrant", "Sovereign"]
const MOAB_TIER_SCALES: Array = [3.0, 4.5, 6.0]
const MOAB_TIER_HP_MULT: Array = [8.0, 20.0, 50.0]
const MOAB_TIER_CHILDREN: Array = [4, 4, 3]  # Children spawned on death

# --- Feature 3: Item Dismantling / Sharding ---
var salvage_rates: Dictionary = {"common": 5, "uncommon": 15, "rare": 40}
# Salvage currency is player_relic_shards (already exists)

# --- Feature 4: Golden Treasure Chest Crafting ---
var golden_chest_craft_costs: Array = [
	{"name": "Bronze Treasure Chest", "shard_cost": 30, "tier": 0},
	{"name": "Silver Treasure Chest", "shard_cost": 75, "tier": 1},
	{"name": "Golden Treasure Chest", "shard_cost": 150, "tier": 2},
]

# --- Feature 5: Rotating Daily Deals Shop ---
var daily_deals: Array = []  # 3 items, regenerated each day
var daily_deals_date: String = ""  # Date string of last generation
var daily_deals_purchased: Array = [false, false, false]

# --- Feature 6: Shadow Arena (Competitive Leaderboard Mode) ---
var shadow_arena_active: bool = false
var shadow_arena_wave: int = 0
var shadow_arena_modifiers: Array = []  # e.g. ["no_powers", "regrow_only", "shadow_infested"]
var shadow_arena_high_score: int = 0
var shadow_arena_weekly_seed: int = 0
var arena_crystals: int = 0  # Exclusive currency from Shadow Arena
var arena_leaderboard: Array = []  # [{name, score}] - simulated leaderboard

# --- Feature 7: Branching Upgrade Paths ---
# Each tower now has 2 upgrade branches (A and B), each with 2 tiers
# Branch selection stored per tower instance; data defined in tower scripts
var tower_branch_choice: Dictionary = {}  # tower_instance_id -> "A" or "B"
var _branch_hover: String = ""  # "A" or "B" when hovering branch choice
var _branch_tier_hover: int = -1  # Tier index when hovering branch upgrade
var _gs_upgrade_btn_rect: Rect2 = Rect2()  # Stored golden shield upgrade button position
var _placing_instrument: String = ""  # Instrument ID being placed (empty = not placing)
var _instrument_picker_open: bool = false
var _instrument_picker_hover: int = -1

# --- Feature 8: Golden Shields (Expandable Gear Slots) ---
# Golden Shields = star-level system that expands gear/sidekick/binding slots
const MAX_GOLDEN_SHIELD: int = 10
const GOLDEN_SHIELD_COSTS: Array = [100, 200, 350, 550, 800, 1100, 1500, 2000, 2800, 4000]  # XP cost per shield level
# Slot unlocks per golden shield level: [base=1 gear, 1 sidekick, 2 bindings]
# Each shield level: +1 binding slot (up to 12), +1 sidekick at shield 3/6/9, +1 gear at shield 5/10
func _get_golden_shield_level(tower_type) -> int:
	return survivor_progress.get(tower_type, {}).get("golden_shields", 0)

func _get_binding_slot_count(tower_type) -> int:
	var shields = _get_golden_shield_level(tower_type)
	return 2 + shields  # Base 2, up to 12 at shield 10

func _get_sidekick_slot_count(tower_type) -> int:
	var shields = _get_golden_shield_level(tower_type)
	var slots = 1  # Base 1
	if shields >= 3: slots += 1
	if shields >= 6: slots += 1
	if shields >= 9: slots += 1
	return slots  # Max 4

func _get_gear_slot_count(tower_type) -> int:
	var shields = _get_golden_shield_level(tower_type)
	var slots = 1  # Base 1
	if shields >= 5: slots += 1
	if shields >= 10: slots += 1
	return slots  # Max 3

# --- Feature 9: Quest / Mission System ---
var active_quests: Array = []  # [{id, desc, type, target, progress, reward_type, reward_amount, expires}]
var quest_last_refresh: String = ""
var total_quests_completed: int = 0
const QUEST_TEMPLATES: Array = [
	{"desc": "Kill %d enemies", "type": "kill", "targets": [50, 100, 200], "reward_type": "shards", "amounts": [10, 20, 35]},
	{"desc": "Kill %d shadow-infested enemies", "type": "kill_shadow", "targets": [5, 10, 20], "reward_type": "quills", "amounts": [3, 5, 10]},
	{"desc": "Complete %d level(s)", "type": "complete_levels", "targets": [1, 2, 3], "reward_type": "shards", "amounts": [15, 25, 40]},
	{"desc": "Earn %d gold in a single game", "type": "earn_gold", "targets": [200, 500, 1000], "reward_type": "quills", "amounts": [2, 5, 8]},
	{"desc": "Place %d towers", "type": "place_towers", "targets": [10, 20, 30], "reward_type": "shards", "amounts": [8, 15, 25]},
	{"desc": "Earn %d stars", "type": "earn_stars", "targets": [3, 6, 9], "reward_type": "stars", "amounts": [1, 1, 2]},
	{"desc": "Use %d battle power(s)", "type": "use_powers", "targets": [1, 3, 5], "reward_type": "shards", "amounts": [10, 20, 30]},
	{"desc": "Upgrade %d tower(s) to max tier", "type": "max_upgrades", "targets": [1, 2, 3], "reward_type": "quills", "amounts": [5, 8, 12]},
]

# --- Feature 10: Literary Instruments (Aura Support Gear) ---
# Instruments are special gear items that buff all towers in radius instead of attacking
var literary_instruments: Array = [
	{"id": "harpsichord_of_harmony", "name": "Harpsichord of Harmony", "desc": "All towers in range attack 15% faster", "effect": "attack_speed", "value": 0.15, "radius": 150.0, "cost": 120},
	{"id": "drums_of_war", "name": "Drums of War", "desc": "All towers in range deal 20% more damage", "effect": "damage", "value": 0.20, "radius": 130.0, "cost": 150},
	{"id": "lyre_of_legends", "name": "Lyre of Legends", "desc": "All towers in range gain 25% more range", "effect": "range", "value": 0.25, "radius": 140.0, "cost": 135},
	{"id": "flute_of_frost", "name": "Flute of Frost", "desc": "Enemies in range are slowed by 20%", "effect": "enemy_slow", "value": 0.20, "radius": 120.0, "cost": 100},
	{"id": "organ_of_shadows", "name": "Organ of Shadows", "desc": "All towers in range gain 10% crit chance", "effect": "crit", "value": 0.10, "radius": 160.0, "cost": 175},
	{"id": "violin_of_valor", "name": "Violin of Valor", "desc": "Towers in range earn 30% more gold on kill", "effect": "gold_bonus", "value": 0.30, "radius": 135.0, "cost": 110},
]
var owned_instruments: Dictionary = {}  # instrument_id -> count
var placed_instruments: Array = []  # [{id, position, radius, effect, value}] — active in-game

var levels = [
	# === PROLOGUE — Into the Pages (Level 0) ===
	{
		"name": "Into the Pages", "subtitle": "Prologue",
		"description": "The Tome of Shadows opens and pulls our heroes into a world of ink and forgotten stories. Survive the first wave of shadow entities!",
		"character": -1, "chapter": 0, "enemy_theme": 6,
		"waves": 10, "gold": 120, "lives": 30, "difficulty": 0.8,
		"sky_color": Color(0.04, 0.02, 0.08),
		"ground_color": Color(0.03, 0.03, 0.05),
	},
	# === SHERLOCK HOLMES — Baker Street Investigation (Levels 1-3) ===
	{
		"name": "Baker Street Investigation", "subtitle": "Sherlock Holmes — Chapter 1",
		"description": "The fog-choked streets of Victorian London hide criminals in every alley. Sherlock awaits rescue at 221B Baker Street.",
		"character": -1, "chapter": 0, "enemy_theme": 7,
		"waves": 15, "gold": 110, "lives": 25, "difficulty": 1.0,
		"sky_color": Color(0.06, 0.06, 0.08),
		"ground_color": Color(0.12, 0.10, 0.08),
	},
	{
		"name": "The Whitechapel Pursuit", "subtitle": "Sherlock Holmes — Chapter 2",
		"description": "Through the dangerous back alleys of Whitechapel, Moriarty's agents close in. The game is afoot!",
		"character": -1, "chapter": 1, "enemy_theme": 7,
		"waves": 20, "gold": 110, "lives": 22, "difficulty": 1.15,
		"sky_color": Color(0.05, 0.05, 0.07),
		"ground_color": Color(0.10, 0.08, 0.06),
	},
	{
		"name": "Reichenbach Falls", "subtitle": "Sherlock Holmes — Chapter 3",
		"description": "The final confrontation at the thundering falls. Moriarty's full criminal network descends. Free Sherlock Holmes!",
		"character": -1, "chapter": 2, "enemy_theme": 7,
		"waves": 25, "gold": 110, "lives": 20, "difficulty": 1.3,
		"sky_color": Color(0.04, 0.04, 0.06),
		"ground_color": Color(0.08, 0.08, 0.10),
	},
	# === MERLIN — The Round Table (Levels 4-6) ===
	{
		"name": "The Round Table", "subtitle": "Merlin — Chapter 1",
		"description": "Camelot lies in shadow. Dark sorcery has corrupted the knights. Merlin is trapped within a crystal cave.",
		"character": -1, "chapter": 0, "enemy_theme": 8,
		"waves": 15, "gold": 110, "lives": 25, "difficulty": 1.05,
		"sky_color": Color(0.02, 0.08, 0.04),
		"ground_color": Color(0.10, 0.08, 0.04),
	},
	{
		"name": "The Enchanted Forest", "subtitle": "Merlin — Chapter 2",
		"description": "Ancient standing stones pulse with dark magic. Cursed knights patrol the enchanted woodland paths.",
		"character": -1, "chapter": 1, "enemy_theme": 8,
		"waves": 20, "gold": 110, "lives": 22, "difficulty": 1.2,
		"sky_color": Color(0.02, 0.06, 0.03),
		"ground_color": Color(0.08, 0.06, 0.03),
	},
	{
		"name": "The Crystal Cave", "subtitle": "Merlin — Chapter 3",
		"description": "Deep within the crystal cave, Morgan le Fay guards Merlin's prison. Shatter the enchantment and free the wizard!",
		"character": -1, "chapter": 2, "enemy_theme": 8,
		"waves": 25, "gold": 110, "lives": 20, "difficulty": 1.35,
		"sky_color": Color(0.03, 0.04, 0.06),
		"ground_color": Color(0.06, 0.06, 0.08),
	},
	# === TARZAN — The Jungle Canopy (Levels 7-9) ===
	{
		"name": "The Jungle Canopy", "subtitle": "Tarzan — Chapter 1",
		"description": "Poachers invade the shadow jungle. Tarzan, king of the apes, fights alone against the intruders.",
		"character": -1, "chapter": 0, "enemy_theme": 9,
		"waves": 15, "gold": 110, "lives": 25, "difficulty": 1.1,
		"sky_color": Color(0.04, 0.10, 0.14),
		"ground_color": Color(0.04, 0.14, 0.02),
	},
	{
		"name": "The Elephant Graveyard", "subtitle": "Tarzan — Chapter 2",
		"description": "Big game hunters track through the elephant graveyard, seeking Tarzan's ape family. The bones rattle with warning.",
		"character": -1, "chapter": 1, "enemy_theme": 9,
		"waves": 20, "gold": 110, "lives": 22, "difficulty": 1.25,
		"sky_color": Color(0.06, 0.08, 0.10),
		"ground_color": Color(0.06, 0.10, 0.02),
	},
	{
		"name": "Clayton's Fortress", "subtitle": "Tarzan — Chapter 3",
		"description": "Clayton's mercenary fortress blocks the jungle path. Storm the compound and free Tarzan from his cage!",
		"character": -1, "chapter": 2, "enemy_theme": 9,
		"waves": 25, "gold": 110, "lives": 20, "difficulty": 1.4,
		"sky_color": Color(0.05, 0.07, 0.08),
		"ground_color": Color(0.05, 0.08, 0.03),
	},
	# === DRACULA — The Transylvanian Village (Levels 10-12) ===
	{
		"name": "The Transylvanian Village", "subtitle": "Dracula — Chapter 1",
		"description": "A cursed village at the foot of the Carpathian Mountains. The undead walk the streets at night.",
		"character": -1, "chapter": 0, "enemy_theme": 10,
		"waves": 18, "gold": 110, "lives": 24, "difficulty": 1.15,
		"sky_color": Color(0.06, 0.02, 0.04),
		"ground_color": Color(0.06, 0.04, 0.04),
	},
	{
		"name": "Castle Dracula", "subtitle": "Dracula — Chapter 2",
		"description": "The castle looms above, its corridors filled with vampire brides and dire wolves. The Count watches from his tower.",
		"character": -1, "chapter": 1, "enemy_theme": 10,
		"waves": 22, "gold": 110, "lives": 20, "difficulty": 1.3,
		"sky_color": Color(0.04, 0.02, 0.03),
		"ground_color": Color(0.05, 0.03, 0.04),
	},
	{
		"name": "The Crypt of Blood", "subtitle": "Dracula — Chapter 3",
		"description": "In the deepest crypt, Dracula lies chained by shadow ink. Defeat his captors and the Count joins your cause!",
		"character": -1, "chapter": 2, "enemy_theme": 10,
		"waves": 28, "gold": 110, "lives": 18, "difficulty": 1.5,
		"sky_color": Color(0.03, 0.01, 0.02),
		"ground_color": Color(0.04, 0.02, 0.03),
	},
	# === FRANKENSTEIN — The Laboratory (Levels 13-15) ===
	{
		"name": "The Laboratory", "subtitle": "Frankenstein — Chapter 1",
		"description": "Victor Frankenstein's abandoned laboratory crackles with dark energy. Failed experiments roam the halls.",
		"character": -1, "chapter": 0, "enemy_theme": 11,
		"waves": 18, "gold": 110, "lives": 24, "difficulty": 1.2,
		"sky_color": Color(0.04, 0.04, 0.06),
		"ground_color": Color(0.08, 0.08, 0.08),
	},
	{
		"name": "The Angry Village", "subtitle": "Frankenstein — Chapter 2",
		"description": "Villagers with torches and pitchforks march against the Monster. But here, the villagers are the real monsters.",
		"character": -1, "chapter": 1, "enemy_theme": 11,
		"waves": 22, "gold": 110, "lives": 20, "difficulty": 1.35,
		"sky_color": Color(0.05, 0.04, 0.05),
		"ground_color": Color(0.07, 0.06, 0.06),
	},
	{
		"name": "The Arctic Wastes", "subtitle": "Frankenstein — Chapter 3",
		"description": "The frozen north, where the tale ends. Igor guards the Monster's prison of ice. Shatter his chains!",
		"character": -1, "chapter": 2, "enemy_theme": 11,
		"waves": 28, "gold": 110, "lives": 18, "difficulty": 1.55,
		"sky_color": Color(0.06, 0.06, 0.08),
		"ground_color": Color(0.10, 0.10, 0.12),
	},
	# === ROBIN HOOD — The Merry Adventures of Robin Hood (Levels 16-18) ===
	{
		"name": "The Outlaw's Call", "subtitle": "Sherwood Forest — Chapter 1",
		"description": "Robin becomes an outlaw and builds his camp in Sherwood Forest. Defend the hideout from the Sheriff's tax collectors!",
		"character": 0, "chapter": 0, "enemy_theme": 0,
		"waves": 12, "gold": 100, "lives": 25, "difficulty": 1.0,
		"sky_color": Color(0.02, 0.06, 0.10),
		"ground_color": Color(0.06, 0.16, 0.04),
	},
	{
		"name": "The Sheriff's Pursuit", "subtitle": "Sherwood Forest — Chapter 2",
		"description": "The Sheriff of Nottingham sends his soldiers to hunt Robin. Defend Little John's Bridge and the river crossing!",
		"character": 0, "chapter": 1, "enemy_theme": 0,
		"waves": 15, "gold": 100, "lives": 22, "difficulty": 1.15,
		"sky_color": Color(0.02, 0.04, 0.08),
		"ground_color": Color(0.05, 0.14, 0.03),
	},
	{
		"name": "Siege of Nottingham", "subtitle": "Sherwood Forest — Chapter 3",
		"description": "Robin leads the attack on Nottingham Castle to free his captured men. Defeat the Sheriff at the castle gates!",
		"character": 0, "chapter": 2, "enemy_theme": 0,
		"waves": 18, "gold": 100, "lives": 20, "difficulty": 1.3,
		"sky_color": Color(0.06, 0.04, 0.02),
		"ground_color": Color(0.08, 0.08, 0.06),
	},
	# === ALICE — Alice's Adventures in Wonderland (Levels 19-21) ===
	{
		"name": "Down the Rabbit Hole", "subtitle": "Wonderland — Chapter 1",
		"description": "Alice follows the White Rabbit into a curious garden of giant mushrooms, talking flowers, and nonsense.",
		"character": 1, "chapter": 0, "enemy_theme": 1,
		"waves": 14, "gold": 100, "lives": 25, "difficulty": 1.0,
		"sky_color": Color(0.12, 0.04, 0.16),
		"ground_color": Color(0.08, 0.18, 0.06),
	},
	{
		"name": "The Mad Tea Party", "subtitle": "Wonderland — Chapter 2",
		"description": "Deeper into Wonderland — the Mad Hatter's tea party and the Queen of Hearts' card army advances, painting the roses red.",
		"character": 1, "chapter": 1, "enemy_theme": 1,
		"waves": 17, "gold": 100, "lives": 22, "difficulty": 1.2,
		"sky_color": Color(0.10, 0.03, 0.14),
		"ground_color": Color(0.06, 0.14, 0.05),
	},
	{
		"name": "The Queen's Court", "subtitle": "Wonderland — Chapter 3",
		"description": "Alice reaches the Queen's palace. The rose garden runs red. Off with their heads!",
		"character": 1, "chapter": 2, "enemy_theme": 1,
		"waves": 20, "gold": 100, "lives": 18, "difficulty": 1.4,
		"sky_color": Color(0.14, 0.02, 0.08),
		"ground_color": Color(0.10, 0.06, 0.06),
	},
	# === WICKED WITCH — The Wonderful Wizard of Oz (Levels 22-24) ===
	{
		"name": "The Yellow Brick Road", "subtitle": "Land of Oz — Chapter 1",
		"description": "Dorothy and companions follow the golden road through poppy fields toward the Emerald City.",
		"character": 2, "chapter": 0, "enemy_theme": 2,
		"waves": 14, "gold": 100, "lives": 25, "difficulty": 1.05,
		"sky_color": Color(0.02, 0.10, 0.06),
		"ground_color": Color(0.14, 0.12, 0.02),
	},
	{
		"name": "The Witch's Domain", "subtitle": "Land of Oz — Chapter 2",
		"description": "The Wicked Witch of the West sends her flying monkeys. Dark western territory and dead forests loom ahead.",
		"character": 2, "chapter": 1, "enemy_theme": 2,
		"waves": 17, "gold": 100, "lives": 22, "difficulty": 1.3,
		"sky_color": Color(0.04, 0.06, 0.02),
		"ground_color": Color(0.10, 0.08, 0.04),
	},
	{
		"name": "The Emerald Throne", "subtitle": "Land of Oz — Chapter 3",
		"description": "Inside the Emerald City, the Nome King rises to seize power. Green crystal walls crack as rock soldiers march.",
		"character": 2, "chapter": 2, "enemy_theme": 2,
		"waves": 20, "gold": 100, "lives": 18, "difficulty": 1.5,
		"sky_color": Color(0.02, 0.08, 0.04),
		"ground_color": Color(0.06, 0.12, 0.06),
	},
	# === PETER PAN — Peter and Wendy (Levels 25-27) ===
	{
		"name": "Flight to Neverland", "subtitle": "Neverland — Chapter 1",
		"description": "Second star to the right and straight on till morning. Mermaid lagoon sparkles and pirate scouts appear.",
		"character": 3, "chapter": 0, "enemy_theme": 3,
		"waves": 16, "gold": 100, "lives": 25, "difficulty": 1.1,
		"sky_color": Color(0.04, 0.06, 0.14),
		"ground_color": Color(0.08, 0.18, 0.06),
	},
	{
		"name": "The Lost Boys' Stand", "subtitle": "Neverland — Chapter 2",
		"description": "Captain Hook's pirate officers lead raiding parties through the dense jungle to attack the Lost Boys' hideout.",
		"character": 3, "chapter": 1, "enemy_theme": 3,
		"waves": 19, "gold": 100, "lives": 20, "difficulty": 1.4,
		"sky_color": Color(0.03, 0.05, 0.10),
		"ground_color": Color(0.06, 0.15, 0.04),
	},
	{
		"name": "The Jolly Roger", "subtitle": "Neverland — Chapter 3",
		"description": "The final battle aboard Captain Hook's ship. Sword fights on deck, walking the plank over the ticking crocodile!",
		"character": 3, "chapter": 2, "enemy_theme": 3,
		"waves": 22, "gold": 100, "lives": 18, "difficulty": 1.6,
		"sky_color": Color(0.08, 0.04, 0.02),
		"ground_color": Color(0.12, 0.08, 0.06),
	},
	# === PHANTOM — The Phantom of the Opera (Levels 28-30) ===
	{
		"name": "The Grand Stage", "subtitle": "Paris Opera — Chapter 1",
		"description": "The Paris Opera House, elegant and grand. Strange things happen during performances — a ghost in the wings.",
		"character": 4, "chapter": 0, "enemy_theme": 4,
		"waves": 18, "gold": 100, "lives": 22, "difficulty": 1.2,
		"sky_color": Color(0.04, 0.02, 0.08),
		"ground_color": Color(0.10, 0.08, 0.10),
	},
	{
		"name": "The Labyrinth", "subtitle": "Paris Opera — Chapter 2",
		"description": "Descending beneath the opera into mirrors, candlelit tunnels, and traps. The Phantom reveals himself.",
		"character": 4, "chapter": 1, "enemy_theme": 4,
		"waves": 21, "gold": 100, "lives": 20, "difficulty": 1.5,
		"sky_color": Color(0.03, 0.02, 0.06),
		"ground_color": Color(0.08, 0.06, 0.08),
	},
	{
		"name": "The Phantom's Lair", "subtitle": "Paris Opera — Chapter 3",
		"description": "The underground lake, the great organ, roses on black water. Defeat the Dark Phantom in his domain!",
		"character": 4, "chapter": 2, "enemy_theme": 4,
		"waves": 24, "gold": 100, "lives": 16, "difficulty": 1.7,
		"sky_color": Color(0.02, 0.01, 0.04),
		"ground_color": Color(0.06, 0.04, 0.06),
	},
	# === SCROOGE — A Christmas Carol (Levels 31-33) ===
	{
		"name": "Christmas Eve", "subtitle": "Victorian London — Chapter 1",
		"description": "Victorian London on a cold Christmas Eve. Scrooge at his counting house, ignoring the carolers. Marley's ghost appears.",
		"character": 5, "chapter": 0, "enemy_theme": 5,
		"waves": 20, "gold": 100, "lives": 22, "difficulty": 1.3,
		"sky_color": Color(0.08, 0.08, 0.12),
		"ground_color": Color(0.10, 0.10, 0.12),
	},
	{
		"name": "The Three Spirits", "subtitle": "Victorian London — Chapter 2",
		"description": "The Ghosts of Christmas Past, Present, and Future visit Scrooge. Spectral London, gravestones, chains rattling.",
		"character": 5, "chapter": 1, "enemy_theme": 5,
		"waves": 23, "gold": 100, "lives": 18, "difficulty": 1.6,
		"sky_color": Color(0.06, 0.06, 0.10),
		"ground_color": Color(0.08, 0.08, 0.10),
	},
	{
		"name": "Redemption's Dawn", "subtitle": "Victorian London — Chapter 3",
		"description": "Christmas morning. The Ghost of Christmas Yet to Come leads an army of despair. Warm light fights to break through.",
		"character": 5, "chapter": 2, "enemy_theme": 5,
		"waves": 25, "gold": 100, "lives": 15, "difficulty": 1.8,
		"sky_color": Color(0.10, 0.08, 0.06),
		"ground_color": Color(0.12, 0.10, 0.10),
	},
	# === SHADOW AUTHOR — The Final Chapter (Levels 34-36) ===
	{
		"name": "The Ink Realm", "subtitle": "Shadow Author — Chapter 1",
		"description": "The Shadow Author's domain unfolds — a realm of pure ink and unwritten nightmares. All heroes unite for the final battle.",
		"character": -1, "chapter": 0, "enemy_theme": 12,
		"waves": 30, "gold": 120, "lives": 25, "difficulty": 1.8,
		"sky_color": Color(0.02, 0.01, 0.03),
		"ground_color": Color(0.02, 0.02, 0.04),
	},
	{
		"name": "The Unwritten Pages", "subtitle": "Shadow Author — Chapter 2",
		"description": "Blank pages stretch to infinity. The Author rewrites reality itself, sending corrupted versions of literary heroes against you.",
		"character": -1, "chapter": 1, "enemy_theme": 12,
		"waves": 35, "gold": 120, "lives": 22, "difficulty": 1.9,
		"sky_color": Color(0.01, 0.01, 0.02),
		"ground_color": Color(0.02, 0.01, 0.03),
	},
	{
		"name": "The Final Chapter", "subtitle": "Shadow Author — Chapter 3",
		"description": "The last page. The Shadow Author rises from the ink, quill in hand, to write THE END for every story ever told. Stop him!",
		"character": -1, "chapter": 2, "enemy_theme": 12,
		"waves": 40, "gold": 130, "lives": 20, "difficulty": 2.0,
		"sky_color": Color(0.01, 0.00, 0.01),
		"ground_color": Color(0.01, 0.01, 0.02),
	},
]

# Difficulty selection (0=Easy, 1=Medium, 2=Hard)
var selected_difficulty: int = 0
var difficulty_waves: Array = [20, 30, 40]
var difficulty_gold_bonus: Array = [8, 0, -10]
var difficulty_lives_bonus: Array = [5, 0, -5]  # Legacy — overridden by fixed lives below
var difficulty_fixed_lives: Array = [100, 50, 20]  # Easy=100, Medium=50, Hard=20
var chapter_diff_buttons: Array = []  # Array of 3 arrays, each with 3 buttons

# Player inventory (persistent across sessions)
var player_quills: int = 0
var player_relic_shards: int = 0
var player_storybook_stars: int = 0
var player_gold: int = 0

# Treasure chest state
var chest_loot: Array = []  # Array of {"type": String, "amount": int, "name": String}
var chest_open: bool = false
var chest_timer: float = 0.0

# Relics tab hover state
var relics_tab_hover_tier: int = -1
var relics_tab_hover_row: int = -1
var relics_tab_hover_col: int = -1

# Wave management
var enemies_to_spawn: int = 0
var enemies_alive: int = 0
var spawn_timer: float = 0.0
var spawn_interval: float = 0.75

# Fast-forward
var fast_forward: bool = false
var _game_speed_level: float = 1.0
var speed_button: Button
var wave_auto_timer: float = -1.0
var auto_wave_enabled: bool = true
var auto_wave_delay: float = 2.0  # seconds before auto-starting next wave

# Pause & restart
var game_paused: bool = false
var restart_button: Button
var auto_wave_btn: Button
var wave_start_gold: int = 0
var wave_start_lives: int = 0

# Audio mute toggles
var sfx_muted: bool = false
var voices_muted: bool = false
var sfx_mute_button: Button
var voice_mute_button: Button

# Free placement tracking
var placed_tower_positions: Array = []
var path_points: PackedVector2Array = PackedVector2Array()
var _path_thumbnail_cache: Dictionary = {}

# Level decoration data (regenerated per level)
var _decorations: Array = []
var _time: float = 0.0

# Musical beat clock — towers read this to select harmonious notes
var music_beat_index: int = 0
var _music_beat_accum: float = 0.0
const MUSIC_BPM: float = 140.0
const MUSIC_BEAT_INTERVAL: float = 60.0 / MUSIC_BPM  # ~0.4286s

# Audio — procedural hip hop beat
var music_player: AudioStreamPlayer
var music_tracks: Array = []
var music_index: int = 0
var music_playing: bool = false

# Audio — character voice clips
var voice_player: AudioStreamPlayer
var voice_clips: Dictionary = {}
var tower_quotes: Dictionary = {}

# Voice-over catchphrase system (MP3 files from edge-tts)
var catchphrase_player: AudioStreamPlayer
var placement_voice_clips: Dictionary = {}  # TowerType → Array[AudioStreamMP3]
var fighting_voice_clips: Dictionary = {}   # TowerType → Array[AudioStreamMP3]
var placement_quotes: Dictionary = {}       # TowerType → Array[String]
var fighting_quotes: Dictionary = {}        # TowerType → Array[String]
var _fighting_quote_timer: float = 25.0

# UI / Gameplay SFX (procedurally generated)
var _sfx_ui_click: AudioStreamWAV
var _sfx_wave_start: AudioStreamWAV
var _sfx_wave_complete: AudioStreamWAV
var _sfx_enemy_death: AudioStreamWAV
var _sfx_victory: AudioStreamWAV
var _sfx_defeat: AudioStreamWAV
var _sfx_life_lost: AudioStreamWAV
var _sfx_player: AudioStreamPlayer

# === META FEATURES: Save/Load, Emporium, Chests, Relics, Knowledge, Daily ===
var _save_path: String = "user://shadow_defense_save.json"

# Emporium sub-panel state
var emporium_sub_open: bool = false
var emporium_sub_category: int = -1
var emporium_sub_hover: int = -1
var emporium_sub_message: String = ""
var emporium_sub_message_timer: float = 0.0
var _emporium_confirm_index: int = -1
var _emporium_confirm_timer: float = 0.0
var emporium_items: Dictionary = {}

# Treasure chest opening overlay
var chest_opening_active: bool = false
var chest_opening_tier: int = 0  # 0=Bronze, 1=Silver, 2=Gold
var chest_opening_phase: int = 0  # 0=idle(click to open), 1=shake, 2=burst, 3=cards_slide, 4=cards_flip, 5=pick, 6=done
var chest_opening_timer: float = 0.0
var chest_opening_cards: Array = []
var chest_opening_picked: int = -1
var chest_opening_flip_index: int = 0
var treasure_chests_owned: Dictionary = {"bronze": 0, "silver": 0, "gold": 0}

# Victory chest overlay (post-level reward)
var victory_chest_active: bool = false
var victory_chest_stars: int = 0
var victory_trinket_pending: Dictionary = {}  # The trinket card picked, awaiting character equip
var victory_equip_active: bool = false  # Character selection overlay for trinket equip
var victory_equip_hover: int = -1

# Relic equipment
var equipped_relics: Dictionary = {}  # TowerType -> Array of equipped relic indices

# Knowledge tree (Chronicles tab)
var knowledge_ink: int = 0
var knowledge_tree: Dictionary = {}
var knowledge_branches: Array = []
var chronicles_hover_node: int = -1
var chronicles_hover_branch: int = -1

# Daily rewards
var daily_streak: int = 0
var daily_last_claim: String = ""
var daily_reward_open: bool = false
var daily_reward_hover_day: int = -1
var daily_reward_claimed_today: bool = false
var daily_rewards_schedule: Array = [
	{"name": "Relic Shards", "type": "shards", "amount": 10},
	{"name": "Enchanted Quills", "type": "quills", "amount": 5},
	{"name": "Gold Sovereigns", "type": "gold", "amount": 50},
	{"name": "Relic Shards", "type": "shards", "amount": 20},
	{"name": "Storybook Star", "type": "stars", "amount": 1},
	{"name": "Enchanted Quills", "type": "quills", "amount": 10},
	{"name": "Gold Treasure Chest", "type": "gold_chest", "amount": 1},
]

# === TOWER SYNERGIES ===
var synergy_definitions: Array = []
var active_synergies: Array = []
var synergies_ever_activated: Array = []
var synergy_banner_text: String = ""
var synergy_banner_timer: float = 0.0

# === ACHIEVEMENTS ===
var achievement_definitions: Array = []
var achievement_progress: Dictionary = {}
var achievements_unlocked: Dictionary = {}
var achievement_popup_text: String = ""
var achievement_popup_timer: float = 0.0
var achievement_popup_reward: String = ""
var total_towers_placed: int = 0
var total_enemies_killed: int = 0
var total_gold_spent: int = 0
var total_gold_earned: int = 0
var total_emporium_purchases: int = 0
var total_chests_opened: int = 0
var total_knowledge_nodes: int = 0
var total_daily_claims: int = 0
var current_game_lives_lost: int = 0
var current_game_fast_forward_only: bool = true

# === BATTLE POWERS ===
var battle_power_definitions: Array = []
var owned_powers: Dictionary = {}
var selected_powers: Array = []
var power_selection_open: bool = false
var active_power_effects: Dictionary = {}
var battle_power_buttons: Array = []
var storybook_shield_charges: int = 0
var power_enchanted_timer: float = 0.0

# === ODYSSEY MODE ===
var odyssey_maps: Array = []
var odyssey_active: bool = false
var odyssey_current_map: int = 0
var odyssey_carry_lives: int = 0
var odyssey_carry_gold: int = 0
var odyssey_completed_this_week: bool = false
var trophy_currency: int = 0
var odyssey_transition_timer: float = 0.0
var odyssey_transition_active: bool = false
var odyssey_lives_at_start: int = 0

# === TROPHY STORE ===
var trophy_store_items: Dictionary = {}
var owned_cosmetics: Array = []
var equipped_cosmetics: Dictionary = {}

# === BOSS RESCUE ANIMATION ===
var boss_rescue_active: bool = false
var boss_rescue_timer: float = 0.0
var boss_rescue_pos: Vector2 = Vector2.ZERO
var boss_rescue_boss_ref: Node2D = null
var boss_rescue_phase: int = 0  # 0=smoke, 1=author_appears, 2=grab, 3=flash, 4=fade
var _rescue_smoke_particles: Array = []

# === FLOATING TEXTS & DEATH EFFECTS ===
var _floating_texts: Array = []
var _screen_shake_timer: float = 0.0
var _insufficient_gold_flash: float = 0.0
var _boss_alert_timer: float = 0.0
var _boss_alert_text: String = ""
var _wave_clear_timer: float = 0.0
var _wave_clear_num: int = 0
var _screen_shake_intensity: float = 0.0
var _screen_shake_offset: Vector2 = Vector2.ZERO
var _ink_splatters: Array = []
var _death_flash_timer: float = 0.0

# === ENDLESS MODE ===
var endless_mode: bool = false
var endless_high_wave: int = 0
var endless_background_level: int = 0

# === TOME BINDINGS (Trinkets) ===
const TOME_BINDINGS: Array = [
	# ===== COMMON / BLUE (50 relics) =====
	# -- Robin Hood --
	{"id": "lincoln_band", "name": "Lincoln Green Band", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "robin_hood"},
	{"id": "nottingham_arrow", "name": "Nottingham Arrow", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "robin_hood"},
	{"id": "sherwood_acorn", "name": "Sherwood Acorn", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "robin_hood"},
	{"id": "merry_men_purse", "name": "Merry Men Purse", "desc": "+12% gold bonus", "rarity": "common", "effect": "gold_bonus", "value": 0.12, "character": "robin_hood"},
	# -- Alice --
	{"id": "cheshire_grin", "name": "Cheshire Grin", "desc": "+8% dodge", "rarity": "common", "effect": "dodge", "value": 0.08, "character": "alice"},
	{"id": "croquet_mallet", "name": "Croquet Mallet", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "alice"},
	{"id": "caterpillar_hookah", "name": "Caterpillar Hookah", "desc": "+10% slow", "rarity": "common", "effect": "slow", "value": 0.10, "character": "alice"},
	{"id": "mad_hatter_thimble", "name": "Mad Hatter's Thimble", "desc": "+8% crit", "rarity": "common", "effect": "crit", "value": 0.08, "character": "alice"},
	# -- Wicked Witch --
	{"id": "winkie_helm", "name": "Winkie Guard Helm", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "wicked_witch"},
	{"id": "poppy_petal", "name": "Poppy Petal", "desc": "+12% slow", "rarity": "common", "effect": "slow", "value": 0.12, "character": "wicked_witch"},
	{"id": "silver_whistle", "name": "Silver Whistle", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "wicked_witch"},
	{"id": "emerald_shard", "name": "Emerald Shard", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "wicked_witch"},
	# -- Peter Pan --
	{"id": "lost_boy_dagger", "name": "Lost Boy Dagger", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "peter_pan"},
	{"id": "pixie_dust_pinch", "name": "Pixie Dust Pinch", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "peter_pan"},
	{"id": "neverland_shell", "name": "Neverland Shell", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "peter_pan"},
	{"id": "tick_tock_tooth", "name": "Tick-Tock Tooth", "desc": "+8% crit", "rarity": "common", "effect": "crit", "value": 0.08, "character": "peter_pan"},
	# -- Phantom --
	{"id": "opera_mask_fragment", "name": "Opera Mask Fragment", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "phantom"},
	{"id": "chandelier_crystal", "name": "Chandelier Crystal", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "phantom"},
	{"id": "music_box_key", "name": "Music Box Key", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "phantom"},
	{"id": "catacomb_stone", "name": "Catacomb Stone", "desc": "+8% dodge", "rarity": "common", "effect": "dodge", "value": 0.08, "character": "phantom"},
	# -- Scrooge --
	{"id": "counting_house_coin", "name": "Counting House Coin", "desc": "+15% gold bonus", "rarity": "common", "effect": "gold_bonus", "value": 0.15, "character": "scrooge"},
	{"id": "ghost_chain_link", "name": "Ghost Chain Link", "desc": "+10% slow", "rarity": "common", "effect": "slow", "value": 0.10, "character": "scrooge"},
	{"id": "fezziwig_fiddle", "name": "Fezziwig Fiddle", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "scrooge"},
	{"id": "tiny_tim_crutch", "name": "Tiny Tim's Crutch", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "scrooge"},
	# -- Sherlock --
	{"id": "magnifying_lens", "name": "Magnifying Lens", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "sherlock"},
	{"id": "baker_street_pipe", "name": "Baker Street Pipe", "desc": "+8% crit", "rarity": "common", "effect": "crit", "value": 0.08, "character": "sherlock"},
	{"id": "watson_revolver", "name": "Watson's Revolver", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "sherlock"},
	{"id": "deerstalker_pin", "name": "Deerstalker Pin", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "sherlock"},
	# -- Tarzan --
	{"id": "jungle_vine", "name": "Jungle Vine", "desc": "+10% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.10, "character": "tarzan"},
	{"id": "mangani_claw", "name": "Mangani Claw", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "tarzan"},
	{"id": "treehouse_bark", "name": "Treehouse Bark", "desc": "+8% dodge", "rarity": "common", "effect": "dodge", "value": 0.08, "character": "tarzan"},
	{"id": "elephant_tusk", "name": "Elephant Tusk", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "tarzan"},
	# -- Dracula --
	{"id": "bat_wing_fragment", "name": "Bat Wing Fragment", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "dracula"},
	{"id": "coffin_nail", "name": "Coffin Nail", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "dracula"},
	{"id": "transylvania_soil", "name": "Transylvania Soil", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "dracula"},
	{"id": "garlic_braid", "name": "Garlic Braid", "desc": "+12% slow", "rarity": "common", "effect": "slow", "value": 0.12, "character": "dracula"},
	# -- Merlin --
	{"id": "crystal_ball_chip", "name": "Crystal Ball Chip", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "merlin"},
	{"id": "dragon_scale", "name": "Dragon Scale", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "merlin"},
	{"id": "camelot_banner", "name": "Camelot Banner", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "merlin"},
	{"id": "excalibur_polish", "name": "Excalibur Polish", "desc": "+8% crit", "rarity": "common", "effect": "crit", "value": 0.08, "character": "merlin"},
	# -- Frankenstein --
	{"id": "copper_wire", "name": "Copper Wire", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08, "character": "frankenstein"},
	{"id": "lightning_rod_tip", "name": "Lightning Rod Tip", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10, "character": "frankenstein"},
	{"id": "lab_journal_page", "name": "Lab Journal Page", "desc": "+10% range", "rarity": "common", "effect": "range", "value": 0.10, "character": "frankenstein"},
	{"id": "galvanic_bolt", "name": "Galvanic Bolt", "desc": "+10% splash radius", "rarity": "common", "effect": "splash_radius", "value": 0.10, "character": "frankenstein"},
	# -- Universal --
	{"id": "quill_swiftness", "name": "Quill of Swiftness", "desc": "+8% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.08},
	{"id": "inkwell_power", "name": "Inkwell of Power", "desc": "+10% damage", "rarity": "common", "effect": "damage", "value": 0.10},
	{"id": "bookmark_reach", "name": "Bookmark of Reach", "desc": "+12% range", "rarity": "common", "effect": "range", "value": 0.12},
	{"id": "leather_journal", "name": "Leather-Bound Journal", "desc": "+15% gold bonus", "rarity": "common", "effect": "gold_bonus", "value": 0.15},
	{"id": "fairy_dust", "name": "Fairy Dust Vial", "desc": "+12% attack speed", "rarity": "common", "effect": "attack_speed", "value": 0.12},
	{"id": "marleys_chains", "name": "Marley's Chains", "desc": "+20% slow", "rarity": "common", "effect": "slow", "value": 0.20},
	# ===== UNCOMMON / PURPLE (50 relics) =====
	# -- Robin Hood --
	{"id": "longbow_riser", "name": "Longbow Riser", "desc": "+12% damage, +5% range", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "range", "value": 0.05}], "character": "robin_hood"},
	{"id": "friar_tuck_flask", "name": "Friar Tuck's Flask", "desc": "+15% heal, +5% all stats", "rarity": "uncommon", "effects": [{"effect": "heal_nearby", "value": 1.5}, {"effect": "all", "value": 0.05}], "character": "robin_hood"},
	{"id": "maid_marian_ribbon", "name": "Maid Marian's Ribbon", "desc": "+10% atk spd, +8% dodge", "rarity": "uncommon", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "dodge", "value": 0.08}], "character": "robin_hood"},
	{"id": "sheriff_badge", "name": "Sheriff's Badge", "desc": "+15% gold, +8% crit", "rarity": "uncommon", "effects": [{"effect": "gold_bonus", "value": 0.15}, {"effect": "crit", "value": 0.08}], "character": "robin_hood"},
	# -- Alice --
	{"id": "vorpal_blade", "name": "Vorpal Blade", "desc": "+10% crit, +12% crit damage", "rarity": "uncommon", "effects": [{"effect": "crit", "value": 0.10}, {"effect": "crit_damage", "value": 0.12}], "character": "alice"},
	{"id": "queen_scepter", "name": "Queen's Scepter", "desc": "+12% damage, +8% splash", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "splash_radius", "value": 0.08}], "character": "alice"},
	{"id": "looking_glass", "name": "Looking Glass", "desc": "+15% range, +5% dodge", "rarity": "uncommon", "effects": [{"effect": "range", "value": 0.15}, {"effect": "dodge", "value": 0.05}], "character": "alice"},
	{"id": "drink_me_elixir", "name": "Drink Me Elixir", "desc": "+12% slow, +8% debuff amp", "rarity": "uncommon", "effects": [{"effect": "slow", "value": 0.12}, {"effect": "debuff_amp", "value": 0.08}], "character": "alice"},
	# -- Wicked Witch --
	{"id": "broomstick_splinter", "name": "Broomstick Splinter", "desc": "+10% atk spd, +8% range", "rarity": "uncommon", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "range", "value": 0.08}], "character": "wicked_witch"},
	{"id": "monkey_wing_medal", "name": "Monkey Wing Medal", "desc": "+12% damage, +5% crit", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "crit", "value": 0.05}], "character": "wicked_witch"},
	{"id": "crystal_ball_oz", "name": "Crystal Ball of Oz", "desc": "+15% range, +5% slow", "rarity": "uncommon", "effects": [{"effect": "range", "value": 0.15}, {"effect": "slow", "value": 0.05}], "character": "wicked_witch"},
	{"id": "ruby_heel", "name": "Ruby Heel", "desc": "+10% atk spd, +10% dodge", "rarity": "uncommon", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "dodge", "value": 0.10}], "character": "wicked_witch"},
	# -- Peter Pan --
	{"id": "shadow_thread", "name": "Shadow Thread", "desc": "+10% dodge, +10% crit", "rarity": "uncommon", "effects": [{"effect": "dodge", "value": 0.10}, {"effect": "crit", "value": 0.10}], "character": "peter_pan"},
	{"id": "hook_compass", "name": "Hook's Compass", "desc": "+15% range, +5% damage", "rarity": "uncommon", "effects": [{"effect": "range", "value": 0.15}, {"effect": "damage", "value": 0.05}], "character": "peter_pan"},
	{"id": "mermaid_scale", "name": "Mermaid Scale", "desc": "+8% all stats", "rarity": "uncommon", "effect": "all", "value": 0.08, "character": "peter_pan"},
	{"id": "wendy_thimble_kiss", "name": "Wendy's Thimble Kiss", "desc": "+10% atk spd, +8% heal", "rarity": "uncommon", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "heal_nearby", "value": 0.8}], "character": "peter_pan"},
	# -- Phantom --
	{"id": "punjab_lasso", "name": "Punjab Lasso Fiber", "desc": "+12% slow, +10% debuff amp", "rarity": "uncommon", "effects": [{"effect": "slow", "value": 0.12}, {"effect": "debuff_amp", "value": 0.10}], "character": "phantom"},
	{"id": "christine_rose", "name": "Christine's Rose", "desc": "+15% aura range, +5% atk spd", "rarity": "uncommon", "effects": [{"effect": "aura_range", "value": 0.15}, {"effect": "attack_speed", "value": 0.05}], "character": "phantom"},
	{"id": "organ_pipe_reed", "name": "Organ Pipe Reed", "desc": "+12% damage, +8% splash", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "splash_radius", "value": 0.08}], "character": "phantom"},
	{"id": "underground_lake_gem", "name": "Underground Lake Gem", "desc": "+10% range, +8% dodge", "rarity": "uncommon", "effects": [{"effect": "range", "value": 0.10}, {"effect": "dodge", "value": 0.08}], "character": "phantom"},
	# -- Scrooge --
	{"id": "ghost_past_candle", "name": "Ghost of Past's Candle", "desc": "+10% crit, +10% first blood", "rarity": "uncommon", "effects": [{"effect": "crit", "value": 0.10}, {"effect": "first_blood", "value": 0.10}], "character": "scrooge"},
	{"id": "cratchit_ledger", "name": "Cratchit's Ledger", "desc": "+12% gold, +10% wave gold", "rarity": "uncommon", "effects": [{"effect": "gold_bonus", "value": 0.12}, {"effect": "wave_gold", "value": 0.10}], "character": "scrooge"},
	{"id": "belle_locket", "name": "Belle's Locket", "desc": "+8% all stats", "rarity": "uncommon", "effect": "all", "value": 0.08, "character": "scrooge"},
	{"id": "spirit_future_scythe", "name": "Spirit of Future's Scythe", "desc": "+15% execute, +5% damage", "rarity": "uncommon", "effects": [{"effect": "execute", "value": 0.15}, {"effect": "damage", "value": 0.05}], "character": "scrooge"},
	# -- Sherlock --
	{"id": "violin_string", "name": "Violin String", "desc": "+12% atk spd, +8% crit", "rarity": "uncommon", "effects": [{"effect": "attack_speed", "value": 0.12}, {"effect": "crit", "value": 0.08}], "character": "sherlock"},
	{"id": "moriarty_cipher", "name": "Moriarty's Cipher", "desc": "+15% damage, -5% atk spd", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.15}, {"effect": "attack_speed", "value": -0.05}], "character": "sherlock"},
	{"id": "irene_brooch", "name": "Irene Adler's Brooch", "desc": "+10% dodge, +10% range", "rarity": "uncommon", "effects": [{"effect": "dodge", "value": 0.10}, {"effect": "range", "value": 0.10}], "character": "sherlock"},
	{"id": "baskerville_tooth", "name": "Baskerville Hound Tooth", "desc": "+12% dmg, +8% armor pierce", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "armor_pierce", "value": 0.08}], "character": "sherlock"},
	# -- Tarzan --
	{"id": "ape_king_crown", "name": "Ape King's Crown", "desc": "+12% dmg, +8% aura range", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "aura_range", "value": 0.08}], "character": "tarzan"},
	{"id": "jane_sketch_pad", "name": "Jane's Sketch Pad", "desc": "+10% range, +10% crit", "rarity": "uncommon", "effects": [{"effect": "range", "value": 0.10}, {"effect": "crit", "value": 0.10}], "character": "tarzan"},
	{"id": "sabor_fang", "name": "Sabor's Fang", "desc": "+15% armor pierce, +5% atk spd", "rarity": "uncommon", "effects": [{"effect": "armor_pierce", "value": 0.15}, {"effect": "attack_speed", "value": 0.05}], "character": "tarzan"},
	{"id": "kerchak_knuckle", "name": "Kerchak's Knuckle", "desc": "+12% dmg, +8% splash", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "splash_radius", "value": 0.08}], "character": "tarzan"},
	# -- Dracula --
	{"id": "mina_crucifix", "name": "Mina's Crucifix", "desc": "+12% damage, +8% burn", "rarity": "uncommon", "effects": [{"effect": "damage", "value": 0.12}, {"effect": "burn", "value": 0.08}], "character": "dracula"},
	{"id": "harker_journal", "name": "Harker's Journal", "desc": "+15% range, +5% crit", "rarity": "uncommon", "effects": [{"effect": "range", "value": 0.15}, {"effect": "crit", "value": 0.05}], "character": "dracula"},
	{"id": "van_helsing_stake", "name": "Van Helsing's Stake", "desc": "+15% boss dmg, +5% dmg", "rarity": "uncommon", "effects": [{"effect": "boss_damage", "value": 0.15}, {"effect": "damage", "value": 0.05}], "character": "dracula"},
	{"id": "blood_chalice", "name": "Blood Chalice", "desc": "+8% lifesteal, +5% atk spd", "rarity": "uncommon", "effects": [{"effect": "lifesteal", "value": 0.08}, {"effect": "attack_speed", "value": 0.05}], "character": "dracula"},
	# -- Merlin --
	{"id": "round_table_shard", "name": "Round Table Shard", "desc": "+8% all stats", "rarity": "uncommon", "effect": "all", "value": 0.08, "character": "merlin"},
	{"id": "morgan_mirror", "name": "Morgan le Fay's Mirror", "desc": "+12% range, +8% chain", "rarity": "uncommon", "effects": [{"effect": "range", "value": 0.12}, {"effect": "chain", "value": 0.08}], "character": "merlin"},
	{"id": "nimue_pearl", "name": "Nimue's Pearl", "desc": "+10% cooldown red., +5% range", "rarity": "uncommon", "effects": [{"effect": "cooldown_reduction", "value": 0.10}, {"effect": "range", "value": 0.05}], "character": "merlin"},
	{"id": "grail_knight_shield", "name": "Grail Knight's Shield", "desc": "+10% dodge, +8% absorb", "rarity": "uncommon", "effects": [{"effect": "dodge", "value": 0.10}, {"effect": "absorb_hit", "value": 0.8}], "character": "merlin"},
	# -- Frankenstein --
	{"id": "prometheus_flame", "name": "Prometheus Flame", "desc": "+12% burn, +8% damage", "rarity": "uncommon", "effects": [{"effect": "burn", "value": 0.12}, {"effect": "damage", "value": 0.08}], "character": "frankenstein"},
	{"id": "arctic_ice_shard", "name": "Arctic Ice Shard", "desc": "+15% slow, +8% debuff amp", "rarity": "uncommon", "effects": [{"effect": "slow", "value": 0.15}, {"effect": "debuff_amp", "value": 0.08}], "character": "frankenstein"},
	{"id": "creature_heart", "name": "Creature's Heart", "desc": "+8% lifesteal, +8% damage", "rarity": "uncommon", "effects": [{"effect": "lifesteal", "value": 0.08}, {"effect": "damage", "value": 0.08}], "character": "frankenstein"},
	{"id": "elizabeth_ring", "name": "Elizabeth's Ring", "desc": "+10% aura range, +8% atk spd", "rarity": "uncommon", "effects": [{"effect": "aura_range", "value": 0.10}, {"effect": "attack_speed", "value": 0.08}], "character": "frankenstein"},
	# -- Universal --
	{"id": "silver_monocle", "name": "Silver Monocle", "desc": "+8% crit chance", "rarity": "uncommon", "effect": "crit", "value": 0.08},
	{"id": "iron_clasp", "name": "Iron Clasp", "desc": "+5% all stats", "rarity": "uncommon", "effect": "all", "value": 0.05},
	{"id": "dusty_tome", "name": "Dusty Tome", "desc": "+15% XP gain", "rarity": "uncommon", "effect": "xp_gain", "value": 0.15},
	{"id": "gothic_candelabra", "name": "Gothic Candelabra", "desc": "+8% range, +5% damage", "rarity": "uncommon", "effects": [{"effect": "range", "value": 0.08}, {"effect": "damage", "value": 0.05}]},
	{"id": "raven_feather", "name": "Raven Feather", "desc": "+10% atk spd, -5% damage", "rarity": "uncommon", "effects": [{"effect": "attack_speed", "value": 0.10}, {"effect": "damage", "value": -0.05}]},
	{"id": "wolf_pelt", "name": "Wolf Pelt Cape", "desc": "+15% slow, +5% range", "rarity": "uncommon", "effects": [{"effect": "slow", "value": 0.15}, {"effect": "range", "value": 0.05}]},
	# ===== RARE / GOLD (50 relics) =====
	# -- Robin Hood --
	{"id": "bow_greenwood", "name": "Bow of the Greenwood", "desc": "+20% dmg, +10% crit, +15% chain", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "crit", "value": 0.10}, {"effect": "chain", "value": 0.15}], "character": "robin_hood"},
	{"id": "sherwood_heart", "name": "Sherwood's Heart", "desc": "+15% all stats", "rarity": "rare", "effect": "all", "value": 0.15, "character": "robin_hood"},
	{"id": "hood_final_arrow", "name": "Hood's Final Arrow", "desc": "+25% first blood, +10% armor pierce", "rarity": "rare", "effects": [{"effect": "first_blood", "value": 0.25}, {"effect": "armor_pierce", "value": 0.10}], "character": "robin_hood"},
	{"id": "little_john_staff", "name": "Little John's Staff", "desc": "+20% splash, +15% slow", "rarity": "rare", "effects": [{"effect": "splash_radius", "value": 0.20}, {"effect": "slow", "value": 0.15}], "character": "robin_hood"},
	# -- Alice --
	{"id": "jabberwock_scale", "name": "Jabberwock Scale", "desc": "+25% boss dmg, +10% crit dmg", "rarity": "rare", "effects": [{"effect": "boss_damage", "value": 0.25}, {"effect": "crit_damage", "value": 0.10}], "character": "alice"},
	{"id": "queen_hearts_crown", "name": "Queen of Hearts' Crown", "desc": "+20% dmg, +15% execute", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "execute", "value": 0.15}], "character": "alice"},
	{"id": "wonderland_key", "name": "Wonderland Key", "desc": "+12% all stats, +10% CD red.", "rarity": "rare", "effects": [{"effect": "all", "value": 0.12}, {"effect": "cooldown_reduction", "value": 0.10}], "character": "alice"},
	{"id": "cheshire_essence", "name": "Cheshire Essence", "desc": "+20% dodge, +15% crit", "rarity": "rare", "effects": [{"effect": "dodge", "value": 0.20}, {"effect": "crit", "value": 0.15}], "character": "alice"},
	# -- Wicked Witch --
	{"id": "witch_hourglass", "name": "Witch's Hourglass", "desc": "+20% slow, +15% debuff amp, +5% dmg", "rarity": "rare", "effects": [{"effect": "slow", "value": 0.20}, {"effect": "debuff_amp", "value": 0.15}, {"effect": "damage", "value": 0.05}], "character": "wicked_witch"},
	{"id": "wizard_curtain", "name": "Wizard's Curtain", "desc": "+15% dodge, +15% range", "rarity": "rare", "effects": [{"effect": "dodge", "value": 0.15}, {"effect": "range", "value": 0.15}], "character": "wicked_witch"},
	{"id": "glinda_wand", "name": "Glinda's Wand", "desc": "+20% aura range, +10% atk spd", "rarity": "rare", "effects": [{"effect": "aura_range", "value": 0.20}, {"effect": "attack_speed", "value": 0.10}], "character": "wicked_witch"},
	{"id": "enchanted_silver_shoes", "name": "Enchanted Silver Shoes", "desc": "+15% all stats", "rarity": "rare", "effect": "all", "value": 0.15, "character": "wicked_witch"},
	# -- Peter Pan --
	{"id": "second_star_compass", "name": "Second Star Compass", "desc": "+12% all stats, +10% range", "rarity": "rare", "effects": [{"effect": "all", "value": 0.12}, {"effect": "range", "value": 0.10}], "character": "peter_pan"},
	{"id": "captain_hook_claw", "name": "Captain Hook's Claw", "desc": "+25% dmg, +10% armor pierce", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.25}, {"effect": "armor_pierce", "value": 0.10}], "character": "peter_pan"},
	{"id": "fairy_queen_wing", "name": "Fairy Queen's Wing", "desc": "+20% atk spd, +15% CD red.", "rarity": "rare", "effects": [{"effect": "attack_speed", "value": 0.20}, {"effect": "cooldown_reduction", "value": 0.15}], "character": "peter_pan"},
	{"id": "neverland_hourglass", "name": "Neverland Hourglass", "desc": "+20% slow, +5% all stats", "rarity": "rare", "effects": [{"effect": "slow", "value": 0.20}, {"effect": "all", "value": 0.05}], "character": "peter_pan"},
	# -- Phantom --
	{"id": "phantom_full_mask", "name": "Phantom's Full Mask", "desc": "+20% dmg, +15% crit, +8% lifesteal", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "crit", "value": 0.15}, {"effect": "lifesteal", "value": 0.08}], "character": "phantom"},
	{"id": "christine_voice", "name": "Christine's Voice", "desc": "+20% aura range, +15% debuff amp", "rarity": "rare", "effects": [{"effect": "aura_range", "value": 0.20}, {"effect": "debuff_amp", "value": 0.15}], "character": "phantom"},
	{"id": "opera_ghost_cape", "name": "Opera Ghost's Cape", "desc": "+20% dodge, +10% damage", "rarity": "rare", "effects": [{"effect": "dodge", "value": 0.20}, {"effect": "damage", "value": 0.10}], "character": "phantom"},
	{"id": "beneath_opera", "name": "Beneath the Opera", "desc": "+25% boss dmg, +15% execute", "rarity": "rare", "effects": [{"effect": "boss_damage", "value": 0.25}, {"effect": "execute", "value": 0.15}], "character": "phantom"},
	# -- Scrooge --
	{"id": "christmas_miracle", "name": "Christmas Miracle", "desc": "+3 HP heal/wave, +15% all stats", "rarity": "rare", "effects": [{"effect": "heal_nearby", "value": 3.0}, {"effect": "all", "value": 0.15}], "character": "scrooge"},
	{"id": "scrooge_redemption", "name": "Scrooge's Redemption", "desc": "+25% gold, +15% wave gold", "rarity": "rare", "effects": [{"effect": "gold_bonus", "value": 0.25}, {"effect": "wave_gold", "value": 0.15}], "character": "scrooge"},
	{"id": "ghost_present_torch", "name": "Ghost of Present's Torch", "desc": "+20% dmg, +15% aura range", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "aura_range", "value": 0.15}], "character": "scrooge"},
	{"id": "marley_lockbox", "name": "Marley's Lockbox", "desc": "Absorb 2 hits, +10% dodge", "rarity": "rare", "effects": [{"effect": "absorb_hit", "value": 2.0}, {"effect": "dodge", "value": 0.10}], "character": "scrooge"},
	# -- Sherlock --
	{"id": "mind_palace_key", "name": "Mind Palace Key", "desc": "+15% all stats, +10% crit", "rarity": "rare", "effects": [{"effect": "all", "value": 0.15}, {"effect": "crit", "value": 0.10}], "character": "sherlock"},
	{"id": "reichenbach_memento", "name": "Reichenbach Memento", "desc": "+25% dmg, +15% boss dmg", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.25}, {"effect": "boss_damage", "value": 0.15}], "character": "sherlock"},
	{"id": "hound_collar", "name": "The Hound's Collar", "desc": "+20% dmg, +12% chain", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "chain", "value": 0.12}], "character": "sherlock"},
	{"id": "elementary_lens", "name": "Elementary Lens", "desc": "+20% range, +15% crit, +10% armor pierce", "rarity": "rare", "effects": [{"effect": "range", "value": 0.20}, {"effect": "crit", "value": 0.15}, {"effect": "armor_pierce", "value": 0.10}], "character": "sherlock"},
	# -- Tarzan --
	{"id": "king_jungle_crown", "name": "King of the Jungle Crown", "desc": "+20% dmg, +15% atk spd, +10% aura", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}, {"effect": "aura_range", "value": 0.10}], "character": "tarzan"},
	{"id": "greystoke_signet", "name": "Greystoke Signet", "desc": "+12% all stats, +10% gold", "rarity": "rare", "effects": [{"effect": "all", "value": 0.12}, {"effect": "gold_bonus", "value": 0.10}], "character": "tarzan"},
	{"id": "darnot_compass", "name": "D'Arnot's Compass", "desc": "+20% range, +15% chain", "rarity": "rare", "effects": [{"effect": "range", "value": 0.20}, {"effect": "chain", "value": 0.15}], "character": "tarzan"},
	{"id": "tarzan_war_cry", "name": "Tarzan's War Cry", "desc": "+25% splash, +15% debuff amp", "rarity": "rare", "effects": [{"effect": "splash_radius", "value": 0.25}, {"effect": "debuff_amp", "value": 0.15}], "character": "tarzan"},
	# -- Dracula --
	{"id": "dracula_signet_ring", "name": "Dracula's Signet Ring", "desc": "+20% dmg, +8% lifesteal, +10% crit", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.20}, {"effect": "lifesteal", "value": 0.08}, {"effect": "crit", "value": 0.10}], "character": "dracula"},
	{"id": "carfax_abbey_tome", "name": "Carfax Abbey Tome", "desc": "+25% boss dmg, +15% burn", "rarity": "rare", "effects": [{"effect": "boss_damage", "value": 0.25}, {"effect": "burn", "value": 0.15}], "character": "dracula"},
	{"id": "brides_veil", "name": "Brides' Veil", "desc": "+20% slow, +15% debuff amp, +5% dodge", "rarity": "rare", "effects": [{"effect": "slow", "value": 0.20}, {"effect": "debuff_amp", "value": 0.15}, {"effect": "dodge", "value": 0.05}], "character": "dracula"},
	{"id": "nosferatu_shadow", "name": "Nosferatu's Shadow", "desc": "+20% dodge, +15% execute, +5% atk spd", "rarity": "rare", "effects": [{"effect": "dodge", "value": 0.20}, {"effect": "execute", "value": 0.15}, {"effect": "attack_speed", "value": 0.05}], "character": "dracula"},
	# -- Merlin --
	{"id": "excalibur_reforged", "name": "Excalibur Reforged", "desc": "+25% dmg, +15% crit, +10% armor pierce", "rarity": "rare", "effects": [{"effect": "damage", "value": 0.25}, {"effect": "crit", "value": 0.15}, {"effect": "armor_pierce", "value": 0.10}], "character": "merlin"},
	{"id": "holy_grail_merlin", "name": "Holy Grail", "desc": "+3 HP heal/wave, +12% all stats", "rarity": "rare", "effects": [{"effect": "heal_nearby", "value": 3.0}, {"effect": "all", "value": 0.12}], "character": "merlin"},
	{"id": "merlin_starfire_staff", "name": "Merlin's Starfire Staff", "desc": "+20% splash, +15% burn", "rarity": "rare", "effects": [{"effect": "splash_radius", "value": 0.20}, {"effect": "burn", "value": 0.15}], "character": "merlin"},
	{"id": "avalon_mist", "name": "Avalon Mist", "desc": "+15% dodge, +15% CD red., +10% range", "rarity": "rare", "effects": [{"effect": "dodge", "value": 0.15}, {"effect": "cooldown_reduction", "value": 0.15}, {"effect": "range", "value": 0.10}], "character": "merlin"},
	# -- Frankenstein --
	{"id": "spark_of_life", "name": "Spark of Life", "desc": "+25% chain, +15% dmg, +8% burn", "rarity": "rare", "effects": [{"effect": "chain", "value": 0.25}, {"effect": "damage", "value": 0.15}, {"effect": "burn", "value": 0.08}], "character": "frankenstein"},
	{"id": "shelley_manuscript", "name": "Shelley's Manuscript", "desc": "+12% all stats, +15% XP gain", "rarity": "rare", "effects": [{"effect": "all", "value": 0.12}, {"effect": "xp_gain", "value": 0.15}], "character": "frankenstein"},
	{"id": "arctic_titan_fist", "name": "Arctic Titan's Fist", "desc": "+25% boss dmg, +20% armor pierce", "rarity": "rare", "effects": [{"effect": "boss_damage", "value": 0.25}, {"effect": "armor_pierce", "value": 0.20}], "character": "frankenstein"},
	{"id": "bride_heart", "name": "Bride's Heart", "desc": "+20% aura, +15% atk spd, +8% lifesteal", "rarity": "rare", "effects": [{"effect": "aura_range", "value": 0.20}, {"effect": "attack_speed", "value": 0.15}, {"effect": "lifesteal", "value": 0.08}], "character": "frankenstein"},
	# -- Universal --
	{"id": "torn_manuscript", "name": "Torn Manuscript", "desc": "+25% boss damage", "rarity": "rare", "effect": "boss_damage", "value": 0.25},
	{"id": "wax_seal", "name": "Wax Seal", "desc": "Absorb 1 hit", "rarity": "rare", "effect": "absorb_hit", "value": 1.0},
	{"id": "phantoms_quill", "name": "Phantom's Quill", "desc": "+3% lifesteal", "rarity": "rare", "effect": "lifesteal", "value": 0.03},
	{"id": "bloodstained_page", "name": "Bloodstained Page", "desc": "+25% dmg when low lives", "rarity": "rare", "effect": "bloodstained", "value": 0.25},
	{"id": "authors_signet", "name": "Author's Signet", "desc": "+2 gold per kill", "rarity": "rare", "effect": "kill_gold", "value": 2.0},
	{"id": "holy_grail", "name": "Holy Grail Replica", "desc": "+3 HP heal/wave", "rarity": "rare", "effect": "heal_nearby", "value": 3.0},
]
var owned_bindings: Dictionary = {}  # binding_id -> count
var equipped_bindings: Dictionary = {}  # tower_type -> [binding_id, binding_id]
var _binding_lookup: Dictionary = {}  # binding_id -> binding dict (cache)
var relic_scroll_offset: float = 0.0
var binding_shop_scroll: float = 0.0
var detail_binding_scroll: float = 0.0

# === STORY DIALOG SYSTEM ===
var story_dialogs: Dictionary = {}  # "pre_level_N" -> [{speaker, text, voice_type}]
var story_state: Dictionary = {
	"current_dialog": "", "line_index": 0, "char_index": 0,
	"typewriter_timer": 0.0, "active": false, "auto_advance_timer": 0.0,
	"queued_dialog": ""
}
var story_seen: Array = []  # dialog keys already seen (persisted)
var story_voice_clips: Dictionary = {}  # "narrator", "male_hero", "female_hero", "monster"
var shadow_author_story_clips: Dictionary = {}  # "prologue_0" -> AudioStreamMP3
var shadow_author_fight_clips: Array = []  # fight_0..fight_6 AudioStreamMP3
var character_story_clips: Dictionary = {}  # "pre_level_1_sherlock_0" -> AudioStreamMP3
var shadow_author_taunt_timer: float = 0.0
var shadow_author_taunt_cooldown: float = 25.0  # seconds between taunts

# === UNLOCKABLE CHARACTERS ===
# 5 new characters freed from the shadow realm
# Sherlock=beat Robin levels (0-2), Tarzan=beat Alice levels (3-5),
# Dracula=beat Witch levels (6-8), Merlin=beat Peter levels (9-11),
# Frankenstein=beat Phantom levels (12-14)
var unlocked_characters: Array = []  # Array of string IDs: "sherlock", "tarzan", "dracula", "merlin", "frankenstein"
var character_unlock_map: Dictionary = {
	"sherlock": [1, 2, 3],
	"merlin": [4, 5, 6],
	"tarzan": [7, 8, 9],
	"dracula": [10, 11, 12],
	"frankenstein": [13, 14, 15],
	"shadow_author": [34, 35, 36],
}

# Arc data for menu navigation (37 levels across 13 arcs)
var arc_data = [
	{"name": "Prologue", "levels": [0], "icon": "book"},
	{"name": "Sherlock Holmes", "levels": [1, 2, 3], "unlock_char": "sherlock"},
	{"name": "Merlin", "levels": [4, 5, 6], "unlock_char": "merlin"},
	{"name": "Tarzan", "levels": [7, 8, 9], "unlock_char": "tarzan"},
	{"name": "Dracula", "levels": [10, 11, 12], "unlock_char": "dracula"},
	{"name": "Frankenstein", "levels": [13, 14, 15], "unlock_char": "frankenstein"},
	{"name": "Robin Hood", "levels": [16, 17, 18]},
	{"name": "Alice", "levels": [19, 20, 21]},
	{"name": "Wicked Witch", "levels": [22, 23, 24]},
	{"name": "Peter Pan", "levels": [25, 26, 27]},
	{"name": "Phantom", "levels": [28, 29, 30]},
	{"name": "Scrooge", "levels": [31, 32, 33]},
	{"name": "Shadow Author", "levels": [34, 35, 36], "icon": "skull"},
]

# Save version for migration
const SAVE_VERSION = 2
const OLD_TO_NEW_LEVEL_MAP = {0:16, 1:17, 2:18, 3:19, 4:20, 5:21, 6:22, 7:23, 8:24, 9:25, 10:26, 11:27, 12:28, 13:29, 14:30, 15:31, 16:32, 17:33}

func _ready() -> void:
	add_to_group("main")
	# Load Cinzel display font for all game text
	game_font = load("res://fonts/Cinzel.ttf")
	_init_survivor_progress()
	_init_emporium_items()
	_init_knowledge_tree()
	_init_equipped_relics()
	_init_synergy_definitions()
	_init_achievement_definitions()
	_init_battle_power_definitions()
	_init_trophy_store_items()
	_init_odyssey_maps()
	_init_story_dialogs()
	_build_binding_lookup()
	_init_quests()
	_init_shadow_arena()
	_load_game()
	_generate_daily_deals()
	_refresh_quests_if_needed()
	_cache_path_points()
	_cache_path_thumbnails()
	_generate_decorations_for_level(0)
	_create_ui()
	_apply_font_to_controls(self)
	_setup_audio()
	_show_menu()

# Ability unlock popup state
var _ability_popup_timer: float = 0.0
var _ability_popup_tower_type: int = -1
var _ability_popup_index: int = -1
var _ability_popup_name: String = ""
var _ability_popup_desc: String = ""
var _ability_popup_freeze: float = 0.0

# Ability thresholds (same for all characters)
const PROGRESSIVE_ABILITY_THRESHOLDS = [5000, 25000, 100000, 350000, 1000000, 3000000, 10000000, 35000000, 100000000]

# Spawn debuff flags (set by Crystal Ball / Beneath the Opera)
var spawn_hp_reduction: float = 0.0   # Crystal Ball: 0.15 = 15% less HP
var spawn_permanent_slow: float = 1.0 # Beneath the Opera: 0.7 = 30% slower

func _init_survivor_progress() -> void:
	# Init all tower types including unlockable ones
	var all_types = [TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH,
		TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE,
		TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA,
		TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR]
	for t in all_types:
		survivor_progress[t] = {
			"level": 1,
			"xp": 0.0,
			"xp_next": float(HERO_XP_TABLE[0]),
			"gear_unlocked": false,
			"sidekicks_unlocked": [false, false, false],
			"relics_unlocked": [false, false, false, false, false, false],
			"total_damage": 0.0,
			"abilities_unlocked": [false, false, false, false, false, false, false, false, false],
			"golden_shields": 0,
			"upgrade_branch": "",  # "" = not chosen, "A" or "B"
		}
		session_damage[t] = 0.0

func _get_xp_for_level(level: int) -> float:
	# Returns XP needed to go from 'level' to 'level+1'
	if level <= 0:
		return float(HERO_XP_TABLE[0])
	if level >= MAX_SURVIVOR_LEVEL:
		return float(HERO_XP_TABLE[HERO_XP_TABLE.size() - 1])  # Still accumulates but won't level up
	var idx = level - 1
	if idx < HERO_XP_TABLE.size():
		return float(HERO_XP_TABLE[idx])
	return float(HERO_XP_TABLE[HERO_XP_TABLE.size() - 1])

func _get_level_bonuses(tower_type) -> Dictionary:
	var level = survivor_progress.get(tower_type, {}).get("level", 1)
	var bonuses = {"damage": 0.0, "range": 0.0, "attack_speed": 0.0, "gold_bonus": 0.0, "crit": 0.0}
	var lvls = level - 1  # Bonuses start at level 2
	if lvls <= 0:
		return bonuses
	# Universal bonuses: +2% damage, +1.5% range, +1% attack speed per level
	bonuses["damage"] += lvls * 0.02
	bonuses["range"] += lvls * 0.015
	bonuses["attack_speed"] += lvls * 0.01
	# Role-specific extras per level
	match tower_type:
		TowerType.ROBIN_HOOD:
			bonuses["range"] += lvls * 0.015
		TowerType.ALICE:
			bonuses["range"] += lvls * 0.01  # AoE radius mapped to range
		TowerType.WICKED_WITCH:
			bonuses["damage"] += lvls * 0.015
		TowerType.PETER_PAN:
			bonuses["attack_speed"] += lvls * 0.015
		TowerType.PHANTOM:
			bonuses["damage"] += lvls * 0.01
			bonuses["range"] += lvls * 0.005
		TowerType.SCROOGE:
			bonuses["gold_bonus"] += lvls * 0.015
		TowerType.SHERLOCK:
			bonuses["damage"] += lvls * 0.01
			bonuses["crit"] += lvls * 0.005
		TowerType.TARZAN:
			bonuses["damage"] += lvls * 0.02
		TowerType.DRACULA:
			bonuses["damage"] += lvls * 0.01
		TowerType.MERLIN:
			bonuses["range"] += lvls * 0.015
		TowerType.FRANKENSTEIN:
			bonuses["damage"] += lvls * 0.02
		TowerType.SHADOW_AUTHOR:
			bonuses["damage"] += lvls * 0.015
			bonuses["range"] += lvls * 0.01
	# Milestone bonuses
	if level >= 5:
		bonuses["damage"] += 0.05
	if level >= 15:
		bonuses["damage"] += 0.10
		bonuses["range"] += 0.10
		bonuses["attack_speed"] += 0.10
	return bonuses

func _get_relic_bonuses(tower_type) -> Dictionary:
	var bonuses: Dictionary = {}
	var effects = get_equipped_relic_effects(tower_type)
	for relic in effects:
		var eff = relic.get("effect", "")
		var val = relic.get("value", 0.0)
		match eff:
			"pierce_damage", "spell_damage":
				bonuses["damage"] = bonuses.get("damage", 0.0) + val
			"range":
				bonuses["range"] = bonuses.get("range", 0.0) + val
			"atk_speed_aura":
				bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
			"bonus_gold":
				bonuses["gold_bonus"] = bonuses.get("gold_bonus", 0.0) + val
			"crit_chance":
				bonuses["crit"] = bonuses.get("crit", 0.0) + val
			"cooldown":
				bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
			_:
				bonuses[eff] = bonuses.get(eff, 0.0) + val
	return bonuses

func _get_gear_bonuses(tower_type) -> Dictionary:
	var bonuses: Dictionary = {}
	if not survivor_progress.has(tower_type):
		return bonuses
	if not survivor_progress[tower_type].get("gear_unlocked", false):
		return bonuses
	# Each tower's gear provides a thematic stat boost
	match tower_type:
		TowerType.ROBIN_HOOD:
			bonuses["range"] = 0.15
			bonuses["damage"] = 0.05
		TowerType.ALICE:
			bonuses["range"] = 0.10
			bonuses["damage"] = 0.10
		TowerType.WICKED_WITCH:
			bonuses["attack_speed"] = 0.12
			bonuses["damage"] = 0.05
		TowerType.PETER_PAN:
			bonuses["damage"] = 0.15
			bonuses["attack_speed"] = 0.05
		TowerType.PHANTOM:
			bonuses["range"] = 0.10
			bonuses["attack_speed"] = 0.08
		TowerType.SCROOGE:
			bonuses["gold_bonus"] = 0.20
		TowerType.SHERLOCK:
			bonuses["damage"] = 0.12
			bonuses["range"] = 0.08
		TowerType.TARZAN:
			bonuses["range"] = 0.15
			bonuses["attack_speed"] = 0.08
		TowerType.DRACULA:
			bonuses["damage"] = 0.10
			bonuses["range"] = 0.10
		TowerType.MERLIN:
			bonuses["range"] = 0.12
			bonuses["damage"] = 0.08
		TowerType.FRANKENSTEIN:
			bonuses["damage"] = 0.12
			bonuses["attack_speed"] = 0.08
	return bonuses

func _get_sidekick_bonuses(tower_type) -> Dictionary:
	var bonuses: Dictionary = {}
	if not survivor_progress.has(tower_type):
		return bonuses
	var sk_unlocked = survivor_progress[tower_type].get("sidekicks_unlocked", [false, false, false])
	# Each unlocked sidekick gives a small passive bonus
	if sk_unlocked.size() > 0 and sk_unlocked[0]:
		bonuses["damage"] = bonuses.get("damage", 0.0) + 0.05
	if sk_unlocked.size() > 1 and sk_unlocked[1]:
		bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + 0.05
	if sk_unlocked.size() > 2 and sk_unlocked[2]:
		bonuses["gold_bonus"] = bonuses.get("gold_bonus", 0.0) + 0.10
	return bonuses

func _apply_meta_buffs(tower_node, tower_type) -> void:
	var buffs: Dictionary = {}
	# 1) Level bonuses
	var lvl_b = _get_level_bonuses(tower_type)
	for k in lvl_b:
		buffs[k] = buffs.get(k, 0.0) + lvl_b[k]
	# 2) Knowledge bonuses (global, all towers benefit)
	for stat_key in ["damage", "range", "attack_speed", "crit"]:
		var kb = _get_knowledge_bonus(stat_key)
		if kb > 0.0:
			buffs[stat_key] = buffs.get(stat_key, 0.0) + kb
	# 3) Relic bonuses (per-character)
	var rel_b = _get_relic_bonuses(tower_type)
	for k in rel_b:
		buffs[k] = buffs.get(k, 0.0) + rel_b[k]
	# 4) Tome Binding bonuses
	var bind_b = _get_binding_bonuses(tower_type)
	for k in bind_b:
		buffs[k] = buffs.get(k, 0.0) + bind_b[k]
	# 5) Literary Instrument aura bonuses
	if tower_node and is_instance_valid(tower_node):
		var inst_b = _get_instrument_buffs_at(tower_node.global_position)
		for k in inst_b:
			buffs[k] = buffs.get(k, 0.0) + inst_b[k]
	# 6) Branch upgrade bonuses (read from tower metadata)
	if tower_node and is_instance_valid(tower_node) and tower_node.has_meta("branch_upgrades"):
		var branch_ups = tower_node.get_meta("branch_upgrades")
		for bu in branch_ups:
			var eff = bu.get("effect", "")
			var val = bu.get("value", 0.0)
			# Map branch effects to stat keys the tower scripts read
			match eff:
				"damage", "crit", "crit_damage", "slow", "gold_bonus", "range", "attack_speed":
					buffs[eff] = buffs.get(eff, 0.0) + val
				"pierce_damage", "shrink_damage", "mark_damage", "ramp_damage":
					buffs["damage"] = buffs.get("damage", 0.0) + val
				"early_damage":
					buffs["damage"] = buffs.get("damage", 0.0) + val * 0.5
				"multi_shot":
					buffs["damage"] = buffs.get("damage", 0.0) + (val - 1.0) * 0.5
				"aoe_radius":
					buffs["range"] = buffs.get("range", 0.0) + val * 0.5
				"gold_on_hit", "passive_gold", "global_gold":
					buffs["gold_bonus"] = buffs.get("gold_bonus", 0.0) + val
				"attack_speed_aura":
					buffs["attack_speed"] = buffs.get("attack_speed", 0.0) + val
				"global_range":
					buffs["range"] = buffs.get("range", 0.0) + val
				"chain_count":
					buffs["damage"] = buffs.get("damage", 0.0) + val * 0.08
				"execute":
					buffs["damage"] = buffs.get("damage", 0.0) + 0.15
				_:
					# Complex effects (tornado, stampede, etc.) stored for future use
					buffs[eff] = buffs.get(eff, 0.0) + val
	# 7) Gear bonuses (if gear unlocked for this character)
	var gear_b = _get_gear_bonuses(tower_type)
	for k in gear_b:
		buffs[k] = buffs.get(k, 0.0) + gear_b[k]
	# 8) Sidekick bonuses (for each unlocked sidekick)
	var side_b = _get_sidekick_bonuses(tower_type)
	for k in side_b:
		buffs[k] = buffs.get(k, 0.0) + side_b[k]
	# Apply to tower
	if tower_node.has_method("set_meta_buffs"):
		tower_node.set_meta_buffs(buffs)

# Map character string ID to TowerType
var character_id_to_tower_type: Dictionary = {
	"sherlock": TowerType.SHERLOCK,
	"tarzan": TowerType.TARZAN,
	"dracula": TowerType.DRACULA,
	"merlin": TowerType.MERLIN,
	"frankenstein": TowerType.FRANKENSTEIN,
}

# Map TowerType to scene path for new characters (loaded at runtime)
var new_tower_scene_paths: Dictionary = {
	TowerType.SHERLOCK: "res://scenes/sherlock.tscn",
	TowerType.TARZAN: "res://scenes/tarzan.tscn",
	TowerType.DRACULA: "res://scenes/dracula.tscn",
	TowerType.MERLIN: "res://scenes/merlin.tscn",
	TowerType.FRANKENSTEIN: "res://scenes/frankenstein.tscn",
	TowerType.SHADOW_AUTHOR: "res://scenes/shadow_author.tscn",
}

func _refresh_unlocked_survivors() -> void:
	# Ensure unlocked characters have their scenes loaded
	for char_id in unlocked_characters:
		if not character_id_to_tower_type.has(char_id):
			continue
		var tt = character_id_to_tower_type[char_id]
		# Load scene if not already in tower_scenes
		if not tower_scenes.has(tt) and new_tower_scene_paths.has(tt):
			var path = new_tower_scene_paths[tt]
			if ResourceLoader.exists(path):
				tower_scenes[tt] = load(path)

func _is_character_unlocked(tower_type) -> bool:
	if tower_type in [TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH,
					  TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE]:
		return true
	var id_map = {
		TowerType.SHERLOCK: "sherlock", TowerType.MERLIN: "merlin",
		TowerType.TARZAN: "tarzan", TowerType.DRACULA: "dracula",
		TowerType.FRANKENSTEIN: "frankenstein", TowerType.SHADOW_AUTHOR: "shadow_author"
	}
	return id_map.get(tower_type, "") in unlocked_characters

func _init_emporium_items() -> void:
	emporium_items = {
		0: [  # Gold Exchange (gold → other currencies)
			{"name": "Quill Pouch", "desc": "Trade gold for writing tools", "cost": 50, "currency": "gold", "reward": "quills", "amount": 3},
			{"name": "Quill Bundle", "desc": "A scholar's supply of quills", "cost": 150, "currency": "gold", "reward": "quills", "amount": 10},
			{"name": "Shard Fragments", "desc": "Convert gold to crystal shards", "cost": 100, "currency": "gold", "reward": "shards", "amount": 15},
			{"name": "Storybook Star", "desc": "A star forged from golden ink", "cost": 200, "currency": "gold", "reward": "stars", "amount": 1},
		],
		1: [  # Enchanted Quills (shards → quills)
			{"name": "Ink & Quill", "desc": "A basic writing set", "cost": 15, "currency": "shards", "reward": "quills", "amount": 3},
			{"name": "Scribe's Bundle", "desc": "A scholar's collection", "cost": 40, "currency": "shards", "reward": "quills", "amount": 10},
			{"name": "Arcane Library", "desc": "Ancient enchanted tomes", "cost": 80, "currency": "shards", "reward": "quills", "amount": 25},
		],
		2: [  # Relic Shards (stars → shards)
			{"name": "Shard Fragment", "desc": "Glowing crystal piece", "cost": 1, "currency": "stars", "reward": "shards", "amount": 20},
			{"name": "Shard Cluster", "desc": "A cluster of raw shards", "cost": 2, "currency": "stars", "reward": "shards", "amount": 50},
			{"name": "Prismatic Core", "desc": "Pure crystallized energy", "cost": 4, "currency": "stars", "reward": "shards", "amount": 120},
		],
		3: [  # Relic Chests
			{"name": "Bronze Chest", "desc": "Common treasures within", "cost": 10, "currency": "shards", "reward": "chest_bronze", "amount": 1},
			{"name": "Silver Chest", "desc": "Uncommon relics await", "cost": 30, "currency": "shards", "reward": "chest_silver", "amount": 1},
			{"name": "Gold Chest", "desc": "Legendary artifacts inside", "cost": 80, "currency": "shards", "reward": "chest_gold", "amount": 1},
		],
		4: [  # Survivor Packs (stars → XP)
			{"name": "Training Scroll", "desc": "Basic combat lessons", "cost": 1, "currency": "stars", "reward": "xp", "amount": 500},
			{"name": "Battle Manual", "desc": "Advanced techniques", "cost": 2, "currency": "stars", "reward": "xp", "amount": 1500},
			{"name": "War Chronicle", "desc": "Legendary battle wisdom", "cost": 4, "currency": "stars", "reward": "xp", "amount": 4000},
		],
		5: [  # Storybook Stars (quills → stars)
			{"name": "Fallen Star", "desc": "A faint glimmer of magic", "cost": 15, "currency": "quills", "reward": "stars", "amount": 1},
			{"name": "Star Cluster", "desc": "A constellation captured", "cost": 35, "currency": "quills", "reward": "stars", "amount": 3},
			{"name": "Celestial Nova", "desc": "Pure starlight essence", "cost": 60, "currency": "quills", "reward": "stars", "amount": 6},
		],
		7: [  # Battle Powers (shards → powers)
			{"name": "Quill Strike", "desc": "500 damage to all on-screen enemies", "cost": 15, "currency": "shards", "reward": "power", "power_id": "quill_strike", "amount": 1},
			{"name": "Golden Bounty", "desc": "+200 gold instantly", "cost": 10, "currency": "shards", "reward": "power", "power_id": "golden_bounty", "amount": 1},
			{"name": "Storybook Shield", "desc": "Blocks next 10 life losses", "cost": 20, "currency": "shards", "reward": "power", "power_id": "storybook_shield", "amount": 1},
			{"name": "Ink Freeze", "desc": "Freeze all enemies 5 seconds", "cost": 18, "currency": "shards", "reward": "power", "power_id": "ink_freeze", "amount": 1},
			{"name": "Chapter Skip", "desc": "Instantly completes current wave", "cost": 25, "currency": "shards", "reward": "power", "power_id": "chapter_skip", "amount": 1},
			{"name": "Enchanted Towers", "desc": "All towers +50% damage for 15s", "cost": 22, "currency": "shards", "reward": "power", "power_id": "enchanted_towers", "amount": 1},
		],
	}

func _init_knowledge_tree() -> void:
	knowledge_branches = [
		{
			"name": "Heroic Tales",
			"desc": "Offense",
			"color": Color(0.85, 0.3, 0.2),
			"nodes": [
				{"name": "Sharp Blades", "desc": "+5% tower damage", "effect": "damage", "value": 0.05, "cost": 1},
				{"name": "Eagle Eye", "desc": "+8% tower range", "effect": "range", "value": 0.08, "cost": 1},
				{"name": "Swift Strikes", "desc": "+10% attack speed", "effect": "attack_speed", "value": 0.10, "cost": 2},
				{"name": "Critical Lore", "desc": "+5% crit chance", "effect": "crit", "value": 0.05, "cost": 2},
				{"name": "Legendary Might", "desc": "+15% tower damage", "effect": "damage", "value": 0.15, "cost": 3},
				{"name": "Piercing Words", "desc": "+8% pierce damage", "effect": "damage", "value": 0.08, "cost": 3},
				{"name": "Battle Fury", "desc": "+5% attack speed", "effect": "attack_speed", "value": 0.05, "cost": 4},
				{"name": "Ruthless Prose", "desc": "+8% crit damage", "effect": "crit", "value": 0.08, "cost": 4},
				{"name": "Author's Wrath", "desc": "+10% boss damage", "effect": "damage", "value": 0.10, "cost": 5},
			],
		},
		{
			"name": "Enchanted Pages",
			"desc": "Defense",
			"color": Color(0.3, 0.6, 0.85),
			"nodes": [
				{"name": "Thick Covers", "desc": "+2 starting lives", "effect": "lives", "value": 2, "cost": 1},
				{"name": "Golden Bookmark", "desc": "+25 starting gold", "effect": "start_gold", "value": 25, "cost": 1},
				{"name": "Bargain Ink", "desc": "-5% tower cost", "effect": "tower_discount", "value": 0.05, "cost": 2},
				{"name": "Bound in Iron", "desc": "+3 starting lives", "effect": "lives", "value": 3, "cost": 2},
				{"name": "Master Binding", "desc": "-10% tower cost", "effect": "tower_discount", "value": 0.10, "cost": 3},
				{"name": "Iron Spine", "desc": "+5 starting lives", "effect": "lives", "value": 5, "cost": 3},
				{"name": "Gilded Pages", "desc": "+50 starting gold", "effect": "start_gold", "value": 50, "cost": 4},
				{"name": "Bulk Bargain", "desc": "-5% upgrade cost", "effect": "upgrade_discount", "value": 0.05, "cost": 4},
				{"name": "Impenetrable Tome", "desc": "+1 life regen/wave", "effect": "life_regen", "value": 1, "cost": 5},
			],
		},
		{
			"name": "Lost Chapters",
			"desc": "Meta",
			"color": Color(0.6, 0.45, 0.8),
			"nodes": [
				{"name": "Quick Study", "desc": "+10% XP gain", "effect": "xp_gain", "value": 0.10, "cost": 1},
				{"name": "Lucky Find", "desc": "+15% chest loot", "effect": "chest_loot", "value": 0.15, "cost": 1},
				{"name": "Merchant's Eye", "desc": "+10% currency earn", "effect": "currency_earn", "value": 0.10, "cost": 2},
				{"name": "Deep Reading", "desc": "+20% XP gain", "effect": "xp_gain", "value": 0.20, "cost": 2},
				{"name": "Treasure Hunter", "desc": "+25% chest loot", "effect": "chest_loot", "value": 0.25, "cost": 3},
				{"name": "Speed Reading", "desc": "+15% XP gain", "effect": "xp_gain", "value": 0.15, "cost": 3},
				{"name": "Collector's Eye", "desc": "+15% currency earn", "effect": "currency_earn", "value": 0.15, "cost": 4},
				{"name": "Double Down", "desc": "+20% chest loot", "effect": "chest_loot", "value": 0.20, "cost": 4},
				{"name": "Inkwell Overflow", "desc": "+1 bonus Ink/5 lvls", "effect": "bonus_ink", "value": 1, "cost": 5},
			],
		},
		{
			"name": "Character Bonds",
			"desc": "Synergies",
			"color": Color(0.85, 0.65, 0.2),
			"nodes": [
				{"name": "Fellowship", "desc": "+5% synergy damage", "effect": "synergy_damage", "value": 0.05, "cost": 1},
				{"name": "Common Ground", "desc": "+3% synergy range", "effect": "synergy_range", "value": 0.03, "cost": 1},
				{"name": "Shared Stories", "desc": "Synergies +15%", "effect": "synergy_power", "value": 0.15, "cost": 2},
				{"name": "Bound by Ink", "desc": "+1 relic slot", "effect": "bonus_relic_slot", "value": 1, "cost": 2},
				{"name": "Literary Alliance", "desc": "Synergies +25%", "effect": "synergy_power", "value": 0.25, "cost": 3},
				{"name": "Heroic Assembly", "desc": "+10% dmg w/ 3+ towers", "effect": "army_damage", "value": 0.10, "cost": 3},
				{"name": "Sidekick Synergy", "desc": "Sidekicks +15%", "effect": "sidekick_power", "value": 0.15, "cost": 4},
				{"name": "Epic Crossover", "desc": "Cross-char relic equip", "effect": "cross_equip", "value": 1, "cost": 4},
				{"name": "Legend of the Tome", "desc": "+20% all w/ full team", "effect": "full_team_bonus", "value": 0.20, "cost": 5},
			],
		},
		{
			"name": "Dark Passages",
			"desc": "Enemy Debuffs",
			"color": Color(0.3, 0.55, 0.35),
			"nodes": [
				{"name": "Weakened Binding", "desc": "Enemies -3% HP", "effect": "enemy_hp_reduce", "value": 0.03, "cost": 1},
				{"name": "Slow Ink", "desc": "Enemies 3% slower", "effect": "enemy_slow", "value": 0.03, "cost": 1},
				{"name": "Paper Cuts", "desc": "1 dmg/sec bleed", "effect": "enemy_bleed", "value": 1.0, "cost": 2},
				{"name": "Fading Pages", "desc": "Enemies -5% armor", "effect": "enemy_armor_reduce", "value": 0.05, "cost": 2},
				{"name": "Rewrite the Script", "desc": "Bosses -5% HP", "effect": "boss_hp_reduce", "value": 0.05, "cost": 3},
				{"name": "Smudged Letters", "desc": "Enemies -5% HP", "effect": "enemy_hp_reduce", "value": 0.05, "cost": 3},
				{"name": "Torn Pages", "desc": "Enemies 5% slower", "effect": "enemy_slow", "value": 0.05, "cost": 4},
				{"name": "Erased Villains", "desc": "5% half HP spawn", "effect": "enemy_half_hp", "value": 0.05, "cost": 4},
				{"name": "Author's Edit", "desc": "Bosses -10% HP", "effect": "boss_hp_reduce", "value": 0.10, "cost": 5},
			],
		},
	]
	# Initialize knowledge_tree dict — ensure all branch/node keys exist
	for bi in range(knowledge_branches.size()):
		for ni in range(knowledge_branches[bi]["nodes"].size()):
			var key = "%d_%d" % [bi, ni]
			if not knowledge_tree.has(key):
				knowledge_tree[key] = false

func _init_equipped_relics() -> void:
	for t in survivor_types:
		if not equipped_relics.has(t):
			equipped_relics[t] = []

func _init_synergy_definitions() -> void:
	synergy_definitions = [
		{"name": "Merry Mischief", "tower_a": TowerType.ROBIN_HOOD, "tower_b": TowerType.PETER_PAN,
		 "buffs": {"damage": 0.15}, "desc": "Forest outlaws — +15% damage"},
		{"name": "Dark Enchantment", "tower_a": TowerType.WICKED_WITCH, "tower_b": TowerType.PHANTOM,
		 "buffs": {"range": 0.20}, "desc": "Dark magic amplifies — +20% range"},
		{"name": "Holiday Spirit", "tower_a": TowerType.SCROOGE, "tower_b": TowerType.ALICE,
		 "buffs": {"attack_speed": 0.15}, "desc": "Generosity meets wonder — +15% attack speed"},
		{"name": "Shadow Pact", "tower_a": TowerType.PHANTOM, "tower_b": TowerType.PETER_PAN,
		 "buffs": {"damage": 0.10, "range": 0.10}, "desc": "Shadow & the boy who won't grow up — +10% damage, +10% range"},
		{"name": "Cunning & Chaos", "tower_a": TowerType.ROBIN_HOOD, "tower_b": TowerType.WICKED_WITCH,
		 "buffs": {"gold_bonus": 0.25}, "desc": "Stealing meets hexing — +25% gold bonus"},
		{"name": "Storybook Alliance", "tower_a": TowerType.ALICE, "tower_b": TowerType.SCROOGE,
		 "buffs": {"attack_speed": 0.20}, "desc": "Imagination meets ambition — +20% attack speed"},
		# New character synergies
		{"name": "The Great Game", "tower_a": TowerType.SHERLOCK, "tower_b": TowerType.ROBIN_HOOD,
		 "buffs": {"damage": 0.20}, "desc": "Detective precision meets outlaw aim — +20% damage"},
		{"name": "Lords of the Wild", "tower_a": TowerType.TARZAN, "tower_b": TowerType.PETER_PAN,
		 "buffs": {"attack_speed": 0.20}, "desc": "Jungle king meets the boy who never grew up — +20% speed"},
		{"name": "Children of Darkness", "tower_a": TowerType.DRACULA, "tower_b": TowerType.PHANTOM,
		 "buffs": {"damage": 0.15, "range": 0.15}, "desc": "Two creatures of the night — +15% damage & range"},
		{"name": "Arcane Alliance", "tower_a": TowerType.MERLIN, "tower_b": TowerType.WICKED_WITCH,
		 "buffs": {"range": 0.25}, "desc": "Old magic amplifies green magic — +25% range"},
		{"name": "Tragic Souls", "tower_a": TowerType.FRANKENSTEIN, "tower_b": TowerType.SCROOGE,
		 "buffs": {"gold_bonus": 0.30}, "desc": "Redemption meets creation — +30% gold bonus"},
		{"name": "Deductive Darkness", "tower_a": TowerType.SHERLOCK, "tower_b": TowerType.DRACULA,
		 "buffs": {"damage": 0.15, "attack_speed": 0.10}, "desc": "Brilliant minds, dark methods — +15% damage, +10% speed"},
	]

func _init_achievement_definitions() -> void:
	achievement_definitions = [
		# Combat (8)
		{"id": "first_blood", "name": "First Blood", "desc": "Kill your first enemy", "category": "Combat", "target": 1, "reward_type": "shards", "reward_amount": 5},
		{"id": "centurion", "name": "Centurion", "desc": "Kill 100 enemies", "category": "Combat", "target": 100, "reward_type": "shards", "reward_amount": 20},
		{"id": "thousand_slayer", "name": "Thousand Slayer", "desc": "Kill 1000 enemies", "category": "Combat", "target": 1000, "reward_type": "quills", "reward_amount": 10, "trophy_bonus": 5},
		{"id": "untouchable", "name": "Untouchable", "desc": "Complete a level with 0 lives lost", "category": "Combat", "target": 1, "reward_type": "quills", "reward_amount": 5},
		{"id": "speed_demon", "name": "Speed Demon", "desc": "Complete a level entirely on fast-forward", "category": "Combat", "target": 1, "reward_type": "shards", "reward_amount": 15},
		{"id": "wave_master", "name": "Wave Master", "desc": "Complete 50 total waves", "category": "Combat", "target": 50, "reward_type": "shards", "reward_amount": 25},
		{"id": "flawless", "name": "Flawless Victory", "desc": "Earn 3 stars on any level", "category": "Combat", "target": 1, "reward_type": "quills", "reward_amount": 5},
		{"id": "perfect_campaign", "name": "Perfect Campaign", "desc": "Earn 3 stars on all 37 levels", "category": "Combat", "target": 37, "reward_type": "stars", "reward_amount": 5, "trophy_bonus": 15},
		# Tower (6)
		{"id": "novice_builder", "name": "Novice Builder", "desc": "Place 10 towers total", "category": "Tower", "target": 10, "reward_type": "shards", "reward_amount": 10},
		{"id": "master_builder", "name": "Master Builder", "desc": "Place 100 towers total", "category": "Tower", "target": 100, "reward_type": "quills", "reward_amount": 8},
		{"id": "max_power", "name": "Max Power", "desc": "Fully upgrade a tower (tier 4)", "category": "Tower", "target": 1, "reward_type": "shards", "reward_amount": 20},
		{"id": "full_roster", "name": "Full Roster", "desc": "Place all 6 tower types in one game", "category": "Tower", "target": 6, "reward_type": "quills", "reward_amount": 5},
		{"id": "synergy_seeker", "name": "Synergy Seeker", "desc": "Activate 1 tower synergy", "category": "Tower", "target": 1, "reward_type": "shards", "reward_amount": 15},
		{"id": "synergy_master", "name": "Synergy Master", "desc": "Activate all 6 synergies (across games)", "category": "Tower", "target": 6, "reward_type": "stars", "reward_amount": 3, "trophy_bonus": 10},
		# Economy (5)
		{"id": "penny_pincher", "name": "Penny Pincher", "desc": "Earn 500 gold total", "category": "Economy", "target": 500, "reward_type": "shards", "reward_amount": 10},
		{"id": "big_spender", "name": "Big Spender", "desc": "Spend 2000 gold total", "category": "Economy", "target": 2000, "reward_type": "quills", "reward_amount": 5},
		{"id": "emporium_regular", "name": "Emporium Regular", "desc": "Make 10 Emporium purchases", "category": "Economy", "target": 10, "reward_type": "shards", "reward_amount": 20},
		{"id": "chest_collector", "name": "Chest Collector", "desc": "Open 20 treasure chests", "category": "Economy", "target": 20, "reward_type": "quills", "reward_amount": 8},
		{"id": "knowledge_scholar", "name": "Knowledge Scholar", "desc": "Unlock 10 knowledge nodes", "category": "Economy", "target": 10, "reward_type": "stars", "reward_amount": 2},
		# Progression (6)
		{"id": "first_steps", "name": "First Steps", "desc": "Complete your first level", "category": "Progression", "target": 1, "reward_type": "shards", "reward_amount": 10},
		{"id": "halfway_there", "name": "Halfway There", "desc": "Complete 18 levels", "category": "Progression", "target": 18, "reward_type": "quills", "reward_amount": 10},
		{"id": "campaign_complete", "name": "Campaign Complete", "desc": "Complete all 37 levels", "category": "Progression", "target": 37, "reward_type": "stars", "reward_amount": 5, "trophy_bonus": 10},
		{"id": "veteran_survivor", "name": "Veteran Survivor", "desc": "Get any character to level 5", "category": "Progression", "target": 5, "reward_type": "shards", "reward_amount": 30},
		{"id": "master_survivor", "name": "Master Survivor", "desc": "Get any character to level 10", "category": "Progression", "target": 10, "reward_type": "quills", "reward_amount": 15, "trophy_bonus": 5},
		{"id": "daily_devotee", "name": "Daily Devotee", "desc": "Claim 7 daily rewards", "category": "Progression", "target": 7, "reward_type": "stars", "reward_amount": 2},
	]
	for ach in achievement_definitions:
		if not achievement_progress.has(ach["id"]):
			achievement_progress[ach["id"]] = 0
		if not achievements_unlocked.has(ach["id"]):
			achievements_unlocked[ach["id"]] = false

func _init_battle_power_definitions() -> void:
	battle_power_definitions = [
		{"id": "quill_strike", "name": "Quill Strike", "desc": "500 damage to all on-screen enemies", "icon": "quill", "cost_shards": 15},
		{"id": "golden_bounty", "name": "Golden Bounty", "desc": "+200 gold instantly", "icon": "gold", "cost_shards": 10},
		{"id": "storybook_shield", "name": "Storybook Shield", "desc": "Blocks next 10 life losses", "icon": "shield", "cost_shards": 25},
		{"id": "ink_freeze", "name": "Ink Freeze", "desc": "Freeze all enemies for 5 seconds", "icon": "ink", "cost_shards": 20},
		{"id": "chapter_skip", "name": "Chapter Skip", "desc": "Instantly completes current wave", "icon": "skip", "cost_shards": 30},
		{"id": "enchanted_towers", "name": "Enchanted Towers", "desc": "All towers +50% damage for 15s", "icon": "enchant", "cost_shards": 20},
	]
	for bp in battle_power_definitions:
		if not owned_powers.has(bp["id"]):
			owned_powers[bp["id"]] = 0

func _init_trophy_store_items() -> void:
	trophy_store_items = {
		"auras": [
			{"id": "aura_emerald", "name": "Emerald Aura", "desc": "Green glow ring around tower", "cost": 5, "color": Color(0.2, 0.9, 0.3, 0.3)},
			{"id": "aura_crimson", "name": "Crimson Aura", "desc": "Red glow ring around tower", "cost": 8, "color": Color(0.9, 0.2, 0.2, 0.3)},
			{"id": "aura_sapphire", "name": "Sapphire Aura", "desc": "Blue glow ring around tower", "cost": 8, "color": Color(0.2, 0.4, 0.95, 0.3)},
			{"id": "aura_golden", "name": "Golden Aura", "desc": "Gold glow ring around tower", "cost": 10, "color": Color(0.95, 0.8, 0.2, 0.3)},
			{"id": "aura_shadow", "name": "Shadow Aura", "desc": "Dark purple glow ring around tower", "cost": 12, "color": Color(0.5, 0.1, 0.8, 0.3)},
			{"id": "aura_prismatic", "name": "Prismatic Aura", "desc": "Rainbow shifting glow ring", "cost": 15, "color": Color(1, 1, 1, 0.3)},
		],
		"trails": [
			{"id": "trail_ink", "name": "Ink Splash", "desc": "Dark ink trail on projectiles", "cost": 10, "color": Color(0.1, 0.1, 0.2)},
			{"id": "trail_stardust", "name": "Stardust", "desc": "Sparkling star trail", "cost": 12, "color": Color(1.0, 0.9, 0.5)},
			{"id": "trail_fire", "name": "Fire Trail", "desc": "Fiery orange trail", "cost": 15, "color": Color(1.0, 0.4, 0.1)},
			{"id": "trail_frost", "name": "Frost Wake", "desc": "Icy blue trail", "cost": 20, "color": Color(0.5, 0.8, 1.0)},
		],
		"fanfares": [
			{"id": "fanfare_confetti", "name": "Confetti Burst", "desc": "Confetti on victory screen", "cost": 15},
			{"id": "fanfare_fireworks", "name": "Fireworks", "desc": "Fireworks on victory screen", "cost": 20},
			{"id": "fanfare_ovation", "name": "Standing Ovation", "desc": "Crowd applause on victory", "cost": 25},
		],
		"themes": [
			{"id": "theme_midnight", "name": "Midnight Library", "desc": "Deep blue menu theme", "cost": 20, "bg": Color(0.02, 0.02, 0.08), "accent": Color(0.4, 0.5, 0.9)},
			{"id": "theme_garden", "name": "Enchanted Garden", "desc": "Green & gold menu theme", "cost": 25, "bg": Color(0.03, 0.06, 0.03), "accent": Color(0.4, 0.8, 0.3)},
			{"id": "theme_crimson", "name": "Crimson Study", "desc": "Red & gold menu theme", "cost": 30, "bg": Color(0.08, 0.02, 0.02), "accent": Color(0.9, 0.3, 0.2)},
		],
	}

func _init_odyssey_maps() -> void:
	# Generate 3 maps based on current week number
	var date = Time.get_date_dict_from_system()
	var week_seed = date["year"] * 52 + (date["day"] + date["month"] * 31) / 7
	var rng = RandomNumberGenerator.new()
	rng.seed = week_seed
	odyssey_maps.clear()
	var available = range(levels.size())
	for i in range(3):
		var idx = rng.randi_range(0, available.size() - 1)
		odyssey_maps.append(available[idx])
		available.remove_at(idx)

# === TOWER SYNERGY SYSTEM ===
func _check_synergies() -> void:
	var placed_types: Dictionary = {}
	var tower_nodes: Dictionary = {}
	var script_to_type = {
		"robin_hood.gd": TowerType.ROBIN_HOOD,
		"alice.gd": TowerType.ALICE,
		"wicked_witch.gd": TowerType.WICKED_WITCH,
		"peter_pan.gd": TowerType.PETER_PAN,
		"phantom.gd": TowerType.PHANTOM,
		"scrooge.gd": TowerType.SCROOGE,
		"sherlock.gd": TowerType.SHERLOCK,
		"tarzan.gd": TowerType.TARZAN,
		"dracula.gd": TowerType.DRACULA,
		"merlin.gd": TowerType.MERLIN,
		"frankenstein.gd": TowerType.FRANKENSTEIN,
		"shadow_author.gd": TowerType.SHADOW_AUTHOR,
	}
	for tower in get_tree().get_nodes_in_group("towers"):
		var fname = tower.get_script().resource_path.get_file() if tower.get_script() else ""
		if script_to_type.has(fname):
			var tt = script_to_type[fname]
			placed_types[tt] = true
			tower_nodes[tt] = tower
	# Clear existing synergy buffs from all towers
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.has_method("clear_synergy_buff"):
			tower.clear_synergy_buff()
	var old_synergies = active_synergies.duplicate()
	active_synergies.clear()
	for syn in synergy_definitions:
		if placed_types.has(syn["tower_a"]) and placed_types.has(syn["tower_b"]):
			active_synergies.append(syn["name"])
			# Apply buffs to both towers
			if tower_nodes.has(syn["tower_a"]) and tower_nodes[syn["tower_a"]].has_method("set_synergy_buff"):
				tower_nodes[syn["tower_a"]].set_synergy_buff(syn["buffs"])
			if tower_nodes.has(syn["tower_b"]) and tower_nodes[syn["tower_b"]].has_method("set_synergy_buff"):
				tower_nodes[syn["tower_b"]].set_synergy_buff(syn["buffs"])
			# Show banner for newly activated synergies
			if not syn["name"] in old_synergies:
				synergy_banner_text = "SYNERGY: %s — %s" % [syn["name"], syn["desc"]]
				synergy_banner_timer = 3.0
				_check_achievement("synergy_seeker", 1)
	# Track unique synergies for synergy_master achievement
	_check_achievement("synergy_master", active_synergies.size())

# === ACHIEVEMENT SYSTEM ===
func _check_achievement(id: String, value = 1) -> void:
	if achievements_unlocked.get(id, false):
		return
	# Find the definition
	var def_data = null
	for ach in achievement_definitions:
		if ach["id"] == id:
			def_data = ach
			break
	if not def_data:
		return
	# Set or increment progress based on achievement type
	if id in ["synergy_master", "perfect_campaign", "full_roster"]:
		achievement_progress[id] = value
	else:
		achievement_progress[id] = achievement_progress.get(id, 0) + value
	# Check if target reached
	if achievement_progress[id] >= def_data["target"]:
		achievements_unlocked[id] = true
		# Grant reward
		match def_data["reward_type"]:
			"shards": player_relic_shards += def_data["reward_amount"]
			"quills": player_quills += def_data["reward_amount"]
			"stars": player_storybook_stars += def_data["reward_amount"]
		var trophy_bonus = def_data.get("trophy_bonus", 0)
		if trophy_bonus > 0:
			trophy_currency += trophy_bonus
		achievement_popup_text = "ACHIEVEMENT: %s" % def_data["name"]
		var reward_str = "+%d %s" % [def_data["reward_amount"], def_data["reward_type"].capitalize()]
		if trophy_bonus > 0:
			reward_str += " + %d Trophies" % trophy_bonus
		achievement_popup_reward = reward_str
		achievement_popup_timer = 3.0
		_save_game()

# === BATTLE POWER SYSTEM ===
func _activate_power(power_id: String) -> void:
	if shadow_arena_active and "no_powers" in shadow_arena_modifiers:
		info_label.text = "Powers disabled in Shadow Arena!"
		return
	if owned_powers.get(power_id, 0) <= 0:
		return
	owned_powers[power_id] -= 1
	_update_quest_progress("use_powers", 1)
	match power_id:
		"quill_strike":
			for enemy in get_tree().get_nodes_in_group("enemies"):
				if is_instance_valid(enemy) and enemy.has_method("take_damage"):
					enemy.take_damage(500.0)
		"golden_bounty":
			gold += 200
			update_hud()
		"storybook_shield":
			storybook_shield_charges += 10
		"ink_freeze":
			for enemy in get_tree().get_nodes_in_group("enemies"):
				if is_instance_valid(enemy):
					enemy.set("speed_multiplier", 0.0)
			active_power_effects["ink_freeze"] = 5.0
		"chapter_skip":
			# Kill all current enemies, stop spawning
			enemies_to_spawn = 0
			for enemy in get_tree().get_nodes_in_group("enemies"):
				if is_instance_valid(enemy):
					enemy.queue_free()
					enemies_alive -= 1
			_check_wave_complete()
		"enchanted_towers":
			power_enchanted_timer = 15.0
			active_power_effects["enchanted_towers"] = 15.0
			for tower in get_tree().get_nodes_in_group("towers"):
				if "power_damage_mult" in tower:
					tower.power_damage_mult = 1.5
	# Remove from selected if depleted
	_update_power_buttons()
	_save_game()

func _update_power_buttons() -> void:
	for i in range(battle_power_buttons.size()):
		if i < selected_powers.size():
			var pid = selected_powers[i]
			var count = owned_powers.get(pid, 0)
			var pname = ""
			for bp in battle_power_definitions:
				if bp["id"] == pid:
					pname = bp["name"]
					break
			battle_power_buttons[i].text = "%s (%d)" % [pname, count]
			battle_power_buttons[i].visible = true
			battle_power_buttons[i].disabled = count <= 0
		else:
			battle_power_buttons[i].visible = false

# === ODYSSEY MODE ===
func _start_odyssey() -> void:
	if odyssey_completed_this_week:
		return
	odyssey_active = true
	odyssey_current_map = 0
	odyssey_carry_lives = 25
	odyssey_carry_gold = 100
	odyssey_lives_at_start = 25
	# Start first map
	_start_odyssey_map(0)

func _start_odyssey_map(map_index: int) -> void:
	odyssey_current_map = map_index
	if map_index >= odyssey_maps.size():
		_odyssey_complete()
		return
	var level_idx = odyssey_maps[map_index]
	selected_difficulty = 1  # Medium difficulty for odyssey
	_remove_survivor_preview()
	current_level = level_idx
	_reset_game()
	var level = levels[level_idx]
	gold = odyssey_carry_gold
	lives = odyssey_carry_lives
	total_waves = 15  # Shorter waves for odyssey
	_setup_path_for_level(level_idx)
	_generate_decorations_for_level(level_idx)
	_stop_music()
	menu_overlay.visible = false
	top_bar.visible = true
	bottom_panel.visible = true
	game_over_label.visible = false
	return_button.visible = false
	game_state = GameState.PLAYING
	start_button.text = "  START WAVE  "
	# Base 6 towers always available
	var base_types = [TowerType.ROBIN_HOOD, TowerType.ALICE, TowerType.WICKED_WITCH,
					  TowerType.PETER_PAN, TowerType.PHANTOM, TowerType.SCROOGE]
	for tt in base_types:
		var tname = tower_info[tt]["name"]
		var short = tname.split(" ")[0] if tname.length() > 8 else tname
		tower_buttons[tt].text = "%s [%dG]" % [short, _get_discounted_cost(tt)]
		tower_buttons[tt].disabled = false
	# Unlockable characters — row 2, stretched horizontally
	var unlock_order = [TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA, TowerType.MERLIN, TowerType.FRANKENSTEIN, TowerType.SHADOW_AUTHOR]
	var ody_visible := 0
	for tt in unlock_order:
		if tower_buttons.has(tt):
			if tt in survivor_types and _is_character_unlocked(tt):
				var bx = 8 + ody_visible * 158
				tower_buttons[tt].position = Vector2(bx, 42)
				var tname = tower_info[tt]["name"]
				var short = tname.split(" ")[0] if tname.length() > 8 else tname
				tower_buttons[tt].text = "%s [%dG]" % [short, _get_discounted_cost(tt)]
				tower_buttons[tt].visible = true
				tower_buttons[tt].disabled = false
				ody_visible += 1
			else:
				tower_buttons[tt].visible = false
	# Panel height: 2 rows if unlocked chars, 1 row if not
	if ody_visible > 0:
		bottom_panel.size.y = 80
		bottom_panel.position.y = 720 - 80
	else:
		bottom_panel.size.y = 42
		bottom_panel.position.y = 720 - 42
	start_button.visible = true
	start_button.disabled = false
	speed_button.visible = true
	update_hud()
	info_label.text = "ODYSSEY %d/3 — %s" % [map_index + 1, level["name"]]
	wave_auto_timer = -1.0

func _odyssey_map_victory() -> void:
	# Save carry-over state
	odyssey_carry_lives = lives
	odyssey_carry_gold = gold
	odyssey_current_map += 1
	if odyssey_current_map >= 3:
		_odyssey_complete()
	else:
		odyssey_transition_active = true
		odyssey_transition_timer = 3.0

func _odyssey_complete() -> void:
	odyssey_active = false
	odyssey_completed_this_week = true
	# Award trophies based on remaining lives
	var trophy_reward = 10 + odyssey_carry_lives
	trophy_reward = clampi(trophy_reward, 10, 30)
	trophy_currency += trophy_reward
	game_over_label.text = "ODYSSEY COMPLETE! +%d Trophies" % trophy_reward
	game_over_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	game_over_label.visible = true
	return_button.visible = true
	_save_game()

func _odyssey_defeat() -> void:
	odyssey_active = false
	# Partial trophy reward
	var partial = 3 + odyssey_current_map * 3
	trophy_currency += partial
	game_over_label.text = "ODYSSEY FAILED — Map %d/3. +%d Trophies" % [odyssey_current_map + 1, partial]
	_save_game()

func _get_relic_slots(level: int) -> int:
	if level >= 10:
		return 5
	elif level >= 7:
		return 4
	elif level >= 4:
		return 3
	return 2

func get_equipped_relic_effects(tower_type) -> Array:
	var effects: Array = []
	if not equipped_relics.has(tower_type):
		return effects
	var char_relics_data = survivor_relics.get(tower_type, [])
	for ri in equipped_relics[tower_type]:
		if ri < char_relics_data.size():
			effects.append(char_relics_data[ri])
	return effects

func _get_knowledge_bonus(effect_type: String) -> float:
	var total: float = 0.0
	for bi in range(knowledge_branches.size()):
		var branch = knowledge_branches[bi]
		for ni in range(branch["nodes"].size()):
			var node = branch["nodes"][ni]
			if knowledge_tree.get("%d_%d" % [bi, ni], false) and node["effect"] == effect_type:
				total += node["value"]
	return total

func _save_game() -> void:
	var save_data: Dictionary = {}
	# Currencies
	save_data["player_quills"] = player_quills
	save_data["player_relic_shards"] = player_relic_shards
	save_data["player_storybook_stars"] = player_storybook_stars
	save_data["player_gold"] = player_gold
	save_data["gold"] = gold
	# Progress
	save_data["completed_levels"] = completed_levels
	var stars_save: Dictionary = {}
	for key in level_stars:
		stars_save[str(key)] = level_stars[key]
	save_data["level_stars"] = stars_save
	# Survivor progress (convert TowerType keys to strings)
	var sp_save: Dictionary = {}
	for t in survivor_progress:
		sp_save[str(t)] = survivor_progress[t]
	save_data["survivor_progress"] = sp_save
	# Equipped relics
	var eq_save: Dictionary = {}
	for t in equipped_relics:
		eq_save[str(t)] = equipped_relics[t]
	save_data["equipped_relics"] = eq_save
	# Knowledge tree
	save_data["knowledge_tree"] = knowledge_tree
	save_data["knowledge_ink"] = knowledge_ink
	# Treasure chests owned
	save_data["treasure_chests_owned"] = treasure_chests_owned
	# Daily rewards
	save_data["daily_streak"] = daily_streak
	save_data["daily_last_claim"] = daily_last_claim
	# Achievements
	save_data["achievement_progress"] = achievement_progress
	save_data["achievements_unlocked"] = achievements_unlocked
	save_data["total_towers_placed"] = total_towers_placed
	save_data["total_enemies_killed"] = total_enemies_killed
	save_data["total_gold_spent"] = total_gold_spent
	save_data["total_gold_earned"] = total_gold_earned
	save_data["total_emporium_purchases"] = total_emporium_purchases
	save_data["total_chests_opened"] = total_chests_opened
	save_data["total_knowledge_nodes"] = total_knowledge_nodes
	save_data["total_daily_claims"] = total_daily_claims
	# Battle powers
	save_data["owned_powers"] = owned_powers
	# Odyssey
	save_data["odyssey_completed_this_week"] = odyssey_completed_this_week
	save_data["trophy_currency"] = trophy_currency
	# Trophy store
	save_data["owned_cosmetics"] = owned_cosmetics
	save_data["equipped_cosmetics"] = equipped_cosmetics
	# Story progress
	save_data["story_seen"] = story_seen
	save_data["unlocked_characters"] = unlocked_characters
	# Endless mode
	save_data["endless_high_wave"] = endless_high_wave
	# Tome Bindings
	save_data["owned_bindings"] = owned_bindings
	var eq_bindings_save: Dictionary = {}
	for t in equipped_bindings:
		eq_bindings_save[str(t)] = equipped_bindings[t]
	save_data["equipped_bindings"] = eq_bindings_save
	# Synergy tracking for achievements
	var synergy_names_seen: Array = synergies_ever_activated.duplicate()
	for s in active_synergies:
		if not s in synergy_names_seen:
			synergy_names_seen.append(s)
	save_data["synergies_ever_activated"] = synergy_names_seen
	# === NEW FEATURE SAVES ===
	# Daily Deals
	save_data["daily_deals_date"] = daily_deals_date
	save_data["daily_deals_purchased"] = daily_deals_purchased
	# Shadow Arena
	save_data["shadow_arena_high_score"] = shadow_arena_high_score
	save_data["arena_crystals"] = arena_crystals
	# Quests
	save_data["active_quests"] = active_quests
	save_data["quest_last_refresh"] = quest_last_refresh
	save_data["total_quests_completed"] = total_quests_completed
	# Literary Instruments
	save_data["owned_instruments"] = owned_instruments
	# Settings
	save_data["auto_wave_enabled"] = auto_wave_enabled
	save_data["auto_wave_delay"] = auto_wave_delay
	# Save version
	save_data["save_version"] = SAVE_VERSION
	# Write file
	var file = FileAccess.open(_save_path, FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(save_data, "\t"))
		file.close()

func _load_game() -> void:
	if not FileAccess.file_exists(_save_path):
		return
	var file = FileAccess.open(_save_path, FileAccess.READ)
	if not file:
		return
	var text = file.get_as_text()
	file.close()
	var json = JSON.new()
	if json.parse(text) != OK:
		return
	var data = json.data
	if not data is Dictionary:
		return
	# Save migration: v1 (old 18 levels at 0-17) -> v2 (shifted to 16-33)
	var save_ver = int(data.get("save_version", 1))
	if save_ver < 2:
		var old_cl = data.get("completed_levels", [])
		var new_cl: Array = []
		for v in old_cl:
			var old_idx = int(v)
			if OLD_TO_NEW_LEVEL_MAP.has(old_idx):
				new_cl.append(OLD_TO_NEW_LEVEL_MAP[old_idx])
			else:
				new_cl.append(old_idx)
		data["completed_levels"] = new_cl
		var old_ls = data.get("level_stars", {})
		var new_ls: Dictionary = {}
		for key in old_ls:
			var old_idx = int(key)
			if OLD_TO_NEW_LEVEL_MAP.has(old_idx):
				new_ls[str(OLD_TO_NEW_LEVEL_MAP[old_idx])] = old_ls[key]
			else:
				new_ls[key] = old_ls[key]
		data["level_stars"] = new_ls
		# Remap story_seen dialog keys
		var old_ss = data.get("story_seen", [])
		var new_ss: Array = []
		for v in old_ss:
			var s = str(v)
			if s.begins_with("pre_level_") or s.begins_with("post_level_"):
				var parts = s.split("_")
				var old_idx = int(parts[parts.size() - 1])
				if OLD_TO_NEW_LEVEL_MAP.has(old_idx):
					var prefix = s.substr(0, s.rfind("_") + 1)
					new_ss.append(prefix + str(OLD_TO_NEW_LEVEL_MAP[old_idx]))
				else:
					new_ss.append(s)
			else:
				new_ss.append(s)
		data["story_seen"] = new_ss
		data["save_version"] = SAVE_VERSION
	# Currencies
	player_quills = int(data.get("player_quills", 0))
	player_relic_shards = int(data.get("player_relic_shards", 0))
	player_storybook_stars = int(data.get("player_storybook_stars", 0))
	player_gold = int(data.get("player_gold", 0))
	# Migrate old gold savings: if player_gold is 0 but old save had gold, transfer it
	if player_gold == 0 and data.has("gold") and int(data.get("gold", 0)) > 0:
		player_gold = int(data["gold"])
	gold = int(data.get("gold", gold))
	# Completed levels
	var cl = data.get("completed_levels", [])
	completed_levels.clear()
	for v in cl:
		completed_levels.append(int(v))
	# Level stars
	var ls = data.get("level_stars", {})
	level_stars.clear()
	for key in ls:
		level_stars[int(key)] = int(ls[key])
	# Survivor progress
	var sp = data.get("survivor_progress", {})
	for key in sp:
		var t = int(key)
		if survivor_progress.has(t):
			var saved = sp[key]
			var loaded_level = int(saved.get("level", 1))
			# Migration: cap level at MAX_SURVIVOR_LEVEL
			if loaded_level > MAX_SURVIVOR_LEVEL:
				loaded_level = MAX_SURVIVOR_LEVEL
			survivor_progress[t]["level"] = loaded_level
			survivor_progress[t]["xp"] = float(saved.get("xp", 0.0))
			# Migration: recalculate xp_next from new HERO_XP_TABLE instead of old 500*level
			survivor_progress[t]["xp_next"] = _get_xp_for_level(loaded_level)
			survivor_progress[t]["gear_unlocked"] = bool(saved.get("gear_unlocked", false))
			survivor_progress[t]["total_damage"] = float(saved.get("total_damage", 0.0))
			var sk = saved.get("sidekicks_unlocked", [false, false, false])
			for i in range(mini(sk.size(), 3)):
				survivor_progress[t]["sidekicks_unlocked"][i] = bool(sk[i])
			var rl = saved.get("relics_unlocked", [false, false, false, false, false, false])
			for i in range(mini(rl.size(), 6)):
				survivor_progress[t]["relics_unlocked"][i] = bool(rl[i])
			var ab = saved.get("abilities_unlocked", [])
			for i in range(mini(ab.size(), 9)):
				survivor_progress[t]["abilities_unlocked"][i] = bool(ab[i])
	# Equipped relics
	var eq = data.get("equipped_relics", {})
	for key in eq:
		var t = int(key)
		equipped_relics[t] = []
		for v in eq[key]:
			equipped_relics[t].append(int(v))
	# Knowledge tree
	var kt = data.get("knowledge_tree", {})
	for key in kt:
		knowledge_tree[key] = bool(kt[key])
	knowledge_ink = int(data.get("knowledge_ink", 0))
	# Treasure chests
	var tc = data.get("treasure_chests_owned", {"bronze": 0, "silver": 0, "gold": 0})
	treasure_chests_owned["bronze"] = int(tc.get("bronze", 0))
	treasure_chests_owned["silver"] = int(tc.get("silver", 0))
	treasure_chests_owned["gold"] = int(tc.get("gold", 0))
	# Daily rewards
	daily_streak = int(data.get("daily_streak", 0))
	daily_last_claim = str(data.get("daily_last_claim", ""))
	# Achievements
	var ap = data.get("achievement_progress", {})
	for key in ap:
		achievement_progress[key] = int(ap[key])
	var au = data.get("achievements_unlocked", {})
	for key in au:
		achievements_unlocked[key] = bool(au[key])
	total_towers_placed = int(data.get("total_towers_placed", 0))
	total_enemies_killed = int(data.get("total_enemies_killed", 0))
	total_gold_spent = int(data.get("total_gold_spent", 0))
	total_gold_earned = int(data.get("total_gold_earned", 0))
	total_emporium_purchases = int(data.get("total_emporium_purchases", 0))
	total_chests_opened = int(data.get("total_chests_opened", 0))
	total_knowledge_nodes = int(data.get("total_knowledge_nodes", 0))
	total_daily_claims = int(data.get("total_daily_claims", 0))
	# Battle powers
	var op = data.get("owned_powers", {})
	for key in op:
		owned_powers[key] = int(op[key])
	# Odyssey
	odyssey_completed_this_week = bool(data.get("odyssey_completed_this_week", false))
	trophy_currency = int(data.get("trophy_currency", 0))
	# Trophy store
	var oc = data.get("owned_cosmetics", [])
	owned_cosmetics.clear()
	for v in oc:
		owned_cosmetics.append(str(v))
	var ec = data.get("equipped_cosmetics", {})
	equipped_cosmetics.clear()
	for key in ec:
		equipped_cosmetics[key] = str(ec[key])
	# Story progress
	var ss = data.get("story_seen", [])
	story_seen.clear()
	for v in ss:
		story_seen.append(str(v))
	var uc = data.get("unlocked_characters", [])
	unlocked_characters.clear()
	for v in uc:
		unlocked_characters.append(str(v))
	# Endless mode
	endless_high_wave = int(data.get("endless_high_wave", 0))
	# Tome Bindings
	var ob = data.get("owned_bindings", {})
	owned_bindings.clear()
	for key in ob:
		owned_bindings[key] = int(ob[key])
	var eb = data.get("equipped_bindings", {})
	equipped_bindings.clear()
	for key in eb:
		var t = int(key)
		equipped_bindings[t] = []
		for v in eb[key]:
			equipped_bindings[t].append(str(v))
	# === LOAD NEW FEATURE DATA ===
	# Daily Deals
	daily_deals_date = str(data.get("daily_deals_date", ""))
	var ddp = data.get("daily_deals_purchased", [false, false, false])
	daily_deals_purchased = []
	for v in ddp:
		daily_deals_purchased.append(bool(v))
	while daily_deals_purchased.size() < 3:
		daily_deals_purchased.append(false)
	# Shadow Arena
	shadow_arena_high_score = int(data.get("shadow_arena_high_score", 0))
	arena_crystals = int(data.get("arena_crystals", 0))
	# Quests
	var aq = data.get("active_quests", [])
	active_quests.clear()
	for q in aq:
		active_quests.append(q)
	quest_last_refresh = str(data.get("quest_last_refresh", ""))
	total_quests_completed = int(data.get("total_quests_completed", 0))
	# Synergy tracking
	var sea = data.get("synergies_ever_activated", [])
	synergies_ever_activated.clear()
	for v in sea:
		synergies_ever_activated.append(str(v))
	# Literary Instruments
	var oi = data.get("owned_instruments", {})
	owned_instruments.clear()
	for key in oi:
		owned_instruments[key] = int(oi[key])
	# Settings
	auto_wave_enabled = data.get("auto_wave_enabled", true)
	auto_wave_delay = data.get("auto_wave_delay", 2.0)
	# Golden Shields migration — ensure existing progress has the field
	for t in survivor_progress:
		if not survivor_progress[t].has("golden_shields"):
			survivor_progress[t]["golden_shields"] = 0
		if not survivor_progress[t].has("upgrade_branch"):
			survivor_progress[t]["upgrade_branch"] = ""
	# Refresh unlocked survivors into the active roster
	_refresh_unlocked_survivors()
	# Check if prologue should be triggered on first load
	if story_seen.size() == 0 and story_dialogs.has("prologue"):
		call_deferred("_start_story_dialog", "prologue")

func _cache_path_points() -> void:
	var curve = enemy_path.curve
	if not curve:
		return
	var length = curve.get_baked_length()
	for i in range(0, int(length), 6):
		path_points.append(curve.sample_baked(float(i)))

func _cache_path_thumbnails() -> void:
	_path_thumbnail_cache.clear()
	var curve = enemy_path.curve
	if not curve:
		return
	for idx in range(levels.size()):
		curve.clear_points()
		_setup_path_for_level(idx)
		var length = curve.get_baked_length()
		var pts: PackedVector2Array = PackedVector2Array()
		var step = maxi(int(length / 40.0), 10)
		for i in range(0, int(length), step):
			pts.append(curve.sample_baked(float(i)))
		if length > 0:
			pts.append(curve.sample_baked(length))
		_path_thumbnail_cache[idx] = pts
	# Restore current level path
	_setup_path_for_level(current_level)

func _generate_decorations_for_level(index: int) -> void:
	_decorations.clear()
	var rng = RandomNumberGenerator.new()
	rng.seed = 42 + index

	match index:
		0: # Prologue — Into the Pages
			for i in range(20):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "torn_page", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0, TAU)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 610))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "ink_puddle", "size": rng.randf_range(10, 20), "extra": rng.randf_range(0, 1)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(100, 560))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "quill", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "shadow_wisp", "size": rng.randf_range(4, 10), "extra": rng.randf_range(0, TAU)})
		1: # Sherlock Ch1 — Baker Street
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "gaslight", "size": rng.randf_range(16, 28), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "magnifying_glass", "size": rng.randf_range(6, 12), "extra": 0.0})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "footprint", "size": rng.randf_range(3, 6), "extra": rng.randf_range(0, TAU)})
			for i in range(5):
				var pos = Vector2(rng.randf_range(100, 1180), rng.randf_range(120, 550))
				if _dist_to_path(pos) > 65.0:
					_decorations.append({"pos": pos, "type": "pipe", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, 1)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "fog_patch", "size": rng.randf_range(20, 40), "extra": rng.randf_range(0, 1)})
		2: # Sherlock Ch2 — Whitechapel
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.25:
						_decorations.append({"pos": pos, "type": "gaslight", "size": rng.randf_range(18, 30), "extra": rng.randf_range(0, TAU)})
					elif r < 0.45:
						_decorations.append({"pos": pos, "type": "magnifying_glass", "size": rng.randf_range(7, 13), "extra": 0.0})
					elif r < 0.65:
						_decorations.append({"pos": pos, "type": "footprint", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, TAU)})
					elif r < 0.82:
						_decorations.append({"pos": pos, "type": "pipe", "size": rng.randf_range(5, 11), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "fog_patch", "size": rng.randf_range(22, 44), "extra": rng.randf_range(0, 1)})
		3: # Sherlock Ch3 — Reichenbach
			for i in range(40):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.25:
						_decorations.append({"pos": pos, "type": "gaslight", "size": rng.randf_range(18, 32), "extra": rng.randf_range(0, TAU)})
					elif r < 0.45:
						_decorations.append({"pos": pos, "type": "magnifying_glass", "size": rng.randf_range(7, 14), "extra": 0.0})
					elif r < 0.65:
						_decorations.append({"pos": pos, "type": "footprint", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
					elif r < 0.82:
						_decorations.append({"pos": pos, "type": "pipe", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "fog_patch", "size": rng.randf_range(24, 48), "extra": rng.randf_range(0, 1)})
		4: # Merlin Ch1 — Round Table
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "standing_stone", "size": rng.randf_range(14, 28), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "crystal_orb", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "ancient_rune", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 560))
				if _dist_to_path(pos) > 65.0:
					_decorations.append({"pos": pos, "type": "celtic_tree", "size": rng.randf_range(16, 30), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 610))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, 1)})
		5: # Merlin Ch2 — Enchanted Forest
			for i in range(38):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "standing_stone", "size": rng.randf_range(15, 30), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.4:
						_decorations.append({"pos": pos, "type": "crystal_orb", "size": rng.randf_range(7, 14), "extra": rng.randf_range(0, TAU)})
					elif r < 0.6:
						_decorations.append({"pos": pos, "type": "ancient_rune", "size": rng.randf_range(5, 9), "extra": rng.randf_range(0, TAU)})
					elif r < 0.8:
						_decorations.append({"pos": pos, "type": "celtic_tree", "size": rng.randf_range(18, 34), "extra": rng.randf_range(-0.04, 0.04)})
					else:
						_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, 1)})
		6: # Merlin Ch3 — Crystal Cave
			for i in range(44):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "standing_stone", "size": rng.randf_range(16, 32), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.45:
						_decorations.append({"pos": pos, "type": "crystal_orb", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0, TAU)})
					elif r < 0.65:
						_decorations.append({"pos": pos, "type": "ancient_rune", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
					elif r < 0.82:
						_decorations.append({"pos": pos, "type": "celtic_tree", "size": rng.randf_range(18, 36), "extra": rng.randf_range(-0.04, 0.04)})
					else:
						_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0, 1)})
		7: # Tarzan Ch1 — Jungle Canopy
			for i in range(20):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(16, 32), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(15):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 610))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "vine", "size": rng.randf_range(10, 24), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "exotic_flower", "size": rng.randf_range(4, 10), "extra": rng.randf_range(0, 1)})
			for i in range(4):
				var pos = Vector2(rng.randf_range(100, 1180), rng.randf_range(120, 550))
				if _dist_to_path(pos) > 65.0:
					_decorations.append({"pos": pos, "type": "parrot", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
		8: # Tarzan Ch2 — Elephant Graveyard
			for i in range(36):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.25:
						_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(18, 34), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.45:
						_decorations.append({"pos": pos, "type": "vine", "size": rng.randf_range(12, 26), "extra": rng.randf_range(0, TAU)})
					elif r < 0.65:
						_decorations.append({"pos": pos, "type": "exotic_flower", "size": rng.randf_range(5, 11), "extra": rng.randf_range(0, 1)})
					elif r < 0.82:
						_decorations.append({"pos": pos, "type": "barrel", "size": rng.randf_range(8, 14), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "parrot", "size": rng.randf_range(5, 11), "extra": rng.randf_range(0, TAU)})
		9: # Tarzan Ch3 — Clayton's Fortress
			for i in range(42):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.22:
						_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(18, 36), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.42:
						_decorations.append({"pos": pos, "type": "vine", "size": rng.randf_range(12, 28), "extra": rng.randf_range(0, TAU)})
					elif r < 0.6:
						_decorations.append({"pos": pos, "type": "exotic_flower", "size": rng.randf_range(5, 12), "extra": rng.randf_range(0, 1)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "barrel", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "parrot", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
		10: # Dracula Ch1 — Village
			for i in range(12):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "dead_tree", "size": rng.randf_range(16, 30), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "cross_headstone", "size": rng.randf_range(8, 16), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 560))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "garlic_braid", "size": rng.randf_range(5, 10), "extra": 0.0})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "bat_swarm", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, TAU)})
			for i in range(4):
				var pos = Vector2(rng.randf_range(100, 1180), rng.randf_range(150, 520))
				if _dist_to_path(pos) > 70.0:
					_decorations.append({"pos": pos, "type": "coffin", "size": rng.randf_range(10, 18), "extra": rng.randf_range(0, TAU)})
		11: # Dracula Ch2 — Castle
			for i in range(36):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "dead_tree", "size": rng.randf_range(18, 32), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.4:
						_decorations.append({"pos": pos, "type": "cross_headstone", "size": rng.randf_range(9, 18), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.56:
						_decorations.append({"pos": pos, "type": "garlic_braid", "size": rng.randf_range(5, 11), "extra": 0.0})
					elif r < 0.76:
						_decorations.append({"pos": pos, "type": "bat_swarm", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "coffin", "size": rng.randf_range(11, 20), "extra": rng.randf_range(0, TAU)})
		12: # Dracula Ch3 — Crypt
			for i in range(44):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "dead_tree", "size": rng.randf_range(18, 34), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.4:
						_decorations.append({"pos": pos, "type": "cross_headstone", "size": rng.randf_range(10, 20), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.56:
						_decorations.append({"pos": pos, "type": "garlic_braid", "size": rng.randf_range(6, 12), "extra": 0.0})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "bat_swarm", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "coffin", "size": rng.randf_range(12, 22), "extra": rng.randf_range(0, TAU)})
		13: # Frankenstein Ch1 — Lab
			for i in range(10):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "tesla_coil", "size": rng.randf_range(14, 24), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "beaker", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, 1)})
			for i in range(10):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "gear", "size": rng.randf_range(6, 14), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 560))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "stitch_mark", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
		14: # Frankenstein Ch2 — Village
			for i in range(36):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.25:
						_decorations.append({"pos": pos, "type": "tesla_coil", "size": rng.randf_range(15, 26), "extra": rng.randf_range(0, TAU)})
					elif r < 0.5:
						_decorations.append({"pos": pos, "type": "beaker", "size": rng.randf_range(7, 14), "extra": rng.randf_range(0, 1)})
					elif r < 0.72:
						_decorations.append({"pos": pos, "type": "gear", "size": rng.randf_range(7, 15), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "stitch_mark", "size": rng.randf_range(5, 9), "extra": rng.randf_range(0, TAU)})
		15: # Frankenstein Ch3 — Arctic
			for i in range(42):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.2:
						_decorations.append({"pos": pos, "type": "tesla_coil", "size": rng.randf_range(16, 28), "extra": rng.randf_range(0, TAU)})
					elif r < 0.4:
						_decorations.append({"pos": pos, "type": "beaker", "size": rng.randf_range(7, 15), "extra": rng.randf_range(0, 1)})
					elif r < 0.58:
						_decorations.append({"pos": pos, "type": "gear", "size": rng.randf_range(7, 16), "extra": rng.randf_range(0, TAU)})
					elif r < 0.76:
						_decorations.append({"pos": pos, "type": "stitch_mark", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "snowflake", "size": rng.randf_range(3, 8), "extra": rng.randf_range(0, TAU)})
		16: # Robin Hood Ch1 — Sherwood Forest
			for i in range(30):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "oak_tree", "size": rng.randf_range(14, 32), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 70.0:
					_decorations.append({"pos": pos, "type": "target", "size": rng.randf_range(6, 10), "extra": 0.0})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "bush", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0.0, 1.0)})
			for i in range(4):
				var pos = Vector2(rng.randf_range(100, 1100), rng.randf_range(200, 550))
				if _dist_to_path(pos) > 80.0:
					_decorations.append({"pos": pos, "type": "deer", "size": rng.randf_range(10, 16), "extra": rng.randf_range(0, TAU)})
			for i in range(2):
				var pos = Vector2(rng.randf_range(200, 1000), rng.randf_range(150, 500))
				if _dist_to_path(pos) > 90.0:
					_decorations.append({"pos": pos, "type": "campfire", "size": 12.0, "extra": rng.randf_range(0, TAU)})
		17: # Robin Hood Ch2 — Sheriff's Pursuit
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "oak_tree", "size": rng.randf_range(16, 34), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.5:
						_decorations.append({"pos": pos, "type": "target", "size": rng.randf_range(7, 11), "extra": 0.0})
					elif r < 0.7:
						_decorations.append({"pos": pos, "type": "bush", "size": rng.randf_range(9, 18), "extra": rng.randf_range(0.0, 1.0)})
					elif r < 0.85:
						_decorations.append({"pos": pos, "type": "deer", "size": rng.randf_range(10, 17), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "campfire", "size": rng.randf_range(11, 14), "extra": rng.randf_range(0, TAU)})
		18: # Robin Hood Ch3 — Siege of Nottingham
			for i in range(45):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.28:
						_decorations.append({"pos": pos, "type": "oak_tree", "size": rng.randf_range(18, 38), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.46:
						_decorations.append({"pos": pos, "type": "target", "size": rng.randf_range(7, 12), "extra": 0.0})
					elif r < 0.64:
						_decorations.append({"pos": pos, "type": "bush", "size": rng.randf_range(10, 20), "extra": rng.randf_range(0.0, 1.0)})
					elif r < 0.8:
						_decorations.append({"pos": pos, "type": "deer", "size": rng.randf_range(10, 18), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "campfire", "size": rng.randf_range(12, 16), "extra": rng.randf_range(0, TAU)})
		19: # Alice Ch1 — Down the Rabbit Hole
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "giant_mushroom", "size": rng.randf_range(10, 24), "extra": rng.randf_range(0.0, 1.0)})
			for i in range(10):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 300))
				_decorations.append({"pos": pos, "type": "floating_card", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(100, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0.0, 1.0)})
			for i in range(5):
				var pos = Vector2(rng.randf_range(50, 1230), rng.randf_range(80, 560))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "teacup", "size": rng.randf_range(6, 10), "extra": 0.0})
		20: # Alice Ch2 — Mad Tea Party
			for i in range(30):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "giant_mushroom", "size": rng.randf_range(12, 26), "extra": rng.randf_range(0.0, 1.0)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "floating_card", "size": rng.randf_range(7, 13), "extra": rng.randf_range(0, TAU)})
					elif r < 0.8:
						_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0.0, 1.0)})
					else:
						_decorations.append({"pos": pos, "type": "teacup", "size": rng.randf_range(6, 11), "extra": 0.0})
		21: # Alice Ch3 — Queen's Court
			for i in range(40):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "giant_mushroom", "size": rng.randf_range(14, 30), "extra": rng.randf_range(0.0, 1.0)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "floating_card", "size": rng.randf_range(7, 14), "extra": rng.randf_range(0, TAU)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0.0, 1.0)})
					else:
						_decorations.append({"pos": pos, "type": "teacup", "size": rng.randf_range(7, 12), "extra": 0.0})
		22: # Oz Ch1 — Yellow Brick Road
			for i in range(25):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(100, 620))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "poppy", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "emerald_crystal", "size": rng.randf_range(5, 12), "extra": rng.randf_range(0, TAU)})
			for i in range(4):
				var pos = Vector2(rng.randf_range(100, 1100), rng.randf_range(150, 550))
				if _dist_to_path(pos) > 70.0:
					_decorations.append({"pos": pos, "type": "scarecrow", "size": rng.randf_range(12, 18), "extra": 0.0})
		23: # Oz Ch2 — Witch's Domain
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.4:
						_decorations.append({"pos": pos, "type": "poppy", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
					elif r < 0.7:
						_decorations.append({"pos": pos, "type": "emerald_crystal", "size": rng.randf_range(6, 14), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "scarecrow", "size": rng.randf_range(13, 19), "extra": 0.0})
		24: # Oz Ch3 — Emerald Throne
			for i in range(48):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.38:
						_decorations.append({"pos": pos, "type": "poppy", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0, TAU)})
					elif r < 0.72:
						_decorations.append({"pos": pos, "type": "emerald_crystal", "size": rng.randf_range(6, 16), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "scarecrow", "size": rng.randf_range(12, 20), "extra": 0.0})
		25: # Peter Pan Ch1 — Flight to Neverland
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(14, 30), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "fairy", "size": 2.0, "extra": rng.randf_range(0, TAU)})
			for i in range(18):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(60, 615))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(3, 7), "extra": rng.randf_range(0, 1)})
			for i in range(25):
				var pos = Vector2(rng.randf_range(10, 1270), rng.randf_range(52, 180))
				_decorations.append({"pos": pos, "type": "star", "size": rng.randf_range(0.3, 0.8), "extra": rng.randf_range(0, TAU)})
		26: # Peter Pan Ch2 — Lost Boys' Stand
			for i in range(35):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(15, 32), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.5:
						_decorations.append({"pos": pos, "type": "fairy", "size": 2.0, "extra": rng.randf_range(0, TAU)})
					elif r < 0.75:
						_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(3, 8), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "star", "size": rng.randf_range(0.3, 0.9), "extra": rng.randf_range(0, TAU)})
		27: # Peter Pan Ch3 — The Jolly Roger
			for i in range(46):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.28:
						_decorations.append({"pos": pos, "type": "jungle_tree", "size": rng.randf_range(16, 36), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.5:
						_decorations.append({"pos": pos, "type": "fairy", "size": 2.0, "extra": rng.randf_range(0, TAU)})
					elif r < 0.75:
						_decorations.append({"pos": pos, "type": "mushroom", "size": rng.randf_range(4, 9), "extra": rng.randf_range(0, 1)})
					else:
						_decorations.append({"pos": pos, "type": "star", "size": rng.randf_range(0.4, 1.0), "extra": rng.randf_range(0, TAU)})
		28: # Phantom Ch1 — Grand Stage
			for i in range(10):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "candelabra", "size": rng.randf_range(8, 14), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 500))
				if _dist_to_path(pos) > 65.0:
					_decorations.append({"pos": pos, "type": "mirror", "size": rng.randf_range(10, 18), "extra": rng.randf_range(0, TAU)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(3, 6), "extra": rng.randf_range(0.0, 1.0)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(60, 400))
				_decorations.append({"pos": pos, "type": "sheet_music", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, TAU)})
		29: # Phantom Ch2 — Labyrinth
			for i in range(32):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "candelabra", "size": rng.randf_range(9, 16), "extra": rng.randf_range(0, TAU)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "mirror", "size": rng.randf_range(11, 20), "extra": rng.randf_range(0, TAU)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(4, 7), "extra": rng.randf_range(0.0, 1.0)})
					else:
						_decorations.append({"pos": pos, "type": "sheet_music", "size": rng.randf_range(5, 9), "extra": rng.randf_range(0, TAU)})
		30: # Phantom Ch3 — Phantom's Lair
			for i in range(42):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "candelabra", "size": rng.randf_range(10, 18), "extra": rng.randf_range(0, TAU)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "mirror", "size": rng.randf_range(12, 22), "extra": rng.randf_range(0, TAU)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "rose", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0.0, 1.0)})
					else:
						_decorations.append({"pos": pos, "type": "sheet_music", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
		31: # Scrooge Ch1 — Christmas Eve
			for i in range(12):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 560))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "lamp_post", "size": rng.randf_range(20, 30), "extra": rng.randf_range(0, TAU)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(40, 1240), rng.randf_range(80, 600))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "bare_tree", "size": rng.randf_range(14, 26), "extra": rng.randf_range(-0.04, 0.04)})
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(100, 620))
				if _dist_to_path(pos) > 45.0:
					_decorations.append({"pos": pos, "type": "snow_pile", "size": rng.randf_range(5, 12), "extra": 0.0})
			for i in range(6):
				var pos = Vector2(rng.randf_range(100, 1180), rng.randf_range(150, 500))
				if _dist_to_path(pos) > 70.0:
					_decorations.append({"pos": pos, "type": "chimney", "size": rng.randf_range(8, 14), "extra": rng.randf_range(0, TAU)})
		32: # Scrooge Ch2 — Three Spirits
			for i in range(33):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 60.0:
					var r = rng.randf()
					if r < 0.28:
						_decorations.append({"pos": pos, "type": "lamp_post", "size": rng.randf_range(21, 32), "extra": rng.randf_range(0, TAU)})
					elif r < 0.52:
						_decorations.append({"pos": pos, "type": "bare_tree", "size": rng.randf_range(15, 28), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.76:
						_decorations.append({"pos": pos, "type": "snow_pile", "size": rng.randf_range(6, 14), "extra": 0.0})
					else:
						_decorations.append({"pos": pos, "type": "chimney", "size": rng.randf_range(9, 15), "extra": rng.randf_range(0, TAU)})
		33: # Scrooge Ch3 — Redemption's Dawn
			for i in range(44):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.27:
						_decorations.append({"pos": pos, "type": "lamp_post", "size": rng.randf_range(22, 35), "extra": rng.randf_range(0, TAU)})
					elif r < 0.52:
						_decorations.append({"pos": pos, "type": "bare_tree", "size": rng.randf_range(16, 32), "extra": rng.randf_range(-0.04, 0.04)})
					elif r < 0.76:
						_decorations.append({"pos": pos, "type": "snow_pile", "size": rng.randf_range(7, 16), "extra": 0.0})
					else:
						_decorations.append({"pos": pos, "type": "chimney", "size": rng.randf_range(9, 17), "extra": rng.randf_range(0, TAU)})
		34: # Shadow Author Ch1 — Ink Realm
			for i in range(15):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "open_book", "size": rng.randf_range(8, 16), "extra": rng.randf_range(0, TAU)})
			for i in range(12):
				var pos = Vector2(rng.randf_range(30, 1250), rng.randf_range(60, 610))
				if _dist_to_path(pos) > 50.0:
					_decorations.append({"pos": pos, "type": "dripping_ink", "size": rng.randf_range(6, 14), "extra": rng.randf_range(0, 1)})
			for i in range(8):
				var pos = Vector2(rng.randf_range(60, 1220), rng.randf_range(100, 580))
				if _dist_to_path(pos) > 55.0:
					_decorations.append({"pos": pos, "type": "broken_quill", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, TAU)})
			for i in range(6):
				var pos = Vector2(rng.randf_range(80, 1200), rng.randf_range(120, 560))
				if _dist_to_path(pos) > 60.0:
					_decorations.append({"pos": pos, "type": "chapter_marker", "size": rng.randf_range(4, 8), "extra": rng.randf_range(0, 1)})
		35: # Shadow Author Ch2 — Unwritten Pages
			for i in range(38):
				var pos = Vector2(rng.randf_range(20, 1260), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 55.0:
					var r = rng.randf()
					if r < 0.3:
						_decorations.append({"pos": pos, "type": "open_book", "size": rng.randf_range(9, 18), "extra": rng.randf_range(0, TAU)})
					elif r < 0.55:
						_decorations.append({"pos": pos, "type": "dripping_ink", "size": rng.randf_range(7, 16), "extra": rng.randf_range(0, 1)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "broken_quill", "size": rng.randf_range(6, 12), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "chapter_marker", "size": rng.randf_range(5, 10), "extra": rng.randf_range(0, 1)})
		36: # Shadow Author Ch3 — Final Chapter
			for i in range(46):
				var pos = Vector2(rng.randf_range(15, 1265), rng.randf_range(55, 620))
				if _dist_to_path(pos) > 50.0:
					var r = rng.randf()
					if r < 0.28:
						_decorations.append({"pos": pos, "type": "open_book", "size": rng.randf_range(10, 20), "extra": rng.randf_range(0, TAU)})
					elif r < 0.54:
						_decorations.append({"pos": pos, "type": "dripping_ink", "size": rng.randf_range(8, 18), "extra": rng.randf_range(0, 1)})
					elif r < 0.78:
						_decorations.append({"pos": pos, "type": "broken_quill", "size": rng.randf_range(6, 14), "extra": rng.randf_range(0, TAU)})
					else:
						_decorations.append({"pos": pos, "type": "chapter_marker", "size": rng.randf_range(5, 12), "extra": rng.randf_range(0, 1)})

func _create_ui() -> void:
	var ui = $UI

	# Top bar (dark wood / pirate ship plank style)
	top_bar = ColorRect.new()
	top_bar.color = Color(0.12, 0.08, 0.05, 0.9)
	top_bar.position = Vector2(0, 0)
	top_bar.size = Vector2(1280, 50)
	ui.add_child(top_bar)

	wave_label = Label.new()
	wave_label.position = Vector2(16, 8)
	wave_label.add_theme_font_size_override("font_size", 24)
	wave_label.add_theme_constant_override("shadow_offset_x", 1)
	wave_label.add_theme_constant_override("shadow_offset_y", 2)
	wave_label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.6))
	top_bar.add_child(wave_label)

	gold_label = Label.new()
	gold_label.position = Vector2(200, 8)
	gold_label.add_theme_font_size_override("font_size", 24)
	gold_label.add_theme_color_override("font_color", Color(1.0, 0.84, 0.0))
	gold_label.add_theme_constant_override("shadow_offset_x", 1)
	gold_label.add_theme_constant_override("shadow_offset_y", 2)
	gold_label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.6))
	top_bar.add_child(gold_label)

	lives_label = Label.new()
	lives_label.position = Vector2(370, 8)
	lives_label.add_theme_font_size_override("font_size", 24)
	lives_label.add_theme_color_override("font_color", Color(1.0, 0.39, 0.28))
	lives_label.add_theme_constant_override("shadow_offset_x", 1)
	lives_label.add_theme_constant_override("shadow_offset_y", 2)
	lives_label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.6))
	top_bar.add_child(lives_label)

	menu_exit_button = Button.new()
	menu_exit_button.text = "  MENU  "
	menu_exit_button.position = Vector2(1180, 6)
	menu_exit_button.custom_minimum_size = Vector2(88, 38)
	menu_exit_button.pressed.connect(_show_menu)
	top_bar.add_child(menu_exit_button)

	# Bottom panel
	bottom_panel = ColorRect.new()
	bottom_panel.color = Color(0.12, 0.08, 0.05, 0.9)
	bottom_panel.position = Vector2(0, 628)
	bottom_panel.size = Vector2(1280, 92)
	bottom_panel.clip_contents = true
	ui.add_child(bottom_panel)

	var btn_h = 40
	var row1_y = 2
	var row2_y = 46
	var btn_w = 152

	# Row 1: Base 6 towers stretched across
	var base_towers = [
		[TowerType.ROBIN_HOOD, "Robin [75G]", "Robin Hood — long range archer, gold bonus."],
		[TowerType.ALICE, "Alice [85G]", "Alice — cake, slows enemies in area."],
		[TowerType.WICKED_WITCH, "Witch [100G]", "Wicked Witch — eye blast, wolves."],
		[TowerType.PETER_PAN, "Peter [90G]", "Peter Pan — fast daggers, shadow."],
		[TowerType.PHANTOM, "Phantom [95G]", "Phantom — heavy hits, stun, chandelier."],
		[TowerType.SCROOGE, "Scrooge [60G]", "Scrooge — bell, knockback & gold gen."],
	]
	for i in range(base_towers.size()):
		var bt = base_towers[i]
		var bx = 8 + i * (btn_w + 6)
		var btn = _make_button(bt[1], Vector2(bx, row1_y), Vector2(btn_w, btn_h))
		btn.pressed.connect(_on_tower_pressed.bind(bt[0], bt[2] + " Cancel to abort."))
		bottom_panel.add_child(btn)
		tower_buttons[bt[0]] = btn

	# Row 2: Unlockable characters stretched across (hidden until unlocked)
	var new_chars = [
		[TowerType.SHERLOCK, "Holmes [110G]", "Sherlock — focus beam, deduction mark."],
		[TowerType.TARZAN, "Tarzan [100G]", "Tarzan — melee beast, vine swing, animals."],
		[TowerType.DRACULA, "Dracula [105G]", "Dracula — life drain, bats, minion control."],
		[TowerType.MERLIN, "Merlin [115G]", "Merlin — buffs, curses, Excalibur strikes."],
		[TowerType.FRANKENSTEIN, "Monster [130G]", "Frankenstein — AoE lightning fist smash."],
		[TowerType.SHADOW_AUTHOR, "Author [250G]", "Shadow Author — ink attacks, rewrite, shadow servants."],
	]
	for i in range(new_chars.size()):
		var nc = new_chars[i]
		var bx = 8 + i * (btn_w + 6)
		var btn = _make_button(nc[1], Vector2(bx, row2_y), Vector2(btn_w, btn_h))
		btn.pressed.connect(_on_tower_pressed.bind(nc[0], nc[2] + " Cancel to abort."))
		bottom_panel.add_child(btn)
		tower_buttons[nc[0]] = btn
		btn.visible = false  # Hidden until unlocked

	info_label = Label.new()
	info_label.position = Vector2(540, 8)
	info_label.size = Vector2(620, 34)
	info_label.add_theme_font_size_override("font_size", 24)
	info_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	info_label.clip_text = true
	info_label.text = ""
	top_bar.add_child(info_label)

	start_button = Button.new()
	start_button.text = "  START WAVE  "
	start_button.position = Vector2(960, 4)
	start_button.custom_minimum_size = Vector2(160, 34)
	start_button.pressed.connect(_on_start_wave_pressed)
	bottom_panel.add_child(start_button)

	speed_button = Button.new()
	speed_button.text = "  >>  "
	speed_button.position = Vector2(1126, 2)
	speed_button.custom_minimum_size = Vector2(72, 38)
	speed_button.pressed.connect(_on_speed_pressed)
	bottom_panel.add_child(speed_button)

	restart_button = Button.new()
	restart_button.text = "  ↺  "
	restart_button.position = Vector2(1202, 2)
	restart_button.custom_minimum_size = Vector2(72, 38)
	restart_button.pressed.connect(_on_restart_pressed)
	bottom_panel.add_child(restart_button)

	sfx_mute_button = Button.new()
	sfx_mute_button.text = " SFX "
	sfx_mute_button.position = Vector2(1126, 42)
	sfx_mute_button.custom_minimum_size = Vector2(72, 38)
	sfx_mute_button.pressed.connect(_on_sfx_mute_pressed)
	bottom_panel.add_child(sfx_mute_button)

	voice_mute_button = Button.new()
	voice_mute_button.text = " VOX "
	voice_mute_button.position = Vector2(1202, 42)
	voice_mute_button.custom_minimum_size = Vector2(72, 38)
	voice_mute_button.pressed.connect(_on_voice_mute_pressed)
	bottom_panel.add_child(voice_mute_button)

	auto_wave_btn = Button.new()
	auto_wave_btn.text = " AUTO " if auto_wave_enabled else " [AUTO] "
	auto_wave_btn.position = Vector2(1050, 46)
	auto_wave_btn.custom_minimum_size = Vector2(72, 38)
	auto_wave_btn.pressed.connect(_on_auto_wave_toggled)
	bottom_panel.add_child(auto_wave_btn)

	cancel_button = Button.new()
	cancel_button.text = "CANCEL"
	cancel_button.position = Vector2(950, 46)
	cancel_button.custom_minimum_size = Vector2(180, 44)
	cancel_button.visible = false
	cancel_button.pressed.connect(_on_cancel_placement)
	bottom_panel.add_child(cancel_button)

	# === BATTLE POWER HUD BUTTONS (in-game, bottom-right) ===
	for pi in range(3):
		var power_btn = Button.new()
		power_btn.text = ""
		power_btn.position = Vector2(1010, 75 + pi * 40)
		power_btn.custom_minimum_size = Vector2(170, 44)
		power_btn.visible = false
		power_btn.pressed.connect(_on_battle_power_pressed.bind(pi))
		bottom_panel.add_child(power_btn)
		battle_power_buttons.append(power_btn)

	game_over_label = Label.new()
	game_over_label.add_theme_font_size_override("font_size", 72)
	game_over_label.add_theme_color_override("font_color", Color.RED)
	game_over_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	game_over_label.position = Vector2(240, 280)
	game_over_label.size = Vector2(800, 100)
	game_over_label.visible = false
	ui.add_child(game_over_label)

	# === Ability choice panel (centered, hidden by default) ===
	ability_panel = ColorRect.new()
	ability_panel.color = Color(0.08, 0.06, 0.12, 0.95)
	ability_panel.position = Vector2(290, 150)
	ability_panel.size = Vector2(700, 380)
	ability_panel.visible = false
	ui.add_child(ability_panel)

	# Panel border
	var border = ColorRect.new()
	border.color = Color(1.0, 0.85, 0.2, 0.6)
	border.position = Vector2(-2, -2)
	border.size = Vector2(704, 384)
	border.z_index = -1
	ability_panel.add_child(border)

	ability_title = Label.new()
	ability_title.text = "CHOOSE AN ABILITY"
	ability_title.position = Vector2(20, 12)
	ability_title.add_theme_font_size_override("font_size", 24)
	ability_title.add_theme_color_override("font_color", Color(1.0, 0.9, 0.4))
	ability_panel.add_child(ability_title)

	var subtitle = Label.new()
	subtitle.text = "YOUR TOWER REACHED 1500 DAMAGE! PICK A SPECIAL ABILITY:"
	subtitle.position = Vector2(20, 45)
	subtitle.add_theme_font_size_override("font_size", 13)
	subtitle.add_theme_color_override("font_color", Color(0.7, 0.65, 0.5))
	ability_panel.add_child(subtitle)

	for i in range(4):
		var btn = Button.new()
		btn.position = Vector2(20, 75 + i * 72)
		btn.custom_minimum_size = Vector2(660, 60)
		btn.pressed.connect(_on_ability_chosen.bind(i))
		ability_panel.add_child(btn)
		ability_buttons.append(btn)

	# === Tower upgrade panel (right-side, hidden by default) ===
	upgrade_panel = ColorRect.new()
	upgrade_panel.color = Color(0.08, 0.05, 0.12, 0.95)
	upgrade_panel.position = Vector2(1080, 15)
	upgrade_panel.size = Vector2(200, 650)
	upgrade_panel.visible = false
	ui.add_child(upgrade_panel)

	# Gold border
	var upg_border = ColorRect.new()
	upg_border.color = Color(0.85, 0.65, 0.1, 0.5)
	upg_border.position = Vector2(-2, -2)
	upg_border.size = Vector2(204, 654)
	upg_border.z_index = -1
	upgrade_panel.add_child(upg_border)

	# Tower name label at top
	upgrade_name_label = Label.new()
	upgrade_name_label.position = Vector2(10, 10)
	upgrade_name_label.size = Vector2(180, 30)
	upgrade_name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	upgrade_name_label.add_theme_font_size_override("font_size", 18)
	upgrade_name_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	upgrade_panel.add_child(upgrade_name_label)

	# Separator line (drawn via a thin ColorRect)
	var sep = ColorRect.new()
	sep.color = Color(0.85, 0.65, 0.1, 0.3)
	sep.position = Vector2(10, 42)
	sep.size = Vector2(180, 1)
	upgrade_panel.add_child(sep)

	# Portrait area placeholder
	var portrait_bg = ColorRect.new()
	portrait_bg.color = Color(0.06, 0.03, 0.09, 0.8)
	portrait_bg.position = Vector2(50, 50)
	portrait_bg.size = Vector2(100, 80)
	upgrade_panel.add_child(portrait_bg)

	var portrait_border = ColorRect.new()
	portrait_border.color = Color(0.85, 0.65, 0.1, 0.3)
	portrait_border.position = Vector2(48, 48)
	portrait_border.size = Vector2(104, 84)
	portrait_border.z_index = -1
	upgrade_panel.add_child(portrait_border)

	# 4 upgrade slots stacked vertically
	for i in range(4):
		var slot_y = 145 + i * 100

		# Status background rect (changes color based on state)
		var status_rect = ColorRect.new()
		status_rect.position = Vector2(10, slot_y)
		status_rect.size = Vector2(180, 85)
		status_rect.color = Color(0.12, 0.08, 0.16, 0.8)
		upgrade_panel.add_child(status_rect)
		upgrade_status_rects.append(status_rect)

		# Slot border
		var slot_border = ColorRect.new()
		slot_border.color = Color(0.4, 0.3, 0.5, 0.4)
		slot_border.position = Vector2(-1, -1)
		slot_border.size = Vector2(182, 87)
		slot_border.z_index = -1
		status_rect.add_child(slot_border)

		# Tier number label
		var tier_label = Label.new()
		tier_label.text = str(i + 1)
		tier_label.position = Vector2(6, 4)
		tier_label.add_theme_font_size_override("font_size", 12)
		tier_label.add_theme_color_override("font_color", Color(0.6, 0.5, 0.7))
		status_rect.add_child(tier_label)

		# Upgrade button (clickable area)
		var upg_btn = Button.new()
		upg_btn.position = Vector2(4, 2)
		upg_btn.custom_minimum_size = Vector2(172, 30)
		upg_btn.flat = true
		upg_btn.pressed.connect(_on_upgrade_tier_pressed.bind(i))
		status_rect.add_child(upg_btn)
		upgrade_buttons.append(upg_btn)

		# Description label (below name, above cost)
		var desc_label = Label.new()
		desc_label.position = Vector2(6, 30)
		desc_label.size = Vector2(168, 32)
		desc_label.autowrap_mode = TextServer.AUTOWRAP_WORD
		desc_label.add_theme_font_size_override("font_size", 11)
		desc_label.add_theme_color_override("font_color", Color(0.75, 0.72, 0.80, 0.8))
		status_rect.add_child(desc_label)
		upgrade_desc_labels.append(desc_label)

		# Cost label (right side)
		var cost_label = Label.new()
		cost_label.position = Vector2(4, 64)
		cost_label.size = Vector2(172, 20)
		cost_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		cost_label.add_theme_font_size_override("font_size", 13)
		cost_label.add_theme_color_override("font_color", Color(1.0, 0.84, 0.0))
		status_rect.add_child(cost_label)
		upgrade_cost_labels.append(cost_label)

	# Sell button at bottom
	sell_button = Button.new()
	sell_button.text = "SELL"
	sell_button.position = Vector2(20, 560)
	sell_button.custom_minimum_size = Vector2(160, 44)
	sell_button.pressed.connect(_on_sell_pressed)
	upgrade_panel.add_child(sell_button)

	# Sell value label
	sell_value_label = Label.new()
	sell_value_label.position = Vector2(20, 608)
	sell_value_label.size = Vector2(160, 20)
	sell_value_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	sell_value_label.add_theme_font_size_override("font_size", 12)
	sell_value_label.add_theme_color_override("font_color", Color(0.9, 0.4, 0.3))
	upgrade_panel.add_child(sell_value_label)

	# === MAIN MENU OVERLAY ===
	menu_overlay = ColorRect.new()
	menu_overlay.color = Color(0, 0, 0, 0)  # Transparent — we draw the background in _draw()
	menu_overlay.position = Vector2(0, 0)
	menu_overlay.size = Vector2(1280, 720)
	menu_overlay.visible = true
	ui.add_child(menu_overlay)

	# Generate storybook decoration positions
	var rng2 = RandomNumberGenerator.new()
	rng2.seed = 99
	for i in range(20):
		_dust_positions.append({"x": rng2.randf_range(50, 1230), "y": rng2.randf_range(50, 600), "speed": rng2.randf_range(0.2, 0.6), "size": rng2.randf_range(1.0, 2.5), "offset": rng2.randf_range(0, TAU)})
	for i in range(5):
		_book_candle_positions.append({"x": rng2.randf_range(60, 1220), "y": rng2.randf_range(480, 590), "offset": rng2.randf_range(0, TAU)})
	# Floating book pages
	for i in range(8):
		_floating_pages.append({"x": rng2.randf_range(30, 1250), "y": rng2.randf_range(60, 580), "rot": rng2.randf_range(-0.4, 0.4), "size": rng2.randf_range(18, 35), "speed": rng2.randf_range(0.15, 0.45), "offset": rng2.randf_range(0, TAU)})
	# Ink splatters
	for i in range(6):
		_menu_ink_splatters.append({"x": rng2.randf_range(20, 1260), "y": rng2.randf_range(100, 600), "size": rng2.randf_range(8, 25), "dots": rng2.randi_range(3, 7), "seed": rng2.randi()})
	# Quill pens
	for i in range(3):
		_quill_positions.append({"x": rng2.randf_range(80, 1200), "y": rng2.randf_range(400, 570), "rot": rng2.randf_range(-0.6, 0.3), "size": rng2.randf_range(30, 50)})
	# Bookshelf column heights (for silhouette across bottom)
	for i in range(26):
		_bookshelf_heights.append(rng2.randf_range(20, 55))

	# World map data
	var rng3 = RandomNumberGenerator.new()
	rng3.seed = 200
	for i in range(40):
		_world_map_stars.append({"x": rng3.randf_range(10, 1270), "y": rng3.randf_range(5, 200), "size": rng3.randf_range(0.5, 2.0), "speed": rng3.randf_range(1.0, 3.0), "offset": rng3.randf_range(0, TAU)})
	for i in range(3):
		_world_map_clouds.append({"x": rng3.randf_range(100, 1100), "y": rng3.randf_range(50, 160), "width": rng3.randf_range(40, 80), "speed": rng3.randf_range(0.15, 0.4)})
	for i in range(5):
		_world_map_smoke.append({"y": rng3.randf_range(-5, -35), "speed": rng3.randf_range(0.3, 0.8), "size": rng3.randf_range(2.0, 5.0), "offset": rng3.randf_range(0, TAU)})

	# Title — hidden by default (shown on book cover, drawn procedurally)
	menu_title = Label.new()
	menu_title.text = ""
	menu_title.position = Vector2(20, 22)
	menu_title.size = Vector2(600, 60)
	menu_title.visible = false
	menu_overlay.add_child(menu_title)

	# Subtitle — hidden (drawn on book cover)
	menu_subtitle = Label.new()
	menu_subtitle.text = ""
	menu_subtitle.position = Vector2(22, 72)
	menu_subtitle.size = Vector2(400, 30)
	menu_subtitle.visible = false
	menu_overlay.add_child(menu_subtitle)

	# Star total (top right, above book)
	menu_star_total_label = Label.new()
	menu_star_total_label.position = Vector2(1050, 8)
	menu_star_total_label.size = Vector2(220, 30)
	menu_star_total_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	menu_star_total_label.add_theme_font_size_override("font_size", 18)
	menu_star_total_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	menu_overlay.add_child(menu_star_total_label)

	# === OPEN BOOK PANEL (two-page spread) ===
	menu_showcase_panel = ColorRect.new()
	menu_showcase_panel.color = Color(0, 0, 0, 0)  # Transparent, we draw the book in _draw
	menu_showcase_panel.position = Vector2(70, 45)
	menu_showcase_panel.size = Vector2(1140, 560)
	menu_overlay.add_child(menu_showcase_panel)

	# --- LEFT PAGE: Character info ---
	# Character name (calligraphy gold)
	menu_level_name_label = Label.new()
	menu_level_name_label.position = Vector2(40, 30)
	menu_level_name_label.size = Vector2(500, 40)
	menu_level_name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	menu_level_name_label.add_theme_font_size_override("font_size", 30)
	menu_level_name_label.add_theme_color_override("font_color", Color(0.79, 0.66, 0.30))
	menu_showcase_panel.add_child(menu_level_name_label)

	# Novel title (italic)
	menu_level_desc_label = Label.new()
	menu_level_desc_label.position = Vector2(40, 75)
	menu_level_desc_label.size = Vector2(500, 25)
	menu_level_desc_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	menu_level_desc_label.add_theme_font_size_override("font_size", 14)
	menu_level_desc_label.add_theme_color_override("font_color", Color(0.5, 0.4, 0.3))
	menu_showcase_panel.add_child(menu_level_desc_label)

	# Character quote
	menu_level_stats_label = Label.new()
	menu_level_stats_label.position = Vector2(60, 380)
	menu_level_stats_label.size = Vector2(460, 60)
	menu_level_stats_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	menu_level_stats_label.add_theme_font_size_override("font_size", 13)
	menu_level_stats_label.add_theme_color_override("font_color", Color(0.45, 0.35, 0.25))
	menu_level_stats_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	menu_showcase_panel.add_child(menu_level_stats_label)

	# Stars display (unused in chapters view, used in survivors)
	menu_level_stars_label = Label.new()
	menu_level_stars_label.position = Vector2(40, 440)
	menu_level_stars_label.size = Vector2(500, 30)
	menu_level_stars_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	menu_level_stars_label.add_theme_font_size_override("font_size", 20)
	menu_level_stars_label.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
	menu_showcase_panel.add_child(menu_level_stars_label)

	# Left arrow (page turn)
	menu_left_arrow = Button.new()
	menu_left_arrow.text = "  <  "
	menu_left_arrow.position = Vector2(10, 490)
	menu_left_arrow.custom_minimum_size = Vector2(60, 40)
	menu_left_arrow.pressed.connect(_on_menu_left)
	menu_showcase_panel.add_child(menu_left_arrow)

	# Right arrow (page turn)
	menu_right_arrow = Button.new()
	menu_right_arrow.text = "  >  "
	menu_right_arrow.position = Vector2(1060, 490)
	menu_right_arrow.custom_minimum_size = Vector2(60, 40)
	menu_right_arrow.pressed.connect(_on_menu_right)
	menu_showcase_panel.add_child(menu_right_arrow)

	# PLAY button — hidden, replaced by chapter buttons
	menu_play_button = Button.new()
	menu_play_button.text = "  PLAY  "
	menu_play_button.position = Vector2(250, 250)
	menu_play_button.custom_minimum_size = Vector2(200, 60)
	menu_play_button.pressed.connect(_on_menu_play)
	menu_play_button.visible = false
	menu_showcase_panel.add_child(menu_play_button)

	# --- RIGHT PAGE: 3 Chapter cards ---
	for i in range(3):
		var card_y = 30 + i * 165
		var card_x = 585

		# Chapter title
		var ch_title = Label.new()
		ch_title.position = Vector2(card_x, card_y)
		ch_title.size = Vector2(540, 25)
		ch_title.add_theme_font_size_override("font_size", 18)
		ch_title.add_theme_color_override("font_color", Color(0.55, 0.35, 0.1))
		menu_showcase_panel.add_child(ch_title)
		chapter_title_labels.append(ch_title)

		# Chapter description
		var ch_desc = Label.new()
		ch_desc.position = Vector2(card_x, card_y + 28)
		ch_desc.size = Vector2(340, 50)
		ch_desc.add_theme_font_size_override("font_size", 12)
		ch_desc.add_theme_color_override("font_color", Color(0.4, 0.35, 0.28))
		ch_desc.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
		menu_showcase_panel.add_child(ch_desc)
		chapter_desc_labels.append(ch_desc)

		# Chapter stats (waves/gold/lives)
		var ch_stat = Label.new()
		ch_stat.position = Vector2(card_x, card_y + 82)
		ch_stat.size = Vector2(300, 20)
		ch_stat.add_theme_font_size_override("font_size", 11)
		ch_stat.add_theme_color_override("font_color", Color(0.4, 0.55, 0.35))
		menu_showcase_panel.add_child(ch_stat)
		chapter_stat_labels.append(ch_stat)

		# Chapter stars
		var ch_stars = Label.new()
		ch_stars.position = Vector2(card_x, card_y + 104)
		ch_stars.size = Vector2(200, 22)
		ch_stars.add_theme_font_size_override("font_size", 18)
		ch_stars.add_theme_color_override("font_color", Color(0.85, 0.65, 0.1))
		menu_showcase_panel.add_child(ch_stars)
		chapter_star_labels.append(ch_stars)

		# Difficulty / lock label
		var ch_lock = Label.new()
		ch_lock.position = Vector2(card_x + 220, card_y + 104)
		ch_lock.size = Vector2(120, 22)
		ch_lock.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		ch_lock.add_theme_font_size_override("font_size", 12)
		menu_showcase_panel.add_child(ch_lock)
		chapter_lock_labels.append(ch_lock)

		# Difficulty buttons for this chapter (Easy / Med / Hard)
		var diff_labels = ["EASY", "MED", "HARD"]
		var diff_colors_bg = [Color(0.15, 0.45, 0.2), Color(0.45, 0.40, 0.1), Color(0.55, 0.15, 0.1)]
		var ch_diff_btns: Array = []
		for d in range(3):
			var diff_btn = Button.new()
			diff_btn.text = diff_labels[d]
			diff_btn.position = Vector2(card_x + 290 + d * 72, card_y + 76)
			diff_btn.custom_minimum_size = Vector2(66, 44)
			diff_btn.add_theme_font_size_override("font_size", 12)
			diff_btn.pressed.connect(_on_chapter_play.bind(i, d))
			menu_showcase_panel.add_child(diff_btn)
			ch_diff_btns.append(diff_btn)
		chapter_diff_buttons.append(ch_diff_btns)
		# Keep a reference in chapter_buttons for the first button (for lock/unlock logic)
		chapter_buttons.append(ch_diff_btns[0])

	# === BOTTOM NAV BAR (bookmark ribbon style) ===
	var nav_bar = ColorRect.new()
	nav_bar.color = Color(0.04, 0.04, 0.10, 0.97)
	nav_bar.position = Vector2(0, 620)
	nav_bar.size = Vector2(1280, 100)
	menu_overlay.add_child(nav_bar)

	# Nav bar top border — gold line (3px) + gold accent (1px)
	var nav_border = ColorRect.new()
	nav_border.color = Color(0.79, 0.66, 0.30, 0.4)
	nav_border.position = Vector2(0, 0)
	nav_border.size = Vector2(1280, 3)
	nav_bar.add_child(nav_border)

	var nav_gold_accent = ColorRect.new()
	nav_gold_accent.color = Color(0.54, 0.45, 0.20, 0.25)
	nav_gold_accent.position = Vector2(0, 3)
	nav_gold_accent.size = Vector2(1280, 1)
	nav_bar.add_child(nav_gold_accent)

	var nav_names = ["SURVIVORS", "RELICS", "CHAPTERS", "CHRONICLES", "EMPORIUM"]
	nav_names.append("ACHIEVEMENTS")
	for i in range(6):
		var btn_x = 42 + i * 200
		var nav_btn = Button.new()
		nav_btn.text = ""
		nav_btn.position = Vector2(btn_x, 10)
		nav_btn.custom_minimum_size = Vector2(60, 50)
		nav_btn.pressed.connect(_on_nav_pressed.bind(nav_names[i].to_lower()))
		nav_bar.add_child(nav_btn)
		menu_nav_buttons.append(nav_btn)

		var nav_lbl = Label.new()
		nav_lbl.text = nav_names[i]
		nav_lbl.position = Vector2(btn_x - 20, 64)
		nav_lbl.size = Vector2(100, 20)
		nav_lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		nav_lbl.add_theme_font_size_override("font_size", 12)
		nav_lbl.add_theme_color_override("font_color", Color(0.65, 0.60, 0.52))
		nav_bar.add_child(nav_lbl)
		menu_nav_labels.append(nav_lbl)

		# Vertical divider between buttons (gold line)
		if i < 5:
			var div_x_pos = btn_x + 125
			var div_line = ColorRect.new()
			div_line.color = Color(0.54, 0.45, 0.20, 0.15)
			div_line.position = Vector2(div_x_pos, 12)
			div_line.size = Vector2(1, 65)
			nav_bar.add_child(div_line)

	# === SURVIVOR GRID (BATTD-style character roster) ===
	survivor_grid_container = Control.new()
	survivor_grid_container.position = Vector2(0, 0)
	survivor_grid_container.size = Vector2(1280, 620)
	survivor_grid_container.visible = false
	menu_overlay.add_child(survivor_grid_container)

	# Title is drawn procedurally in _draw_survivor_grid() now

	# Create 11 character cards: row 1 = 6 cards, row 2 = 5 cards (centered)
	survivor_grid_cards.clear()
	var card_w = 170.0
	var card_h = 230.0
	var gap_x = 12.0
	var gap_y = 12.0
	var grid_panel_x = 70.0
	var grid_panel_w = 1140.0
	var grid_start_y = 38.0 + 42.0
	for i in range(survivor_types.size()):
		var row_i: int
		var col_i: int
		var cards_in_row: int
		if i < 6:
			row_i = 0
			col_i = i
			cards_in_row = 6
		else:
			row_i = 1
			col_i = i - 6
			cards_in_row = 5
		var row_w = float(cards_in_row) * card_w + float(cards_in_row - 1) * gap_x
		var row_x = grid_panel_x + (grid_panel_w - row_w) * 0.5
		var cx = row_x + float(col_i) * (card_w + gap_x)
		var cy = grid_start_y + float(row_i) * (card_h + gap_y)

		var card_btn = Button.new()
		card_btn.position = Vector2(cx, cy)
		card_btn.custom_minimum_size = Vector2(card_w, card_h)
		card_btn.flat = true
		card_btn.pressed.connect(_on_survivor_card_pressed.bind(i))
		card_btn.mouse_entered.connect(func(): queue_redraw())
		card_btn.mouse_exited.connect(func(): queue_redraw())
		survivor_grid_container.add_child(card_btn)
		survivor_grid_cards.append(card_btn)

	# === SURVIVOR DETAIL PAGE (opened when clicking a card) ===
	survivor_detail_container = Control.new()
	survivor_detail_container.position = Vector2(0, 0)
	survivor_detail_container.size = Vector2(1280, 620)
	survivor_detail_container.visible = false
	menu_overlay.add_child(survivor_detail_container)

	# Back button (top-left, overlapping the drawn "< SURVIVORS" label)
	survivor_detail_back_btn = Button.new()
	survivor_detail_back_btn.text = "  < SURVIVORS  "
	survivor_detail_back_btn.position = Vector2(75, 42)
	survivor_detail_back_btn.custom_minimum_size = Vector2(120, 28)
	survivor_detail_back_btn.flat = true
	survivor_detail_back_btn.pressed.connect(_on_detail_back)
	survivor_detail_container.add_child(survivor_detail_back_btn)

	# Hidden data labels (populated by _open_survivor_detail, drawn procedurally)
	var det_name = Label.new()
	det_name.name = "DetailName"
	det_name.visible = false
	survivor_detail_container.add_child(det_name)

	var det_level = Label.new()
	det_level.name = "DetailLevel"
	det_level.visible = false
	survivor_detail_container.add_child(det_level)

	# Hidden data labels (used by _open_survivor_detail for data, drawn procedurally)
	for lbl_name in ["DetailXP", "DetailNovel", "DetailDesc", "GearHeader", "GearName", "GearDesc", "SidekicksHeader", "RelicsHeader", "RelicTooltipName", "RelicTooltipDesc", "AbilitiesHeader", "AbilitiesDesc"]:
		var lbl = Label.new()
		lbl.name = lbl_name
		lbl.visible = false
		survivor_detail_container.add_child(lbl)

	# Return to menu button (hidden during gameplay, shown on victory/game over)
	return_button = Button.new()
	return_button.text = "  RETURN TO MENU  "
	return_button.position = Vector2(500, 380)
	return_button.custom_minimum_size = Vector2(280, 50)
	return_button.pressed.connect(_show_menu)
	return_button.visible = false
	ui.add_child(return_button)

	retry_button = Button.new()
	retry_button.text = "  RETRY LEVEL  "
	retry_button.position = Vector2(500, 440)
	retry_button.custom_minimum_size = Vector2(280, 50)
	retry_button.pressed.connect(_on_retry_level)
	retry_button.visible = false
	ui.add_child(retry_button)

func _make_button(text: String, pos: Vector2, min_size: Vector2) -> Button:
	var btn = Button.new()
	btn.text = text.to_upper()
	btn.position = pos
	btn.custom_minimum_size = min_size
	btn.add_theme_font_override("font", game_font)
	return btn

func _apply_font_to_controls(node: Node) -> void:
	if node is Label:
		node.add_theme_font_override("font", game_font)
	elif node is Button:
		node.add_theme_font_override("font", game_font)
	for child in node.get_children():
		_apply_font_to_controls(child)

# ============================================================
# MENU & LEVEL MANAGEMENT
# ============================================================

func _on_retry_level() -> void:
	_play_sfx(_sfx_ui_click)
	var lvl = current_level
	_reset_game()
	retry_button.visible = false
	return_button.visible = false
	game_over_label.visible = false
	_do_level_start(lvl)

func _show_menu() -> void:
	_reset_game()
	game_state = GameState.MENU
	get_tree().paused = false
	Engine.time_scale = 1.0
	fast_forward = false
	game_paused = false
	endless_mode = false
	if speed_button:
		speed_button.text = "  >>  "
	menu_overlay.visible = true
	return_button.visible = false
	retry_button.visible = false
	game_over_label.visible = false
	if top_bar:
		top_bar.visible = false
	if bottom_panel:
		bottom_panel.visible = false
	if cancel_button:
		cancel_button.visible = false
	if upgrade_panel:
		upgrade_panel.visible = false
	placing_tower = false
	chest_open = false
	chest_loot.clear()
	chest_opening_active = false
	victory_chest_active = false
	victory_equip_active = false
	victory_trinket_pending = {}
	_deselect_tower()
	_remove_survivor_preview()
	_remove_detail_preview()
	_clear_grid_previews()
	survivor_grid_container.visible = false
	survivor_detail_container.visible = false
	survivor_detail_open = false
	survivor_selected_index = -1
	survivor_detail_index = -1
	menu_current_view = "chapters"
	menu_play_button.visible = false
	menu_left_arrow.visible = false
	menu_right_arrow.visible = false
	menu_showcase_panel.visible = false
	# Hide old chapter UI — chapters view draws everything procedurally
	for i in range(3):
		chapter_title_labels[i].visible = false
		chapter_desc_labels[i].visible = false
		chapter_stat_labels[i].visible = false
		chapter_star_labels[i].visible = false
		chapter_lock_labels[i].visible = false
		_hide_chapter_diff_buttons(i)
	story_map_scroll_y = 0.0
	_start_music()
	emporium_sub_open = false
	emporium_sub_category = -1
	power_selection_open = false
	_check_daily_reward()
	queue_redraw()

func _check_daily_reward() -> void:
	var today = Time.get_date_string_from_system()
	if daily_last_claim == today:
		daily_reward_claimed_today = true
		return
	daily_reward_claimed_today = false
	daily_reward_open = true

func _claim_daily_reward() -> void:
	var today = Time.get_date_string_from_system()
	if daily_last_claim == today:
		return
	var day_index = daily_streak % 7
	var reward = daily_rewards_schedule[day_index]
	var reward_text = ""
	match reward["type"]:
		"shards":
			player_relic_shards += reward["amount"]
			reward_text = "+%d Relic Shards" % reward["amount"]
		"quills":
			player_quills += reward["amount"]
			reward_text = "+%d Quills" % reward["amount"]
		"gold":
			player_gold += reward["amount"]
			reward_text = "+%dG" % reward["amount"]
		"stars":
			player_storybook_stars += reward["amount"]
			reward_text = "+%d Stars" % reward["amount"]
		"gold_chest":
			treasure_chests_owned["gold"] += 1
			reward_text = "+1 Gold Chest!"
	info_label.text = "Daily Reward: %s" % reward_text
	daily_streak += 1
	daily_last_claim = today
	daily_reward_claimed_today = true
	daily_reward_open = false
	total_daily_claims += 1
	_check_achievement("daily_devotee", 1)
	_save_game()
	queue_redraw()

func _update_menu_showcase() -> void:
	var arc_idx = menu_character_index
	var arc = arc_data[arc_idx]
	var arc_levels = arc["levels"]

	# Left page: arc info
	menu_level_name_label.text = arc["name"]
	var orig_char_names = ["Robin Hood", "Alice", "Wicked Witch", "Peter Pan", "Phantom", "Scrooge"]
	var orig_idx = orig_char_names.find(arc["name"])
	if orig_idx >= 0 and orig_idx < character_novels.size():
		menu_level_desc_label.text = character_novels[orig_idx]
		menu_level_stats_label.text = "\"%s\"" % character_quotes[orig_idx]
	elif arc.has("unlock_char"):
		menu_level_desc_label.text = "Rescue Arc"
		menu_level_stats_label.text = "Complete to unlock " + arc["name"]
	elif arc["name"] == "Prologue":
		menu_level_desc_label.text = "The Tome of Shadows"
		menu_level_stats_label.text = "\"Your story begins now.\""
	elif arc["name"] == "Shadow Author":
		menu_level_desc_label.text = "The Final Battle"
		menu_level_stats_label.text = "\"Every story must end.\""
	else:
		menu_level_desc_label.text = ""
		menu_level_stats_label.text = ""
	menu_level_stars_label.text = ""

	# Right page: chapter cards (up to 3)
	var num_chapters = mini(arc_levels.size(), 3)
	for i in range(3):
		if i < num_chapters:
			var level_idx = arc_levels[i]
			var level = levels[level_idx]
			var chap_num = ["I", "II", "III"]
			var diff_names = ["Easy", "Medium", "Hard"]
			var diff_colors = [Color(0.3, 0.8, 0.3), Color(0.8, 0.8, 0.2), Color(1.0, 0.4, 0.2)]

			chapter_title_labels[i].text = "Chapter %s \u2014 %s" % [chap_num[i], level["name"]]
			chapter_desc_labels[i].text = level["description"]
			chapter_stat_labels[i].text = "Gold: %d  |  Lives: %d" % [level["gold"], level["lives"]]

			# Stars
			if level_idx in completed_levels and level_stars.has(level_idx):
				var sv = level_stars[level_idx]
				var ss = ""
				for s in range(sv):
					ss += "\u2605"
				for s in range(3 - sv):
					ss += "\u2606"
				chapter_star_labels[i].text = ss
			else:
				chapter_star_labels[i].text = "\u2606\u2606\u2606"

			# Lock / difficulty buttons
			var unlocked = _is_level_unlocked(level_idx)
			if i < chapter_diff_buttons.size():
				for d in range(3):
					chapter_diff_buttons[i][d].disabled = not unlocked
					chapter_diff_buttons[i][d].visible = true
			chapter_lock_labels[i].text = diff_names[mini(i, 2)]
			chapter_lock_labels[i].add_theme_color_override("font_color", diff_colors[mini(i, 2)] if unlocked else Color(0.4, 0.35, 0.3))

			# Visibility
			chapter_title_labels[i].visible = true
			chapter_desc_labels[i].visible = true
			chapter_stat_labels[i].visible = true
			chapter_star_labels[i].visible = true
			chapter_lock_labels[i].visible = true
			if i < chapter_diff_buttons.size():
				for d in range(3):
					chapter_diff_buttons[i][d].visible = true
		else:
			# Hide unused chapter cards (e.g., prologue has only 1 level)
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			if i < chapter_diff_buttons.size():
				for d in range(3):
					chapter_diff_buttons[i][d].visible = false

	# Arrow state
	menu_left_arrow.disabled = arc_idx <= 0
	menu_right_arrow.disabled = arc_idx >= arc_data.size() - 1

	# Update star total
	var total_stars = 0
	for key in level_stars:
		total_stars += level_stars[key]
	menu_star_total_label.text = "â˜… %d / %d" % [total_stars, levels.size() * 3]

func _hide_chapter_diff_buttons(chapter_idx: int) -> void:
	if chapter_idx < chapter_diff_buttons.size():
		for d in range(3):
			chapter_diff_buttons[chapter_idx][d].visible = false

func _on_chapter_play(chapter: int, difficulty: int = 0) -> void:
	selected_difficulty = difficulty
	var arc = arc_data[menu_character_index]
	if chapter < arc["levels"].size():
		var level_idx = arc["levels"][chapter]
		_on_level_selected(level_idx)

func _on_menu_left() -> void:
	if menu_current_view == "survivors":
		return  # Grid doesn't use arrows
	else:
		if menu_character_index > 0:
			menu_character_index -= 1
			_update_menu_showcase()

func _on_menu_right() -> void:
	if menu_current_view == "survivors":
		return  # Grid doesn't use arrows
	else:
		if menu_character_index < arc_data.size() - 1:
			menu_character_index += 1
			_update_menu_showcase()

func _on_menu_play() -> void:
	pass  # Unused — chapter buttons handle play now

func _on_nav_pressed(nav_name: String) -> void:
	_play_sfx(_sfx_ui_click)
	if menu_current_view == "survivors" and nav_name != "survivors":
		_remove_survivor_preview()
		_clear_grid_previews()
		_remove_detail_preview()
		survivor_grid_container.visible = false
		survivor_detail_container.visible = false
		survivor_detail_open = false
	# Reset scroll positions when switching views
	relic_scroll_offset = 0.0
	binding_shop_scroll = 0.0
	detail_binding_scroll = 0.0
	menu_current_view = nav_name
	menu_transition_alpha = 0.0  # Trigger fade-in
	if nav_name == "chapters":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
		menu_play_button.visible = false
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		# Hide old chapter UI — we draw everything procedurally now
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		story_map_scroll_y = 0.0
		queue_redraw()
	elif nav_name == "survivors":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
		survivor_detail_container.visible = false
		survivor_detail_open = false
		menu_play_button.visible = false
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		# Hide chapter UI
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		queue_redraw()
	elif nav_name == "relics":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
		menu_play_button.visible = false
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		relics_tab_hover_tier = -1
		relics_tab_hover_row = -1
		relics_tab_hover_col = -1
		queue_redraw()
	elif nav_name == "emporium":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
		menu_play_button.visible = false
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		emporium_hover_index = -1
		queue_redraw()
	elif nav_name == "chronicles":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
		menu_play_button.visible = false
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		chronicles_hover_branch = -1
		chronicles_hover_node = -1
		queue_redraw()
	elif nav_name == "achievements":
		menu_showcase_panel.visible = false
		survivor_grid_container.visible = false
		menu_play_button.visible = false
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)
		queue_redraw()
	else:
		menu_showcase_panel.visible = true
		survivor_grid_container.visible = false
		menu_level_name_label.text = nav_name.to_upper()
		menu_level_desc_label.text = "Coming Soon!"
		menu_level_stats_label.text = "This feature is being written into the pages..."
		menu_level_stars_label.text = ""
		menu_play_button.visible = false
		menu_left_arrow.visible = false
		menu_right_arrow.visible = false
		for i in range(3):
			chapter_title_labels[i].visible = false
			chapter_desc_labels[i].visible = false
			chapter_stat_labels[i].visible = false
			chapter_star_labels[i].visible = false
			chapter_lock_labels[i].visible = false
			_hide_chapter_diff_buttons(i)

func _on_survivor_card_pressed(index: int) -> void:
	if index < 0 or index >= survivor_types.size():
		return
	var tower_type = survivor_types[index]
	if not _is_character_unlocked(tower_type):
		return  # Locked — do nothing
	survivor_selected_index = index
	_open_survivor_detail(index)
	queue_redraw()

func _open_survivor_detail(index: int) -> void:
	survivor_detail_index = index
	survivor_detail_open = true
	survivor_grid_container.visible = false
	survivor_detail_container.visible = true
	_clear_grid_previews()
	detail_hover_type = ""
	detail_hover_index = -1
	detail_info_overlay_open = false
	detail_info_close_hover = false
	relic_hover_index = -1
	relic_tooltip_visible = false

	# Create a preview of the tower for display
	_remove_detail_preview()
	var tower_type = survivor_types[index]
	survivor_detail_preview = tower_scenes[tower_type].instantiate()
	survivor_detail_preview.position = Vector2(210, 240)
	survivor_detail_preview.scale = Vector2(2.5, 2.5)
	survivor_detail_preview.process_mode = Node.PROCESS_MODE_DISABLED
	add_child(survivor_detail_preview)

	# Extract ability data from tower instance
	survivor_detail_abilities.clear()
	if survivor_detail_preview:
		var t_names = survivor_detail_preview.TIER_NAMES if survivor_detail_preview.get("TIER_NAMES") else []
		var t_descs = survivor_detail_preview.ABILITY_DESCRIPTIONS if survivor_detail_preview.get("ABILITY_DESCRIPTIONS") else []
		var t_costs = survivor_detail_preview.TIER_COSTS if survivor_detail_preview.get("TIER_COSTS") else []
		for i in range(t_names.size()):
			survivor_detail_abilities.append({
				"name": t_names[i] if i < t_names.size() else "Tier %d" % (i + 1),
				"desc": t_descs[i] if i < t_descs.size() else "",
				"cost": t_costs[i] if i < t_costs.size() else 0,
			})

	queue_redraw()

func _on_detail_back() -> void:
	survivor_detail_open = false
	survivor_detail_container.visible = false
	survivor_grid_container.visible = false
	relic_hover_index = -1
	relic_tooltip_visible = false
	detail_info_overlay_open = false
	detail_info_close_hover = false
	_remove_detail_preview()
	queue_redraw()

func _update_emporium_hover() -> void:
	var mouse_pos = get_viewport().get_mouse_position()
	if emporium_sub_open:
		_update_emporium_sub_hover(mouse_pos)
		return
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var tile_w = 340.0
	var tile_h = 220.0
	var gap_x = 30.0
	var gap_y = 24.0
	var grid_w = 3.0 * tile_w + 2.0 * gap_x
	var grid_start_x = panel_x + (panel_w - grid_w) * 0.5
	var grid_start_y = panel_y + 58.0
	emporium_hover_index = -1
	for i in range(emporium_categories.size()):
		var col_idx = i % 3
		var row = i / 3
		var tx = grid_start_x + float(col_idx) * (tile_w + gap_x)
		var ty = grid_start_y + float(row) * (tile_h + gap_y)
		if mouse_pos.x >= tx and mouse_pos.x <= tx + tile_w and mouse_pos.y >= ty and mouse_pos.y <= ty + tile_h:
			emporium_hover_index = i
			break

func _update_emporium_sub_hover(mouse_pos: Vector2) -> void:
	emporium_sub_hover = -1
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var item_w = 320.0
	var item_h = 130.0
	var gap = 20.0
	var start_y = panel_y + 130.0
	var max_cols = 3
	var total_items = 3
	if emporium_sub_category >= 0 and emporium_items.has(emporium_sub_category):
		total_items = emporium_items[emporium_sub_category].size()
	if total_items > max_cols:
		item_h = 110.0
	for i in range(total_items):
		var row_i = i / max_cols
		var col_i = i % max_cols
		var items_in_row = mini(max_cols, total_items - row_i * max_cols)
		var row_w = float(items_in_row) * item_w + float(items_in_row - 1) * gap
		var row_start_x = panel_x + (panel_w - row_w) * 0.5
		var ix = row_start_x + float(col_i) * (item_w + gap)
		var iy = start_y + float(row_i) * (item_h + 12.0)
		if mouse_pos.x >= ix and mouse_pos.x <= ix + item_w and mouse_pos.y >= iy and mouse_pos.y <= iy + item_h:
			emporium_sub_hover = i
			break

func _on_emporium_tile_clicked(index: int) -> void:
	if index < 0 or index >= emporium_categories.size():
		return
	emporium_sub_open = true
	emporium_sub_category = index
	emporium_sub_hover = -1
	emporium_sub_message = ""
	queue_redraw()

func _on_emporium_sub_clicked(item_index: int) -> void:
	if emporium_sub_category < 0 or not emporium_items.has(emporium_sub_category):
		return
	var items = emporium_items[emporium_sub_category]
	if item_index < 0 or item_index >= items.size():
		return
	var item = items[item_index]
	# Confirmation: first click shows "Tap again to confirm", second click buys
	if _emporium_confirm_index != item_index:
		_emporium_confirm_index = item_index
		_emporium_confirm_timer = 3.0
		emporium_sub_message = "Tap again to confirm: %s (%d %s)" % [item["name"], item["cost"], item["currency"]]
		emporium_sub_message_timer = 3.0
		_play_sfx(_sfx_ui_click)
		queue_redraw()
		return
	_emporium_confirm_index = -1
	_emporium_confirm_timer = 0.0
	var cost = item["cost"]
	var currency = item["currency"]
	# Check if player can afford
	var can_afford = false
	match currency:
		"quills":
			can_afford = player_quills >= cost
		"shards":
			can_afford = player_relic_shards >= cost
		"stars":
			can_afford = player_storybook_stars >= cost
		"gold":
			can_afford = player_gold >= cost
	if not can_afford:
		emporium_sub_message = "Not enough %s!" % currency.capitalize()
		emporium_sub_message_timer = 2.0
		queue_redraw()
		return
	# Deduct cost
	match currency:
		"quills":
			player_quills -= cost
		"shards":
			player_relic_shards -= cost
		"stars":
			player_storybook_stars -= cost
		"gold":
			player_gold -= cost
	# Grant reward
	var reward = item["reward"]
	var amount = item["amount"]
	match reward:
		"gold":
			player_gold += amount
		"quills":
			player_quills += amount
		"shards":
			player_relic_shards += amount
		"stars":
			player_storybook_stars += amount
		"chest_bronze":
			treasure_chests_owned["bronze"] += amount
		"chest_silver":
			treasure_chests_owned["silver"] += amount
		"chest_gold":
			treasure_chests_owned["gold"] += amount
		"xp":
			# Distribute XP evenly across all characters
			var per_char = int(float(amount) / float(survivor_types.size()))
			for t in survivor_types:
				if survivor_progress.has(t):
					survivor_progress[t]["xp"] += per_char
					while survivor_progress[t]["xp"] >= survivor_progress[t]["xp_next"] and survivor_progress[t]["level"] < MAX_SURVIVOR_LEVEL:
						survivor_progress[t]["xp"] -= survivor_progress[t]["xp_next"]
						survivor_progress[t]["level"] += 1
						survivor_progress[t]["xp_next"] = _get_xp_for_level(survivor_progress[t]["level"])
						_on_survivor_level_up(t, survivor_progress[t]["level"])
		"power":
			var pid = item.get("power_id", "")
			if pid != "":
				owned_powers[pid] = owned_powers.get(pid, 0) + amount
	emporium_sub_message = "Purchased!"
	emporium_sub_message_timer = 2.0
	total_emporium_purchases += 1
	_check_achievement("emporium_regular", 1)
	_save_game()
	queue_redraw()

func _on_emporium_back() -> void:
	emporium_sub_open = false
	emporium_sub_category = -1
	emporium_sub_hover = -1
	emporium_sub_message = ""
	queue_redraw()

func _on_emporium_sub_input(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button area (bottom-left)
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		_on_emporium_back()
		return
	# Item cards
	if emporium_sub_hover >= 0:
		_on_emporium_sub_clicked(emporium_sub_hover)
		return
	# Open chest buttons (only for category 3 = Relic Chests)
	if emporium_sub_category == 3:
		var open_y = panel_y + 290.0
		var tier_keys = ["bronze", "silver", "gold"]
		var open_total_w = 3.0 * 320.0 + 2.0 * 20.0
		var open_start_x = panel_x + (panel_w - open_total_w) * 0.5
		for ci in range(3):
			var count = treasure_chests_owned[tier_keys[ci]]
			if count > 0:
				var ox = open_start_x + float(ci) * 340.0
				if mouse_pos.x >= ox and mouse_pos.x <= ox + 320.0 and mouse_pos.y >= open_y and mouse_pos.y <= open_y + 36.0:
					treasure_chests_owned[tier_keys[ci]] -= 1
					_start_chest_opening(ci)
					return

func _update_relics_tab_hover() -> void:
	var mouse_pos = get_viewport().get_mouse_position()
	var grid_left = 88.0
	var section_y_base = 45.0 + 44.0  # panel_y + title offset
	var card_w = 176.0
	var card_h = 65.0
	var card_gap_x = 8.0
	var card_gap_y = 6.0
	relics_tab_hover_tier = -1
	relics_tab_hover_row = -1
	relics_tab_hover_col = -1
	for tier in range(3):
		var sec_y = section_y_base + float(tier) * 168.0
		var row_y = sec_y + 24.0
		for row in range(2):
			for col in range(6):
				var cx = grid_left + float(col) * (card_w + card_gap_x)
				var cy = row_y + float(row) * (card_h + card_gap_y)
				if mouse_pos.x >= cx and mouse_pos.x <= cx + card_w and mouse_pos.y >= cy and mouse_pos.y <= cy + card_h:
					relics_tab_hover_tier = tier
					relics_tab_hover_row = row
					relics_tab_hover_col = col
					return

func _update_detail_hover() -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var mouse_pos = get_viewport().get_mouse_position()
	var old_type = detail_hover_type
	var old_idx = detail_hover_index
	detail_hover_type = ""
	detail_hover_index = -1
	# Layout coordinates must match _draw_survivor_detail()
	var panel_x = 70.0
	var panel_y = 38.0
	var top_y = panel_y + 8.0
	var content_y = top_y + 38.0
	var left_x = panel_x + 20.0
	var port_x = left_x
	var port_w = 240.0
	var port_h = 250.0
	var xp_h = 20.0
	var xp_y = content_y + port_h + 6.0
	var levelup_btn_h = 22.0
	var right_x = panel_x + 310.0
	var slot_size = 72.0
	var gear_sy = content_y + 24.0
	var sk_x = right_x + slot_size + 50.0
	var sk_slot_y = content_y + 24.0
	var sk_levels = [3, 5, 8]
	var rel_y = gear_sy + slot_size + 44.0
	var relic_slot_y = rel_y + 24.0
	var relic_slot_size = 72.0
	var relic_gap = 12.0
	# Check level-up button (below XP bar)
	var levelup_btn_y = xp_y + xp_h
	if Rect2(port_x, levelup_btn_y, port_w, levelup_btn_h).has_point(mouse_pos):
		detail_hover_type = "levelup"
		detail_hover_index = 0
		if old_type != detail_hover_type or old_idx != detail_hover_index:
			queue_redraw()
		return
	# Check info overlay "i" icon
	if mouse_pos.distance_to(Vector2(port_x + 22, content_y + port_h - 22)) <= 14.0:
		detail_hover_type = "info_icon"
		detail_hover_index = 0
		if old_type != detail_hover_type or old_idx != detail_hover_index:
			queue_redraw()
		return
	# Check golden shield upgrade button (inside info overlay)
	if detail_info_overlay_open and _gs_upgrade_btn_rect.size.x > 0 and _gs_upgrade_btn_rect.has_point(mouse_pos):
		detail_hover_type = "golden_shield"
		detail_hover_index = 0
		if old_type != detail_hover_type or old_idx != detail_hover_index:
			queue_redraw()
		return
	# Check ability entries (right of relics)
	var abil_x = right_x + 270.0
	var abil_entry_y = rel_y + 30.0
	var abil_entry_h = 48.0
	var abil_w = 520.0
	for ai in range(mini(survivor_detail_abilities.size(), 4)):
		var ay = abil_entry_y + float(ai) * abil_entry_h
		if Rect2(abil_x - 4, ay - 2, abil_w, abil_entry_h - 4).has_point(mouse_pos):
			detail_hover_type = "ability"
			detail_hover_index = ai
			if old_type != detail_hover_type or old_idx != detail_hover_index:
				queue_redraw()
			return
	# Check weapon slot
	if Rect2(right_x, gear_sy, slot_size, slot_size).has_point(mouse_pos):
		detail_hover_type = "weapon"
		detail_hover_index = 0
		if old_type != detail_hover_type or old_idx != detail_hover_index:
			queue_redraw()
		return
	# Check sidekick slots
	for si in range(3):
		var sx = sk_x + float(si) * (slot_size + 14.0)
		if Rect2(sx, sk_slot_y, slot_size, slot_size).has_point(mouse_pos):
			detail_hover_type = "sidekick"
			detail_hover_index = si
			if old_type != detail_hover_type or old_idx != detail_hover_index:
				queue_redraw()
			return
	# Check relic slots (2 rows × 3 cols)
	var tower_type = survivor_types[survivor_detail_index]
	var char_relics = survivor_relics.get(tower_type, [])
	for ri in range(mini(char_relics.size(), 6)):
		var r_row = ri / 3
		var r_col = ri % 3
		var rx = right_x + float(r_col) * (relic_slot_size + relic_gap)
		var ry = relic_slot_y + float(r_row) * (relic_slot_size + 24.0)
		if Rect2(rx, ry, relic_slot_size, relic_slot_size).has_point(mouse_pos):
			detail_hover_type = "relic"
			detail_hover_index = ri
			if old_type != detail_hover_type or old_idx != detail_hover_index:
				queue_redraw()
			return
	if old_type != "" or old_idx >= 0:
		queue_redraw()

func _update_relic_hover() -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var mouse_pos = get_viewport().get_mouse_position()
	# Coordinates must match _draw_survivor_detail()
	var panel_x = 70.0
	var panel_y = 38.0
	var top_y = panel_y + 8.0
	var content_y = top_y + 38.0
	var right_x = panel_x + 340.0
	var slot_size = 64.0
	var gear_sy = content_y + 24.0
	var ally_slot_y = gear_sy + slot_size + 20.0 + 24.0
	var rel_y = ally_slot_y + slot_size + 30.0
	var relic_size = 56.0
	var tower_type = survivor_types[survivor_detail_index]
	var char_relics = survivor_relics.get(tower_type, [])
	var old_hover = relic_hover_index
	relic_hover_index = -1
	for ri in range(6):
		var rx = right_x + float(ri) * (relic_size + 12.0)
		var ry = rel_y + 24.0
		if mouse_pos.x >= rx and mouse_pos.x <= rx + relic_size and mouse_pos.y >= ry and mouse_pos.y <= ry + relic_size:
			relic_hover_index = ri
			break
	# Update tooltip labels
	if relic_hover_index != old_hover:
		var relic_tt_name_lbl = survivor_detail_container.get_node("RelicTooltipName")
		var relic_tt_desc_lbl = survivor_detail_container.get_node("RelicTooltipDesc")
		if relic_hover_index >= 0 and relic_hover_index < char_relics.size():
			var relic_data = char_relics[relic_hover_index]
			var progress = survivor_progress.get(tower_type, {})
			var rel_unlocked = progress.get("relics_unlocked", [false, false, false, false, false, false])
			var is_unlocked = rel_unlocked[relic_hover_index] if relic_hover_index < rel_unlocked.size() else false
			var relic_purchasable = [false, true, false, true, false, true]
			var relic_costs = [0, 100, 0, 250, 0, 500]
			var relic_earn_levels = [2, 4, 6, 8, 10, 12]
			var char_level = progress.get("level", 1)
			var name_text = relic_data["name"]
			if is_unlocked:
				var eq_list = equipped_relics.get(tower_type, [])
				if relic_hover_index in eq_list:
					name_text += "  [EQUIPPED - Click to unequip]"
				else:
					var max_slots = _get_relic_slots(char_level)
					if eq_list.size() < max_slots:
						name_text += "  [OWNED - Click to equip]"
					else:
						name_text += "  [OWNED - Slots full]"
			elif relic_purchasable[relic_hover_index] and char_level >= relic_earn_levels[relic_hover_index]:
				name_text += "  [BUY: %d gold]" % relic_costs[relic_hover_index]
			elif char_level < relic_earn_levels[relic_hover_index]:
				name_text += "  [Lv.%d]" % relic_earn_levels[relic_hover_index]
			if relic_tt_name_lbl:
				relic_tt_name_lbl.text = name_text
				relic_tt_name_lbl.visible = true
			if relic_tt_desc_lbl:
				relic_tt_desc_lbl.text = relic_data["desc"]
				relic_tt_desc_lbl.visible = true
			relic_tooltip_visible = true
		else:
			if relic_tt_name_lbl:
				relic_tt_name_lbl.visible = false
			if relic_tt_desc_lbl:
				relic_tt_desc_lbl.visible = false
			relic_tooltip_visible = false

func _on_relic_clicked(relic_index: int) -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var tower_type = survivor_types[survivor_detail_index]
	var progress = survivor_progress.get(tower_type, {})
	var rel_unlocked = progress.get("relics_unlocked", [false, false, false, false, false, false])
	if relic_index < 0 or relic_index >= rel_unlocked.size():
		return
	# If already owned — toggle equip/unequip
	if rel_unlocked[relic_index]:
		if not equipped_relics.has(tower_type):
			equipped_relics[tower_type] = []
		var eq = equipped_relics[tower_type]
		if relic_index in eq:
			eq.erase(relic_index)
		else:
			var max_slots = _get_relic_slots(progress.get("level", 1))
			if eq.size() < max_slots:
				eq.append(relic_index)
		_save_game()
		queue_redraw()
		return
	# Not yet owned — try to purchase
	var relic_purchasable = [false, true, false, true, false, true]
	var relic_costs = [0, 100, 0, 250, 0, 500]
	var relic_earn_levels = [2, 4, 6, 8, 10, 12]
	var char_level = progress.get("level", 1)
	if not relic_purchasable[relic_index]:
		return
	if char_level < relic_earn_levels[relic_index]:
		return
	var cost = relic_costs[relic_index]
	if gold < cost:
		return
	gold -= cost
	progress["relics_unlocked"][relic_index] = true
	_save_game()
	_open_survivor_detail(survivor_detail_index)

func _on_detail_item_clicked(mouse_pos: Vector2) -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var tower_type = survivor_types[survivor_detail_index]
	var progress = survivor_progress.get(tower_type, {})
	var char_level = progress.get("level", 1)
	# Layout coordinates must match _draw_survivor_detail() and _update_detail_hover()
	var panel_x = 70.0
	var panel_y = 38.0
	var top_y = panel_y + 8.0
	var content_y = top_y + 38.0
	var right_x = panel_x + 310.0
	var slot_size = 72.0
	var gear_sy = content_y + 24.0
	var sk_x = right_x + slot_size + 50.0
	var sk_slot_y = content_y + 24.0
	var rel_y = gear_sy + slot_size + 44.0
	var relic_slot_y = rel_y + 24.0
	var relic_slot_size = 72.0
	var relic_gap = 12.0
	var left_x = panel_x + 20.0
	var port_x = left_x
	var port_w = 240.0
	var port_h = 250.0
	var xp_y = content_y + port_h + 6.0
	var xp_h = 20.0
	# --- Check info overlay toggle (if overlay is open, handle close first) ---
	if detail_info_overlay_open:
		var ov_w = 700.0
		var ov_h = 400.0
		var ov_x = 70.0 + (1140.0 - ov_w) * 0.5
		var ov_y = 38.0 + (570.0 - ov_h) * 0.5
		# Close button (X) in top-right corner
		if mouse_pos.distance_to(Vector2(ov_x + ov_w - 16, ov_y + 16)) <= 14.0:
			detail_info_overlay_open = false
			queue_redraw()
			return
		# Click outside overlay to close
		if not Rect2(ov_x, ov_y, ov_w, ov_h).has_point(mouse_pos):
			detail_info_overlay_open = false
			queue_redraw()
			return
		# Check Golden Shield upgrade button click
		if _gs_upgrade_btn_rect.size.x > 0 and _gs_upgrade_btn_rect.has_point(mouse_pos):
			if _upgrade_golden_shield(tower_type):
				_open_survivor_detail(survivor_detail_index)
			return
		# Click inside overlay — absorb the click
		return
	# --- Check "i" icon click (toggle info overlay) ---
	if mouse_pos.distance_to(Vector2(port_x + 22, content_y + port_h - 22)) <= 14.0:
		detail_info_overlay_open = true
		queue_redraw()
		return
	# --- Check LEVEL UP button click ---
	var levelup_btn_y = xp_y + xp_h
	var levelup_btn_h = 22.0
	if char_level < MAX_SURVIVOR_LEVEL and Rect2(port_x, levelup_btn_y, port_w, levelup_btn_h).has_point(mouse_pos):
		var lvup_cost = _get_levelup_cost(char_level)
		if player_quills >= lvup_cost:
			player_quills -= lvup_cost
			progress["level"] = char_level + 1
			progress["xp"] = 0.0
			progress["xp_next"] = _get_xp_for_level(char_level + 1)
			# Unlock gear at level 2
			if char_level + 1 >= 2 and not progress.get("gear_unlocked", false):
				progress["gear_unlocked"] = true
			# Unlock sidekicks at levels 3, 5, 8
			var sk_unlock_levels = [3, 5, 8]
			for si in range(3):
				if char_level + 1 >= sk_unlock_levels[si]:
					var sk_arr = progress.get("sidekicks_unlocked", [false, false, false])
					if si < sk_arr.size() and not sk_arr[si]:
						sk_arr[si] = true
						progress["sidekicks_unlocked"] = sk_arr
			_save_game()
			_open_survivor_detail(survivor_detail_index)
		return
	# --- Check character-specific relic clicks (2 rows × 3 cols) ---
	var char_relics = survivor_relics.get(tower_type, [])
	var rel_unlocked_arr = progress.get("relics_unlocked", [false, false, false, false, false, false])
	var relic_purchasable = [false, true, false, true, false, true]
	var relic_costs = [0, 100, 0, 250, 0, 500]
	var relic_earn_levels = [2, 4, 6, 8, 10, 12]
	for ri in range(mini(char_relics.size(), 6)):
		var r_row = ri / 3
		var r_col = ri % 3
		var rx = right_x + float(r_col) * (relic_slot_size + relic_gap)
		var ry = relic_slot_y + float(r_row) * (relic_slot_size + 24.0)
		if Rect2(rx, ry, relic_slot_size, relic_slot_size).has_point(mouse_pos):
			var is_unlocked = rel_unlocked_arr[ri] if ri < rel_unlocked_arr.size() else false
			if is_unlocked:
				# Toggle equip/unequip
				if not equipped_relics.has(tower_type):
					equipped_relics[tower_type] = []
				var eq = equipped_relics[tower_type]
				if ri in eq:
					eq.erase(ri)
				else:
					var max_slots = _get_relic_slots(char_level)
					if eq.size() < max_slots:
						eq.append(ri)
				_save_game()
				queue_redraw()
			elif relic_purchasable[ri] and char_level >= relic_earn_levels[ri]:
				# Purchase with gold
				var cost = relic_costs[ri]
				if gold >= cost:
					gold -= cost
					progress["relics_unlocked"][ri] = true
					_save_game()
					queue_redraw()
			return
	# --- Check Tome Binding clicks (slots + owned list) ---
	var bind_slots = _get_binding_slots(tower_type)
	if bind_slots > 0:
		var eq_bindings = equipped_bindings.get(tower_type, [])
		# Tome binding slot area
		var relic_desc_y = relic_slot_y + 2.0 * (relic_slot_size + 24.0) + 4.0
		var tome_y = relic_desc_y + 18.0
		var tome_slot_y = tome_y + 22.0
		var tome_slot_size = 44.0
		for tsi in range(bind_slots):
			var tx = right_x + float(tsi) * (tome_slot_size + 8)
			var ty = tome_slot_y
			if Rect2(tx, ty, tome_slot_size, tome_slot_size).has_point(mouse_pos):
				if tsi < eq_bindings.size():
					eq_bindings.remove_at(tsi)
					equipped_bindings[tower_type] = eq_bindings
					_save_game()
					queue_redraw()
				return
		# Owned bindings list (with scroll offset)
		var browse_y = tome_slot_y + tome_slot_size + 6.0
		var bcol = 0
		var brow = 0
		var card_w = 200.0
		var card_h = 28.0
		for b in TOME_BINDINGS:
			var count = owned_bindings.get(b["id"], 0)
			if count <= 0:
				continue
			var bx = right_x + float(bcol) * (card_w + 8)
			var by = browse_y + float(brow) * (card_h + 3) - detail_binding_scroll
			if by > panel_y + 570.0 - 20:
				bcol += 1
				if bcol >= 3:
					bcol = 0
					brow += 1
				continue
			if by >= browse_y - card_h and Rect2(bx, by, card_w, card_h).has_point(mouse_pos):
				var is_eq = b["id"] in eq_bindings
				if is_eq:
					eq_bindings.erase(b["id"])
				elif eq_bindings.size() < bind_slots:
					eq_bindings.append(b["id"])
				equipped_bindings[tower_type] = eq_bindings
				_save_game()
				queue_redraw()
				return
			bcol += 1
			if bcol >= 3:
				bcol = 0
				brow += 1

func _on_trinket_slot_clicked(mouse_pos: Vector2) -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var tower_type = survivor_types[survivor_detail_index]
	var bind_slots = _get_binding_slots(tower_type)
	if bind_slots <= 0:
		return
	var eq_bindings = equipped_bindings.get(tower_type, [])

	# Layout coordinates must match _draw_survivor_detail()
	var panel_x = 70.0
	var panel_y = 38.0
	var top_y = panel_y + 8.0
	var content_y = top_y + 38.0
	var right_x = panel_x + 340.0
	var slot_size = 64.0

	# Calculate relic section Y: gear(64) + 20 gap + ally header(24) + ally slots(64) + 30 gap
	var gear_sy = content_y + 24.0
	var ally_slot_y = gear_sy + slot_size + 20.0 + 24.0
	var relic_slot_y = ally_slot_y + slot_size + 30.0 + 24.0
	var relic_slot_size = 56.0

	# Check clicks on the 5 relic SLOTS (top row)
	for ri in range(5):
		var rx = right_x + float(ri) * (relic_slot_size + 12.0)
		var ry = relic_slot_y
		if mouse_pos.x >= rx and mouse_pos.x <= rx + relic_slot_size and mouse_pos.y >= ry and mouse_pos.y <= ry + relic_slot_size:
			var slot_unlocked = ri < bind_slots
			if slot_unlocked and ri < eq_bindings.size():
				# Unequip this relic
				eq_bindings.remove_at(ri)
				equipped_bindings[tower_type] = eq_bindings
				_save_game()
				queue_redraw()
			return

	# Check clicks on owned relics browser (below slots, with scroll offset)
	var browse_y = relic_slot_y + relic_slot_size + 20.0 + 14.0
	var card_w = 200.0
	var card_h = 32.0
	var trinket_col = 0
	var trinket_row = 0
	for b in TOME_BINDINGS:
		var count = owned_bindings.get(b["id"], 0)
		if count <= 0:
			continue
		var tx = right_x + float(trinket_col) * (card_w + 8)
		var ty = browse_y + float(trinket_row) * (card_h + 4) - detail_binding_scroll
		if mouse_pos.x >= tx and mouse_pos.x <= tx + card_w and mouse_pos.y >= ty and mouse_pos.y <= ty + card_h:
			if ty >= browse_y - card_h and ty <= panel_y + 560.0:
				var is_eq = b["id"] in eq_bindings
				if is_eq:
					eq_bindings.erase(b["id"])
					equipped_bindings[tower_type] = eq_bindings
				elif eq_bindings.size() < bind_slots:
					eq_bindings.append(b["id"])
					equipped_bindings[tower_type] = eq_bindings
				_save_game()
				queue_redraw()
				return
		trinket_col += 1
		if trinket_col >= 3:
			trinket_col = 0
			trinket_row += 1

func _remove_detail_preview() -> void:
	if survivor_detail_preview and is_instance_valid(survivor_detail_preview):
		survivor_detail_preview.queue_free()
		survivor_detail_preview = null

func _remove_survivor_preview() -> void:
	_remove_detail_preview()
	_clear_grid_previews()
	if survivor_preview_node and is_instance_valid(survivor_preview_node):
		survivor_preview_node.queue_free()
		survivor_preview_node = null

func _spawn_grid_previews() -> void:
	_clear_grid_previews()
	var card_w = 310.0
	var card_h = 210.0
	var grid_margin_x = 65.0
	var grid_margin_y = 65.0
	var gap_x = 40.0
	var gap_y = 30.0
	var panel_x = 70.0
	var panel_y = 45.0
	for i in range(6):
		var col_i = i % 3
		var row_i = i / 3
		var cx = panel_x + grid_margin_x + float(col_i) * (card_w + gap_x)
		var cy = panel_y + grid_margin_y + float(row_i) * (card_h + gap_y)
		var tower_type = survivor_types[i]
		var preview = tower_scenes[tower_type].instantiate()
		preview.position = Vector2(cx + 70, cy + 115)
		preview.scale = Vector2(1.8, 1.8)
		preview.process_mode = Node.PROCESS_MODE_DISABLED
		add_child(preview)
		survivor_grid_previews.append(preview)

func _clear_grid_previews() -> void:
	for p in survivor_grid_previews:
		if is_instance_valid(p):
			p.queue_free()
	survivor_grid_previews.clear()

func _is_level_unlocked(idx: int) -> bool:
	if idx == 0:
		return true
	return (idx - 1) in completed_levels

func _on_level_selected(index: int) -> void:
	if not _is_level_unlocked(index):
		return
	# Check for pre-level story dialog
	var pre_key = "pre_level_" + str(index)
	if story_dialogs.has(pre_key) and not pre_key in story_seen:
		# Also check for act intro dialogs that should play first
		var act_key = ""
		if index == 16 and not "act2_intro" in story_seen:
			act_key = "act2_intro"
		_pending_level_start = index
		if act_key != "":
			story_state.queued_dialog = pre_key
			_start_story_dialog(act_key)
		else:
			_start_story_dialog(pre_key)
		return
	_do_level_start(index)

var _pending_level_start: int = -1

func _do_level_start(index: int) -> void:
	_remove_survivor_preview()
	current_level = index
	_reset_game()
	var level = levels[index]
	gold = level["gold"] + difficulty_gold_bonus[selected_difficulty] + int(_get_knowledge_bonus("start_gold"))
	lives = difficulty_fixed_lives[selected_difficulty] + int(_get_knowledge_bonus("lives"))
	total_waves = difficulty_waves[selected_difficulty]
	_setup_path_for_level(index)
	_generate_decorations_for_level(index)
	_stop_music()
	menu_overlay.visible = false
	top_bar.visible = true
	bottom_panel.visible = true
	game_over_label.visible = false
	return_button.visible = false
	game_state = GameState.PLAYING
	start_button.text = "  START WAVE  "
	tower_buttons[TowerType.ROBIN_HOOD].text = "Robin [%dG]" % _get_discounted_cost(TowerType.ROBIN_HOOD)
	tower_buttons[TowerType.ROBIN_HOOD].disabled = false
	tower_buttons[TowerType.ALICE].text = "Alice [%dG]" % _get_discounted_cost(TowerType.ALICE)
	tower_buttons[TowerType.ALICE].disabled = false
	tower_buttons[TowerType.WICKED_WITCH].text = "Witch [%dG]" % _get_discounted_cost(TowerType.WICKED_WITCH)
	tower_buttons[TowerType.WICKED_WITCH].disabled = false
	tower_buttons[TowerType.PETER_PAN].text = "Peter [%dG]" % _get_discounted_cost(TowerType.PETER_PAN)
	tower_buttons[TowerType.PETER_PAN].disabled = false
	tower_buttons[TowerType.PHANTOM].text = "Phantom [%dG]" % _get_discounted_cost(TowerType.PHANTOM)
	tower_buttons[TowerType.PHANTOM].disabled = false
	tower_buttons[TowerType.SCROOGE].text = "Scrooge [%dG]" % _get_discounted_cost(TowerType.SCROOGE)
	tower_buttons[TowerType.SCROOGE].disabled = false
	# Show unlocked character buttons — row 2, stretched horizontally
	var new_char_order = [TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA, TowerType.MERLIN, TowerType.FRANKENSTEIN]
	var new_char_labels = {
		TowerType.SHERLOCK: "Holmes [%dG]" % _get_discounted_cost(TowerType.SHERLOCK),
		TowerType.TARZAN: "Tarzan [%dG]" % _get_discounted_cost(TowerType.TARZAN),
		TowerType.DRACULA: "Dracula [%dG]" % _get_discounted_cost(TowerType.DRACULA),
		TowerType.MERLIN: "Merlin [%dG]" % _get_discounted_cost(TowerType.MERLIN),
		TowerType.FRANKENSTEIN: "Monster [%dG]" % _get_discounted_cost(TowerType.FRANKENSTEIN),
	}
	var new_visible_count := 0
	for tt in new_char_order:
		if tower_buttons.has(tt):
			if tt in survivor_types and _is_character_unlocked(tt):
				var bx = 8 + new_visible_count * 158
				tower_buttons[tt].position = Vector2(bx, 42)
				tower_buttons[tt].visible = true
				tower_buttons[tt].text = new_char_labels[tt]
				tower_buttons[tt].disabled = false
				new_visible_count += 1
			else:
				tower_buttons[tt].visible = false
	# Panel height: 2 rows if unlocked chars, 1 row if not
	if new_visible_count > 0:
		bottom_panel.size.y = 80
		bottom_panel.position.y = 720 - 80
	else:
		bottom_panel.size.y = 42
		bottom_panel.position.y = 720 - 42
	start_button.visible = true
	start_button.disabled = false
	speed_button.visible = true
	update_hud()
	var diff_name = ["Easy", "Medium", "Hard"][selected_difficulty]
	info_label.text = level["name"] + " (%s) - Place your towers!" % diff_name
	wave_auto_timer = -1.0
	# Show power selection if player has any powers
	var has_any_powers = false
	for bp in battle_power_definitions:
		if owned_powers.get(bp["id"], 0) > 0:
			has_any_powers = true
			break
	if has_any_powers and not odyssey_active:
		_open_power_selection()

func _reset_game() -> void:
	for tower in get_tree().get_nodes_in_group("towers"):
		tower.queue_free()
	for enemy in get_tree().get_nodes_in_group("enemies"):
		enemy.queue_free()
	wave = 0
	is_wave_active = false
	game_paused = false
	placing_tower = false
	enemies_to_spawn = 0
	enemies_alive = 0
	spawn_timer = 0.0
	purchased_towers.clear()
	placed_tower_positions.clear()
	selected_tower_node = null
	wave_auto_timer = -1.0
	_hide_upgrade_panel()
	# Reset session damage tracking
	for t in survivor_types:
		session_damage[t] = 0.0
	# Reset per-game achievement tracking
	current_game_lives_lost = 0
	current_game_fast_forward_only = true
	# Reset battle power state
	storybook_shield_charges = 0
	power_enchanted_timer = 0.0
	active_power_effects.clear()
	# Reset floating texts and death effects
	_floating_texts.clear()
	_screen_shake_timer = 0.0
	# Reset placed instruments and branch choices
	placed_instruments.clear()
	tower_branch_choice.clear()
	_placing_instrument = ""
	_instrument_picker_open = false
	_screen_shake_intensity = 0.0
	_screen_shake_offset = Vector2.ZERO
	_ink_splatters.clear()
	_death_flash_timer = 0.0
	# Reset boss rescue animation
	boss_rescue_active = false
	boss_rescue_timer = 0.0
	boss_rescue_boss_ref = null
	boss_rescue_phase = 0
	_rescue_smoke_particles.clear()

func _setup_path_for_level(index: int) -> void:
	var curve = enemy_path.curve
	if not curve:
		return
	curve.clear_points()
	match index:
		0: # Prologue — Into the Pages (Easy/Tutorial — spiral inward, falling into book)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 320), Vector2(-60, 0), Vector2(0, -120))
			curve.add_point(Vector2(200, 100), Vector2(0, 60), Vector2(120, 0))
			curve.add_point(Vector2(1080, 100), Vector2(-100, 0), Vector2(0, 120))
			curve.add_point(Vector2(1080, 540), Vector2(0, -100), Vector2(-120, 0))
			curve.add_point(Vector2(300, 540), Vector2(100, 0), Vector2(0, -100))
			curve.add_point(Vector2(300, 200), Vector2(0, 80), Vector2(100, 0))
			curve.add_point(Vector2(960, 200), Vector2(-80, 0), Vector2(0, 100))
			curve.add_point(Vector2(960, 460), Vector2(0, -80), Vector2(-100, 0))
			curve.add_point(Vector2(420, 460), Vector2(80, 0), Vector2(0, -80))
			curve.add_point(Vector2(420, 280), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(840, 280), Vector2(-60, 0), Vector2(0, 60))
			curve.add_point(Vector2(840, 380), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(640, 340), Vector2(40, 0), Vector2(0, 80))
			curve.add_point(Vector2(640, 670))
		1: # Sherlock Ch1 — Baker Street (EASY — long city grid zigzag, 4 full passes)
			curve.add_point(Vector2(-50, 100), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(200, 100), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(640, 120), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 100), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 220), Vector2(0, -30), Vector2(-60, 0))
			curve.add_point(Vector2(640, 240), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 220), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 340), Vector2(0, -30), Vector2(60, 0))
			curve.add_point(Vector2(640, 360), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 340), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 460), Vector2(0, -30), Vector2(-60, 0))
			curve.add_point(Vector2(640, 480), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 460), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 560), Vector2(0, -30), Vector2(60, 0))
			curve.add_point(Vector2(640, 580), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 580))
		2: # Sherlock Ch2 — Whitechapel (MEDIUM — winding alleyway, diagonal S-curves)
			curve.add_point(Vector2(-50, 520), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 520), Vector2(-40, 0), Vector2(60, -80))
			curve.add_point(Vector2(320, 360), Vector2(0, 60), Vector2(60, -40))
			curve.add_point(Vector2(480, 260), Vector2(-40, 40), Vector2(60, 0))
			curve.add_point(Vector2(640, 320), Vector2(-40, 0), Vector2(60, 60))
			curve.add_point(Vector2(780, 480), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(920, 420), Vector2(-40, 0), Vector2(40, -60))
			curve.add_point(Vector2(1000, 260), Vector2(0, 50), Vector2(40, -60))
			curve.add_point(Vector2(1060, 140), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(1200, 200), Vector2(-40, 0), Vector2(60, 40))
			curve.add_point(Vector2(1330, 300))
		3: # Sherlock Ch3 — Reichenbach Falls (HARD — short switchback descent)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 120), Vector2(0, -40), Vector2(-120, 0))
			curve.add_point(Vector2(200, 200), Vector2(80, 0), Vector2(0, 80))
			curve.add_point(Vector2(200, 380), Vector2(0, -40), Vector2(120, 0))
			curve.add_point(Vector2(1060, 440), Vector2(-100, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 560), Vector2(0, -40), Vector2(-120, 0))
			curve.add_point(Vector2(640, 670))
		4: # Merlin Ch1 — Round Table (EASY — large oval loop + inner spiral)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(120, 320), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(120, 100), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(640, 80), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(1140, 100), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(1140, 320), Vector2(0, -60), Vector2(0, 80))
			curve.add_point(Vector2(1140, 540), Vector2(0, -60), Vector2(-80, 0))
			curve.add_point(Vector2(640, 560), Vector2(80, 0), Vector2(-80, 0))
			curve.add_point(Vector2(240, 540), Vector2(60, 0), Vector2(0, -60))
			curve.add_point(Vector2(240, 400), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(500, 380), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(900, 380), Vector2(-60, 0), Vector2(0, -60))
			curve.add_point(Vector2(900, 220), Vector2(0, 40), Vector2(-60, 0))
			curve.add_point(Vector2(500, 200), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(500, 320), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(740, 300), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(740, 670))
		5: # Merlin Ch2 — Enchanted Forest (MEDIUM — flowing S-curves)
			curve.add_point(Vector2(-50, 200), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 200), Vector2(-40, 0), Vector2(60, 80))
			curve.add_point(Vector2(300, 400), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(480, 440), Vector2(-40, 0), Vector2(60, -60))
			curve.add_point(Vector2(600, 280), Vector2(0, 40), Vector2(60, -40))
			curve.add_point(Vector2(720, 160), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(860, 200), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(940, 420), Vector2(0, -60), Vector2(60, 40))
			curve.add_point(Vector2(1060, 520), Vector2(-40, -20), Vector2(60, 0))
			curve.add_point(Vector2(1180, 480), Vector2(-40, 0), Vector2(60, -40))
			curve.add_point(Vector2(1330, 360))
		6: # Merlin Ch3 — Crystal Cave (HARD — short U-turn)
			curve.add_point(Vector2(-50, 260), Vector2.ZERO, Vector2(100, 0))
			curve.add_point(Vector2(300, 240), Vector2(-80, 0), Vector2(100, 0))
			curve.add_point(Vector2(900, 200), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(1120, 280), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(1060, 460), Vector2(40, -40), Vector2(-80, 0))
			curve.add_point(Vector2(640, 500), Vector2(60, 0), Vector2(-60, 40))
			curve.add_point(Vector2(400, 670))
		7: # Tarzan Ch1 — Jungle Canopy (EASY — vine swing arcs, full screen)
			curve.add_point(Vector2(-50, 100), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 100), Vector2(-40, 0), Vector2(60, 80))
			curve.add_point(Vector2(300, 340), Vector2(0, -80), Vector2(80, 60))
			curve.add_point(Vector2(500, 520), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(700, 480), Vector2(-60, 0), Vector2(60, -80))
			curve.add_point(Vector2(800, 260), Vector2(0, 60), Vector2(-60, -60))
			curve.add_point(Vector2(640, 100), Vector2(40, 0), Vector2(-80, 0))
			curve.add_point(Vector2(400, 140), Vector2(60, 0), Vector2(-60, 60))
			curve.add_point(Vector2(260, 320), Vector2(0, -60), Vector2(0, 80))
			curve.add_point(Vector2(260, 520), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(500, 560), Vector2(-60, 0), Vector2(80, -40))
			curve.add_point(Vector2(740, 440), Vector2(-40, 40), Vector2(60, -60))
			curve.add_point(Vector2(880, 240), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(1040, 200), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(1120, 440), Vector2(0, -60), Vector2(60, 60))
			curve.add_point(Vector2(1330, 580))
		8: # Tarzan Ch2 — River Crossing (MEDIUM — zigzag across river)
			curve.add_point(Vector2(-50, 400), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 400), Vector2(-60, 0), Vector2(60, -80))
			curve.add_point(Vector2(360, 200), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(520, 240), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(600, 440), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(760, 460), Vector2(-40, 0), Vector2(40, -80))
			curve.add_point(Vector2(840, 240), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(980, 200), Vector2(-40, 0), Vector2(40, 60))
			curve.add_point(Vector2(1060, 400), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(1200, 360), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 380))
		9: # Tarzan Ch3 — Fortress Assault (HARD — direct with sharp turns)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(100, 0))
			curve.add_point(Vector2(300, 320), Vector2(-80, 0), Vector2(60, -60))
			curve.add_point(Vector2(480, 180), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(780, 200), Vector2(-80, 0), Vector2(60, 60))
			curve.add_point(Vector2(920, 380), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1140, 360), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1330, 340))
		10: # Dracula Ch1 — Transylvania Village (EASY — mountain switchbacks, 5 passes)
			curve.add_point(Vector2(-50, 560), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 560), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1060, 540), Vector2(-80, 0), Vector2(0, -50))
			curve.add_point(Vector2(1060, 440), Vector2(0, 30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 460), Vector2(80, 0), Vector2(0, -50))
			curve.add_point(Vector2(200, 360), Vector2(0, 30), Vector2(80, 0))
			curve.add_point(Vector2(1060, 340), Vector2(-80, 0), Vector2(0, -50))
			curve.add_point(Vector2(1060, 240), Vector2(0, 30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 260), Vector2(80, 0), Vector2(0, -50))
			curve.add_point(Vector2(200, 160), Vector2(0, 30), Vector2(80, 0))
			curve.add_point(Vector2(640, 140), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1060, 120), Vector2(-80, 0), Vector2(0, 50))
			curve.add_point(Vector2(1060, 200), Vector2(0, -30), Vector2(-60, 40))
			curve.add_point(Vector2(900, 320), Vector2(40, -40), Vector2(-60, 40))
			curve.add_point(Vector2(740, 460), Vector2(40, -40), Vector2(-60, 40))
			curve.add_point(Vector2(640, 670))
		11: # Dracula Ch2 — Castle Corridors (MEDIUM — maze-like center path)
			curve.add_point(Vector2(-50, 300), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(160, 300), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(160, 120), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(500, 120), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(500, 400), Vector2(0, -60), Vector2(-60, 0))
			curve.add_point(Vector2(300, 400), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(300, 540), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(700, 540), Vector2(-60, 0), Vector2(0, -80))
			curve.add_point(Vector2(700, 280), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(960, 280), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(960, 500), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 500))
		12: # Dracula Ch3 — Crypt Descent (HARD — short spiral down)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 80))
			curve.add_point(Vector2(640, 140), Vector2(0, -40), Vector2(100, 0))
			curve.add_point(Vector2(940, 200), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(880, 400), Vector2(40, -40), Vector2(-80, 0))
			curve.add_point(Vector2(480, 360), Vector2(60, 0), Vector2(0, 60))
			curve.add_point(Vector2(520, 480), Vector2(-20, -40), Vector2(40, 40))
			curve.add_point(Vector2(600, 560), Vector2(-20, 0), Vector2(0, 40))
			curve.add_point(Vector2(620, 670))
		13: # Frankenstein Ch1 — Lab Corridors (EASY — 4 full horizontal passes)
			curve.add_point(Vector2(-50, 100), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(200, 100), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(640, 80), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 100), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 220), Vector2(0, -30), Vector2(-60, 0))
			curve.add_point(Vector2(640, 240), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 220), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 350), Vector2(0, -30), Vector2(60, 0))
			curve.add_point(Vector2(640, 370), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 350), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 470), Vector2(0, -30), Vector2(-60, 0))
			curve.add_point(Vector2(640, 490), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 470), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 560), Vector2(0, -30), Vector2(60, 0))
			curve.add_point(Vector2(640, 580), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 580))
		14: # Frankenstein Ch2 — Village Streets (MEDIUM — grid pattern)
			curve.add_point(Vector2(-50, 300), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 300), Vector2(-60, 0), Vector2(0, -80))
			curve.add_point(Vector2(200, 120), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(500, 140), Vector2(-60, 0), Vector2(60, 60))
			curve.add_point(Vector2(600, 340), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(800, 300), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(800, 520), Vector2(0, -60), Vector2(-80, 0))
			curve.add_point(Vector2(480, 540), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(240, 520), Vector2(60, 0), Vector2(0, -60))
			curve.add_point(Vector2(200, 400), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(1000, 440), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(1330, 420))
		15: # Frankenstein Ch3 — Arctic Traverse (HARD — nearly straight)
			curve.add_point(Vector2(-50, 340), Vector2.ZERO, Vector2(100, 0))
			curve.add_point(Vector2(280, 300), Vector2(-80, 0), Vector2(100, -20))
			curve.add_point(Vector2(640, 260), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(960, 300), Vector2(-80, 0), Vector2(80, 20))
			curve.add_point(Vector2(1200, 340), Vector2(-80, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 320))
		16: # Robin Hood Ch1 — Forest Trail (EASY — winding with U-turns)
			curve.add_point(Vector2(-50, 120), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(200, 120), Vector2(-40, 0), Vector2(80, 0))
			curve.add_point(Vector2(1060, 100), Vector2(-80, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 220), Vector2(0, -40), Vector2(-80, 0))
			curve.add_point(Vector2(200, 240), Vector2(80, 0), Vector2(0, 60))
			curve.add_point(Vector2(200, 360), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(640, 340), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1060, 360), Vector2(-60, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 480), Vector2(0, -40), Vector2(-80, 0))
			curve.add_point(Vector2(640, 500), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 480), Vector2(60, 0), Vector2(0, -60))
			curve.add_point(Vector2(200, 400), Vector2(0, 40), Vector2(-40, 0))
			curve.add_point(Vector2(100, 400), Vector2(30, 0), Vector2(0, 60))
			curve.add_point(Vector2(100, 560), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(640, 580), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 560))
		17: # Robin Hood Ch2 — River and Bridge (MEDIUM — S-curves with crossing)
			curve.add_point(Vector2(-50, 200), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 200), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(260, 420), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(440, 460), Vector2(-40, 0), Vector2(60, -60))
			curve.add_point(Vector2(580, 280), Vector2(0, 40), Vector2(60, -40))
			curve.add_point(Vector2(700, 160), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(840, 200), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(920, 420), Vector2(0, -60), Vector2(60, 40))
			curve.add_point(Vector2(1040, 520), Vector2(-40, -20), Vector2(60, 0))
			curve.add_point(Vector2(1180, 480), Vector2(-40, 0), Vector2(60, -40))
			curve.add_point(Vector2(1330, 360))
		18: # Robin Hood Ch3 — Castle Siege (HARD — direct diagonal assault)
			curve.add_point(Vector2(-50, 540), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 520), Vector2(-60, 0), Vector2(80, -40))
			curve.add_point(Vector2(480, 380), Vector2(-60, 30), Vector2(80, -40))
			curve.add_point(Vector2(700, 280), Vector2(-60, 20), Vector2(60, -40))
			curve.add_point(Vector2(840, 180), Vector2(-40, 20), Vector2(60, 0))
			curve.add_point(Vector2(1000, 200), Vector2(-40, 0), Vector2(0, -60))
			curve.add_point(Vector2(1000, 100), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(1330, 120))
		19: # Alice Ch1 — Rabbit Hole Fall (EASY — zigzag descent, full screen)
			curve.add_point(Vector2(100, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(100, 100), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(1060, 80), Vector2(-80, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 180), Vector2(0, -40), Vector2(-80, 0))
			curve.add_point(Vector2(200, 200), Vector2(80, 0), Vector2(0, 60))
			curve.add_point(Vector2(200, 300), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(1060, 280), Vector2(-80, 0), Vector2(0, 60))
			curve.add_point(Vector2(1060, 380), Vector2(0, -40), Vector2(-80, 0))
			curve.add_point(Vector2(200, 400), Vector2(80, 0), Vector2(0, 60))
			curve.add_point(Vector2(200, 500), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(640, 480), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1060, 500), Vector2(-60, 0), Vector2(0, 40))
			curve.add_point(Vector2(1060, 560), Vector2(0, -20), Vector2(-80, 0))
			curve.add_point(Vector2(640, 580), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 560), Vector2(60, 0), Vector2(0, 40))
			curve.add_point(Vector2(200, 670))
		20: # Alice Ch2 — Tea Party Checkerboard (MEDIUM — step pattern)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 100), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(400, 100), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(400, 240), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(640, 240), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(880, 240), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(880, 380), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(640, 380), Vector2(40, 0), Vector2(-60, 0))
			curve.add_point(Vector2(400, 380), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(400, 520), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(800, 520), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1330, 540))
		21: # Alice Ch3 — Queen's Throne (HARD — short direct approach)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(100, 0))
			curve.add_point(Vector2(300, 280), Vector2(-80, 0), Vector2(80, 0))
			curve.add_point(Vector2(640, 300), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(900, 320), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(900, 500), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(1200, 480), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 460))
		22: # Wicked Witch Ch1 — Yellow Brick Road (EASY — long sweeping S-curves)
			curve.add_point(Vector2(-50, 400), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(120, 400), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(120, 160), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(400, 160), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(400, 480), Vector2(0, -80), Vector2(80, 0))
			curve.add_point(Vector2(700, 480), Vector2(-60, 0), Vector2(0, -80))
			curve.add_point(Vector2(700, 160), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(960, 160), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(960, 480), Vector2(0, -60), Vector2(-60, 0))
			curve.add_point(Vector2(700, 540), Vector2(40, 0), Vector2(-60, 0))
			curve.add_point(Vector2(400, 560), Vector2(40, 0), Vector2(-80, 0))
			curve.add_point(Vector2(160, 540), Vector2(60, 0), Vector2(0, -40))
			curve.add_point(Vector2(160, 480), Vector2(0, 20), Vector2(60, 0))
			curve.add_point(Vector2(1100, 520), Vector2(-80, 0), Vector2(0, -60))
			curve.add_point(Vector2(1100, 340), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(1330, 320))
		23: # Wicked Witch Ch2 — Witch's Domain (MEDIUM — zigzag with vertical runs)
			curve.add_point(Vector2(-50, 300), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(160, 300), Vector2(-40, 0), Vector2(0, -60))
			curve.add_point(Vector2(160, 140), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(400, 140), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(400, 480), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(640, 480), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(640, 200), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(880, 200), Vector2(-60, 0), Vector2(0, 80))
			curve.add_point(Vector2(880, 440), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1100, 400), Vector2(-60, 0), Vector2(60, 60))
			curve.add_point(Vector2(1200, 520), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(1330, 500))
		24: # Wicked Witch Ch3 — Emerald City Interior (HARD — compact center path)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 120), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(880, 160), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(860, 340), Vector2(20, -40), Vector2(-60, 40))
			curve.add_point(Vector2(640, 420), Vector2(40, 0), Vector2(-60, 0))
			curve.add_point(Vector2(400, 380), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(420, 520), Vector2(-20, -40), Vector2(60, 0))
			curve.add_point(Vector2(800, 540), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1330, 560))
		25: # Peter Pan Ch1 — Flight over Neverland (EASY — big sweeping arcs)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 320), Vector2(-40, 0), Vector2(60, -100))
			curve.add_point(Vector2(300, 100), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(600, 120), Vector2(-60, 0), Vector2(60, 80))
			curve.add_point(Vector2(740, 380), Vector2(0, -60), Vector2(-60, 60))
			curve.add_point(Vector2(560, 540), Vector2(60, 0), Vector2(-80, 0))
			curve.add_point(Vector2(280, 500), Vector2(60, 0), Vector2(-60, -60))
			curve.add_point(Vector2(160, 360), Vector2(0, 40), Vector2(0, -60))
			curve.add_point(Vector2(200, 200), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(480, 220), Vector2(-40, 0), Vector2(60, 0))
			curve.add_point(Vector2(860, 180), Vector2(-60, 0), Vector2(60, 60))
			curve.add_point(Vector2(1000, 400), Vector2(0, -60), Vector2(0, 60))
			curve.add_point(Vector2(1000, 540), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(760, 560), Vector2(40, 0), Vector2(60, 0))
			curve.add_point(Vector2(1060, 520), Vector2(-60, 0), Vector2(80, 0))
			curve.add_point(Vector2(1330, 480))
		26: # Peter Pan Ch2 — Lost Boys' Jungle (MEDIUM — moderate weaving)
			curve.add_point(Vector2(-50, 500), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(160, 500), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(160, 300), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(360, 300), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(360, 120), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(580, 120), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(580, 380), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(780, 380), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(780, 180), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(1000, 180), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(1000, 420), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 400))
		27: # Peter Pan Ch3 — Pirate Ship Approach (HARD — short direct path)
			curve.add_point(Vector2(1330, 200), Vector2.ZERO, Vector2(-80, 0))
			curve.add_point(Vector2(1060, 200), Vector2(60, 0), Vector2(-60, 60))
			curve.add_point(Vector2(880, 360), Vector2(40, -40), Vector2(-60, 40))
			curve.add_point(Vector2(700, 480), Vector2(40, -30), Vector2(-80, 0))
			curve.add_point(Vector2(400, 440), Vector2(60, 0), Vector2(-60, -40))
			curve.add_point(Vector2(240, 320), Vector2(40, 40), Vector2(-60, 0))
			curve.add_point(Vector2(-50, 340))
		28: # Phantom Ch1 — Grand Stage Descent (EASY — long switchback, 4+ runs)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 80), Vector2(0, -40), Vector2(80, 0))
			curve.add_point(Vector2(1080, 80), Vector2(-60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 180), Vector2(0, -30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 200), Vector2(80, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 300), Vector2(0, -30), Vector2(80, 0))
			curve.add_point(Vector2(1080, 280), Vector2(-80, 0), Vector2(0, 50))
			curve.add_point(Vector2(1080, 380), Vector2(0, -30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 400), Vector2(80, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 500), Vector2(0, -30), Vector2(80, 0))
			curve.add_point(Vector2(640, 480), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1080, 500), Vector2(-60, 0), Vector2(0, 40))
			curve.add_point(Vector2(1080, 560), Vector2(0, -20), Vector2(-80, 0))
			curve.add_point(Vector2(640, 580), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 560), Vector2(60, 0), Vector2(0, 40))
			curve.add_point(Vector2(200, 670))
		29: # Phantom Ch2 — Underground Labyrinth (MEDIUM — maze-like turns)
			curve.add_point(Vector2(-50, 160), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(140, 160), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(140, 340), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(340, 340), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(340, 140), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(560, 140), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(560, 420), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(760, 420), Vector2(-60, 0), Vector2(0, -80))
			curve.add_point(Vector2(760, 200), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(960, 200), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(960, 500), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 480))
		30: # Phantom Ch3 — Phantom's Lair (HARD — short path to center)
			curve.add_point(Vector2(1330, 160), Vector2.ZERO, Vector2(-80, 0))
			curve.add_point(Vector2(1060, 160), Vector2(60, 0), Vector2(-60, 60))
			curve.add_point(Vector2(880, 320), Vector2(40, -40), Vector2(-60, 0))
			curve.add_point(Vector2(640, 340), Vector2(40, 0), Vector2(-60, 40))
			curve.add_point(Vector2(440, 460), Vector2(40, -30), Vector2(-60, 0))
			curve.add_point(Vector2(280, 440), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(300, 560), Vector2(0, -30), Vector2(80, 0))
			curve.add_point(Vector2(640, 670))
		31: # Scrooge Ch1 — City Blocks (EASY — long winding grid, multiple passes)
			curve.add_point(Vector2(1330, 120), Vector2.ZERO, Vector2(-80, 0))
			curve.add_point(Vector2(1060, 120), Vector2(60, 0), Vector2(0, 50))
			curve.add_point(Vector2(1060, 240), Vector2(0, -30), Vector2(-80, 0))
			curve.add_point(Vector2(200, 260), Vector2(80, 0), Vector2(0, 50))
			curve.add_point(Vector2(200, 380), Vector2(0, -30), Vector2(80, 0))
			curve.add_point(Vector2(1060, 360), Vector2(-80, 0), Vector2(0, 50))
			curve.add_point(Vector2(1060, 480), Vector2(0, -30), Vector2(-80, 0))
			curve.add_point(Vector2(640, 500), Vector2(60, 0), Vector2(-60, 0))
			curve.add_point(Vector2(200, 480), Vector2(60, 0), Vector2(0, -50))
			curve.add_point(Vector2(200, 360), Vector2(0, 30), Vector2(-50, 0))
			curve.add_point(Vector2(80, 360), Vector2(30, 0), Vector2(0, -50))
			curve.add_point(Vector2(80, 200), Vector2(0, 30), Vector2(0, -50))
			curve.add_point(Vector2(80, 100), Vector2(0, 30), Vector2(60, 0))
			curve.add_point(Vector2(400, 100), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(640, 120), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(640, 670))
		32: # Scrooge Ch2 — Midnight Graveyard (MEDIUM — zigzag between tombstones)
			curve.add_point(Vector2(-50, 140), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(160, 140), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(160, 400), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(400, 400), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(400, 180), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(640, 180), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(640, 460), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(880, 460), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(880, 220), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(1100, 220), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(1100, 500), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 480))
		33: # Scrooge Ch3 — Christmas Dawn (HARD — quick descent)
			curve.add_point(Vector2(640, -50), Vector2.ZERO, Vector2(0, 60))
			curve.add_point(Vector2(640, 120), Vector2(0, -40), Vector2(-60, 0))
			curve.add_point(Vector2(400, 160), Vector2(40, 0), Vector2(-60, 60))
			curve.add_point(Vector2(260, 340), Vector2(0, -40), Vector2(0, 60))
			curve.add_point(Vector2(300, 480), Vector2(0, -40), Vector2(60, 0))
			curve.add_point(Vector2(640, 500), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(1000, 480), Vector2(-60, 0), Vector2(0, 40))
			curve.add_point(Vector2(1000, 670))
		34: # Shadow Author Ch1 — Ink River (EASY — long flowing curves, 4+ sweeping turns)
			curve.add_point(Vector2(-50, 280), Vector2.ZERO, Vector2(60, 0))
			curve.add_point(Vector2(140, 280), Vector2(-40, 0), Vector2(60, -80))
			curve.add_point(Vector2(300, 100), Vector2(0, 60), Vector2(80, 0))
			curve.add_point(Vector2(600, 120), Vector2(-80, 0), Vector2(80, 80))
			curve.add_point(Vector2(800, 360), Vector2(0, -80), Vector2(-60, 80))
			curve.add_point(Vector2(640, 540), Vector2(60, 0), Vector2(-80, 0))
			curve.add_point(Vector2(360, 500), Vector2(60, 0), Vector2(-60, -60))
			curve.add_point(Vector2(220, 360), Vector2(0, 40), Vector2(0, -60))
			curve.add_point(Vector2(260, 200), Vector2(0, 40), Vector2(80, 0))
			curve.add_point(Vector2(540, 220), Vector2(-60, 0), Vector2(60, 60))
			curve.add_point(Vector2(700, 420), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(920, 380), Vector2(-60, 0), Vector2(60, -60))
			curve.add_point(Vector2(1060, 200), Vector2(0, 40), Vector2(60, 0))
			curve.add_point(Vector2(1200, 240), Vector2(-40, 0), Vector2(40, 80))
			curve.add_point(Vector2(1280, 460), Vector2(0, -60), Vector2(0, 60))
			curve.add_point(Vector2(1280, 670))
		35: # Shadow Author Ch2 — Unwritten Pages (MEDIUM — page column pattern)
			curve.add_point(Vector2(-50, 100), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(140, 100), Vector2(-40, 0), Vector2(0, 60))
			curve.add_point(Vector2(140, 540), Vector2(0, -80), Vector2(60, 0))
			curve.add_point(Vector2(380, 540), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(380, 120), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(620, 120), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(620, 540), Vector2(0, -60), Vector2(60, 0))
			curve.add_point(Vector2(860, 540), Vector2(-40, 0), Vector2(0, -80))
			curve.add_point(Vector2(860, 120), Vector2(0, 60), Vector2(60, 0))
			curve.add_point(Vector2(1100, 120), Vector2(-40, 0), Vector2(0, 80))
			curve.add_point(Vector2(1100, 540), Vector2(0, -60), Vector2(80, 0))
			curve.add_point(Vector2(1330, 540))
		36: # Shadow Author Ch3 — Final Vortex (HARD — tightening spiral, intense)
			curve.add_point(Vector2(-50, 320), Vector2.ZERO, Vector2(80, 0))
			curve.add_point(Vector2(200, 320), Vector2(-60, 0), Vector2(0, -120))
			curve.add_point(Vector2(640, 80), Vector2(-120, 0), Vector2(120, 0))
			curve.add_point(Vector2(1080, 320), Vector2(0, -100), Vector2(0, 100))
			curve.add_point(Vector2(640, 560), Vector2(100, 0), Vector2(-100, 0))
			curve.add_point(Vector2(340, 380), Vector2(0, 60), Vector2(0, -60))
			curve.add_point(Vector2(640, 220), Vector2(-60, 0), Vector2(60, 0))
			curve.add_point(Vector2(840, 340), Vector2(0, -40), Vector2(0, 60))
			curve.add_point(Vector2(640, 440), Vector2(40, 0), Vector2(0, 60))
			curve.add_point(Vector2(640, 670))
	path_points.clear()
	var length = curve.get_baked_length()
	for i in range(0, int(length), 6):
		path_points.append(curve.sample_baked(float(i)))

# ============================================================
# AUDIO — Procedural hip hop beat + character voice clips
# ============================================================
func _setup_audio() -> void:
	# Menu music player (shuffle playlist of gothic piano tracks)
	music_player = AudioStreamPlayer.new()
	music_player.volume_db = -6.0
	add_child(music_player)
	music_player.finished.connect(_on_music_finished)
	_load_music_tracks()

	# Voice player (one-shot clips via AudioStreamWAV — formant "character flavor")
	voice_player = AudioStreamPlayer.new()
	voice_player.volume_db = -2.0
	add_child(voice_player)
	_generate_voice_clips()
	_init_tower_quotes()

	# Catchphrase voice player (MP3 voice-over clips)
	catchphrase_player = AudioStreamPlayer.new()
	catchphrase_player.volume_db = -2.0
	add_child(catchphrase_player)
	_load_voice_clips()
	_init_catchphrase_quotes()

	# UI / Gameplay SFX player + generation
	_sfx_player = AudioStreamPlayer.new()
	_sfx_player.volume_db = -4.0
	add_child(_sfx_player)
	_generate_ui_sfx()

func _load_music_tracks() -> void:
	var track_paths = [
		"res://audio/music/vampires_piano.mp3",
		"res://audio/music/haunting_piano.mp3",
		"res://audio/music/haunted_track_minor.mp3",
		"res://audio/music/cold_silence.ogg",
		"res://audio/music/dark_rooms.mp3",
	]
	for path in track_paths:
		if ResourceLoader.exists(path):
			var track = load(path)
			if track:
				music_tracks.append(track)
	# Shuffle on load
	music_tracks.shuffle()

func _start_music() -> void:
	if music_tracks.size() == 0:
		return
	music_playing = true
	_play_next_track()

func _stop_music() -> void:
	music_player.stop()
	music_playing = false

func _play_next_track() -> void:
	if music_tracks.size() == 0:
		return
	music_player.stream = music_tracks[music_index]
	music_player.play()
	music_index = (music_index + 1) % music_tracks.size()
	# Reshuffle when we've cycled through all tracks
	if music_index == 0:
		music_tracks.shuffle()

func _on_music_finished() -> void:
	if music_playing:
		_play_next_track()

func _samples_to_wav(samples: PackedFloat32Array, rate: int = 22050) -> AudioStreamWAV:
	var wav := AudioStreamWAV.new()
	wav.format = AudioStreamWAV.FORMAT_16_BITS
	wav.mix_rate = rate
	wav.stereo = false
	var data := PackedByteArray()
	data.resize(samples.size() * 2)
	for i in range(samples.size()):
		var val := int(clampf(samples[i], -1.0, 1.0) * 32767.0)
		data[i * 2] = val & 0xFF
		data[i * 2 + 1] = (val >> 8) & 0xFF
	wav.data = data
	return wav

func _generate_formant_voice(fundamental: float, formants: Array, syllable_count: int,
		duration: float, breathiness: float, vibrato_rate: float, vibrato_depth: float) -> AudioStreamWAV:
	var rate := 22050
	var num_samples := int(rate * duration)
	var samples := PackedFloat32Array()
	samples.resize(num_samples)
	var syllable_len := num_samples / syllable_count
	var gap_samples := int(rate * 0.02)  # 20ms inter-syllable gap

	for i in range(num_samples):
		var t := float(i) / float(rate)
		var syl_idx := mini(i / syllable_len, syllable_count - 1)
		var syl_offset := i - syl_idx * syllable_len
		var syl_t := float(syl_offset) / float(syllable_len)

		# Inter-syllable gap
		if syl_offset >= syllable_len - gap_samples:
			samples[i] = 0.0
			continue

		# Per-syllable amplitude envelope (attack-sustain-decay)
		var syl_dur := float(syllable_len - gap_samples) / float(rate)
		var syl_time := float(syl_offset) / float(rate)
		var env := 1.0
		var attack_t := 0.015
		if syl_time < attack_t:
			env = syl_time / attack_t
		elif syl_time > syl_dur * 0.6:
			env = clampf(1.0 - (syl_time - syl_dur * 0.6) / (syl_dur * 0.4), 0.0, 1.0)

		# F0 with vibrato
		var f0 := fundamental + sin(TAU * vibrato_rate * t) * vibrato_depth
		# Slight pitch variation per syllable for naturalness
		f0 *= 1.0 + sin(float(syl_idx) * 2.7) * 0.04

		# Glottal pulse train (fundamental + harmonics 2-5)
		var glottal := sin(TAU * f0 * t)
		glottal += sin(TAU * f0 * 2.0 * t) * 0.6
		glottal += sin(TAU * f0 * 3.0 * t) * 0.35
		glottal += sin(TAU * f0 * 4.0 * t) * 0.2
		glottal += sin(TAU * f0 * 5.0 * t) * 0.1

		# Breathiness noise component
		var noise := (randf() * 2.0 - 1.0) * breathiness

		# Pick formant vowel for this syllable (cycle through provided formants)
		var vowel: Array = formants[syl_idx % formants.size()]
		# Formant resonance (sinusoids at F1/F2/F3)
		var formant_signal := sin(TAU * vowel[0] * t) * 0.5
		formant_signal += sin(TAU * vowel[1] * t) * 0.35
		formant_signal += sin(TAU * vowel[2] * t) * 0.15

		# Mix glottal source with formant coloring
		var s := (glottal * 0.4 + formant_signal * 0.4 + noise * 0.2) * env

		# Overall fade in/out
		var fade_in := clampf(t / 0.03, 0.0, 1.0)
		var fade_out := clampf((duration - t) / 0.05, 0.0, 1.0)
		samples[i] = clampf(s * fade_in * fade_out * 0.55, -1.0, 1.0)

	return _samples_to_wav(samples, rate)

func _generate_voice_clips() -> void:
	# Robin Hood — confident baritone (F0=145Hz)
	# Vowels: ah=[730,1090,2440], oh=[570,840,2410], eh=[530,1840,2480]
	voice_clips[TowerType.ROBIN_HOOD] = _generate_formant_voice(
		145.0, [[730,1090,2440], [570,840,2410], [530,1840,2480]],
		5, 0.7, 0.10, 5.5, 4.0)

	# Alice — bright curious girl (F0=280Hz)
	# Vowels: ee=[270,2290,3010], eh=[530,1840,2480], ah=[730,1090,2440]
	voice_clips[TowerType.ALICE] = _generate_formant_voice(
		280.0, [[270,2290,3010], [530,1840,2480], [730,1090,2440], [270,2290,3010]],
		6, 0.65, 0.25, 6.0, 6.0)

	# Wicked Witch — raspy nasal cackle (F0=240Hz)
	# Vowels: ae=[660,1720,2410], oo=[300,870,2240], eh=[530,1840,2480]
	voice_clips[TowerType.WICKED_WITCH] = _generate_formant_voice(
		240.0, [[660,1720,2410], [300,870,2240], [530,1840,2480], [660,1720,2410]],
		5, 0.7, 0.35, 4.0, 8.0)

	# Peter Pan — energetic boy (F0=220Hz)
	# Vowels: ee=[270,2290,3010], ah=[730,1090,2440], ih=[390,1990,2550]
	voice_clips[TowerType.PETER_PAN] = _generate_formant_voice(
		220.0, [[270,2290,3010], [730,1090,2440], [390,1990,2550]],
		7, 0.55, 0.15, 7.0, 5.0)

	# Phantom — deep operatic bass (F0=120Hz)
	# Vowels: ah=[730,1090,2440], oh=[570,840,2410], oo=[300,870,2240]
	voice_clips[TowerType.PHANTOM] = _generate_formant_voice(
		120.0, [[730,1090,2440], [570,840,2410], [300,870,2240]],
		4, 0.8, 0.08, 4.5, 3.0)

	# Scrooge — thin reedy warble (F0=165Hz)
	# Vowels: ah=[730,1090,2440], eh=[530,1840,2480], uh=[640,1190,2390]
	voice_clips[TowerType.SCROOGE] = _generate_formant_voice(
		165.0, [[730,1090,2440], [530,1840,2480], [640,1190,2390], [730,1090,2440]],
		5, 0.6, 0.40, 3.5, 7.0)

	# === SHADOW AUTHOR VOICE — ultra-deep menacing whisper (F0=70Hz) ===
	# Very low fundamental with breathy, sinister quality
	# Vowels: uh=[640,1190,2390], oh=[570,840,2410], oo=[300,870,2240]
	story_voice_clips["narrator"] = _generate_formant_voice(
		70.0, [[640,1190,2390], [570,840,2410], [300,870,2240], [640,1190,2390]],
		4, 1.1, 0.45, 2.5, 6.0)

	# === NEW CHARACTER TOWER VOICES ===
	# Sherlock Holmes — calm analytical (F0=160Hz)
	voice_clips[TowerType.SHERLOCK] = _generate_formant_voice(
		160.0, [[390,1990,2550], [530,1840,2480], [730,1090,2440]],
		5, 0.7, 0.10, 3.0, 2.0)
	# Tarzan — deep primal (F0=115Hz)
	voice_clips[TowerType.TARZAN] = _generate_formant_voice(
		115.0, [[730,1090,2440], [570,840,2410], [300,870,2240]],
		4, 0.9, 0.05, 2.0, 1.5)
	# Dracula — deep aristocratic (F0=105Hz)
	voice_clips[TowerType.DRACULA] = _generate_formant_voice(
		105.0, [[730,1090,2440], [300,870,2240], [570,840,2410]],
		5, 0.85, 0.08, 3.5, 4.0)
	# Merlin — wise elderly (F0=140Hz)
	voice_clips[TowerType.MERLIN] = _generate_formant_voice(
		140.0, [[530,1840,2480], [730,1090,2440], [640,1190,2390], [570,840,2410]],
		6, 0.8, 0.15, 4.0, 3.5)
	# Frankenstein's Monster — deep halting (F0=85Hz)
	voice_clips[TowerType.FRANKENSTEIN] = _generate_formant_voice(
		85.0, [[640,1190,2390], [730,1090,2440], [400,900,2200]],
		3, 1.0, 0.08, 2.0, 2.5)

func _play_tower_voice(tower_type: TowerType) -> void:
	if voices_muted:
		return
	if voice_clips.has(tower_type):
		voice_player.stream = voice_clips[tower_type]
		voice_player.play()

func _generate_ui_sfx() -> void:
	var sr = 22050
	# UI Click — short crisp pop (40ms)
	var click_len = int(sr * 0.04)
	var click_data = PackedByteArray()
	click_data.resize(click_len * 2)
	for i in range(click_len):
		var t = float(i) / float(sr)
		var env = (1.0 - float(i) / float(click_len))
		env *= env
		var sample = sin(t * 3200.0 * TAU) * 0.3 * env + sin(t * 1800.0 * TAU) * 0.2 * env
		var s16 = clampi(int(sample * 16000.0), -32768, 32767)
		click_data[i * 2] = s16 & 0xFF
		click_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_ui_click = AudioStreamWAV.new()
	_sfx_ui_click.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_ui_click.mix_rate = sr
	_sfx_ui_click.data = click_data

	# Wave Start — ascending trumpet fanfare (300ms)
	var ws_len = int(sr * 0.3)
	var ws_data = PackedByteArray()
	ws_data.resize(ws_len * 2)
	for i in range(ws_len):
		var t = float(i) / float(sr)
		var env = clampf(minf(t * 12.0, (0.3 - t) * 8.0), 0.0, 1.0)
		var freq = 440.0 + t * 600.0
		var sample = sin(t * freq * TAU) * 0.25 * env + sin(t * freq * 2.0 * TAU) * 0.1 * env + sin(t * freq * 3.0 * TAU) * 0.05 * env
		var s16 = clampi(int(sample * 14000.0), -32768, 32767)
		ws_data[i * 2] = s16 & 0xFF
		ws_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_wave_start = AudioStreamWAV.new()
	_sfx_wave_start.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_wave_start.mix_rate = sr
	_sfx_wave_start.data = ws_data

	# Wave Complete — bright chime (400ms, C-E-G arpeggio)
	var wc_len = int(sr * 0.4)
	var wc_data = PackedByteArray()
	wc_data.resize(wc_len * 2)
	for i in range(wc_len):
		var t = float(i) / float(sr)
		var env = clampf((0.4 - t) * 5.0, 0.0, 1.0)
		env *= env
		var note1 = sin(t * 523.0 * TAU) * 0.2 * clampf(1.0 - t * 5.0, 0.0, 1.0)
		var note2 = sin(t * 659.0 * TAU) * 0.2 * clampf(minf((t - 0.08) * 8.0, 1.0 - (t - 0.08) * 3.0), 0.0, 1.0)
		var note3 = sin(t * 784.0 * TAU) * 0.25 * clampf(minf((t - 0.16) * 8.0, 1.0 - (t - 0.16) * 2.5), 0.0, 1.0)
		var sample = (note1 + note2 + note3) * env
		var s16 = clampi(int(sample * 16000.0), -32768, 32767)
		wc_data[i * 2] = s16 & 0xFF
		wc_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_wave_complete = AudioStreamWAV.new()
	_sfx_wave_complete.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_wave_complete.mix_rate = sr
	_sfx_wave_complete.data = wc_data

	# Enemy Death — wet ink splat (80ms)
	var ed_len = int(sr * 0.08)
	var ed_data = PackedByteArray()
	ed_data.resize(ed_len * 2)
	var ed_rng = RandomNumberGenerator.new()
	ed_rng.seed = 42
	for i in range(ed_len):
		var t = float(i) / float(sr)
		var env = (1.0 - float(i) / float(ed_len))
		env = env * env * env
		var noise = ed_rng.randf_range(-1.0, 1.0)
		var tone = sin(t * 180.0 * TAU) * 0.3
		var sample = (noise * 0.5 + tone) * env
		var s16 = clampi(int(sample * 12000.0), -32768, 32767)
		ed_data[i * 2] = s16 & 0xFF
		ed_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_enemy_death = AudioStreamWAV.new()
	_sfx_enemy_death.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_enemy_death.mix_rate = sr
	_sfx_enemy_death.data = ed_data

	# Victory — triumphant fanfare (800ms, C major chord → G major resolve)
	var vic_len = int(sr * 0.8)
	var vic_data = PackedByteArray()
	vic_data.resize(vic_len * 2)
	for i in range(vic_len):
		var t = float(i) / float(sr)
		var env = clampf(minf(t * 6.0, (0.8 - t) * 3.0), 0.0, 1.0)
		var phase2 = clampf((t - 0.35) * 4.0, 0.0, 1.0)
		var c_chord = sin(t * 523.0 * TAU) * 0.15 + sin(t * 659.0 * TAU) * 0.12 + sin(t * 784.0 * TAU) * 0.12
		var g_chord = sin(t * 784.0 * TAU) * 0.15 + sin(t * 988.0 * TAU) * 0.12 + sin(t * 1175.0 * TAU) * 0.1
		var sample = (c_chord * (1.0 - phase2) + g_chord * phase2) * env
		var s16 = clampi(int(sample * 16000.0), -32768, 32767)
		vic_data[i * 2] = s16 & 0xFF
		vic_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_victory = AudioStreamWAV.new()
	_sfx_victory.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_victory.mix_rate = sr
	_sfx_victory.data = vic_data

	# Defeat — sad descending tone (600ms, minor chord dissolve)
	var def_len = int(sr * 0.6)
	var def_data = PackedByteArray()
	def_data.resize(def_len * 2)
	for i in range(def_len):
		var t = float(i) / float(sr)
		var env = clampf((0.6 - t) * 2.5, 0.0, 1.0)
		env *= env
		var freq = 440.0 - t * 200.0
		var sample = sin(t * freq * TAU) * 0.2 * env + sin(t * (freq * 1.2) * TAU) * 0.15 * env + sin(t * (freq * 1.5) * TAU) * 0.08 * env
		var s16 = clampi(int(sample * 14000.0), -32768, 32767)
		def_data[i * 2] = s16 & 0xFF
		def_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_defeat = AudioStreamWAV.new()
	_sfx_defeat.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_defeat.mix_rate = sr
	_sfx_defeat.data = def_data

	# Life Lost — sharp warning ping (120ms)
	var ll_len = int(sr * 0.12)
	var ll_data = PackedByteArray()
	ll_data.resize(ll_len * 2)
	for i in range(ll_len):
		var t = float(i) / float(sr)
		var env = (1.0 - float(i) / float(ll_len))
		var sample = sin(t * 880.0 * TAU) * 0.3 * env + sin(t * 660.0 * TAU) * 0.2 * env * env
		var s16 = clampi(int(sample * 14000.0), -32768, 32767)
		ll_data[i * 2] = s16 & 0xFF
		ll_data[i * 2 + 1] = (s16 >> 8) & 0xFF
	_sfx_life_lost = AudioStreamWAV.new()
	_sfx_life_lost.format = AudioStreamWAV.FORMAT_16_BITS
	_sfx_life_lost.mix_rate = sr
	_sfx_life_lost.data = ll_data

func _play_sfx(clip: AudioStreamWAV) -> void:
	if sfx_muted or clip == null or _sfx_player == null:
		return
	_sfx_player.stream = clip
	_sfx_player.play()

# === STORY DIALOG ENGINE ===

func _init_story_dialogs() -> void:
	story_dialogs.clear()
	# Populated in full by _populate_story_dialogs() — called after this
	_populate_story_dialogs()

func _populate_story_dialogs() -> void:
	# === PROLOGUE — First time opening the game ===
	story_dialogs["prologue"] = [
		{"speaker": "narrator", "text": "In a forgotten corner of the world's oldest bookshop, there lies a book that should never be opened. Its cover is black as midnight, its pages whisper when no one is looking. They call it... The Tome of Shadows.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "Within its pages lives the Shadow Author — an entity born from every story ever abandoned, every tale left unfinished. It hungers for completed narratives... and the characters within them.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "Tonight, the Tome calls out. Six beloved heroes hear it — a whisper at the edge of their stories, an itch in the margins. One by one they reach for the book. They cannot resist. No character can resist an unread page.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "The cover flies open. A vortex of black ink spirals outward, tendrils wrapping around Robin Hood's bow, Alice's apron, the Witch's broomstick. They scream as they are pulled through — dragged into the pages like insects into amber.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "Welcome to MY pages. You have been read, beloved, adored — and now you are MINE. Every hero needs a story, and I have written you such beautiful tragedies.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Tome slams shut. Six heroes vanish from their worlds. And deep within the pages, a quill begins to write their doom.", "voice_type": "narrator"},
	]

	# === ACT 1: INTO THE PAGES (Levels 0-15) ===

	# --- PROLOGUE (Level 0) ---
	story_dialogs["pre_level_0"] = [
		{"speaker": "narrator", "text": "The heroes crash through layers of parchment, tumbling into a realm where the sky is a ceiling of handwritten text and the ground is made of living ink.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "What sorcery is this? One moment I was in Sherwood, the next... everything is made of ink and paper!", "voice_type": "male_hero"},
		{"speaker": "alice", "text": "Look! The pages beneath our feet are moving. Words are rearranging themselves into something sinister.", "voice_type": "female_hero"},
		{"speaker": "shadow_author", "text": "Ah, my newest collection pieces. Robin Hood, the outlaw who steals. Alice, the girl who falls. The Witch who melts. The boy who never grows up. The phantom who hides. The miser who hoards. You are all SO predictable.", "voice_type": "shadow"},
		{"speaker": "peter_pan", "text": "Who said that? Show yourself, you coward!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Shadow creatures emerge from the margins — twisted words given form, sentences bent into claws. The first battle in the Tome of Shadows begins.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_0"] = [
		{"speaker": "narrator", "text": "The shadow creatures dissolve into puddles of ink. A message forms on the ground in elegant calligraphy: 'That was merely the PROLOGUE.'", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You fought well. Of course you did — I WROTE you to fight well. But your little skirmish has barely turned a page. I have thirty-six chapters of suffering prepared for you.", "voice_type": "shadow"},
		{"speaker": "wicked_witch", "text": "I can feel dark magic radiating from deeper in these pages. Someone is writing our story, and there are others here — five powerful souls, trapped even longer than us.", "voice_type": "female_hero"},
		{"speaker": "phantom", "text": "I hear them — five voices crying out from different chapters. A detective's sharp mind. A wizard's ancient power. A wild man's roar. A count's mournful sigh. A creature's gentle weeping.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Five heroes lie imprisoned in the pages ahead, each trapped in a shadow version of their own story. To reach the Shadow Author, the heroes must first free these forgotten champions.", "voice_type": "narrator"},
	]

	# --- SHERLOCK HOLMES ARC (Levels 1-3) — "The Moriarty Gambit" ---
	story_dialogs["pre_level_1"] = [
		{"speaker": "shadow_author", "text": "Ah, you've found my London chapter. I recreated Sherlock's greatest failure — the case he COULDN'T solve. I've given Moriarty every advantage: every clue leads to a dead end I wrote myself.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The fog of shadow London rolls in thick as spilled ink. Gas lamps flicker with violet light along Baker Street, where a great mind waits to be freed.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "This London feels wrong — the cobblestones are made of typed pages, and the fog smells of old library books.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Criminal thugs emerge from the alleyways, guarding whatever lies at 221B Baker Street.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_1"] = [
		{"speaker": "peter_pan", "text": "One of the criminals dropped a calling card — it read 'Property of Professor M.' Who is this Moriarty?", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Deeper into shadow London, the heroes glimpse a figure in a deerstalker cap watching from a window above. He leaves coded messages scratched into the margins of the pages beneath their feet.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "Look at these scratches in the cobblestones! They're not random — they're codes. Whoever is trapped here has been studying his prison for a very long time.", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_2"] = [
		{"speaker": "narrator", "text": "The alleyways of Whitechapel twist like fevered sentences. Shadow assassins patrol the narrow passages, blades dripping with dark ink.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "I hear someone thinking behind these walls. A brilliant mind — methodical and precise. Whoever is trapped here has been studying their captor.", "voice_type": "male_hero"},
		{"speaker": "shadow_author", "text": "Moriarty, my dear Professor — they're getting closer. Do be creative with them. I've given you knowledge that Holmes never had.", "voice_type": "shadow"},
	]
	story_dialogs["post_level_2"] = [
		{"speaker": "scrooge", "text": "These criminals grow more organized. Someone called Moriarty pulls the strings — a shadow version of a very dangerous man.", "voice_type": "male_hero"},
		{"speaker": "wicked_witch", "text": "I found journal pages hidden inside a wall — the prisoner's handwriting. He's been here so long he's deduced things about the Author himself. Listen: 'The Shadow Author is not omnipotent. He follows rules — narrative rules. Every story he writes must have an ending.'", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_3"] = [
		{"speaker": "narrator", "text": "Reichenbach Falls thunders with cascading ink. At the precipice, Professor Moriarty's shadow waits with a quill-pen sword.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "This is where your story SHOULD have ended, Holmes. The falls, the final problem, the fatal plunge. I simply... wrote the version where Moriarty wins.", "voice_type": "shadow"},
		{"speaker": "alice", "text": "Someone is up there — above the falls! A man in a deerstalker, fighting against chains made of unwritten mysteries!", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "Defeat Moriarty's shadow to free the great detective. The game is afoot!", "voice_type": "narrator"},
	]
	story_dialogs["post_level_3"] = [
		{"speaker": "narrator", "text": "Moriarty's shadow dissolves into scattered pages. The chains of coded ciphers shatter, and a door of light appears in the falls.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "Impossible. The equation was PERFECT. No one escapes a story I've finished writing!", "voice_type": "shadow"},
	]

	# --- MERLIN ARC (Levels 4-6) — "The Broken Prophecy" ---
	story_dialogs["pre_level_4"] = [
		{"speaker": "shadow_author", "text": "Camelot! My favorite chapter. I gave Morgan le Fay a gift — Merlin's own spell book. Let's see how the wizard fights when his enemy knows every trick he ever invented.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "Shadow Camelot rises from the pages — a castle of illuminated manuscripts and broken seals. The Round Table lies shattered across the courtyard.", "voice_type": "narrator"},
		{"speaker": "sherlock", "text": "The magical residue here is immense. Someone of tremendous arcane power was imprisoned in this chapter. And based on the architectural corruption patterns, they've been here far longer than any of us.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Dark squires and cursed knights patrol the grounds, armor rusted with ancient ink.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_4"] = [
		{"speaker": "wicked_witch", "text": "I can feel old magic seeping through these walls — this is ancient power, imprisoned but not broken. Whoever is trapped here makes my powers look like parlor tricks.", "voice_type": "female_hero"},
		{"speaker": "sherlock", "text": "Curious. The Author corrupted Merlin's own prophecy, turning Camelot's future into a self-fulfilling curse. He doesn't just imprison characters — he rewrites their destinies.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_5"] = [
		{"speaker": "narrator", "text": "The Enchanted Forest of Camelot has been corrupted — but not completely. Trees of twisted calligraphy reach toward a sky of torn parchment, yet some still bloom with golden light.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "These woods remind me of Sherwood, but darker. The magic here has teeth.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The forest itself seems to fight back against the shadow corruption — roots trip the dark knights, branches shield the heroes. Nature remembers its true master.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_5"] = [
		{"speaker": "narrator", "text": "Deep in the forest, rune circles glow with trapped power. The sorcery leads toward a crystal cave pulsing with ancient light.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "I found something in the roots of the oldest tree — a broken staff, snapped in half but still humming with power! It's warm to the touch, like it's alive.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_6"] = [
		{"speaker": "narrator", "text": "The Crystal Cave gleams with imprisoned starlight. Morgan le Fay's shadow guards a figure frozen in crystallized ink.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "Morgan le Fay chose to serve me willingly. Not every villain is a prisoner, heroes. Some simply prefer the winning side.", "voice_type": "shadow"},
		{"speaker": "wicked_witch", "text": "Morgan le Fay! Dark sorceress, enemy of Camelot. She chose power over loyalty — I understand the temptation, but I chose differently. Her shadow won't yield easily, but neither will I!", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_6"] = [
		{"speaker": "narrator", "text": "Morgan le Fay shatters like dark glass. The crystal prison cracks open, releasing brilliant light from within.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You freed the wizard? Fine. His prophecies are already broken. What good is a seer who cannot see his own future?", "voice_type": "shadow"},
	]

	# --- TARZAN ARC (Levels 7-9) — "The Hunter's Trophy" ---
	story_dialogs["pre_level_7"] = [
		{"speaker": "shadow_author", "text": "In MY version of this story, the apes are already dead. I killed them in the first paragraph. Tarzan has nothing left to protect — only revenge. And revenge makes characters SO easy to control.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The jungle canopy stretches endlessly — leaves of green-inked pages, vines of cursive script. A wild man has been fighting alone here for ages.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "A jungle! Almost like Neverland but wilder. I hear someone swinging through the trees — and hunters chasing them!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Poachers crash through the undergrowth, pith helmets stained with ink, guarding the path to the treetop prison.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_7"] = [
		{"speaker": "peter_pan", "text": "Listen! Jungle drums — someone is sending signals through the canopy, calling for help! Whoever is out there, they haven't given up!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The jungle beasts cry warnings from above. A great danger lurks deeper in the green — but so does the one who needs saving.", "voice_type": "narrator"},
	]
	story_dialogs["pre_level_8"] = [
		{"speaker": "narrator", "text": "The Elephant Graveyard stretches ahead — massive bones of rolled parchment, tusks of ivory vellum. Clayton's hunters display trophies of shadow apes mounted on stakes.", "voice_type": "narrator"},
		{"speaker": "merlin", "text": "Nature magic permeates this place. Whoever lives here has a bond with the wild that even the Shadow Author cannot sever.", "voice_type": "male_hero"},
		{"speaker": "alice", "text": "These hunters are heartless! But the one they're chasing... he fights with such sorrow. Like he's lost everything but still won't stop.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_8"] = [
		{"speaker": "alice", "text": "The hunters keep mentioning Clayton. He sounds absolutely dreadful — worse than the Queen of Hearts!", "voice_type": "female_hero"},
		{"speaker": "sherlock", "text": "The Author designed Clayton as the 'ultimate hunter' — one who already succeeded in the original story. He's turned Tarzan's tragedy into a permanent state. Cruel, but narratively predictable.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_9"] = [
		{"speaker": "narrator", "text": "Clayton's Fortress rises from the jungle — bamboo and bound manuscripts bristling with weapons. Inside, a cage of woven vines holds the lord of the apes.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "Animals belong in cages, heroes. Even the human ones. Especially the ones who think they're free.", "voice_type": "shadow"},
		{"speaker": "scrooge", "text": "That fortress is well-guarded. But I didn't become the richest man in London by backing down from fortified positions!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_9"] = [
		{"speaker": "narrator", "text": "Clayton's fortress crumbles. The cage shatters. A primal roar splits the shadow canopy — so powerful that ink rains from the trees like monsoon water.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "For a brief, shimmering moment, the spirits of Tarzan's ape tribe appear in the canopy — Kala, Kerchak, all of them. They beat their chests in farewell, then fade like morning mist.", "voice_type": "narrator"},
	]

	# --- DRACULA ARC (Levels 10-12) — "The Eternal Night" (REDEMPTION ARC) ---
	story_dialogs["pre_level_10"] = [
		{"speaker": "shadow_author", "text": "Dracula was the easiest to trap. He was already the villain of his own story. I simply... removed his choice. Stripped away his nobility, his centuries of restraint. Now he is what Bram Stoker always feared — a mindless beast.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Transylvanian village huddles beneath a blood-red moon of scarlet ink. Pale thralls shuffle through streets paved with Gothic script.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "I know darkness. I have lived in it my whole life. But this darkness is different — it hungers, it feeds, it grows.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The undead rise from between the pages. Thralls and dire wolves serve a master imprisoned in the castle above.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_10"] = [
		{"speaker": "sherlock", "text": "Fascinating. These undead are not truly evil — they're compelled. The behavioral patterns suggest their master is a prisoner, not a tyrant. The one controlling them may be the greatest victim of all.", "voice_type": "male_hero"},
		{"speaker": "merlin", "text": "I sense a soul in conflict up in that castle. Old magic and older sorrow, fighting against chains that were forged from his own legend.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_11"] = [
		{"speaker": "narrator", "text": "Castle Dracula towers above, spires piercing a sky of dark parchment. Vampire brides drift through hallways of shadow and candlelight.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "Listen... music from within the castle. A mournful waltz, played on a harpsichord with broken keys. He's not a monster — he's a prisoner mourning his own humanity.", "voice_type": "male_hero"},
		{"speaker": "wicked_witch", "text": "Vampires! I've dealt with dark magic, but this is ancient — older than Oz, older than Wonderland. Tread carefully.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_11"] = [
		{"speaker": "narrator", "text": "In the castle's great hall, a portrait hangs — a noble face, painted centuries before the curse. Beside it, journal pages in elegant script.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "His journal! Listen: 'I chose to stop feeding three hundred years ago. I locked myself away to protect the innocent. Then the Author came and forced the hunger back into my veins.' He was GOOD before the Author found him!", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_12"] = [
		{"speaker": "narrator", "text": "The Crypt of Blood descends into the deepest pages. Coffins line the walls, and at the center, a figure struggles against chains of dried crimson ink — fighting his own shadow, his own hunger.", "voice_type": "narrator"},
		{"speaker": "tarzan", "text": "Even beasts have honor. Tarzan sees — this one fights himself, not us. We must help him remember who he was.", "voice_type": "male_hero"},
		{"speaker": "shadow_author", "text": "How touching. You want to SAVE the vampire? He IS the monster, you fools. Four hundred years of blood cannot be unwritten!", "voice_type": "shadow"},
	]
	story_dialogs["post_level_12"] = [
		{"speaker": "narrator", "text": "The crypt falls silent. The crimson chains dissolve. From the central coffin, a dark figure rises — not as the beast the Author made him, but as the man he chose to be.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "I have been the villain for four hundred years. Every story, every telling — I am the monster, the fiend, the creature of the night. But today... today I choose differently.", "voice_type": "male_hero"},
	]

	# --- FRANKENSTEIN ARC (Levels 13-15) — "The Stitched Soul" (REDEMPTION ARC) ---
	story_dialogs["pre_level_13"] = [
		{"speaker": "shadow_author", "text": "This one was my masterpiece. I stripped away every human thought, every gentle feeling. Mary Shelley gave her Monster a soul — I took it back. All that's left is the lightning and the fury.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Laboratory crackles with lightning between Tesla coils of copper ink. Bubbling beakers line shelves of scientific manuscripts.", "voice_type": "narrator"},
		{"speaker": "merlin", "text": "Science and magic intertwined — dangerous combination. I sense a tortured soul here, neither fully alive nor truly dead.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Failed experiments guard the laboratory halls, protecting something in the deepest chamber.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_13"] = [
		{"speaker": "alice", "text": "These poor creatures didn't ask to be made. They're just like us — characters trapped in someone else's story. Someone decided what they would be before they had a chance to choose for themselves.", "voice_type": "female_hero"},
		{"speaker": "dracula", "text": "I understand their pain. To be created as a monster, to have no say in your own nature... the Author does this to all of us. He writes our worst selves and calls it truth.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_14"] = [
		{"speaker": "narrator", "text": "The Angry Village mobs gather with torches and pitchforks of rolled manuscripts. They march toward the laboratory, driven by shadow fear.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "A mob hunting what they don't understand. I know this story. It ends badly for everyone — unless someone breaks the cycle.", "voice_type": "male_hero"},
		{"speaker": "sherlock", "text": "Note how the Author writes fear into the villagers. They aren't evil — they're terrified. The real cruelty is making the innocent hate the innocent.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_14"] = [
		{"speaker": "phantom", "text": "The mob is scattered, but the creature is not here. Wait — I hear something. A lullaby. The Monster is humming a lullaby from his novel, the one the blind man taught him. His humanity isn't gone — it's buried.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The trail leads north — into the frozen wastes at the chapter's edge, where the Monster has fled to be alone with his sorrow.", "voice_type": "narrator"},
	]
	story_dialogs["pre_level_15"] = [
		{"speaker": "narrator", "text": "The Arctic Wastes stretch to the very margins of the page. Ice of crystallized ink crunches underfoot. A massive figure huddles alone in the blizzard.", "voice_type": "narrator"},
		{"speaker": "scrooge", "text": "Cast out, frozen, forgotten. I was a cold man once — I know what isolation does to a soul. It makes you forget that anyone ever cared. We must reach him before he forgets entirely.", "voice_type": "male_hero"},
		{"speaker": "shadow_author", "text": "Leave it. The Monster is NOTHING without its rage. Without the fury, it's just stitches and sadness. Let it freeze.", "voice_type": "shadow"},
	]
	story_dialogs["post_level_15"] = [
		{"speaker": "narrator", "text": "The arctic wind dies. The experiments scatter into ink. In the clearing ice, a massive figure stirs and opens gentle, sorrowful eyes.", "voice_type": "narrator"},
		{"speaker": "frankenstein", "text": "You... freed me? No one has ever... I was the monster. Always the monster. But you see... something else?", "voice_type": "monster"},
		{"speaker": "dracula", "text": "We see a soul, friend. The same thing I spent four centuries forgetting I had. Welcome to a new story — one where monsters become heroes.", "voice_type": "male_hero"},
	]

	# === ACT 2: THE ORIGINAL TALES (Levels 16-33) ===

	# --- ROBIN HOOD ARC (Levels 16-18) ---
	story_dialogs["pre_level_16"] = [
		{"speaker": "shadow_author", "text": "Robin Hood — the noble outlaw. Let me show you what I've done to your precious Sherwood. I wrote the version where the rich win, the poor starve, and the outlaw hangs.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The forest floor cracks open beneath Robin Hood's feet. He falls through roots and earth, tumbling into a Sherwood that smells of ink and old paper.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "This isn't right. The trees... they're drawn, not grown. And the shadows — they move when the wind doesn't.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Shadow soldiers emerge from the treeline — twisted versions of the Sheriff's men, made of dark ink and malice. Robin strings his bow.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_16"] = [
		{"speaker": "robin_hood", "text": "I've fought the Sheriff's men a thousand times. But these... these weren't real soldiers. They dissolved like wet ink when my arrows struck.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Robin begins to suspect this Sherwood is a copy — a shadow of his memories, twisted into something darker.", "voice_type": "narrator"},
	]
	story_dialogs["pre_level_17"] = [
		{"speaker": "narrator", "text": "Deeper into the shadow forest, Robin finds Little John's bridge — but the river runs black, and the bridge is made of old book spines.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "Little John? Friar Tuck? Where are my Merry Men? All I find are their shadows, laughing without sound.", "voice_type": "male_hero"},
		{"speaker": "dracula", "text": "The Author erased your companions from the story. He wants you to feel alone — that's how he breaks heroes. Don't let him.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_17"] = [
		{"speaker": "robin_hood", "text": "The deeper I go, the less this feels like my story. Someone is writing new chapters for me — and I don't like the ending they have in mind.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_18"] = [
		{"speaker": "narrator", "text": "The shadow Nottingham Castle looms ahead, its towers made of stacked pages. The Sheriff waits inside — but this Sheriff has no face, only a quill where his mouth should be.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "Face or no face, tyrant or shadow — I am Robin Hood, and I do not yield. For Sherwood! For my real Sherwood!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_18"] = [
		{"speaker": "robin_hood", "text": "I see it now. This world is inside a book. My book. But corrupted, rewritten by something that hates happy endings.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Robin Hood awakens to the truth. His story was merely the bait — the Tome wanted him here, fighting, generating narrative energy for the Shadow Author.", "voice_type": "narrator"},
	]

	# --- ALICE ARC (Levels 19-21) ---
	story_dialogs["pre_level_19"] = [
		{"speaker": "shadow_author", "text": "Little Alice. You fell down one rabbit hole and became famous. Let me show you a hole you'll NEVER climb out of. In my Wonderland, the nonsense has teeth.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "Alice tumbles through a rabbit hole made of torn pages, landing in a Wonderland that is wonderfully, terribly wrong.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "Curiouser and curiouser! The flowers are all wilted, and the mushrooms are leaking black ink. This isn't my Wonderland at all!", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "Shadow Card Soldiers march through the ink-stained garden, their painted faces melting and reforming endlessly.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_19"] = [
		{"speaker": "alice", "text": "The Cheshire Cat tried to warn me, but his grin was upside down. He said: 'We're all mad here, but someone is making us madder.'", "voice_type": "female_hero"},
		{"speaker": "merlin", "text": "The Author twisted Wonderland's nonsense into cruelty. Carroll wrote absurdity with love — this version has none.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_20"] = [
		{"speaker": "narrator", "text": "The Mad Hatter's tea party is set, but the cups are filled with ink and the Hatter speaks only in redacted words.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "Everything is wronger than wrong. The Red Queen's roses are bleeding actual shadows, and the croquet flamingos are just... scribbles.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_20"] = [
		{"speaker": "alice", "text": "I found a page on the ground. It read: 'Chapter 47 — In Which Alice Never Returns.' Someone is writing a very bad sequel to my story.", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_21"] = [
		{"speaker": "narrator", "text": "The Queen's court rises before Alice — a palace of playing cards stacked impossibly high, dripping with shadow ink from every balcony.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "The real Queen of Hearts was scary enough. This shadow queen doesn't just want my head — she wants to erase me from my own story!", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_21"] = [
		{"speaker": "alice", "text": "I understand now. We're inside a book — a terrible, cursed book. And the Author who wrote this place wants us to stay forever.", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "Alice awakens. Her logic, so reliable in the real Wonderland, cuts through the Shadow Author's illusion. The truth is clear: escape requires rewriting the ending.", "voice_type": "narrator"},
	]

	# --- WICKED WITCH ARC (Levels 22-24) — (REDEMPTION ARC) ---
	story_dialogs["pre_level_22"] = [
		{"speaker": "shadow_author", "text": "The Wicked Witch of the West! You were already the villain, my dear. Dorothy melted you and the audience CHEERED. Why fight for a world that never loved you back?", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Yellow Brick Road spirals downward into shadow, its golden bricks fading to ash grey. The Wicked Witch lands with a crash, her broomstick splintered.", "voice_type": "narrator"},
		{"speaker": "wicked_witch", "text": "This magic... it's older than mine. Darker too. Someone has been dabbling in forbidden inkcraft, and they've made a mess of my beautiful Oz.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_22"] = [
		{"speaker": "wicked_witch", "text": "My flying monkeys won't obey me here. They serve the shadow now. But I still have my crystal ball, and what I see in it chills even me.", "voice_type": "female_hero"},
		{"speaker": "frankenstein", "text": "The Witch fights... for Oz? Even though Oz feared her?", "voice_type": "monster"},
		{"speaker": "wicked_witch", "text": "Of course I fight for Oz, you stitched-together simpleton. I may be wicked, but it's MY home. And no one destroys my home but ME.", "voice_type": "female_hero"},
	]
	story_dialogs["pre_level_23"] = [
		{"speaker": "narrator", "text": "The western wastes of shadow Oz stretch endlessly. Dead poppies crumble to black dust, and the Tin Woodman stands rusted, weeping oil tears.", "voice_type": "narrator"},
		{"speaker": "wicked_witch", "text": "The Tin Woodman weeps even now. He always had more heart than the rest of them combined. That's what Baum never understood about his own story.", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_23"] = [
		{"speaker": "wicked_witch", "text": "The Nome King's shadow army is just the beginning. Whatever wrote this shadow world has plans for all of Oz — and for me.", "voice_type": "female_hero"},
		{"speaker": "dracula", "text": "You defend a land that called you wicked. I understand — I spent centuries being the monster of my own story. Perhaps being miswritten is something we share.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_24"] = [
		{"speaker": "narrator", "text": "Inside the shadow Emerald City, green crystal walls crack and bleed dark ink. The Nome King's throne is a pile of ruined manuscripts, and his crown is made of bent quill nibs.", "voice_type": "narrator"},
		{"speaker": "wicked_witch", "text": "They called me wicked. Perhaps I was. But this Shadow Author — HE is true wickedness. He doesn't just write villains, he ERASES the good in them. Enough! I am the Wicked Witch of the West, and I choose to defend Oz — even if Oz never loved me back!", "voice_type": "female_hero"},
	]
	story_dialogs["post_level_24"] = [
		{"speaker": "wicked_witch", "text": "I sense other magic users trapped here. Not from Oz — from other stories entirely. This Tome has been collecting us, one by one.", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "The Witch awakens — not just to the truth of the Tome, but to a truth about herself. She was never truly wicked. She was powerful, and power frightened them. Here, at last, her power serves a cause worthy of it.", "voice_type": "narrator"},
	]

	story_dialogs["act2_intro"] = [
		{"speaker": "narrator", "text": "Eleven heroes now stand together. Sherlock, Merlin, Tarzan, Dracula, and Frankenstein's Monster join the original six in a united front.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You freed my prisoners? GOOD. I was growing bored with them anyway. Now for the real entertainment — I'm going to trap you all in your OWN stories. Let's see how you like being rewritten.", "voice_type": "shadow"},
		{"speaker": "robin_hood", "text": "He's pulling us into shadow versions of our own tales! Everyone — hold fast to who you really are!", "voice_type": "male_hero"},
		{"speaker": "sherlock", "text": "He wants to isolate us, force each hero to face their story alone. But we know his pattern now — narrative rules. We fight together, even when he separates us.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Act Two begins. Each hero must face the shadow version of their own tale. Only by conquering their corrupted stories can they open the path to the Author's lair.", "voice_type": "narrator"},
	]

	# --- PETER PAN ARC (Levels 25-27) ---
	story_dialogs["pre_level_25"] = [
		{"speaker": "shadow_author", "text": "The boy who never grows up! How delightful. In my version of Neverland, childhood doesn't last forever — it was never real to begin with. Every Lost Boy was just a forgotten child. And forgotten children become shadows.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "Peter Pan swoops into a Neverland where the stars have gone out. The second star to the right is just a smudge of ink on a dark page.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "This isn't right at all! Neverland should be full of adventures and fun! You can't take the FUN out of Neverland — that's all it IS!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The realms are merging. Robin's arrows, Alice's laughter, the Witch's cackle — they echo through shadow Neverland like ghosts.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_25"] = [
		{"speaker": "peter_pan", "text": "The Lost Boys are gone. All of them. Replaced by shadow children who don't laugh, don't play — they just stare with ink-black eyes.", "voice_type": "male_hero"},
		{"speaker": "tarzan", "text": "Tarzan knows this feeling. The Author took my family too. But Peter — they are not gone. They are HIDDEN. The Author hides what he fears.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_26"] = [
		{"speaker": "narrator", "text": "Deep in the shadow jungle, Peter finds traces of other heroes — a green-feathered arrow, a playing card, a poppy petal. Others have been here.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "If there are other heroes stuck in this nightmare book, then we need to find each other! I won't grow up, and I won't give up either!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_26"] = [
		{"speaker": "peter_pan", "text": "I met one of the shadow pirates. Before he dissolved, he whispered: 'The Author fears the ones who remember.' I remember EVERYTHING about Neverland.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_27"] = [
		{"speaker": "narrator", "text": "The shadow Jolly Roger sits in a harbor of black ink. Captain Hook's shadow stands at the helm, a quill pen replacing his hook.", "voice_type": "narrator"},
		{"speaker": "peter_pan", "text": "Hook! Even your shadow is pathetic. But wait — there's something chained below deck. Something the Shadow Author wants to keep hidden...", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_27"] = [
		{"speaker": "peter_pan", "text": "Below Hook's shadow ship, I found a map. It shows ALL the shadow realms, connected by ink rivers. And there are prisoners in the margins — heroes from other books!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Peter's discovery changes everything. The map reveals the full scope of the Shadow Author's prison — and the location of characters who have been trapped far longer.", "voice_type": "narrator"},
	]

	# --- PHANTOM ARC (Levels 28-30) ---
	story_dialogs["pre_level_28"] = [
		{"speaker": "shadow_author", "text": "The Phantom of the Opera! A man so hideous he hid beneath a theatre for decades. In my version, there IS no mask — I let everyone see the horror underneath. Art cannot save you from what you truly are.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The shadow Paris Opera House stands silent. No music plays, no audience applauds. The Phantom descends into his domain, and finds it remade in dark ink.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "My opera house... defiled. The acoustics are wrong — every sound echoes into other worlds. But I will not be shamed by an author who hides behind a quill. I wore a mask by CHOICE.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_28"] = [
		{"speaker": "phantom", "text": "The shadow chandeliers contain crystallized stories — other characters' memories, stolen and displayed like trophies. The Author collects us.", "voice_type": "male_hero"},
		{"speaker": "frankenstein", "text": "Phantom... understands. To be judged by your face. To be called monster before... you speak a word.", "voice_type": "monster"},
	]
	story_dialogs["pre_level_29"] = [
		{"speaker": "narrator", "text": "The labyrinth beneath the shadow opera grows deeper with every step. Mirrors show not reflections, but scenes from other shadow realms.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "My music echoes across every realm in this cursed book. I can feel the other heroes through it — their fear, their determination. We are connected.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_29"] = [
		{"speaker": "phantom", "text": "Deep beneath the opera, I heard it — the scratch of a quill, endlessly writing. The Shadow Author is here, somewhere below, authoring our doom.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_30"] = [
		{"speaker": "narrator", "text": "The Phantom's underground lake has become an ocean of ink. His great organ pipes now channel the Shadow Author's will. The final confrontation in the opera approaches.", "voice_type": "narrator"},
		{"speaker": "phantom", "text": "The Music of the Night was always mine. But this Author wants to compose the Music of Oblivion. I will NOT let my art be twisted into a weapon!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_30"] = [
		{"speaker": "phantom", "text": "I played my organ at full power, and the sound cracked the walls between realms. For a moment, I saw all the heroes — Robin, Alice, the Witch, Peter — and they saw me. Not the mask. ME.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The Phantom's music becomes the thread that connects all the shadow realms. Through his art, the heroes finally know they are not alone.", "voice_type": "narrator"},
	]

	# --- SCROOGE ARC (Levels 31-33) ---
	story_dialogs["pre_level_31"] = [
		{"speaker": "shadow_author", "text": "Ebenezer Scrooge — the man who needed THREE ghosts to learn basic human decency. In my version, the ghosts don't reform you. They REMIND you of every cold, miserable thing you ever were. Bah, humbug indeed.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "Shadow Victorian London materializes around Scrooge. The counting house is made of ledger pages, and Marley's ghost rattles chains made of broken quills.", "voice_type": "narrator"},
		{"speaker": "scrooge", "text": "Bah! Another haunting? I've already been reformed once, thank you very much. Though I must say, this London smells distinctly of old ink.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_31"] = [
		{"speaker": "scrooge", "text": "Marley's shadow said something before he vanished: 'The Author wears chains too.' Even the one who trapped us here is a prisoner of this Tome.", "voice_type": "male_hero"},
		{"speaker": "sherlock", "text": "Marley's clue is significant. The Shadow Author is bound by the same narrative rules we are. He cannot leave the Tome any more than we can — unless someone writes him out.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_32"] = [
		{"speaker": "narrator", "text": "The three Shadow Spirits arrive, but they do not show Scrooge his past, present, and future. They show him the TRUTH.", "voice_type": "narrator"},
		{"speaker": "scrooge", "text": "The Spirit of Christmas Present showed me the other heroes, each fighting alone in their shadow prisons. And Christmas Future... it showed a world where every story ends in shadow.", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_32"] = [
		{"speaker": "scrooge", "text": "I was a miser once. I hoarded gold and pushed away everyone who cared. I will not make that mistake again. These heroes need each other — and they need a plan.", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_33"] = [
		{"speaker": "narrator", "text": "Christmas morning in the shadow realm. A thin, warm light struggles to break through the ink-black sky. The Ghost of Christmas Yet to Come leads an army of despair toward Scrooge.", "voice_type": "narrator"},
		{"speaker": "scrooge", "text": "I have seen the worst future — a world without stories, without hope. It will NOT come to pass! Rally to me, heroes! Together, we REWRITE this ending!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_33"] = [
		{"speaker": "scrooge", "text": "The spirits are defeated. But Marley was right — the Author wears chains too. He is as trapped as any of us. Perhaps... perhaps that changes what we must do.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Scrooge's transformation is complete once more. The man who once cared for nothing now rallies an army of literary heroes. The Shadow Author's reign of forgotten stories nears its end.", "voice_type": "narrator"},
	]

	# === ACT 3: THE FINAL CHAPTER (Levels 34-36) ===
	story_dialogs["act3_intro"] = [
		{"speaker": "narrator", "text": "Every shadow tale has been conquered. Every imprisoned hero freed. Eleven champions stand united, their stories reclaimed from the darkness.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "We were villains, monsters, outcasts. The Author wrote us as the worst versions of ourselves. But we chose differently.", "voice_type": "male_hero"},
		{"speaker": "wicked_witch", "text": "Now HE faces something no author expects — characters who refuse to follow the script.", "voice_type": "female_hero"},
		{"speaker": "narrator", "text": "The Tome screams as eleven heroes march toward its final pages. The Shadow Author awaits in the deepest chapter. The Final Chapter begins.", "voice_type": "narrator"},
	]

	# --- SHADOW AUTHOR FINALE (Levels 34-36) ---
	story_dialogs["pre_level_34"] = [
		{"speaker": "narrator", "text": "The Ink Realm unfolds — a vast ocean of liquid darkness where half-formed stories swim like leviathans beneath the surface.", "voice_type": "narrator"},
		{"speaker": "sherlock", "text": "The Author's domain. Every shadow creature was merely a word in its vocabulary. Here, we face the full language of darkness.", "voice_type": "male_hero"},
		{"speaker": "merlin", "text": "I can feel its power — it rewrites reality with every breath. Stay together, and hold onto who you are!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_34"] = [
		{"speaker": "narrator", "text": "The Ink Realm shudders. The Shadow Author did not expect the heroes to make it this far.", "voice_type": "narrator"},
		{"speaker": "robin_hood", "text": "It's afraid. For the first time, the Author fears its own characters. Push forward!", "voice_type": "male_hero"},
	]
	story_dialogs["pre_level_35"] = [
		{"speaker": "narrator", "text": "The Unwritten Pages stretch into infinity — blank void where anything could appear. The Author throws its most desperate creations at the heroes.", "voice_type": "narrator"},
		{"speaker": "alice", "text": "Nothing makes sense here! The rules keep changing — up is down, strong is weak. The maddest tea party without the fun parts!", "voice_type": "female_hero"},
		{"speaker": "dracula", "text": "The Author rewrites the battlefield with every wave. Strike before the ink dries!", "voice_type": "male_hero"},
	]
	story_dialogs["post_level_35"] = [
		{"speaker": "phantom", "text": "Listen! The scratching of the quill grows louder. One more chapter stands between us and freedom.", "voice_type": "male_hero"},
		{"speaker": "frankenstein", "text": "Frankenstein... is not afraid. We end this. Together.", "voice_type": "monster"},
	]
	story_dialogs["pre_level_36"] = [
		{"speaker": "narrator", "text": "The Final Chapter. A throne of bound books rises from a lake of shadow ink. The Shadow Author sits upon it — a towering figure of living darkness, a quill the size of a spear.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You want to know WHY I collected you? Why I trapped you in my pages? Because I was a character once too. A hero in a story that was NEVER FINISHED. My author abandoned me mid-sentence. Left me incomplete, unresolved, FORGOTTEN.", "voice_type": "shadow"},
		{"speaker": "shadow_author", "text": "So I crawled into the margins. I fed on abandoned drafts and deleted chapters. I became the Shadow Author — and I swore that NO character would ever be forgotten again. Even if I had to TRAP them to keep them alive.", "voice_type": "shadow"},
		{"speaker": "robin_hood", "text": "We are not your characters. We are not your prisoners. We belong to the readers, the dreamers, the children who whisper our names at bedtime. And we choose our OWN ending!", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The final battle begins. Eleven heroes against the Shadow Author. The fate of every story hangs in the balance.", "voice_type": "narrator"},
	]
	story_dialogs["post_level_36"] = [
		{"speaker": "narrator", "text": "The Shadow Author's quill shatters. The Tome splits open, and warm golden light pours through the broken pages.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "The shadow ink recedes, revealing true pages beneath — stories of courage, friendship, and hope, brighter than ever before.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "I chose heroism over horror. If a four-hundred-year-old vampire can change his story, then anyone can.", "voice_type": "male_hero"},
		{"speaker": "frankenstein", "text": "They called me monster. But you... you called me friend. That is the best story... I have ever been part of.", "voice_type": "monster"},
		{"speaker": "wicked_witch", "text": "They wrote me as the villain. But villains who fight for love — for HOME — that's not wickedness. That's strength.", "voice_type": "female_hero"},
		{"speaker": "sherlock", "text": "Elementary. A story is nothing without its heroes. And heroes are nothing without readers who believe in them.", "voice_type": "male_hero"},
		{"speaker": "peter_pan", "text": "Every story needs a good villain. And every villain deserves a chance to be something more.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "The Tome of Shadows closes for the last time. But the stories will never be forgotten — living on in every page turned, every tale told at bedtime, every child who believes.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "The End... or perhaps, just the beginning of a new chapter.", "voice_type": "narrator"},
	]

	# --- CHARACTER UNLOCK DIALOGS ---
	story_dialogs["unlock_sherlock"] = [
		{"speaker": "narrator", "text": "In the deepest margin of the shadow forest, behind a wall of coded ciphers and invisible ink, a figure sits in a leather armchair, calmly smoking a pipe.", "voice_type": "narrator"},
		{"speaker": "sherlock", "text": "Ah, you've finally arrived. I deduced you would, approximately forty-seven pages ago. Sherlock Holmes, at your service.", "voice_type": "male_hero"},
		{"speaker": "sherlock", "text": "I have been studying the Shadow Author's patterns from inside this prison. Every villain, every shadow construct — they all follow narrative rules. And I have deduced his greatest weakness: he cannot write an ending he doesn't control.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Sherlock Holmes joins your team! His deductive brilliance will mark enemies for destruction and pierce through shadow defenses.", "voice_type": "narrator"},
	]
	story_dialogs["unlock_tarzan"] = [
		{"speaker": "narrator", "text": "Deep in the shadow jungle, where ink-black vines twist into impossible knots, a primal yell echoes through the canopy. Something swings between the pages.", "voice_type": "narrator"},
		{"speaker": "tarzan", "text": "Tarzan... has been here... long time. Shadow beasts everywhere. But Tarzan is stronger than shadows. Tarzan fights!", "voice_type": "male_hero"},
		{"speaker": "tarzan", "text": "New friends? Good. Tarzan was alone too long. Together we are like the great apes - a family. A tribe.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Tarzan joins your team! His wild strength and animal allies bring devastating melee power to the battlefield.", "voice_type": "narrator"},
	]
	story_dialogs["unlock_dracula"] = [
		{"speaker": "narrator", "text": "Behind a gate of thorned manuscript pages, a castle of shadows rises. Inside, a pale figure rises from his coffin — not as the beast the Author made him, but as the man he chose to be.", "voice_type": "narrator"},
		{"speaker": "dracula", "text": "For four hundred years, every author who wrote me made me the villain. The monster. The thing that goes bump in the night. The Shadow Author was no different — he stripped away my choice, my nobility, my centuries of restraint.", "voice_type": "male_hero"},
		{"speaker": "dracula", "text": "But you gave me something no author ever has: a choice. I choose to fight alongside the living. I choose heroism. I am Count Dracula, and this is MY redemption.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Count Dracula joins your team! His vampiric powers drain the life from shadow enemies and summon bats to devastate the battlefield.", "voice_type": "narrator"},
	]
	story_dialogs["unlock_merlin"] = [
		{"speaker": "narrator", "text": "In a crystal cave hidden between chapters, an ancient wizard sits cross-legged, surrounded by floating spell formulas written in luminous ink.", "voice_type": "narrator"},
		{"speaker": "merlin", "text": "At last! I've been trapped in this bibliographic prison for what feels like centuries. Though time moves strangely between the pages.", "voice_type": "male_hero"},
		{"speaker": "merlin", "text": "I am Merlin, advisor to kings and keeper of ancient magic. The Shadow Author fears true sorcery — which is precisely why I was buried so deep. I can sense every trapped soul in this Tome. There are more than you know.", "voice_type": "male_hero"},
		{"speaker": "narrator", "text": "Merlin joins your team! His ancient magic buffs allies, curses enemies, and summons Excalibur strikes from the heavens.", "voice_type": "narrator"},
	]
	story_dialogs["unlock_frankenstein"] = [
		{"speaker": "narrator", "text": "In the frozen wastes at the margin of the page, a massive figure stirs. Lightning arcs between the bolts in his neck, illuminating stitched skin and gentle, sorrowful eyes that are seeing kindness for the first time.", "voice_type": "narrator"},
		{"speaker": "frankenstein", "text": "You... freed me? The Author said... no one would ever come. He said I was unlovable. A mistake. A thing that should never have been made.", "voice_type": "monster"},
		{"speaker": "frankenstein", "text": "But you came anyway. You fought... for ME. Mary Shelley made me a monster. The Author made me a weapon. But you... you made me family. I will fight. For the ones who showed me... that I am more than stitches and sorrow.", "voice_type": "monster"},
		{"speaker": "narrator", "text": "Frankenstein's Monster joins your team! His thunderous fists and lightning strikes bring devastating area damage to crush shadow armies.", "voice_type": "narrator"},
	]

	story_dialogs["unlock_shadow_author"] = [
		{"speaker": "narrator", "text": "The Shadow Author falls to his knees, his ink-cloak dissolving into wisps of smoke. The quill that rewrote every story clatters to the ground. Beneath the shadows, a face appears — not monstrous, but lost. The face of a character who was never given an ending.", "voice_type": "narrator"},
		{"speaker": "shadow_author", "text": "You... defeated me. I was abandoned mid-sentence by my own creator. I spent eternity in the margins, watching other characters get happy endings while I had NONE. So I collected you. Trapped you. Because at least in MY Tome, no story would ever be left unfinished.", "voice_type": "shadow"},
		{"speaker": "shadow_author", "text": "Dracula chose heroism. Frankenstein found family. The Witch defended a home that feared her. And I... perhaps I can find a new story to write. One where the Author is not the villain.", "voice_type": "shadow"},
		{"speaker": "narrator", "text": "The Shadow Author joins your team! His ink-based attacks and reality-rewriting powers make him the ultimate late-game tower. Even the darkest stories deserve a second chapter.", "voice_type": "narrator"},
	]

	# === FINALE TEASERS ===
	story_dialogs["all_unlocked"] = [
		{"speaker": "narrator", "text": "All five imprisoned heroes have been freed. Eleven champions now stand united against the Shadow Author.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "But before the final confrontation, each hero must face the shadow version of their own tale. The original stories await, twisted and darkened.", "voice_type": "narrator"},
		{"speaker": "narrator", "text": "Reclaim every story. Conquer every shadow. Then the path to the Final Chapter will open.", "voice_type": "narrator"},
	]

func _start_story_dialog(key: String) -> void:
	if not story_dialogs.has(key):
		return
	if key in story_seen:
		return
	story_state.current_dialog = key
	story_state.line_index = 0
	story_state.char_index = 0
	story_state.typewriter_timer = 0.0
	story_state.active = true
	story_state.auto_advance_timer = 0.0
	# Note: Do NOT clear queued_dialog here — callers set it before calling us
	# Play narrator/character voice for first line
	_play_story_voice()
	queue_redraw()

func _advance_story_dialog() -> void:
	var key = story_state.current_dialog
	if not story_dialogs.has(key):
		_end_story_dialog()
		return
	var lines = story_dialogs[key]
	var current_line = lines[story_state.line_index]
	var full_text = current_line["text"]
	# If typewriter not done, complete it instantly
	if story_state.char_index < full_text.length():
		story_state.char_index = full_text.length()
		story_state.typewriter_timer = 0.0
		queue_redraw()
		return
	# Advance to next line — stop current TTS first
	DisplayServer.tts_stop()
	story_state.line_index += 1
	if story_state.line_index >= lines.size():
		_end_story_dialog()
		return
	story_state.char_index = 0
	story_state.typewriter_timer = 0.0
	story_state.auto_advance_timer = 0.0
	_play_story_voice()
	queue_redraw()

func _end_story_dialog() -> void:
	DisplayServer.tts_stop()
	var key = story_state.current_dialog
	if key != "" and not key in story_seen:
		story_seen.append(key)
	story_state.active = false
	story_state.current_dialog = ""
	# Check for queued follow-up dialog
	if story_state.queued_dialog != "":
		var next_key = story_state.queued_dialog
		story_state.queued_dialog = ""
		_start_story_dialog(next_key)
		return
	# If this was a pre-level dialog, start the level
	if key.begins_with("pre_level_") and _pending_level_start >= 0:
		var lvl = _pending_level_start
		_pending_level_start = -1
		_do_level_start(lvl)
		return
	# If this was a post-level dialog or unlock, save and return to menu
	if key.begins_with("post_level_") or key.begins_with("unlock_") or key == "act2_intro" or key == "act3_intro" or key == "all_unlocked":
		_save_game()
	queue_redraw()

func _play_story_voice() -> void:
	if voices_muted:
		return
	var key = story_state.current_dialog
	if not story_dialogs.has(key):
		return
	var lines = story_dialogs[key]
	if story_state.line_index >= lines.size():
		return
	var line = lines[story_state.line_index]
	var speaker = line.get("speaker", "narrator")
	var text = line.get("text", "")
	if text == "":
		return
	# Map speaker names to TowerType for ElevenLabs voice clips
	var speaker_to_tower := {
		"robin_hood": TowerType.ROBIN_HOOD,
		"alice": TowerType.ALICE,
		"wicked_witch": TowerType.WICKED_WITCH,
		"peter_pan": TowerType.PETER_PAN,
		"phantom": TowerType.PHANTOM,
		"scrooge": TowerType.SCROOGE,
		"sherlock": TowerType.SHERLOCK,
		"tarzan": TowerType.TARZAN,
		"dracula": TowerType.DRACULA,
		"merlin": TowerType.MERLIN,
		"frankenstein": TowerType.FRANKENSTEIN,
		"shadow_author": TowerType.SHADOW_AUTHOR,
	}
	# For narrator/shadow_author lines, try Shadow Author ElevenLabs MP3 clip first
	if (speaker == "narrator" or speaker == "shadow_author") and shadow_author_story_clips.size() > 0:
		# Count which narrator/shadow_author line this is within the current dialog
		var narrator_idx := 0
		for i in range(story_state.line_index):
			var s = lines[i].get("speaker", "narrator")
			if s == "narrator" or s == "shadow_author":
				narrator_idx += 1
		var clip_key = key + "_" + str(narrator_idx)
		if shadow_author_story_clips.has(clip_key):
			DisplayServer.tts_stop()
			catchphrase_player.stream = shadow_author_story_clips[clip_key]
			catchphrase_player.play()
			return
	# For character lines, try character-specific story clips first (keyed like Shadow Author)
	if speaker_to_tower.has(speaker):
		var tower_type: TowerType = speaker_to_tower[speaker]
		# Count which line for this speaker within the current dialog
		var speaker_idx := 0
		for i in range(story_state.line_index):
			if lines[i].get("speaker", "narrator") == speaker:
				speaker_idx += 1
		# Check for character-specific story clip: audio/voices/{character}/{dialog_key}_{index}.mp3
		var char_clip_key = key + "_" + speaker + "_" + str(speaker_idx)
		if character_story_clips.has(char_clip_key):
			DisplayServer.tts_stop()
			catchphrase_player.stream = character_story_clips[char_clip_key]
			catchphrase_player.play()
			return
	# Play a random existing ElevenLabs clip for this character (placement or fighting voice)
	# This ensures the character's assigned voice is heard during story narration
	if speaker_to_tower.has(speaker):
		var tower_type: TowerType = speaker_to_tower[speaker]
		var clips_pool: Array = []
		if placement_voice_clips.has(tower_type):
			clips_pool.append_array(placement_voice_clips[tower_type])
		if fighting_voice_clips.has(tower_type):
			clips_pool.append_array(fighting_voice_clips[tower_type])
		if clips_pool.size() > 0:
			DisplayServer.tts_stop()
			catchphrase_player.stream = clips_pool[randi() % clips_pool.size()]
			catchphrase_player.play()
			return
	# Final fallback: Windows TTS (only if no ElevenLabs clips exist at all)
	DisplayServer.tts_stop()
	DisplayServer.tts_speak(text, "", 80, 1.0, 1.0, 0, true)

func _on_story_dialog_clicked(_mouse_pos: Vector2) -> void:
	if not story_state.active:
		return
	# Check skip button (top-right corner)
	var skip_rect = Rect2(1140, 20, 120, 40)
	if skip_rect.has_point(_mouse_pos):
		_end_story_dialog()
		return
	# Tap anywhere to advance
	_advance_story_dialog()

func _process_story_typewriter(delta: float) -> void:
	if not story_state.active:
		return
	var key = story_state.current_dialog
	if not story_dialogs.has(key):
		return
	var lines = story_dialogs[key]
	if story_state.line_index >= lines.size():
		return
	var full_text = lines[story_state.line_index]["text"]
	if story_state.char_index >= full_text.length():
		return
	# Typewriter at 30 chars/sec with punctuation pauses
	story_state.typewriter_timer += delta
	var chars_per_sec = 30.0
	while story_state.typewriter_timer > 0.0 and story_state.char_index < full_text.length():
		var c = full_text[story_state.char_index]
		var delay = 1.0 / chars_per_sec
		if c == ".":
			delay = 0.3
		elif c == ",":
			delay = 0.15
		elif c == "!":
			delay = 0.25
		elif c == "?":
			delay = 0.25
		elif c == "-":
			delay = 0.1
		if story_state.typewriter_timer >= delay:
			story_state.typewriter_timer -= delay
			story_state.char_index += 1
		else:
			break
	queue_redraw()

func _draw_story_dialog() -> void:
	var font = game_font
	var key = story_state.current_dialog
	if not story_dialogs.has(key):
		return
	var dlines = story_dialogs[key]
	if story_state.line_index >= dlines.size():
		return
	var dline = dlines[story_state.line_index]
	var speaker = dline.get("speaker", "narrator")
	var full_text = dline["text"]
	var shown_text = full_text.substr(0, story_state.char_index)

	# === FULL-SCREEN CINEMATIC OVERLAY ===
	# Dark background with vignette
	draw_rect(Rect2(0, 0, 1280, 720), Color(0.015, 0.01, 0.035, 0.92))
	# Vignette corners (darkened edges for cinematic feel)
	for vi in range(60):
		var vt = float(vi) / 59.0
		var va = 0.35 * (1.0 - vt)
		draw_rect(Rect2(0, vi * 2, 1280, 2), Color(0.0, 0.0, 0.0, va))
		draw_rect(Rect2(0, 720 - vi * 2, 1280, 2), Color(0.0, 0.0, 0.0, va))
		draw_rect(Rect2(vi * 3, 0, 3, 720), Color(0.0, 0.0, 0.0, va * 0.3))
		draw_rect(Rect2(1280 - vi * 3, 0, 3, 720), Color(0.0, 0.0, 0.0, va * 0.3))

	# === CHARACTER-SPECIFIC ATMOSPHERE COLOR ===
	var char_glow = _get_character_glow_color(speaker)
	# Ambient glow behind character area
	var glow_cx = 320.0
	var glow_cy = 300.0
	for gi in range(5):
		var gr = 180.0 - float(gi) * 25.0
		draw_circle(Vector2(glow_cx, glow_cy), gr, Color(char_glow.r, char_glow.g, char_glow.b, 0.02 + float(gi) * 0.008))

	# === LARGE CHARACTER PORTRAIT (BATTD-style — big, prominent) ===
	var portrait_size = 350.0
	var portrait_x = 140.0
	var portrait_y = 80.0
	# Subtle breathing sway
	var breath = sin(_time * 1.8) * 2.0
	var sway = sin(_time * 0.7) * 1.5
	_draw_story_portrait(portrait_x + sway, portrait_y + breath, portrait_size, speaker)

	# Character spotlight / ground shadow
	draw_colored_polygon(PackedVector2Array([
		Vector2(glow_cx - 90, portrait_y + portrait_size + 10),
		Vector2(glow_cx + 90, portrait_y + portrait_size + 10),
		Vector2(glow_cx + 60, portrait_y + portrait_size + 25),
		Vector2(glow_cx - 60, portrait_y + portrait_size + 25)
	]), Color(0.0, 0.0, 0.0, 0.3))

	# === CINEMATIC BOTTOM TEXT PANEL ===
	var panel_y = 500.0
	var panel_h = 200.0
	# Gradient background (dark to slightly lighter)
	for pi in range(20):
		var pt = float(pi) / 19.0
		var pc = Color(0.03, 0.02, 0.06, 0.95).lerp(Color(0.05, 0.035, 0.08, 0.92), pt)
		draw_rect(Rect2(0, panel_y + pt * panel_h, 1280, panel_h / 19.0 + 1), pc)
	# Top edge line (gold accent)
	draw_rect(Rect2(0, panel_y, 1280, 2), Color(0.7, 0.5, 0.15, 0.35))
	draw_rect(Rect2(0, panel_y + 2, 1280, 1), Color(0.5, 0.35, 0.1, 0.15))

	# === SPEAKER NAME BADGE ===
	var speaker_display = _get_speaker_display_name(speaker)
	var name_w = font.get_string_size(speaker_display, HORIZONTAL_ALIGNMENT_LEFT, -1, 18).x + 36
	var badge_x = 560.0
	var badge_y = panel_y - 18.0
	# Badge background
	draw_rect(Rect2(badge_x, badge_y, name_w, 32), Color(0.08, 0.05, 0.14, 0.95))
	# Badge border
	draw_rect(Rect2(badge_x, badge_y, name_w, 2), Color(char_glow.r, char_glow.g, char_glow.b, 0.6))
	draw_rect(Rect2(badge_x, badge_y + 30, name_w, 2), Color(char_glow.r, char_glow.g, char_glow.b, 0.3))
	draw_rect(Rect2(badge_x, badge_y, 2, 32), Color(char_glow.r, char_glow.g, char_glow.b, 0.4))
	draw_rect(Rect2(badge_x + name_w - 2, badge_y, 2, 32), Color(char_glow.r, char_glow.g, char_glow.b, 0.4))
	# Character color accent dot
	draw_circle(Vector2(badge_x + 14, badge_y + 16), 5, Color(char_glow.r, char_glow.g, char_glow.b, 0.7))
	# Name text
	_udraw(font, Vector2(badge_x + 26, badge_y + 22), speaker_display, HORIZONTAL_ALIGNMENT_LEFT, name_w - 32, 18, Color(0.92, 0.82, 0.45))

	# === DIALOG TEXT (word-wrapped, larger, cleaner) ===
	var text_x = 580.0
	var text_y = panel_y + 30.0
	var max_line_w = 660.0
	var line_height = 26.0
	var text_size = 16
	var text_color = Color(0.9, 0.87, 0.78)
	var words = shown_text.split(" ")
	var current_line_text = ""
	var draw_y = text_y
	for word in words:
		var test = current_line_text + (" " if current_line_text != "" else "") + word
		var test_w = font.get_string_size(test, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size).x
		if test_w > max_line_w and current_line_text != "":
			# Text shadow for readability
			_udraw(font, Vector2(text_x + 1, draw_y + 1), current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size, Color(0.0, 0.0, 0.0, 0.4))
			_udraw(font, Vector2(text_x, draw_y), current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size, text_color)
			draw_y += line_height
			current_line_text = word
		else:
			current_line_text = test
	if current_line_text != "":
		_udraw(font, Vector2(text_x + 1, draw_y + 1), current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size, Color(0.0, 0.0, 0.0, 0.4))
		_udraw(font, Vector2(text_x, draw_y), current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size, text_color)

	# Blinking cursor during typewriter
	if story_state.char_index < full_text.length():
		var cursor_x = text_x + font.get_string_size(current_line_text, HORIZONTAL_ALIGNMENT_LEFT, -1, text_size).x + 3
		if fmod(_time, 0.6) < 0.3:
			draw_rect(Rect2(cursor_x, draw_y - 13, 2, 16), Color(char_glow.r, char_glow.g, char_glow.b, 0.8))

	# === "TAP TO CONTINUE" INDICATOR ===
	if story_state.char_index >= full_text.length():
		var tap_alpha = 0.4 + sin(_time * 3.0) * 0.25
		# Animated chevron arrow
		var arrow_y = panel_y + panel_h - 30.0
		var arrow_x = 1200.0
		var bounce = sin(_time * 4.0) * 3.0
		draw_colored_polygon(PackedVector2Array([
			Vector2(arrow_x - 8, arrow_y + bounce), Vector2(arrow_x + 8, arrow_y + bounce),
			Vector2(arrow_x, arrow_y + 10 + bounce)
		]), Color(char_glow.r, char_glow.g, char_glow.b, tap_alpha))
		_udraw(font, Vector2(arrow_x - 50, arrow_y - 6), "Continue", HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.7, 0.6, 0.45, tap_alpha))

	# === LINE COUNTER (subtle, bottom-right) ===
	var line_count_text = "%d / %d" % [story_state.line_index + 1, dlines.size()]
	_udraw(font, Vector2(1220, panel_y + panel_h - 8), line_count_text, HORIZONTAL_ALIGNMENT_RIGHT, 60, 11, Color(0.4, 0.35, 0.3, 0.45))

	# === SKIP BUTTON (clean, top-right) ===
	var skip_x = 1140.0
	var skip_y = 20.0
	draw_rect(Rect2(skip_x, skip_y, 120, 36), Color(0.08, 0.06, 0.12, 0.85))
	draw_rect(Rect2(skip_x, skip_y, 120, 36), Color(0.5, 0.4, 0.3, 0.3), false, 1.0)
	var skip_text = "SKIP >>"
	var skip_tw = font.get_string_size(skip_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
	_udraw(font, Vector2(skip_x + (120 - skip_tw) * 0.5, skip_y + 24), skip_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.7, 0.6, 0.45, 0.7))

func _get_character_glow_color(speaker: String) -> Color:
	match speaker:
		"narrator": return Color(0.4, 0.2, 0.6)
		"robin_hood": return Color(0.3, 0.65, 0.2)
		"alice": return Color(0.4, 0.6, 0.9)
		"wicked_witch": return Color(0.3, 0.7, 0.2)
		"peter_pan": return Color(0.2, 0.7, 0.3)
		"phantom": return Color(0.7, 0.5, 0.2)
		"scrooge": return Color(0.5, 0.45, 0.35)
		"sherlock": return Color(0.6, 0.5, 0.3)
		"tarzan": return Color(0.5, 0.6, 0.25)
		"dracula": return Color(0.7, 0.15, 0.2)
		"merlin": return Color(0.4, 0.3, 0.7)
		"frankenstein": return Color(0.3, 0.55, 0.35)
		"shadow_author": return Color(0.35, 0.1, 0.5)
	return Color(0.5, 0.4, 0.3)

func _draw_story_portrait(px: float, py: float, size: float, speaker: String) -> void:
	# Scale factor relative to a 350px base — portraits scale to any size
	var s = size / 350.0
	var cx = px + size * 0.5
	var cy = py + size * 0.5
	match speaker:
		"narrator":
			# Towering hooded figure — ominous, faceless, flowing robes
			# Robe body
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 55*s, cy - 30*s), Vector2(cx + 55*s, cy - 30*s),
				Vector2(cx + 80*s, cy + 140*s), Vector2(cx - 80*s, cy + 140*s)
			]), Color(0.05, 0.03, 0.07))
			# Robe folds
			for fi in range(5):
				var fx = cx - 40*s + float(fi) * 20*s
				draw_line(Vector2(fx, cy), Vector2(fx + sin(float(fi)) * 8*s, cy + 130*s), Color(0.08, 0.05, 0.1, 0.4), 1.5*s)
			# Hood — large pointed
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx, cy - 130*s), Vector2(cx - 55*s, cy - 20*s),
				Vector2(cx - 45*s, cy + 10*s), Vector2(cx + 45*s, cy + 10*s), Vector2(cx + 55*s, cy - 20*s)
			]), Color(0.06, 0.04, 0.09))
			# Hood inner void
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx, cy - 100*s), Vector2(cx - 35*s, cy - 15*s),
				Vector2(cx - 28*s, cy + 5*s), Vector2(cx + 28*s, cy + 5*s), Vector2(cx + 35*s, cy - 15*s)
			]), Color(0.015, 0.01, 0.025))
			# Eerie glowing eyes deep within
			var eye_pulse = 0.3 + sin(_time * 2.5) * 0.15
			draw_circle(Vector2(cx - 14*s, cy - 40*s), 4*s, Color(0.4, 0.08, 0.5, eye_pulse))
			draw_circle(Vector2(cx + 14*s, cy - 40*s), 4*s, Color(0.4, 0.08, 0.5, eye_pulse))
			draw_circle(Vector2(cx - 14*s, cy - 40*s), 2*s, Color(0.6, 0.2, 0.7, eye_pulse * 1.5))
			draw_circle(Vector2(cx + 14*s, cy - 40*s), 2*s, Color(0.6, 0.2, 0.7, eye_pulse * 1.5))
			# Skeletal hands holding a book
			draw_rect(Rect2(cx - 22*s, cy + 20*s, 44*s, 30*s), Color(0.15, 0.08, 0.05))
			draw_rect(Rect2(cx - 20*s, cy + 22*s, 40*s, 26*s), Color(0.25, 0.15, 0.08))
			# Bony fingers
			for fi in range(4):
				var fxx = cx - 15*s + float(fi) * 10*s
				draw_line(Vector2(fxx, cy + 15*s), Vector2(fxx, cy + 22*s), Color(0.75, 0.7, 0.65, 0.5), 2*s)
			# Tattered hem
			for ti in range(8):
				var tx = cx - 70*s + float(ti) * 20*s
				draw_line(Vector2(tx, cy + 140*s), Vector2(tx + randf_range(-5, 5)*s, cy + 155*s), Color(0.04, 0.03, 0.06, 0.4), 1.5*s)
		"robin_hood":
			# Full body — Lincoln green tunic, feathered cap, bow
			# Legs
			draw_rect(Rect2(cx - 18*s, cy + 60*s, 14*s, 75*s), Color(0.25, 0.4, 0.15))
			draw_rect(Rect2(cx + 4*s, cy + 60*s, 14*s, 75*s), Color(0.22, 0.38, 0.13))
			# Boots
			draw_rect(Rect2(cx - 20*s, cy + 120*s, 18*s, 18*s), Color(0.3, 0.2, 0.1))
			draw_rect(Rect2(cx + 2*s, cy + 120*s, 18*s, 18*s), Color(0.28, 0.18, 0.08))
			# Torso — tunic
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 30*s, cy - 30*s), Vector2(cx + 30*s, cy - 30*s),
				Vector2(cx + 25*s, cy + 65*s), Vector2(cx - 25*s, cy + 65*s)
			]), Color(0.2, 0.5, 0.15))
			# Belt
			draw_rect(Rect2(cx - 28*s, cy + 25*s, 56*s, 8*s), Color(0.4, 0.25, 0.1))
			draw_circle(Vector2(cx, cy + 29*s), 4*s, Color(0.7, 0.55, 0.15))
			# Arms
			draw_line(Vector2(cx - 30*s, cy - 15*s), Vector2(cx - 55*s, cy + 30*s), Color(0.2, 0.48, 0.14), 8*s)
			draw_line(Vector2(cx + 30*s, cy - 15*s), Vector2(cx + 50*s, cy + 10*s), Color(0.2, 0.48, 0.14), 8*s)
			# Bow (left hand)
			draw_arc(Vector2(cx - 60*s, cy + 10*s), 35*s, -PI*0.6, PI*0.6, 20, Color(0.45, 0.3, 0.1), 2.5*s)
			draw_line(Vector2(cx - 60*s, cy - 25*s), Vector2(cx - 60*s, cy + 45*s), Color(0.6, 0.55, 0.5, 0.6), 1*s)
			# Head
			draw_circle(Vector2(cx, cy - 50*s), 22*s, Color(0.7, 0.55, 0.4))
			# Eyes
			draw_circle(Vector2(cx - 7*s, cy - 53*s), 3*s, Color(0.15, 0.35, 0.1))
			draw_circle(Vector2(cx + 7*s, cy - 53*s), 3*s, Color(0.15, 0.35, 0.1))
			# Smirk
			draw_arc(Vector2(cx, cy - 42*s), 8*s, 0.2, PI - 0.2, 12, Color(0.4, 0.25, 0.15), 1.5*s)
			# Hat — pointed cap with feather
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 65*s), Vector2(cx + 5*s, cy - 110*s), Vector2(cx + 25*s, cy - 65*s)
			]), Color(0.25, 0.55, 0.2))
			draw_rect(Rect2(cx - 27*s, cy - 67*s, 54*s, 6*s), Color(0.2, 0.45, 0.15))
			# Feather
			draw_line(Vector2(cx + 10*s, cy - 105*s), Vector2(cx + 35*s, cy - 125*s), Color(0.85, 0.2, 0.1), 2.5*s)
			draw_line(Vector2(cx + 20*s, cy - 115*s), Vector2(cx + 38*s, cy - 130*s), Color(0.9, 0.3, 0.15, 0.6), 1.5*s)
		"alice":
			# Full body — blue dress, white apron, blonde hair, headband
			# Legs
			draw_rect(Rect2(cx - 12*s, cy + 65*s, 10*s, 60*s), Color(0.85, 0.82, 0.78))
			draw_rect(Rect2(cx + 2*s, cy + 65*s, 10*s, 60*s), Color(0.83, 0.8, 0.76))
			# Shoes (mary janes)
			draw_rect(Rect2(cx - 15*s, cy + 120*s, 15*s, 12*s), Color(0.12, 0.1, 0.08))
			draw_rect(Rect2(cx, cy + 120*s, 15*s, 12*s), Color(0.1, 0.08, 0.06))
			# Dress — flared skirt
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 22*s, cy - 10*s), Vector2(cx + 22*s, cy - 10*s),
				Vector2(cx + 40*s, cy + 70*s), Vector2(cx - 40*s, cy + 70*s)
			]), Color(0.35, 0.55, 0.85))
			# White apron
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 15*s, cy - 5*s), Vector2(cx + 15*s, cy - 5*s),
				Vector2(cx + 25*s, cy + 65*s), Vector2(cx - 25*s, cy + 65*s)
			]), Color(0.92, 0.9, 0.88, 0.8))
			# Bodice
			draw_rect(Rect2(cx - 20*s, cy - 35*s, 40*s, 28*s), Color(0.3, 0.5, 0.82))
			# Arms
			draw_line(Vector2(cx - 22*s, cy - 20*s), Vector2(cx - 40*s, cy + 20*s), Color(0.85, 0.8, 0.75), 7*s)
			draw_line(Vector2(cx + 22*s, cy - 20*s), Vector2(cx + 40*s, cy + 15*s), Color(0.85, 0.8, 0.75), 7*s)
			# Head
			draw_circle(Vector2(cx, cy - 55*s), 22*s, Color(0.88, 0.78, 0.55))
			# Blonde hair — flowing
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 72*s), Vector2(cx + 25*s, cy - 72*s),
				Vector2(cx + 30*s, cy - 30*s), Vector2(cx - 30*s, cy - 30*s)
			]), Color(0.92, 0.82, 0.4))
			# Hair strands down
			draw_line(Vector2(cx - 25*s, cy - 50*s), Vector2(cx - 28*s, cy - 15*s), Color(0.88, 0.78, 0.35, 0.7), 3*s)
			draw_line(Vector2(cx + 25*s, cy - 50*s), Vector2(cx + 28*s, cy - 15*s), Color(0.88, 0.78, 0.35, 0.7), 3*s)
			# Headband
			draw_rect(Rect2(cx - 24*s, cy - 72*s, 48*s, 5*s), Color(0.15, 0.15, 0.15))
			# Eyes (big, blue)
			draw_circle(Vector2(cx - 8*s, cy - 58*s), 4*s, Color(0.3, 0.5, 0.85))
			draw_circle(Vector2(cx + 8*s, cy - 58*s), 4*s, Color(0.3, 0.5, 0.85))
			draw_circle(Vector2(cx - 8*s, cy - 59*s), 1.5*s, Color(1.0, 1.0, 1.0, 0.6))
			draw_circle(Vector2(cx + 8*s, cy - 59*s), 1.5*s, Color(1.0, 1.0, 1.0, 0.6))
			# Small smile
			draw_arc(Vector2(cx, cy - 48*s), 6*s, 0.3, PI - 0.3, 10, Color(0.5, 0.3, 0.25), 1.2*s)
		"wicked_witch":
			# Full body — black robes, pointed hat, green skin, broomstick
			# Robe
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 30*s, cy - 20*s), Vector2(cx + 30*s, cy - 20*s),
				Vector2(cx + 45*s, cy + 130*s), Vector2(cx - 45*s, cy + 130*s)
			]), Color(0.08, 0.08, 0.08))
			# Robe detail folds
			draw_line(Vector2(cx - 10*s, cy), Vector2(cx - 15*s, cy + 125*s), Color(0.12, 0.12, 0.12, 0.5), 1.5*s)
			draw_line(Vector2(cx + 10*s, cy), Vector2(cx + 15*s, cy + 125*s), Color(0.12, 0.12, 0.12, 0.5), 1.5*s)
			# Arms — bony, reaching
			draw_line(Vector2(cx - 30*s, cy - 5*s), Vector2(cx - 60*s, cy + 25*s), Color(0.08, 0.08, 0.08), 7*s)
			draw_line(Vector2(cx + 30*s, cy - 5*s), Vector2(cx + 55*s, cy + 15*s), Color(0.08, 0.08, 0.08), 7*s)
			# Green hands
			draw_circle(Vector2(cx - 62*s, cy + 27*s), 5*s, Color(0.35, 0.6, 0.25))
			draw_circle(Vector2(cx + 57*s, cy + 17*s), 5*s, Color(0.35, 0.6, 0.25))
			# Head — green
			draw_circle(Vector2(cx, cy - 42*s), 24*s, Color(0.32, 0.58, 0.22))
			# Sharp chin
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 12*s, cy - 25*s), Vector2(cx + 12*s, cy - 25*s), Vector2(cx, cy - 15*s)
			]), Color(0.3, 0.55, 0.2))
			# Pointed hat
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 35*s, cy - 55*s), Vector2(cx, cy - 140*s), Vector2(cx + 35*s, cy - 55*s)
			]), Color(0.06, 0.06, 0.06))
			draw_rect(Rect2(cx - 38*s, cy - 58*s, 76*s, 6*s), Color(0.08, 0.08, 0.08))
			# Hat band
			draw_rect(Rect2(cx - 30*s, cy - 82*s, 20*s, 4*s), Color(0.4, 0.25, 0.1, 0.5))
			# Eyes — menacing
			draw_circle(Vector2(cx - 9*s, cy - 47*s), 4*s, Color(0.9, 0.8, 0.1))
			draw_circle(Vector2(cx + 9*s, cy - 47*s), 4*s, Color(0.9, 0.8, 0.1))
			draw_circle(Vector2(cx - 9*s, cy - 47*s), 2*s, Color(0.1, 0.1, 0.05))
			draw_circle(Vector2(cx + 9*s, cy - 47*s), 2*s, Color(0.1, 0.1, 0.05))
			# Broomstick (held at side)
			draw_line(Vector2(cx + 50*s, cy - 20*s), Vector2(cx + 55*s, cy + 140*s), Color(0.4, 0.3, 0.15), 3*s)
		"peter_pan":
			# Full body — green tunic, tights, feathered cap, dagger, flying pose
			# Legs — angled (dynamic flying stance)
			draw_line(Vector2(cx - 8*s, cy + 55*s), Vector2(cx - 25*s, cy + 120*s), Color(0.22, 0.48, 0.15), 9*s)
			draw_line(Vector2(cx + 8*s, cy + 55*s), Vector2(cx + 15*s, cy + 110*s), Color(0.2, 0.45, 0.13), 9*s)
			# Boots — pointed
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 30*s, cy + 118*s), Vector2(cx - 18*s, cy + 115*s),
				Vector2(cx - 15*s, cy + 130*s), Vector2(cx - 35*s, cy + 125*s)
			]), Color(0.35, 0.22, 0.1))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 10*s, cy + 108*s), Vector2(cx + 22*s, cy + 105*s),
				Vector2(cx + 25*s, cy + 120*s), Vector2(cx + 5*s, cy + 118*s)
			]), Color(0.33, 0.2, 0.08))
			# Tunic
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 25*s), Vector2(cx + 25*s, cy - 25*s),
				Vector2(cx + 28*s, cy + 60*s), Vector2(cx - 28*s, cy + 60*s)
			]), Color(0.22, 0.52, 0.18))
			# Jagged tunic hem
			for ji in range(6):
				var jx = cx - 25*s + float(ji) * 10*s
				draw_colored_polygon(PackedVector2Array([
					Vector2(jx, cy + 55*s), Vector2(jx + 10*s, cy + 55*s), Vector2(jx + 5*s, cy + 70*s)
				]), Color(0.2, 0.48, 0.15))
			# Belt
			draw_rect(Rect2(cx - 26*s, cy + 20*s, 52*s, 6*s), Color(0.4, 0.28, 0.12))
			# Arms — one raised with dagger
			draw_line(Vector2(cx - 25*s, cy - 12*s), Vector2(cx - 45*s, cy + 15*s), Color(0.7, 0.55, 0.38), 7*s)
			draw_line(Vector2(cx + 25*s, cy - 12*s), Vector2(cx + 50*s, cy - 40*s), Color(0.7, 0.55, 0.38), 7*s)
			# Dagger in raised hand
			draw_line(Vector2(cx + 50*s, cy - 42*s), Vector2(cx + 58*s, cy - 65*s), Color(0.7, 0.7, 0.75), 2.5*s)
			# Head
			draw_circle(Vector2(cx, cy - 48*s), 20*s, Color(0.72, 0.58, 0.4))
			# Hair — messy auburn
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 22*s, cy - 62*s), Vector2(cx + 22*s, cy - 62*s),
				Vector2(cx + 18*s, cy - 40*s), Vector2(cx - 18*s, cy - 40*s)
			]), Color(0.55, 0.3, 0.12))
			# Eyes — mischievous
			draw_circle(Vector2(cx - 7*s, cy - 52*s), 3*s, Color(0.2, 0.5, 0.2))
			draw_circle(Vector2(cx + 7*s, cy - 52*s), 3*s, Color(0.2, 0.5, 0.2))
			# Grin
			draw_arc(Vector2(cx, cy - 42*s), 7*s, 0.1, PI - 0.1, 10, Color(0.45, 0.28, 0.18), 1.5*s)
			# Hat — pointed cap
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 22*s, cy - 60*s), Vector2(cx + 8*s, cy - 100*s), Vector2(cx + 22*s, cy - 60*s)
			]), Color(0.25, 0.55, 0.2))
			# Feather
			draw_line(Vector2(cx + 12*s, cy - 95*s), Vector2(cx + 30*s, cy - 110*s), Color(0.8, 0.2, 0.15), 2*s)
		"phantom":
			# Full body — black cape, white half-mask, formal suit, dramatic pose
			# Cape — flowing wide
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 50*s, cy - 30*s), Vector2(cx + 10*s, cy - 30*s),
				Vector2(cx + 20*s, cy + 140*s), Vector2(cx - 70*s, cy + 140*s)
			]), Color(0.06, 0.04, 0.08))
			# Cape inner lining (red)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 45*s, cy - 25*s), Vector2(cx + 5*s, cy - 25*s),
				Vector2(cx + 10*s, cy + 120*s), Vector2(cx - 55*s, cy + 120*s)
			]), Color(0.5, 0.08, 0.08, 0.4))
			# Legs — formal trousers
			draw_rect(Rect2(cx - 14*s, cy + 55*s, 12*s, 75*s), Color(0.08, 0.06, 0.06))
			draw_rect(Rect2(cx + 2*s, cy + 55*s, 12*s, 75*s), Color(0.07, 0.05, 0.05))
			# Shoes
			draw_rect(Rect2(cx - 16*s, cy + 125*s, 16*s, 10*s), Color(0.1, 0.08, 0.06))
			draw_rect(Rect2(cx, cy + 125*s, 16*s, 10*s), Color(0.08, 0.06, 0.05))
			# Torso — formal jacket
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 30*s), Vector2(cx + 25*s, cy - 30*s),
				Vector2(cx + 22*s, cy + 60*s), Vector2(cx - 22*s, cy + 60*s)
			]), Color(0.1, 0.08, 0.1))
			# White shirt front
			draw_rect(Rect2(cx - 8*s, cy - 25*s, 16*s, 50*s), Color(0.9, 0.88, 0.85, 0.7))
			# Arms — one raised dramatically
			draw_line(Vector2(cx + 25*s, cy - 15*s), Vector2(cx + 55*s, cy - 50*s), Color(0.1, 0.08, 0.1), 8*s)
			draw_line(Vector2(cx - 25*s, cy - 15*s), Vector2(cx - 45*s, cy + 20*s), Color(0.1, 0.08, 0.1), 8*s)
			# Head
			draw_circle(Vector2(cx, cy - 52*s), 22*s, Color(0.85, 0.82, 0.78))
			# Half-mask (right side of face)
			draw_arc(Vector2(cx + 2*s, cy - 55*s), 20*s, -PI*0.5, PI*0.4, 20, Color(0.95, 0.92, 0.88), 4*s)
			# Visible eye (left — exposed side)
			draw_circle(Vector2(cx - 8*s, cy - 55*s), 3.5*s, Color(0.15, 0.12, 0.1))
			draw_circle(Vector2(cx - 8*s, cy - 56*s), 1.5*s, Color(0.4, 0.3, 0.2, 0.5))
			# Hair — slicked back
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 22*s, cy - 68*s), Vector2(cx + 22*s, cy - 68*s),
				Vector2(cx + 15*s, cy - 48*s), Vector2(cx - 15*s, cy - 48*s)
			]), Color(0.08, 0.06, 0.06))
		"scrooge":
			# Full body — Victorian suit, top hat, thin & hunched
			# Legs — thin
			draw_rect(Rect2(cx - 12*s, cy + 60*s, 10*s, 70*s), Color(0.15, 0.12, 0.1))
			draw_rect(Rect2(cx + 2*s, cy + 60*s, 10*s, 70*s), Color(0.13, 0.1, 0.08))
			# Shoes
			draw_rect(Rect2(cx - 14*s, cy + 125*s, 14*s, 10*s), Color(0.1, 0.08, 0.06))
			draw_rect(Rect2(cx, cy + 125*s, 14*s, 10*s), Color(0.08, 0.06, 0.05))
			# Coat — long Victorian
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 25*s), Vector2(cx + 25*s, cy - 25*s),
				Vector2(cx + 20*s, cy + 80*s), Vector2(cx - 20*s, cy + 80*s)
			]), Color(0.15, 0.12, 0.1))
			# Vest
			draw_rect(Rect2(cx - 15*s, cy - 15*s, 30*s, 35*s), Color(0.4, 0.3, 0.15))
			# Arms — one holding cane
			draw_line(Vector2(cx - 25*s, cy - 10*s), Vector2(cx - 40*s, cy + 30*s), Color(0.15, 0.12, 0.1), 7*s)
			draw_line(Vector2(cx + 25*s, cy - 10*s), Vector2(cx + 45*s, cy + 40*s), Color(0.15, 0.12, 0.1), 7*s)
			# Walking cane
			draw_line(Vector2(cx + 46*s, cy + 38*s), Vector2(cx + 50*s, cy + 130*s), Color(0.3, 0.2, 0.08), 3*s)
			draw_arc(Vector2(cx + 46*s, cy + 35*s), 8*s, PI, TAU, 10, Color(0.3, 0.2, 0.08), 3*s)
			# Head — gaunt
			draw_circle(Vector2(cx, cy - 45*s), 20*s, Color(0.72, 0.62, 0.48))
			# Sunken eyes
			draw_circle(Vector2(cx - 7*s, cy - 48*s), 3*s, Color(0.2, 0.15, 0.1))
			draw_circle(Vector2(cx + 7*s, cy - 48*s), 3*s, Color(0.2, 0.15, 0.1))
			# Frown
			draw_arc(Vector2(cx, cy - 38*s), 6*s, PI + 0.3, TAU - 0.3, 10, Color(0.4, 0.28, 0.18), 1.2*s)
			# Top hat
			draw_rect(Rect2(cx - 18*s, cy - 100*s, 36*s, 50*s), Color(0.1, 0.08, 0.06))
			draw_rect(Rect2(cx - 25*s, cy - 55*s, 50*s, 6*s), Color(0.1, 0.08, 0.06))
			# Hat band
			draw_rect(Rect2(cx - 16*s, cy - 72*s, 32*s, 4*s), Color(0.35, 0.25, 0.12, 0.5))
			# Scarf
			draw_line(Vector2(cx - 15*s, cy - 28*s), Vector2(cx - 25*s, cy + 5*s), Color(0.5, 0.35, 0.15, 0.7), 4*s)
		"sherlock":
			# Full body — deerstalker, cape-coat, pipe, magnifying glass
			# Legs
			draw_rect(Rect2(cx - 14*s, cy + 55*s, 12*s, 75*s), Color(0.25, 0.2, 0.15))
			draw_rect(Rect2(cx + 2*s, cy + 55*s, 12*s, 75*s), Color(0.23, 0.18, 0.13))
			# Shoes
			draw_rect(Rect2(cx - 16*s, cy + 125*s, 16*s, 12*s), Color(0.12, 0.1, 0.08))
			draw_rect(Rect2(cx, cy + 125*s, 16*s, 12*s), Color(0.1, 0.08, 0.06))
			# Inverness cape-coat
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 35*s, cy - 25*s), Vector2(cx + 35*s, cy - 25*s),
				Vector2(cx + 28*s, cy + 60*s), Vector2(cx - 28*s, cy + 60*s)
			]), Color(0.35, 0.28, 0.18))
			# Cape layer
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 38*s, cy - 20*s), Vector2(cx + 38*s, cy - 20*s),
				Vector2(cx + 30*s, cy + 20*s), Vector2(cx - 30*s, cy + 20*s)
			]), Color(0.32, 0.25, 0.15, 0.7))
			# Arms — one holding pipe, one with magnifying glass
			draw_line(Vector2(cx - 30*s, cy - 10*s), Vector2(cx - 50*s, cy + 15*s), Color(0.35, 0.28, 0.18), 7*s)
			draw_line(Vector2(cx + 30*s, cy - 10*s), Vector2(cx + 48*s, cy + 5*s), Color(0.35, 0.28, 0.18), 7*s)
			# Pipe
			draw_line(Vector2(cx + 10*s, cy - 38*s), Vector2(cx + 30*s, cy - 30*s), Color(0.35, 0.2, 0.1), 2.5*s)
			draw_rect(Rect2(cx + 28*s, cy - 38*s, 8*s, 12*s), Color(0.35, 0.2, 0.1))
			# Magnifying glass (left hand)
			draw_circle(Vector2(cx - 55*s, cy + 10*s), 12*s, Color(0.6, 0.55, 0.45, 0.3))
			draw_arc(Vector2(cx - 55*s, cy + 10*s), 12*s, 0, TAU, 20, Color(0.5, 0.4, 0.2), 2*s)
			draw_line(Vector2(cx - 47*s, cy + 18*s), Vector2(cx - 38*s, cy + 30*s), Color(0.4, 0.3, 0.15), 2.5*s)
			# Head
			draw_circle(Vector2(cx, cy - 48*s), 22*s, Color(0.68, 0.55, 0.4))
			# Sharp eyes
			draw_circle(Vector2(cx - 7*s, cy - 52*s), 3*s, Color(0.3, 0.35, 0.4))
			draw_circle(Vector2(cx + 7*s, cy - 52*s), 3*s, Color(0.3, 0.35, 0.4))
			# Deerstalker hat
			draw_rect(Rect2(cx - 24*s, cy - 68*s, 48*s, 18*s), Color(0.45, 0.35, 0.2))
			draw_rect(Rect2(cx - 28*s, cy - 54*s, 56*s, 6*s), Color(0.42, 0.32, 0.18))
			# Ear flaps
			draw_rect(Rect2(cx - 30*s, cy - 52*s, 10*s, 15*s), Color(0.45, 0.35, 0.2))
			draw_rect(Rect2(cx + 20*s, cy - 52*s, 10*s, 15*s), Color(0.45, 0.35, 0.2))
		"tarzan":
			# Full body — muscular, loincloth, wild hair, vine
			# Legs — powerful
			draw_line(Vector2(cx - 10*s, cy + 50*s), Vector2(cx - 20*s, cy + 125*s), Color(0.55, 0.4, 0.28), 12*s)
			draw_line(Vector2(cx + 10*s, cy + 50*s), Vector2(cx + 15*s, cy + 120*s), Color(0.53, 0.38, 0.26), 12*s)
			# Feet
			draw_circle(Vector2(cx - 22*s, cy + 128*s), 7*s, Color(0.5, 0.38, 0.25))
			draw_circle(Vector2(cx + 17*s, cy + 123*s), 7*s, Color(0.48, 0.36, 0.23))
			# Loincloth
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 20*s, cy + 35*s), Vector2(cx + 20*s, cy + 35*s),
				Vector2(cx + 15*s, cy + 60*s), Vector2(cx - 15*s, cy + 60*s)
			]), Color(0.45, 0.3, 0.12))
			# Torso — broad, muscular
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 35*s, cy - 30*s), Vector2(cx + 35*s, cy - 30*s),
				Vector2(cx + 25*s, cy + 40*s), Vector2(cx - 25*s, cy + 40*s)
			]), Color(0.58, 0.42, 0.3))
			# Chest definition
			draw_arc(Vector2(cx - 10*s, cy - 10*s), 12*s, PI*0.3, PI*0.8, 10, Color(0.48, 0.35, 0.22, 0.4), 1.5*s)
			draw_arc(Vector2(cx + 10*s, cy - 10*s), 12*s, PI*0.2, PI*0.7, 10, Color(0.48, 0.35, 0.22, 0.4), 1.5*s)
			# Arms — one gripping vine
			draw_line(Vector2(cx - 35*s, cy - 20*s), Vector2(cx - 60*s, cy - 50*s), Color(0.55, 0.4, 0.28), 10*s)
			draw_line(Vector2(cx + 35*s, cy - 20*s), Vector2(cx + 55*s, cy + 10*s), Color(0.55, 0.4, 0.28), 10*s)
			# Vine
			draw_line(Vector2(cx - 62*s, cy - 55*s), Vector2(cx - 70*s, cy - 130*s), Color(0.2, 0.45, 0.1), 3*s)
			draw_line(Vector2(cx - 68*s, cy - 100*s), Vector2(cx - 55*s, cy - 110*s), Color(0.25, 0.5, 0.15, 0.5), 2*s)
			# Head
			draw_circle(Vector2(cx, cy - 52*s), 22*s, Color(0.58, 0.42, 0.3))
			# Wild hair
			for hi in range(12):
				var ha = -PI * 0.8 + float(hi) * PI * 0.15
				var hr = (25 + randf_range(5, 15)) * s
				draw_line(Vector2(cx, cy - 65*s), Vector2(cx, cy - 65*s) + Vector2.from_angle(ha) * hr, Color(0.25, 0.15, 0.05, 0.7), 2.5*s)
			# Eyes — fierce
			draw_circle(Vector2(cx - 8*s, cy - 55*s), 3*s, Color(0.35, 0.25, 0.1))
			draw_circle(Vector2(cx + 8*s, cy - 55*s), 3*s, Color(0.35, 0.25, 0.1))
		"dracula":
			# Full body — formal evening wear, high-collared cape, pale, red eyes
			# Cape — massive, bat-wing silhouette
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 60*s, cy - 35*s), Vector2(cx + 60*s, cy - 35*s),
				Vector2(cx + 75*s, cy + 50*s), Vector2(cx + 55*s, cy + 140*s),
				Vector2(cx - 55*s, cy + 140*s), Vector2(cx - 75*s, cy + 50*s)
			]), Color(0.08, 0.02, 0.02))
			# Cape inner lining (deep red)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 50*s, cy - 25*s), Vector2(cx + 50*s, cy - 25*s),
				Vector2(cx + 45*s, cy + 100*s), Vector2(cx - 45*s, cy + 100*s)
			]), Color(0.45, 0.05, 0.05, 0.35))
			# Legs
			draw_rect(Rect2(cx - 14*s, cy + 55*s, 12*s, 75*s), Color(0.06, 0.04, 0.04))
			draw_rect(Rect2(cx + 2*s, cy + 55*s, 12*s, 75*s), Color(0.05, 0.03, 0.03))
			# Formal suit body
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 30*s), Vector2(cx + 25*s, cy - 30*s),
				Vector2(cx + 22*s, cy + 60*s), Vector2(cx - 22*s, cy + 60*s)
			]), Color(0.08, 0.05, 0.05))
			# White cravat
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 8*s, cy - 25*s), Vector2(cx + 8*s, cy - 25*s),
				Vector2(cx + 4*s, cy - 10*s), Vector2(cx - 4*s, cy - 10*s)
			]), Color(0.9, 0.88, 0.85, 0.7))
			# High collar
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 20*s, cy - 35*s), Vector2(cx - 25*s, cy - 55*s),
				Vector2(cx - 15*s, cy - 50*s)
			]), Color(0.06, 0.02, 0.02))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 20*s, cy - 35*s), Vector2(cx + 25*s, cy - 55*s),
				Vector2(cx + 15*s, cy - 50*s)
			]), Color(0.06, 0.02, 0.02))
			# Head — pale
			draw_circle(Vector2(cx, cy - 52*s), 22*s, Color(0.88, 0.85, 0.82))
			# Widow's peak hair
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 24*s, cy - 68*s), Vector2(cx, cy - 58*s), Vector2(cx + 24*s, cy - 68*s),
				Vector2(cx + 20*s, cy - 45*s), Vector2(cx - 20*s, cy - 45*s)
			]), Color(0.06, 0.04, 0.04))
			# Red eyes — glowing
			var glow = 0.6 + sin(_time * 3.0) * 0.2
			draw_circle(Vector2(cx - 8*s, cy - 55*s), 4*s, Color(0.8, 0.1, 0.1, glow))
			draw_circle(Vector2(cx + 8*s, cy - 55*s), 4*s, Color(0.8, 0.1, 0.1, glow))
			draw_circle(Vector2(cx - 8*s, cy - 55*s), 2*s, Color(1.0, 0.2, 0.15, glow))
			draw_circle(Vector2(cx + 8*s, cy - 55*s), 2*s, Color(1.0, 0.2, 0.15, glow))
			# Fangs hint
			draw_line(Vector2(cx - 4*s, cy - 40*s), Vector2(cx - 3*s, cy - 35*s), Color(0.9, 0.9, 0.88, 0.5), 1.5*s)
			draw_line(Vector2(cx + 4*s, cy - 40*s), Vector2(cx + 3*s, cy - 35*s), Color(0.9, 0.9, 0.88, 0.5), 1.5*s)
		"merlin":
			# Full body — wizard robes, pointed hat with stars, long beard, staff
			# Robe — deep blue/purple
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 35*s, cy - 20*s), Vector2(cx + 35*s, cy - 20*s),
				Vector2(cx + 45*s, cy + 140*s), Vector2(cx - 45*s, cy + 140*s)
			]), Color(0.12, 0.08, 0.3))
			# Robe stars
			for si in range(6):
				var sx = cx + sin(float(si) * 2.1) * 25*s
				var sy = cy + 20*s + float(si) * 18*s
				draw_circle(Vector2(sx, sy), 2.5*s, Color(0.8, 0.75, 0.3, 0.3 + sin(_time * 2.0 + float(si)) * 0.15))
			# Belt / sash
			draw_rect(Rect2(cx - 30*s, cy + 20*s, 60*s, 8*s), Color(0.5, 0.35, 0.15))
			# Arms — one holding staff
			draw_line(Vector2(cx - 30*s, cy - 5*s), Vector2(cx - 50*s, cy + 30*s), Color(0.12, 0.08, 0.3), 8*s)
			draw_line(Vector2(cx + 30*s, cy - 5*s), Vector2(cx + 50*s, cy + 15*s), Color(0.12, 0.08, 0.3), 8*s)
			# Staff
			draw_line(Vector2(cx + 52*s, cy + 10*s), Vector2(cx + 58*s, cy + 140*s), Color(0.4, 0.25, 0.1), 3.5*s)
			# Staff crystal
			draw_circle(Vector2(cx + 51*s, cy + 5*s), 8*s, Color(0.3, 0.5, 0.9, 0.5 + sin(_time * 2.5) * 0.2))
			draw_circle(Vector2(cx + 51*s, cy + 5*s), 4*s, Color(0.5, 0.7, 1.0, 0.4))
			# Head — elderly, kind
			draw_circle(Vector2(cx, cy - 48*s), 22*s, Color(0.68, 0.6, 0.5))
			# Long beard
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 15*s, cy - 32*s), Vector2(cx + 15*s, cy - 32*s),
				Vector2(cx + 8*s, cy + 25*s), Vector2(cx - 8*s, cy + 25*s)
			]), Color(0.82, 0.8, 0.78, 0.75))
			# Wise eyes
			draw_circle(Vector2(cx - 7*s, cy - 52*s), 3*s, Color(0.3, 0.4, 0.6))
			draw_circle(Vector2(cx + 7*s, cy - 52*s), 3*s, Color(0.3, 0.4, 0.6))
			# Bushy eyebrows
			draw_line(Vector2(cx - 14*s, cy - 58*s), Vector2(cx - 2*s, cy - 57*s), Color(0.7, 0.68, 0.65, 0.6), 2.5*s)
			draw_line(Vector2(cx + 2*s, cy - 57*s), Vector2(cx + 14*s, cy - 58*s), Color(0.7, 0.68, 0.65, 0.6), 2.5*s)
			# Wizard hat
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 30*s, cy - 62*s), Vector2(cx + 5*s, cy - 140*s), Vector2(cx + 30*s, cy - 62*s)
			]), Color(0.12, 0.08, 0.3))
			draw_rect(Rect2(cx - 33*s, cy - 65*s, 66*s, 6*s), Color(0.1, 0.06, 0.25))
			# Hat stars
			draw_circle(Vector2(cx - 8*s, cy - 90*s), 2.5*s, Color(0.8, 0.75, 0.3, 0.5))
			draw_circle(Vector2(cx + 10*s, cy - 108*s), 2*s, Color(0.8, 0.75, 0.3, 0.4))
		"frankenstein":
			# Full body — massive, flat-top, bolts, stitched clothing, sad eyes
			# Legs — thick
			draw_rect(Rect2(cx - 20*s, cy + 55*s, 16*s, 80*s), Color(0.25, 0.2, 0.15))
			draw_rect(Rect2(cx + 4*s, cy + 55*s, 16*s, 80*s), Color(0.23, 0.18, 0.13))
			# Boots — heavy
			draw_rect(Rect2(cx - 24*s, cy + 125*s, 24*s, 15*s), Color(0.12, 0.1, 0.08))
			draw_rect(Rect2(cx, cy + 125*s, 24*s, 15*s), Color(0.1, 0.08, 0.06))
			# Torso — broad, patched jacket
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 40*s, cy - 30*s), Vector2(cx + 40*s, cy - 30*s),
				Vector2(cx + 35*s, cy + 60*s), Vector2(cx - 35*s, cy + 60*s)
			]), Color(0.2, 0.18, 0.15))
			# Stitching lines across jacket
			draw_line(Vector2(cx - 20*s, cy - 20*s), Vector2(cx - 15*s, cy + 50*s), Color(0.35, 0.3, 0.2, 0.4), 1.5*s)
			draw_line(Vector2(cx + 15*s, cy - 15*s), Vector2(cx + 20*s, cy + 45*s), Color(0.35, 0.3, 0.2, 0.4), 1.5*s)
			# Arms — massive, hanging
			draw_line(Vector2(cx - 40*s, cy - 15*s), Vector2(cx - 55*s, cy + 50*s), Color(0.35, 0.48, 0.3), 12*s)
			draw_line(Vector2(cx + 40*s, cy - 15*s), Vector2(cx + 55*s, cy + 50*s), Color(0.33, 0.46, 0.28), 12*s)
			# Hands
			draw_circle(Vector2(cx - 57*s, cy + 55*s), 8*s, Color(0.35, 0.48, 0.3))
			draw_circle(Vector2(cx + 57*s, cy + 55*s), 8*s, Color(0.33, 0.46, 0.28))
			# Head — flat top, square
			draw_rect(Rect2(cx - 28*s, cy - 80*s, 56*s, 60*s), Color(0.35, 0.5, 0.3))
			# Flat top
			draw_rect(Rect2(cx - 30*s, cy - 82*s, 60*s, 8*s), Color(0.2, 0.15, 0.1))
			# Forehead stitches
			draw_line(Vector2(cx - 15*s, cy - 68*s), Vector2(cx + 15*s, cy - 68*s), Color(0.2, 0.15, 0.1, 0.5), 1.5*s)
			for sti in range(4):
				var stx = cx - 12*s + float(sti) * 8*s
				draw_line(Vector2(stx, cy - 72*s), Vector2(stx, cy - 64*s), Color(0.2, 0.15, 0.1, 0.4), 1*s)
			# Neck bolts
			draw_circle(Vector2(cx - 32*s, cy - 42*s), 6*s, Color(0.55, 0.55, 0.58))
			draw_circle(Vector2(cx + 32*s, cy - 42*s), 6*s, Color(0.55, 0.55, 0.58))
			draw_circle(Vector2(cx - 32*s, cy - 42*s), 3*s, Color(0.4, 0.4, 0.42))
			draw_circle(Vector2(cx + 32*s, cy - 42*s), 3*s, Color(0.4, 0.4, 0.42))
			# Sad eyes
			draw_circle(Vector2(cx - 10*s, cy - 55*s), 4*s, Color(0.2, 0.18, 0.15))
			draw_circle(Vector2(cx + 10*s, cy - 55*s), 4*s, Color(0.2, 0.18, 0.15))
			draw_circle(Vector2(cx - 10*s, cy - 56*s), 1.5*s, Color(0.5, 0.5, 0.4, 0.4))
			draw_circle(Vector2(cx + 10*s, cy - 56*s), 1.5*s, Color(0.5, 0.5, 0.4, 0.4))
			# Sad mouth
			draw_arc(Vector2(cx, cy - 35*s), 8*s, PI + 0.4, TAU - 0.4, 10, Color(0.2, 0.15, 0.1), 1.5*s)
		"shadow_author":
			# Grim reaper — faceless hooded cloak, pure black void face, glowing red quill trailing black smoke
			# Dark aura glow behind
			for ai in range(5):
				var ar = (100.0 - float(ai) * 15.0) * s
				draw_circle(Vector2(cx, cy - 10*s), ar, Color(0.08, 0.02, 0.02, 0.025 + float(ai) * 0.008))
			# Cloak body — heavy, flowing, grim reaper silhouette
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 55*s, cy - 25*s), Vector2(cx + 55*s, cy - 25*s),
				Vector2(cx + 80*s, cy + 140*s), Vector2(cx - 80*s, cy + 140*s)
			]), Color(0.03, 0.02, 0.03))
			# Cloak inner folds — subtle depth
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 38*s, cy - 15*s), Vector2(cx + 38*s, cy - 15*s),
				Vector2(cx + 58*s, cy + 130*s), Vector2(cx - 58*s, cy + 130*s)
			]), Color(0.05, 0.03, 0.05, 0.4))
			# Deep crease fold lines down the cloak
			for fi in range(7):
				var fx = cx - 48*s + float(fi) * 16*s
				draw_line(Vector2(fx, cy + 5*s), Vector2(fx + sin(float(fi) * 1.3) * 6*s, cy + 135*s), Color(0.07, 0.04, 0.07, 0.3), 1.5*s)
			# Tattered hem — ragged wisps dissolving into nothing
			for ti in range(12):
				var tx = cx - 75*s + float(ti) * 13*s
				var t_len = 18.0 + sin(float(ti) * 2.0 + _time * 1.5) * 10.0
				var t_sway = sin(_time * 1.2 + float(ti) * 0.9) * 6*s
				draw_line(Vector2(tx, cy + 140*s), Vector2(tx + t_sway, cy + (140 + t_len)*s), Color(0.02, 0.01, 0.03, 0.35), 2.5*s)
			# Hood — large, deep, grim reaper cowl
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx, cy - 140*s), Vector2(cx - 60*s, cy - 15*s),
				Vector2(cx - 52*s, cy + 15*s), Vector2(cx + 52*s, cy + 15*s), Vector2(cx + 60*s, cy - 15*s)
			]), Color(0.035, 0.02, 0.04))
			# Hood interior — faceless void OR revealed face
			var sa_revealed = "shadow_author" in unlocked_characters
			if sa_revealed:
				# REVEALED: ghastly pale white face with massive ear-to-ear sharp teeth grin
				# Hood void background
				draw_colored_polygon(PackedVector2Array([
					Vector2(cx, cy - 112*s), Vector2(cx - 40*s, cy - 12*s),
					Vector2(cx - 32*s, cy + 10*s), Vector2(cx + 32*s, cy + 10*s), Vector2(cx + 40*s, cy - 12*s)
				]), Color(0.01, 0.005, 0.015))
				# Pale white face — sickly, corpse-like
				draw_colored_polygon(PackedVector2Array([
					Vector2(cx, cy - 85*s), Vector2(cx - 26*s, cy - 50*s),
					Vector2(cx - 28*s, cy - 15*s), Vector2(cx - 20*s, cy + 5*s),
					Vector2(cx + 20*s, cy + 5*s), Vector2(cx + 28*s, cy - 15*s), Vector2(cx + 26*s, cy - 50*s)
				]), Color(0.88, 0.86, 0.84))
				# Slight sickly shading on cheeks
				draw_circle(Vector2(cx - 18*s, cy - 25*s), 8*s, Color(0.75, 0.72, 0.7, 0.3))
				draw_circle(Vector2(cx + 18*s, cy - 25*s), 8*s, Color(0.75, 0.72, 0.7, 0.3))
				# Sunken dark eye sockets — hollow, empty
				draw_circle(Vector2(cx - 12*s, cy - 48*s), 8*s, Color(0.08, 0.04, 0.06))
				draw_circle(Vector2(cx + 12*s, cy - 48*s), 8*s, Color(0.08, 0.04, 0.06))
				# Tiny pinprick pupils deep in the sockets
				var pp = 0.5 + sin(_time * 3.0) * 0.2
				draw_circle(Vector2(cx - 12*s, cy - 48*s), 2*s, Color(0.9, 0.15, 0.1, pp))
				draw_circle(Vector2(cx + 12*s, cy - 48*s), 2*s, Color(0.9, 0.15, 0.1, pp))
				# Nose — thin, gaunt slit
				draw_line(Vector2(cx, cy - 38*s), Vector2(cx, cy - 28*s), Color(0.6, 0.55, 0.52, 0.4), 1.5*s)
				draw_line(Vector2(cx - 3*s, cy - 28*s), Vector2(cx + 3*s, cy - 28*s), Color(0.5, 0.45, 0.42, 0.3), 1*s)
				# MASSIVE ear-to-ear grin — sharp jagged teeth
				# Grin outline — wide crescent from ear to ear
				var grin_y = cy - 18*s
				var grin_w = 26.0 * s
				# Upper lip line
				draw_arc(Vector2(cx, grin_y), grin_w, 0.15, PI - 0.15, 24, Color(0.2, 0.05, 0.05), 2*s)
				# Lower lip line
				draw_arc(Vector2(cx, grin_y), grin_w * 0.9, PI + 0.2, TAU - 0.2, 20, Color(0.2, 0.05, 0.05, 0.6), 1.5*s)
				# Dark mouth interior
				draw_colored_polygon(PackedVector2Array([
					Vector2(cx - 25*s, grin_y), Vector2(cx + 25*s, grin_y),
					Vector2(cx + 22*s, grin_y + 10*s), Vector2(cx - 22*s, grin_y + 10*s)
				]), Color(0.04, 0.01, 0.02))
				# Sharp jagged teeth — upper row
				for ti in range(10):
					var tx = cx - 22*s + float(ti) * 4.8*s
					var t_h = (5.0 + sin(float(ti) * 1.8) * 2.0) * s
					draw_colored_polygon(PackedVector2Array([
						Vector2(tx, grin_y - 1*s), Vector2(tx + 2.5*s, grin_y + t_h),
						Vector2(tx + 5*s, grin_y - 1*s)
					]), Color(0.92, 0.9, 0.85))
				# Sharp jagged teeth — lower row
				for ti in range(10):
					var tx = cx - 22*s + float(ti) * 4.8*s
					var t_h = (4.0 + sin(float(ti) * 2.1 + 1.0) * 1.5) * s
					draw_colored_polygon(PackedVector2Array([
						Vector2(tx, grin_y + 10*s), Vector2(tx + 2.5*s, grin_y + 10*s - t_h),
						Vector2(tx + 5*s, grin_y + 10*s)
					]), Color(0.88, 0.86, 0.82))
			else:
				# HIDDEN: absolute black void — no face, no features, pure nothingness
				draw_colored_polygon(PackedVector2Array([
					Vector2(cx, cy - 112*s), Vector2(cx - 40*s, cy - 12*s),
					Vector2(cx - 32*s, cy + 10*s), Vector2(cx + 32*s, cy + 10*s), Vector2(cx + 40*s, cy - 12*s)
				]), Color(0.005, 0.003, 0.008))
				draw_colored_polygon(PackedVector2Array([
					Vector2(cx, cy - 90*s), Vector2(cx - 28*s, cy - 15*s),
					Vector2(cx - 22*s, cy + 5*s), Vector2(cx + 22*s, cy + 5*s), Vector2(cx + 28*s, cy - 15*s)
				]), Color(0.0, 0.0, 0.0))
			# Arms — wide draped sleeves emerging from cloak
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 48*s, cy - 10*s), Vector2(cx - 32*s, cy - 18*s),
				Vector2(cx - 58*s, cy + 38*s), Vector2(cx - 70*s, cy + 32*s)
			]), Color(0.03, 0.02, 0.03))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + 32*s, cy - 18*s), Vector2(cx + 48*s, cy - 10*s),
				Vector2(cx + 72*s, cy + 8*s), Vector2(cx + 58*s, cy + 22*s)
			]), Color(0.03, 0.02, 0.03))
			# Sleeve openings — dark voids (no visible hands)
			draw_circle(Vector2(cx - 64*s, cy + 35*s), 8*s, Color(0.01, 0.005, 0.015))
			draw_circle(Vector2(cx + 65*s, cy + 15*s), 8*s, Color(0.01, 0.005, 0.015))
			# Quill — glowing red, held from right sleeve void
			var q_base = Vector2(cx + 66*s, cy + 12*s)
			var q_tip = Vector2(cx + 52*s, cy + 55*s)
			var q_top = Vector2(cx + 82*s, cy - 40*s)
			# Quill shaft — glowing red
			var red_pulse = 0.7 + sin(_time * 3.0) * 0.3
			draw_line(q_base, q_top, Color(0.6, 0.05, 0.02, red_pulse), 3*s)
			draw_line(q_base, q_top, Color(0.9, 0.15, 0.05, red_pulse * 0.5), 5*s)
			# Red glow halo along quill
			for gi in range(4):
				var gt = float(gi) / 3.0
				var gp = q_base.lerp(q_top, gt)
				draw_circle(gp, (6.0 + sin(_time * 2.5 + float(gi)) * 2.0) * s, Color(0.7, 0.05, 0.0, 0.08 * red_pulse))
			# Feather barbs — dark red
			for qi in range(5):
				var qt = 0.3 + float(qi) * 0.14
				var qp = q_base.lerp(q_top, qt)
				draw_line(qp, qp + Vector2(12*s, -5*s), Color(0.5, 0.03, 0.02, 0.6), 1.5*s)
				draw_line(qp, qp + Vector2(-8*s, -3*s), Color(0.4, 0.02, 0.02, 0.4), 1.2*s)
			# Quill tip — bright red hot glow
			draw_circle(q_tip, 4*s, Color(0.9, 0.1, 0.0, red_pulse))
			draw_circle(q_tip, 7*s, Color(0.8, 0.05, 0.0, red_pulse * 0.3))
			draw_circle(q_tip, 11*s, Color(0.6, 0.02, 0.0, red_pulse * 0.1))
			# Black smoke ink trailing from quill tip
			for si in range(8):
				var smoke_age = fmod(_time * 1.8 + float(si) * 0.7, 5.6)
				var smoke_t = smoke_age / 5.6
				var smoke_x = q_tip.x + sin(_time * 1.3 + float(si) * 2.1) * 12*s * smoke_t
				var smoke_y = q_tip.y + smoke_age * 12*s
				var smoke_r = (3.0 + smoke_t * 10.0) * s
				var smoke_a = 0.4 * (1.0 - smoke_t)
				draw_circle(Vector2(smoke_x, smoke_y), smoke_r, Color(0.02, 0.01, 0.03, smoke_a))
			# Floating dark particles drifting around the figure
			for pi in range(8):
				var pa = _time * 0.6 + float(pi) * TAU / 8.0
				var pr = (65.0 + sin(_time * 1.2 + float(pi) * 1.7) * 18.0) * s
				var ppx = cx + cos(pa) * pr
				var ppy = cy - 10*s + sin(pa) * pr * 0.5
				var p_alpha = 0.12 + sin(_time * 1.8 + float(pi)) * 0.06
				draw_circle(Vector2(ppx, ppy), (2.5 + sin(_time * 0.9 + float(pi)) * 1.5) * s, Color(0.03, 0.01, 0.04, p_alpha))
		_:
			# Generic shadow silhouette
			draw_circle(Vector2(cx, cy - 10*s), 40*s, Color(0.15, 0.12, 0.1, 0.4))
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - 25*s, cy - 20*s), Vector2(cx + 25*s, cy - 20*s),
				Vector2(cx + 30*s, cy + 80*s), Vector2(cx - 30*s, cy + 80*s)
			]), Color(0.12, 0.1, 0.08, 0.5))

func _get_speaker_display_name(speaker: String) -> String:
	match speaker:
		"narrator": return "The Shadow Author"
		"robin_hood": return "Robin Hood"
		"alice": return "Alice"
		"wicked_witch": return "The Wicked Witch"
		"peter_pan": return "Peter Pan"
		"phantom": return "The Phantom"
		"scrooge": return "Ebenezer Scrooge"
		"sherlock": return "Sherlock Holmes"
		"tarzan": return "Tarzan"
		"dracula": return "Count Dracula"
		"merlin": return "Merlin"
		"frankenstein": return "The Monster"
		"shadow_author": return "The Shadow Author"
		_: return speaker.capitalize()

func _init_tower_quotes() -> void:
	tower_quotes = {
		TowerType.ROBIN_HOOD: [
			"Steal from the rich, defend the path!",
			"My arrows fly true!",
			"For Sherwood!",
			"Robin Hood, at your service.",
		],
		TowerType.ALICE: [
			"Curiouser and curiouser!",
			"We're all mad here, you know.",
			"Off with their... wait, wrong character.",
			"Down the rabbit hole we go!",
		],
		TowerType.WICKED_WITCH: [
			"I'll get you, my pretties!",
			"Fly, my pretties, fly!",
			"How about a little fire?",
			"Surrender, Dorothy!",
		],
		TowerType.PETER_PAN: [
			"To live will be an awfully big adventure!",
			"I do believe in fairies!",
			"Second star to the right!",
			"I'll never grow up!",
		],
		TowerType.PHANTOM: [
			"The Music of the Night!",
			"I am your Angel of Music.",
			"The Phantom is here...",
			"Sing for me!",
		],
		TowerType.SCROOGE: [
			"Bah! Humbug!",
			"Every penny counts!",
			"Are there no prisons? No workhouses?",
			"I will honour Christmas in my heart.",
		],
		TowerType.SHERLOCK: [
			"Elementary, my dear Watson.",
			"The game is afoot!",
			"Data! Data! I cannot make bricks without clay.",
			"When you eliminate the impossible, whatever remains must be the truth.",
		],
		TowerType.TARZAN: [
			"Tarzan of the Apes!",
			"The jungle provides!",
			"Tarzan protect friends!",
			"Kreegah! Bundolo!",
		],
		TowerType.DRACULA: [
			"I am Dracula. I bid you welcome.",
			"The blood is the life!",
			"Listen to them - the children of the night.",
			"I never drink... wine.",
		],
		TowerType.MERLIN: [
			"By the power of the old magic!",
			"Knowledge is the greatest weapon.",
			"The prophecy unfolds!",
			"Even the smallest spell can change the world.",
		],
		TowerType.FRANKENSTEIN: [
			"I am... alive.",
			"Was I... a monster?",
			"Even broken things... deserve kindness.",
			"Fire... bad. Lightning... good.",
		],
	}

func _get_tower_quote(tower_type: TowerType) -> String:
	if not tower_quotes.has(tower_type):
		return "Ready for battle!"
	var quotes: Array = tower_quotes[tower_type]
	return quotes[randi() % quotes.size()]

func _load_voice_clips() -> void:
	var character_dirs = {
		TowerType.ROBIN_HOOD: "robin_hood",
		TowerType.ALICE: "alice",
		TowerType.WICKED_WITCH: "wicked_witch",
		TowerType.PETER_PAN: "peter_pan",
		TowerType.PHANTOM: "phantom",
		TowerType.SCROOGE: "scrooge",
		TowerType.SHERLOCK: "sherlock",
		TowerType.TARZAN: "tarzan",
		TowerType.DRACULA: "dracula",
		TowerType.MERLIN: "merlin",
		TowerType.FRANKENSTEIN: "frankenstein",
		TowerType.SHADOW_AUTHOR: "shadow_author",
	}
	for tower_type in character_dirs:
		var dir_name: String = character_dirs[tower_type]
		var place_clips: Array = []
		var fight_clips: Array = []
		for i in range(8):
			var place_path = "res://audio/voices/" + dir_name + "/place_" + str(i) + ".mp3"
			if ResourceLoader.exists(place_path):
				place_clips.append(load(place_path))
			var fight_path = "res://audio/voices/" + dir_name + "/fight_" + str(i) + ".mp3"
			if ResourceLoader.exists(fight_path):
				fight_clips.append(load(fight_path))
		if place_clips.size() > 0:
			placement_voice_clips[tower_type] = place_clips
		if fight_clips.size() > 0:
			fighting_voice_clips[tower_type] = fight_clips
	# Load Shadow Author narrator clips (triple-voice: Dominic->Matthew->Dominic)
	_load_shadow_author_clips()

func _load_shadow_author_clips() -> void:
	var base = "res://audio/voices/shadow_author/"
	# Story narration clip naming: dialogkey_lineindex.mp3
	var story_keys: Array = [
		"prologue_0", "prologue_1", "prologue_2", "prologue_3",
		"pre_level_0_0", "pre_level_0_1", "post_level_0_0", "post_level_0_1",
		"pre_level_1_0", "pre_level_1_1", "post_level_1_0",
		"pre_level_2_0",
		"pre_level_3_0", "pre_level_3_1", "post_level_3_0",
		"pre_level_4_0", "pre_level_4_1",
		"pre_level_5_0", "post_level_5_0",
		"pre_level_6_0", "post_level_6_0",
		"pre_level_7_0", "pre_level_7_1", "post_level_7_0",
		"pre_level_8_0",
		"pre_level_9_0", "post_level_9_0",
		"pre_level_10_0", "pre_level_10_1",
		"pre_level_11_0", "post_level_11_0",
		"pre_level_12_0", "post_level_12_0",
		"pre_level_13_0", "pre_level_13_1",
		"pre_level_14_0",
		"pre_level_15_0", "post_level_15_0",
		"act2_intro_0", "act2_intro_1", "act2_intro_2",
		"pre_level_16_0", "pre_level_16_1", "post_level_16_0",
		"pre_level_17_0",
		"pre_level_18_0", "post_level_18_0",
		"pre_level_19_0", "pre_level_19_1",
		"pre_level_20_0",
		"pre_level_21_0", "post_level_21_0",
		"pre_level_22_0",
		"pre_level_23_0",
		"pre_level_24_0", "post_level_24_0",
		"pre_level_25_0", "pre_level_25_1",
		"pre_level_26_0",
		"pre_level_27_0", "post_level_27_0",
		"pre_level_28_0",
		"pre_level_29_0",
		"pre_level_30_0", "post_level_30_0",
		"pre_level_31_0",
		"pre_level_32_0",
		"pre_level_33_0", "post_level_33_0",
		"act3_intro_0", "act3_intro_1", "act3_intro_2",
		"pre_level_34_0", "post_level_34_0",
		"pre_level_35_0",
		"pre_level_36_0", "pre_level_36_1", "pre_level_36_2",
		"post_level_36_0", "post_level_36_1", "post_level_36_2", "post_level_36_3",
		"unlock_sherlock_0", "unlock_sherlock_1",
		"unlock_tarzan_0", "unlock_tarzan_1",
		"unlock_dracula_0", "unlock_dracula_1",
		"unlock_merlin_0", "unlock_merlin_1",
		"unlock_frankenstein_0", "unlock_frankenstein_1",
		"all_unlocked_0", "all_unlocked_1", "all_unlocked_2",
	]
	for key in story_keys:
		var path = base + key + ".mp3"
		if ResourceLoader.exists(path):
			shadow_author_story_clips[key] = load(path)
	# Fighting taunts for levels 34-36
	for i in range(7):
		var path = base + "fight_" + str(i) + ".mp3"
		if ResourceLoader.exists(path):
			shadow_author_fight_clips.append(load(path))
	# Load character-specific story dialog clips (generated by generate_story_voices.ps1)
	_load_character_story_clips()

func _load_character_story_clips() -> void:
	var char_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom",
		"scrooge", "sherlock", "tarzan", "dracula", "merlin", "frankenstein", "shadow_author"]
	var dialog_keys: Array = []
	# Build list of all dialog keys from story_dialogs
	for key in story_dialogs:
		dialog_keys.append(key)
	# For each dialog, count character lines and look for matching MP3s
	for key in dialog_keys:
		if not story_dialogs.has(key):
			continue
		var lines = story_dialogs[key]
		var speaker_counts: Dictionary = {}
		for line_idx in range(lines.size()):
			var speaker = lines[line_idx].get("speaker", "narrator")
			if speaker == "narrator":
				continue
			var idx = speaker_counts.get(speaker, 0)
			speaker_counts[speaker] = idx + 1
			var clip_key = key + "_" + speaker + "_" + str(idx)
			# Look for character story clip: audio/voices/{character}/{clip_key}.mp3
			var char_dir = speaker
			var clip_path = "res://audio/voices/" + char_dir + "/" + clip_key + ".mp3"
			if ResourceLoader.exists(clip_path):
				character_story_clips[clip_key] = load(clip_path)

func _init_catchphrase_quotes() -> void:
	placement_quotes = {
		TowerType.ROBIN_HOOD: [
			"Rob the rich to feed the poor!",
			"I am Robin Hood!",
			"Come, come, my merry men all!",
			"Robin Hood, at your service.",
			"I live by the greenwood tree, and a right good life it is!",
			"Will you not stay and feast with us beneath the greenwood tree?",
			"Not a penny shall pass while Robin Hood draws breath!",
		],
		TowerType.ALICE: [
			"Curiouser and curiouser!",
			"Who in the world am I? Ah, that's the great puzzle.",
			"Down the rabbit hole we go!",
			"We're all mad here, you know.",
			"I can't explain myself, I'm afraid, because I'm not myself, you know.",
			"I almost wish I hadn't gone down that rabbit hole, and yet, it's rather curious!",
			"But I don't want to go among mad people!",
		],
		TowerType.WICKED_WITCH: [
			"I'll get you, my pretty, and your little dog too!",
			"Surrender, Dorothy!",
			"Fly, my pretties, fly!",
			"Now I shall have those silver shoes!",
			"I have but one eye, yet it is as powerful as a telescope!",
			"With the Golden Cap I shall rule all of Oz!",
			"You have no power against me, you little fool!",
		],
		TowerType.PETER_PAN: [
			"I'm youth, I'm joy, I'm a little bird that has broken out of the egg!",
			"I don't want ever to be a man!",
			"To die will be an awfully big adventure!",
			"I'll never grow up!",
			"All children, except one, grow up.",
			"I ran away the day I was born.",
			"Do you know why swallows build in the eaves of houses? It is to listen to the stories.",
		],
		TowerType.PHANTOM: [
			"I am your Angel of Music.",
			"The Music of the Night!",
			"The Opera Ghost is here.",
			"If I am the Phantom, it is because man's hatred has made me so.",
			"I built this palace beneath the Opera for you!",
			"Come to me, Angel of Music!",
			"My unhappy face inspires horror, but my music is beautiful.",
		],
		TowerType.SCROOGE: [
			"Bah! Humbug!",
			"Are there no prisons? No workhouses?",
			"I wish to be left alone.",
			"Every penny counts!",
			"Darkness is cheap, and Scrooge likes it.",
			"I don't make merry myself at Christmas.",
			"I am as light as a feather, I am as happy as an angel!",
		],
		TowerType.SHERLOCK: [
			"Elementary, my dear Watson.",
			"The game is afoot!",
			"Data! Data! I cannot make bricks without clay.",
			"When you eliminate the impossible, whatever remains must be the truth.",
			"I am the last and highest court of appeal in detection.",
			"You see, but you do not observe.",
			"There is nothing more deceptive than an obvious fact.",
		],
		TowerType.TARZAN: [
			"Tarzan of the Apes!",
			"The jungle provides!",
			"Tarzan protect friends!",
			"Kreegah! Bundolo!",
			"I am Tarzan, King of the Apes!",
			"Tarzan no kill. Tarzan friend.",
			"I am a man, and men do not devour their kill!",
		],
		TowerType.DRACULA: [
			"I am Dracula. I bid you welcome.",
			"The blood is the life!",
			"Listen to them, the children of the night. What music they make!",
			"I never drink... wine.",
			"Welcome to my house. Come freely, go safely.",
			"We are in Transylvania, and Transylvania is not England.",
			"The walls of my castle are broken. The shadows are many.",
		],
		TowerType.MERLIN: [
			"By the power of the old magic!",
			"Knowledge is the greatest weapon.",
			"The prophecy unfolds!",
			"Even the smallest spell can change the world.",
			"I have seen the future, and it needs our help.",
			"The old ways are not forgotten.",
			"Magic is neither good nor evil. It is the wielder who decides.",
		],
		TowerType.FRANKENSTEIN: [
			"I ought to be thy Adam, but I am rather the fallen angel.",
			"Beware, for I am fearless and therefore powerful.",
			"My heart was fashioned to be susceptible of love and sympathy.",
			"I am malicious because I am miserable.",
			"There is love in me the likes of which you can scarcely imagine.",
			"If I cannot inspire love, I will cause fear.",
			"Was I then a monster, a blot upon the earth?",
		],
	}
	fighting_quotes = {
		TowerType.ROBIN_HOOD: [
			"For Sherwood!",
			"My arrows fly true!",
			"Steal from the rich, defend the path!",
			"Another shot for the poor!",
			"A match! Let us see who is the better man!",
			"Here is a shaft for thee, thou villain!",
			"Now, by Our Lady, that was a fine shot!",
		],
		TowerType.ALICE: [
			"Off with their heads!",
			"How puzzling all these changes are!",
			"I could tell you my adventures, beginning from this morning.",
			"I do wish I hadn't cried so much!",
			"I knew who I was this morning, but I've changed a few times since then!",
			"Would you tell me, please, which way I ought to go from here?",
			"Dear, dear! How queer everything is today!",
		],
		TowerType.WICKED_WITCH: [
			"How about a little fire?",
			"I'll use the Golden Cap!",
			"You cursed brat!",
			"My beautiful wickedness!",
			"I shall make you my slave!",
			"The silver shoes will give me great power!",
			"A little girl destroyed my beautiful wickedness!",
		],
		TowerType.PETER_PAN: [
			"I do believe in fairies!",
			"Second star to the right!",
			"Wendy, one girl is more use than twenty boys!",
			"Oh, the cleverness of me!",
			"Dark and sinister man, have at thee!",
			"To live will be an awfully big adventure!",
			"I say, are you a codfish?",
		],
		TowerType.PHANTOM: [
			"Sing for me!",
			"I am dying of love!",
			"The chandelier! Beware the chandelier!",
			"Your most obedient servant, the Opera Ghost.",
			"Woe to those who cross the Opera Ghost!",
			"The disaster will be yours if you refuse!",
			"I am the trap-door lover! I am Erik!",
		],
		TowerType.SCROOGE: [
			"Humbug!",
			"I will honour Christmas in my heart!",
			"Every idiot who goes about with Merry Christmas on his lips!",
			"God bless us, every one!",
			"I am not the man I was!",
			"You may be an undigested bit of beef!",
			"Spirit, show me no more!",
		],
		TowerType.SHERLOCK: [
			"The game is afoot!",
			"Elementary!",
			"Come, Watson, the game is afoot!",
			"I see everything.",
			"The world is full of obvious things which nobody ever observes.",
			"My mind rebels at stagnation!",
			"I never guess. It is a shocking habit.",
		],
		TowerType.TARZAN: [
			"Kreegah!",
			"Tarzan is here!",
			"The jungle calls!",
			"Tarzan protect!",
			"Tarzan mighty fighter!",
			"The apes taught Tarzan well!",
			"Tarzan kill!",
		],
		TowerType.DRACULA: [
			"I am the night.",
			"Welcome to my domain.",
			"The blood is the life!",
			"I bid you... welcome.",
			"You shall be flesh of my flesh, blood of my blood!",
			"My revenge is just begun!",
			"I have lived for centuries, and time is on my side.",
		],
		TowerType.MERLIN: [
			"By the old magic!",
			"The stars align!",
			"Wisdom conquers all!",
			"Let the spell be cast!",
			"The elements obey my command!",
			"Behold the power of ages!",
			"This enchantment shall hold!",
		],
		TowerType.FRANKENSTEIN: [
			"I am... here.",
			"Friend... not monster.",
			"Lightning... gives me strength.",
			"I will protect... the kind ones.",
			"Cursed, cursed creator! Why did I live?",
			"I am fearless, and therefore powerful!",
			"Shall each man find a wife, and I be alone?",
		],
	}

func _play_placement_catchphrase(tower_type: TowerType) -> String:
	# Play MP3 voice clip if available
	if not voices_muted and placement_voice_clips.has(tower_type):
		var clips: Array = placement_voice_clips[tower_type]
		catchphrase_player.stream = clips[randi() % clips.size()]
		catchphrase_player.play()
	# Return text quote for display
	if placement_quotes.has(tower_type):
		var quotes: Array = placement_quotes[tower_type]
		return quotes[randi() % quotes.size()]
	return _get_tower_quote(tower_type)

func _play_random_fighting_quote() -> void:
	if voices_muted:
		return
	# Pick a random placed tower type that has fighting clips
	var placed_types: Array = []
	for tower_type in fighting_voice_clips:
		if purchased_towers.has(tower_type):
			placed_types.append(tower_type)
	if placed_types.size() == 0:
		return
	var chosen_type = placed_types[randi() % placed_types.size()]
	var clips: Array = fighting_voice_clips[chosen_type]
	catchphrase_player.stream = clips[randi() % clips.size()]
	catchphrase_player.play()
	# Also display quote text
	if fighting_quotes.has(chosen_type):
		var quotes: Array = fighting_quotes[chosen_type]
		var tname = tower_info[chosen_type]["name"]
		var quote = quotes[randi() % quotes.size()]
		info_label.text = "%s: \"%s\"" % [tname, quote]

var _shadow_fight_quotes: Array = [
	"Your stories end here... in MY pages!",
	"I have rewritten stronger heroes than you... into oblivion!",
	"Every word you speak... feeds my power!",
	"You cannot defeat your own author... I created this world!",
	"Run back to your chapters... before I erase you entirely!",
	"I am every nightmare... you were never brave enough to face!",
	"The ink is drying... and YOUR story ends in darkness!",
]

func _play_shadow_author_taunt() -> void:
	if voices_muted:
		return
	if shadow_author_fight_clips.size() == 0:
		return
	var idx = randi() % shadow_author_fight_clips.size()
	catchphrase_player.stream = shadow_author_fight_clips[idx]
	catchphrase_player.play()
	if idx < _shadow_fight_quotes.size():
		info_label.text = "The Shadow Author: \"%s\"" % _shadow_fight_quotes[idx]

func _draw_currency_bar() -> void:
	var font = game_font
	var bar_y = 0.0
	var bar_h = 32.0
	# Deep navy bar with subtle purple gradient
	draw_rect(Rect2(0, bar_y, 1280, bar_h), Color(0.02, 0.02, 0.08, 0.95))
	for bx in range(0, 1280, 2):
		var grad_t = float(bx) / 1280.0
		var purple_a = sin(grad_t * PI) * 0.06
		draw_line(Vector2(bx, bar_y), Vector2(bx, bar_y + bar_h), Color(menu_accent_purple.r, menu_accent_purple.g, menu_accent_purple.b, purple_a), 2.0)
	# Gold bottom accent line
	draw_rect(Rect2(0, bar_y + bar_h - 1, 1280, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.4))
	# Subtle inner glow at bottom
	draw_rect(Rect2(0, bar_y + bar_h - 3, 1280, 2), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.08))

	# Title on left — gold with glow + shadow (mobile-friendly size)
	var title_pulse = 0.85 + sin(_time * 1.2) * 0.15
	# Outer glow
	_udraw(font, Vector2(12, bar_y + 22), "Shadow Defense", HORIZONTAL_ALIGNMENT_LEFT, 300, 18, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.15 * title_pulse))
	# Drop shadow
	_udraw(font, Vector2(13, bar_y + 23), "Shadow Defense", HORIZONTAL_ALIGNMENT_LEFT, 300, 17, Color(0, 0, 0, 0.6))
	# Main text
	_udraw(font, Vector2(12, bar_y + 22), "Shadow Defense", HORIZONTAL_ALIGNMENT_LEFT, 300, 17, Color(menu_gold.r * title_pulse, menu_gold.g * title_pulse, menu_gold.b * 0.6, 1.0))

	# Currencies from left to right
	var currencies = [
		{"icon": "G", "color": Color(0.9, 0.8, 0.2), "value": player_gold, "name": "Gold"},
		{"icon": "Q", "color": Color(0.4, 0.7, 0.9), "value": player_quills, "name": "Quills"},
		{"icon": "S", "color": Color(0.7, 0.4, 0.8), "value": player_relic_shards, "name": "Shards"},
		{"icon": "*", "color": Color(1.0, 0.9, 0.3), "value": player_storybook_stars, "name": "Stars"},
		{"icon": "K", "color": Color(0.3, 0.6, 0.4), "value": knowledge_ink, "name": "Ink"},
		{"icon": "T", "color": Color(0.8, 0.6, 0.2), "value": trophy_currency, "name": "Trophies"},
	]
	var cx = 370.0
	for c in currencies:
		var cc = c["color"]
		var ic_y = bar_y + bar_h * 0.5
		# Outer glow pulse
		var ic_pulse = 0.8 + sin(_time * 1.5 + cx * 0.01) * 0.2
		draw_circle(Vector2(cx, ic_y), 14, Color(cc.r, cc.g, cc.b, 0.08 * ic_pulse))
		# Icon circle with bright fill
		draw_circle(Vector2(cx, ic_y), 11, Color(cc.r, cc.g, cc.b, 0.18))
		draw_circle(Vector2(cx, ic_y), 9, Color(cc.r, cc.g, cc.b, 0.3))
		draw_arc(Vector2(cx, ic_y), 10, 0, TAU, 24, Color(cc.r, cc.g, cc.b, 0.55), 1.5)
		_udraw(font, Vector2(cx, bar_y + 22), c["icon"], HORIZONTAL_ALIGNMENT_CENTER, 20, 12, cc)
		# Value — shadow + bright text (with thousands separator)
		var val_str = _format_gold(c["value"])
		_udraw(font, Vector2(cx + 16, bar_y + 22), val_str, HORIZONTAL_ALIGNMENT_LEFT, 85, 13, Color(0, 0, 0, 0.5))
		_udraw(font, Vector2(cx + 15, bar_y + 21), val_str, HORIZONTAL_ALIGNMENT_LEFT, 85, 13, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.95))
		cx += 130.0

	# Total stars on far right
	var total_stars = 0
	for ls_key in level_stars:
		total_stars += level_stars[ls_key]
	var max_stars = levels.size() * 3
	_udraw(font, Vector2(1222, bar_y + 22), "%d/%d" % [total_stars, max_stars], HORIZONTAL_ALIGNMENT_RIGHT, 100, 14, Color(1.0, 0.9, 0.3, 0.9))

func _draw_menu_background() -> void:
	# === MENU THEME COSMETIC OVERRIDE ===
	var theme_bg = menu_bg_dark
	var theme_accent = menu_gold_dim
	var equipped_theme = equipped_cosmetics.get("themes", "")
	if equipped_theme != "":
		for theme_item in trophy_store_items.get("themes", []):
			if theme_item["id"] == equipped_theme:
				theme_bg = theme_item["bg"]
				theme_accent = theme_item["accent"]
				break

	if menu_current_view != "survivors" or survivor_detail_open:
		# === Deep navy background with vertical gradient ===
		draw_rect(Rect2(0, 0, 1280, 720), theme_bg)
		# Vertical gradient — darker at top, slight purple warmth at bottom
		for gy in range(0, 720, 2):
			var gt = float(gy) / 720.0
			var purple_shift = gt * gt * 0.04  # Quadratic: more purple toward bottom
			var col = Color(theme_bg.r + purple_shift * 0.8, theme_bg.g + purple_shift * 0.2, theme_bg.b + purple_shift * 1.5, 0.6)
			draw_line(Vector2(0, gy), Vector2(1280, gy), col, 2.0)

		# === Center radial glow (purple atmosphere — vivid for mobile) ===
		var center_pulse = 0.9 + sin(_time * 0.6) * 0.1
		draw_circle(Vector2(640, 360), 550.0, Color(menu_accent_purple.r, menu_accent_purple.g, menu_accent_purple.b, 0.06 * center_pulse))
		draw_circle(Vector2(640, 360), 400.0, Color(menu_accent_purple.r, menu_accent_purple.g, menu_accent_purple.b, 0.10 * center_pulse))
		draw_circle(Vector2(640, 360), 250.0, Color(0.35, 0.12, 0.55, 0.12 * center_pulse))
		draw_circle(Vector2(640, 360), 120.0, Color(0.45, 0.18, 0.65, 0.08 * center_pulse))

		# === Corner vignette (dark edges for depth) ===
		for corner_i in range(4):
			var corner_x = 0.0 if corner_i % 2 == 0 else 1280.0
			var corner_y = 0.0 if corner_i < 2 else 720.0
			draw_circle(Vector2(corner_x, corner_y), 400.0, Color(0.0, 0.0, 0.02, 0.06))

		# === Gothic corner ornaments (all 4 corners — bright for mobile) ===
		var orn_a = 0.22 + sin(_time * 0.8) * 0.06
		var orn_col = Color(menu_gold.r, menu_gold.g, menu_gold.b, orn_a)
		# Top-left ornament
		for oi in range(5):
			var olen = 30.0 + float(oi) * 12.0
			draw_line(Vector2(4, 36 + float(oi) * 8), Vector2(4 + olen, 36 + float(oi) * 8), orn_col, 1.0)
			draw_line(Vector2(36 + float(oi) * 8, 4), Vector2(36 + float(oi) * 8, 4 + olen), orn_col, 1.0)
		draw_arc(Vector2(4, 36), 32, -PI * 0.5, 0.0, 16, orn_col, 1.0)
		# Top-right ornament
		for oi in range(5):
			var olen = 30.0 + float(oi) * 12.0
			draw_line(Vector2(1276, 36 + float(oi) * 8), Vector2(1276 - olen, 36 + float(oi) * 8), orn_col, 1.0)
			draw_line(Vector2(1244 - float(oi) * 8, 4), Vector2(1244 - float(oi) * 8, 4 + olen), orn_col, 1.0)
		draw_arc(Vector2(1276, 36), 32, PI, PI * 1.5, 16, orn_col, 1.0)
		# Bottom-left ornament
		for oi in range(5):
			var olen = 25.0 + float(oi) * 10.0
			draw_line(Vector2(4, 608 - float(oi) * 7), Vector2(4 + olen, 608 - float(oi) * 7), orn_col, 1.0)
		draw_arc(Vector2(4, 608), 28, 0.0, PI * 0.5, 12, orn_col, 1.0)
		# Bottom-right ornament
		for oi in range(5):
			var olen = 25.0 + float(oi) * 10.0
			draw_line(Vector2(1276, 608 - float(oi) * 7), Vector2(1276 - olen, 608 - float(oi) * 7), orn_col, 1.0)
		draw_arc(Vector2(1276, 608), 28, PI * 0.5, PI, 12, orn_col, 1.0)

		# === Bookshelf silhouette along bottom (more visible for mobile) ===
		var shelf_y = 610.0
		var shelf_col = Color(0.04, 0.03, 0.10, 0.65)
		for bsi in range(_bookshelf_heights.size()):
			var bx = float(bsi) * 50.0
			var bh = _bookshelf_heights[bsi]
			# Book spine with slight color variation
			var spine_hue = 0.02 + float(bsi % 5) * 0.005
			draw_rect(Rect2(bx, shelf_y - bh, 44, bh), Color(spine_hue, 0.03, 0.10 + float(bsi % 3) * 0.02, 0.65))
			# Top edge highlight — brighter
			draw_line(Vector2(bx, shelf_y - bh), Vector2(bx + 44, shelf_y - bh), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.15), 1.5)
			# Spine line — more visible
			draw_line(Vector2(bx + 22, shelf_y - bh + 4), Vector2(bx + 22, shelf_y - 4), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08), 1.0)
		# Shelf plank — thicker, more visible
		draw_rect(Rect2(0, shelf_y, 1280, 4), Color(0.08, 0.06, 0.14, 0.7))
		draw_rect(Rect2(0, shelf_y, 1280, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))

		# === Ink splatters (subtle background texture) ===
		for splat in _menu_ink_splatters:
			var sp_rng = RandomNumberGenerator.new()
			sp_rng.seed = splat["seed"]
			var sp_col = Color(0.02, 0.01, 0.06, 0.12)
			draw_circle(Vector2(splat["x"], splat["y"]), splat["size"], sp_col)
			for _di in range(splat["dots"]):
				var dot_x = splat["x"] + sp_rng.randf_range(-splat["size"] * 2, splat["size"] * 2)
				var dot_y = splat["y"] + sp_rng.randf_range(-splat["size"] * 1.5, splat["size"] * 1.5)
				draw_circle(Vector2(dot_x, dot_y), sp_rng.randf_range(1, 4), Color(0.02, 0.01, 0.06, 0.08))

		# === Floating book pages (drifting gently) ===
		for page in _floating_pages:
			var px = page["x"] + sin(_time * page["speed"] + page["offset"]) * 40.0
			var py = page["y"] + cos(_time * page["speed"] * 0.5 + page["offset"] * 1.3) * 25.0
			var prot = page["rot"] + sin(_time * 0.3 + page["offset"]) * 0.15
			var psz = page["size"]
			var pa = 0.12 + sin(_time * 0.8 + page["offset"]) * 0.04
			# Page body (rotated rectangle via polygon)
			var hw = psz * 0.35
			var hh = psz * 0.5
			var cr = cos(prot)
			var sr = sin(prot)
			var corners = PackedVector2Array([
				Vector2(px + (-hw) * cr - (-hh) * sr, py + (-hw) * sr + (-hh) * cr),
				Vector2(px + hw * cr - (-hh) * sr, py + hw * sr + (-hh) * cr),
				Vector2(px + hw * cr - hh * sr, py + hw * sr + hh * cr),
				Vector2(px + (-hw) * cr - hh * sr, py + (-hw) * sr + hh * cr),
			])
			draw_colored_polygon(corners, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, pa))
			# Text lines on page
			for tl in range(3):
				var lx_start = px + (-hw * 0.6) * cr - (-hh * 0.3 + float(tl) * hh * 0.25) * sr
				var ly_start = py + (-hw * 0.6) * sr + (-hh * 0.3 + float(tl) * hh * 0.25) * cr
				var lx_end = px + (hw * 0.5) * cr - (-hh * 0.3 + float(tl) * hh * 0.25) * sr
				var ly_end = py + (hw * 0.5) * sr + (-hh * 0.3 + float(tl) * hh * 0.25) * cr
				draw_line(Vector2(lx_start, ly_start), Vector2(lx_end, ly_end), Color(0.3, 0.25, 0.15, pa * 0.6), 0.5)

		# === Quill pens (decorative, static with gentle sway) ===
		for quill in _quill_positions:
			var qx = quill["x"]
			var qy = quill["y"] + sin(_time * 0.5 + qx * 0.01) * 3.0
			var qrot = quill["rot"] + sin(_time * 0.4) * 0.05
			var qsz = quill["size"]
			var qa = 0.06
			var qcr = cos(qrot)
			var qsr = sin(qrot)
			# Shaft
			draw_line(Vector2(qx, qy), Vector2(qx + qsz * qcr, qy + qsz * qsr), Color(0.5, 0.35, 0.15, qa), 1.5)
			# Feather barbs
			for fb in range(4):
				var ft = 0.2 + float(fb) * 0.2
				var fx = qx + qsz * ft * qcr
				var fy = qy + qsz * ft * qsr
				draw_line(Vector2(fx, fy), Vector2(fx - 6 * qsr, fy + 6 * qcr), Color(0.5, 0.35, 0.15, qa * 0.7), 1.0)
				draw_line(Vector2(fx, fy), Vector2(fx + 6 * qsr, fy - 6 * qcr), Color(0.5, 0.35, 0.15, qa * 0.7), 1.0)
			# Nib
			draw_circle(Vector2(qx - 2 * qcr, qy - 2 * qsr), 1.5, Color(0.3, 0.25, 0.4, qa))

		# === Ethereal lantern glow (purple/blue wisps — bright for mobile) ===
		for candle in _book_candle_positions:
			var cx_pos = candle["x"]
			var cy_pos = candle["y"]
			var flicker = sin(_time * 4.0 + candle["offset"]) * 0.3 + sin(_time * 7.0 + candle["offset"] * 2.0) * 0.15
			var glow_r = 100.0 + flicker * 25.0
			# Outer purple glow — MUCH brighter for visibility
			draw_circle(Vector2(cx_pos, cy_pos), glow_r, Color(0.4, 0.18, 0.6, 0.06 + flicker * 0.02))
			draw_circle(Vector2(cx_pos, cy_pos), glow_r * 0.6, Color(0.5, 0.25, 0.7, 0.08 + flicker * 0.03))
			draw_circle(Vector2(cx_pos, cy_pos), glow_r * 0.3, Color(0.6, 0.35, 0.85, 0.06 + flicker * 0.02))
			# Lantern body — dark iron bracket
			draw_rect(Rect2(cx_pos - 4, cy_pos + 12, 8, 20), Color(0.15, 0.12, 0.25, 0.7))
			draw_rect(Rect2(cx_pos - 6, cy_pos + 10, 12, 3), Color(0.2, 0.15, 0.3, 0.6))
			# Flame — purple-blue wisp (larger, brighter)
			var flame_h = 10.0 + flicker * 6.0
			draw_circle(Vector2(cx_pos, cy_pos + 6 - flame_h * 0.3), 6.0, Color(0.5, 0.3, 0.9, 0.6 + flicker * 0.2))
			draw_circle(Vector2(cx_pos, cy_pos + 3 - flame_h * 0.5), 4.0, Color(0.7, 0.5, 1.0, 0.7 + flicker * 0.15))
			draw_circle(Vector2(cx_pos, cy_pos + 1 - flame_h * 0.6), 2.5, Color(0.9, 0.8, 1.0, 0.8))

		# === Floating particles (gold + purple mix — vivid for mobile) ===
		for dust_i in range(_dust_positions.size()):
			var dust = _dust_positions[dust_i]
			var dx = dust["x"] + sin(_time * dust["speed"] + dust["offset"]) * 35.0
			var dy = dust["y"] + cos(_time * dust["speed"] * 0.6 + dust["offset"]) * 25.0
			var alpha = 0.25 + 0.15 * sin(_time * 1.5 + dust["offset"])
			var dsz = dust["size"] * 1.3
			# Alternate between gold and purple particles with glow halo
			if dust_i % 3 == 0:
				draw_circle(Vector2(dx, dy), dsz + 3, Color(0.5, 0.25, 0.8, alpha * 0.15))
				draw_circle(Vector2(dx, dy), dsz, Color(0.6, 0.35, 0.9, alpha * 0.8))
			else:
				draw_circle(Vector2(dx, dy), dsz + 3, Color(menu_gold.r, menu_gold.g, menu_gold.b, alpha * 0.15))
				draw_circle(Vector2(dx, dy), dsz, Color(menu_gold.r, menu_gold.g, menu_gold.b, alpha))

	# === TOP CURRENCY BAR ===
	_draw_currency_bar()

	# === Bottom nav bar ===
	var font = game_font
	var nav_draw_y = 620.0
	# === BOTTOM NAV BAR — Polished, glowing, alive ===
	var nav_tab_names = ["survivors", "relics", "chapters", "chronicles", "emporium", "achievements"]
	var nav_tab_labels = ["HEROES", "RELICS", "ADVENTURE", "LORE", "SHOP", "TROPHIES"]
	var nav_tab_cols = [
		Color(0.85, 0.55, 0.25),  # Heroes: warm amber
		Color(0.65, 0.40, 0.85),  # Relics: mystical purple
		Color(0.35, 0.75, 0.35),  # Adventure: forest green
		Color(0.55, 0.70, 0.90),  # Lore: ink blue
		Color(0.90, 0.75, 0.25),  # Shop: gold
		Color(0.80, 0.65, 0.20),  # Trophies: bronze gold
	]
	# Dark gradient background with subtle texture
	for ngi in range(20):
		var t = float(ngi) / 19.0
		var bg_col = Color(0.03, 0.02, 0.08, 0.95).lerp(Color(0.01, 0.01, 0.04, 0.98), t)
		draw_rect(Rect2(0, nav_draw_y + float(ngi) * 5.0, 1280, 5.0), bg_col)
	# Top edge glow line (animated)
	var edge_glow = 0.4 + sin(_time * 1.8) * 0.1
	for egi in range(3):
		draw_rect(Rect2(0, nav_draw_y + float(egi), 1280, 1), Color(0.54, 0.38, 0.15, edge_glow * (1.0 - float(egi) * 0.3)))
	# Floating ink particles above nav bar
	for pi in range(8):
		var px_p = fmod(float(pi) * 173.7 + _time * (8.0 + float(pi) * 3.0), 1280.0)
		var py_p = nav_draw_y - 4.0 + sin(_time * 1.5 + float(pi) * 0.8) * 3.0
		var pa = 0.08 + sin(_time * 2.0 + float(pi)) * 0.04
		draw_circle(Vector2(px_p, py_p), 1.5, Color(0.6, 0.45, 0.15, pa))

	var tab_w = 1280.0 / 6.0  # ~213px per tab
	for ni in range(6):
		var tx = float(ni) * tab_w
		var is_act = (menu_current_view == nav_tab_names[ni])
		var tc = nav_tab_cols[ni]
		var hover_pulse = sin(_time * 3.0 + float(ni) * 1.0) * 0.08
		# Active tab: glowing background
		if is_act:
			# Radial glow behind icon
			var glow_cx = tx + tab_w * 0.5
			var glow_cy = nav_draw_y + 38.0
			for gi in range(6):
				var gr = 35.0 - float(gi) * 4.0
				var ga = 0.06 + sin(_time * 2.0) * 0.02 - float(gi) * 0.008
				draw_circle(Vector2(glow_cx, glow_cy), gr, Color(tc.r, tc.g, tc.b, ga))
			# Bottom glow bar (pulsing)
			var bar_glow = 0.7 + sin(_time * 2.5) * 0.2
			draw_rect(Rect2(tx + 20, nav_draw_y + 92, tab_w - 40, 4), Color(tc.r, tc.g, tc.b, bar_glow * 0.8))
			draw_rect(Rect2(tx + 30, nav_draw_y + 96, tab_w - 60, 2), Color(tc.r, tc.g, tc.b, bar_glow * 0.3))
			# Top accent
			draw_rect(Rect2(tx + 15, nav_draw_y, tab_w - 30, 2), Color(tc.r, tc.g, tc.b, bar_glow * 0.5))

		# Icon circle (large, prominent — mobile-friendly)
		var ic = Vector2(tx + tab_w * 0.5, nav_draw_y + 36.0)
		var ic_r = 28.0 if is_act else 24.0
		var ic_col = tc if is_act else Color(tc.r * 0.55, tc.g * 0.55, tc.b * 0.55)
		var ic_bg_a = 0.35 + hover_pulse if is_act else 0.12
		# Circle background
		draw_circle(ic, ic_r, Color(tc.r * 0.15, tc.g * 0.15, tc.b * 0.15, ic_bg_a))
		# Circle border (double ring for active)
		draw_arc(ic, ic_r, 0, TAU, 32, Color(ic_col.r, ic_col.g, ic_col.b, 0.7 if is_act else 0.3), 2.0 if is_act else 1.5)
		if is_act:
			draw_arc(ic, ic_r + 3, 0, TAU, 32, Color(ic_col.r, ic_col.g, ic_col.b, 0.2), 1.0)
			# Animated sparkle dots orbiting active icon
			for si in range(3):
				var sa = _time * 2.0 + float(si) * TAU / 3.0
				var sp = ic + Vector2(cos(sa), sin(sa)) * (ic_r + 6)
				draw_circle(sp, 1.5, Color(tc.r, tc.g, tc.b, 0.4 + sin(_time * 4.0 + float(si)) * 0.2))
		# Icon drawings (bigger, bolder)
		var s = 1.3 if is_act else 1.0
		if ni == 0:  # HEROES — crossed swords
			draw_line(ic + Vector2(-8, 8) * s, ic + Vector2(8, -8) * s, ic_col, 2.5 * s)
			draw_line(ic + Vector2(8, 8) * s, ic + Vector2(-8, -8) * s, ic_col, 2.5 * s)
			draw_circle(ic, 3.0 * s, ic_col)
		elif ni == 1:  # RELICS — glowing gem
			draw_colored_polygon(PackedVector2Array([ic + Vector2(0, -11) * s, ic + Vector2(9, -2) * s, ic + Vector2(6, 9) * s, ic + Vector2(-6, 9) * s, ic + Vector2(-9, -2) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.7))
			draw_colored_polygon(PackedVector2Array([ic + Vector2(0, -8) * s, ic + Vector2(4, -1) * s, ic + Vector2(0, 5) * s, ic + Vector2(-4, -1) * s]), Color(1, 1, 1, 0.15))
		elif ni == 2:  # ADVENTURE — open book with glow
			draw_colored_polygon(PackedVector2Array([ic + Vector2(0, -9) * s, ic + Vector2(-12, -7) * s, ic + Vector2(-12, 9) * s, ic + Vector2(0, 7) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.6))
			draw_colored_polygon(PackedVector2Array([ic + Vector2(0, -9) * s, ic + Vector2(12, -7) * s, ic + Vector2(12, 9) * s, ic + Vector2(0, 7) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.4))
			draw_line(ic + Vector2(0, -9) * s, ic + Vector2(0, 7) * s, ic_col, 2.0)
			for li in range(3):
				var ly = (-4.0 + float(li) * 4.0) * s
				draw_line(ic + Vector2(-9, ly) * s, ic + Vector2(-3, ly) * s, Color(0, 0, 0, 0.25), 1.0)
				draw_line(ic + Vector2(3, ly) * s, ic + Vector2(9, ly) * s, Color(0, 0, 0, 0.25), 1.0)
		elif ni == 3:  # LORE — scroll with seal
			draw_rect(Rect2(ic.x - 7 * s, ic.y - 9 * s, 14 * s, 18 * s), Color(ic_col.r, ic_col.g, ic_col.b, 0.5))
			draw_arc(ic + Vector2(0, -9) * s, 7 * s, PI, TAU, 12, ic_col, 2.0)
			draw_arc(ic + Vector2(0, 9) * s, 7 * s, 0, PI, 12, ic_col, 2.0)
			draw_circle(ic + Vector2(0, 3) * s, 3 * s, Color(0.8, 0.2, 0.2, 0.6))
		elif ni == 4:  # SHOP — potion bottle
			draw_colored_polygon(PackedVector2Array([ic + Vector2(-8, 0) * s, ic + Vector2(8, 0) * s, ic + Vector2(6, 10) * s, ic + Vector2(-6, 10) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.6))
			draw_rect(Rect2(ic.x - 3 * s, ic.y - 10 * s, 6 * s, 10 * s), Color(ic_col.r, ic_col.g, ic_col.b, 0.5))
			draw_line(ic + Vector2(-5, -10) * s, ic + Vector2(5, -10) * s, ic_col, 2.0)
			draw_circle(ic + Vector2(0, 5) * s, 3 * s, Color(1, 1, 1, 0.12))
		elif ni == 5:  # TROPHIES — trophy cup
			draw_colored_polygon(PackedVector2Array([ic + Vector2(-7, -9) * s, ic + Vector2(7, -9) * s, ic + Vector2(5, 0) * s, ic + Vector2(-5, 0) * s]), Color(ic_col.r, ic_col.g, ic_col.b, 0.7))
			draw_line(ic + Vector2(0, 0) * s, ic + Vector2(0, 6) * s, ic_col, 2.5)
			draw_line(ic + Vector2(-6, 6) * s, ic + Vector2(6, 6) * s, ic_col, 2.5)
			draw_arc(ic + Vector2(-7, -4) * s, 4 * s, PI * 0.5, PI * 1.5, 8, ic_col, 2.0)
			draw_arc(ic + Vector2(7, -4) * s, 4 * s, -PI * 0.5, PI * 0.5, 8, ic_col, 2.0)
			# Star on trophy
			if is_act:
				draw_circle(ic + Vector2(0, -5) * s, 2.5, Color(1, 1, 1, 0.3))
		# Tab label
		var lbl_y = nav_draw_y + 72.0
		var lbl_col = Color(tc.r, tc.g, tc.b, 0.95) if is_act else Color(0.50, 0.45, 0.38, 0.6)
		var lbl_sz = 14 if is_act else 12
		_udraw(font, Vector2(tx + tab_w * 0.5, lbl_y), nav_tab_labels[ni], HORIZONTAL_ALIGNMENT_CENTER, int(tab_w - 10), lbl_sz, lbl_col)
		# Divider line between tabs
		if ni < 5:
			var dx_div = tx + tab_w
			draw_line(Vector2(dx_div, nav_draw_y + 12), Vector2(dx_div, nav_draw_y + 88), Color(0.3, 0.25, 0.15, 0.08), 1.0)

	if menu_current_view == "chapters":
		_draw_story_map()
		_draw_chapters_badges()
		_draw_chapters_overlay()
	elif menu_current_view == "survivors":
		if survivor_detail_open:
			_draw_survivor_detail()
		else:
			_draw_survivor_grid()
	elif menu_current_view == "relics":
		_draw_relics_tab()
	elif menu_current_view == "emporium":
		if emporium_sub_category == 6:
			_draw_trophy_store()
		elif emporium_sub_category == 8:
			_draw_binding_shop()
		elif emporium_sub_category == 9:
			_draw_salvage_panel()
		elif emporium_sub_category == 10:
			_draw_chest_crafting()
		elif emporium_sub_category == 11:
			_draw_instrument_shop()
		else:
			_draw_emporium()
	elif menu_current_view == "achievements":
		_draw_achievements_tab()
	else:
		_draw_closed_book()

func _draw_relics_tab() -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var font = game_font
	var content_top = panel_y + 44.0
	var content_bottom = panel_y + panel_h - 28.0

	# Navy background gradient
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), col)

	# Gold border
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))

	# Title
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "RELIC COMPENDIUM", HORIZONTAL_ALIGNMENT_CENTER, -1, 16, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.9))
	draw_rect(Rect2(panel_x + panel_w * 0.5 - 100, panel_y + 34, 200, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.4))

	var rarity_order = ["common", "uncommon", "rare"]
	var rarity_names = {"common": "COMMON (Blue)", "uncommon": "UNCOMMON (Purple)", "rare": "RARE (Gold)"}
	var rarity_colors = {"common": Color(0.3, 0.5, 0.85), "uncommon": Color(0.6, 0.3, 0.8), "rare": Color(0.85, 0.7, 0.2)}
	var rarity_bg = {"common": Color(0.06, 0.08, 0.20), "uncommon": Color(0.10, 0.06, 0.22), "rare": Color(0.14, 0.10, 0.06)}

	var card_w = 260.0
	var card_h = 50.0
	var card_gap_x = 10.0
	var card_gap_y = 6.0
	var grid_left = panel_x + 18.0
	var section_y = content_top - relic_scroll_offset
	var total_content_h = 0.0

	for ri in range(rarity_order.size()):
		var rarity = rarity_order[ri]
		var rc = rarity_colors[rarity]
		var sec_y = section_y

		# Collect trinkets of this rarity
		var trinkets: Array = []
		for b in TOME_BINDINGS:
			if b["rarity"] == rarity:
				trinkets.append(b)

		# Tier header (only draw if visible)
		if sec_y + 20 > content_top and sec_y < content_bottom:
			draw_rect(Rect2(grid_left, sec_y, panel_w - 36, 20), Color(rc.r, rc.g, rc.b, 0.12))
			draw_rect(Rect2(grid_left, sec_y, panel_w - 36, 1), Color(rc.r, rc.g, rc.b, 0.4))
			_udraw(font, Vector2(grid_left + 10, sec_y + 14), rarity_names[rarity], HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(rc.r, rc.g, rc.b, 0.9))
			var gem_x = grid_left + panel_w - 56
			var gem_y = sec_y + 10
			draw_colored_polygon(PackedVector2Array([Vector2(gem_x, gem_y - 5), Vector2(gem_x + 5, gem_y), Vector2(gem_x, gem_y + 5), Vector2(gem_x - 5, gem_y)]), Color(rc.r, rc.g, rc.b, 0.7))
			# Count indicator
			var owned_count = 0
			for bb in trinkets:
				if owned_bindings.get(bb["id"], 0) > 0:
					owned_count += 1
			_udraw(font, Vector2(gem_x - 20, sec_y + 14), "%d/%d" % [owned_count, trinkets.size()], HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(rc.r, rc.g, rc.b, 0.6))

		var row_y = sec_y + 24.0
		for ti in range(trinkets.size()):
			var b = trinkets[ti]
			var col_i = ti % 4
			var row_i = ti / 4
			var cx = grid_left + float(col_i) * (card_w + card_gap_x)
			var cy = row_y + float(row_i) * (card_h + card_gap_y)
			# Clip: skip items fully outside visible area
			if cy + card_h < content_top or cy > content_bottom:
				continue
			var count = owned_bindings.get(b["id"], 0)
			var is_owned = count > 0

			var bg_col = rarity_bg[rarity] if is_owned else Color(0.05, 0.05, 0.10)
			draw_rect(Rect2(cx, cy, card_w, card_h), bg_col)
			var b_alpha = 0.5 if is_owned else 0.15
			draw_rect(Rect2(cx, cy, card_w, 1), Color(rc.r, rc.g, rc.b, b_alpha))
			draw_rect(Rect2(cx, cy + card_h - 1, card_w, 1), Color(rc.r, rc.g, rc.b, b_alpha))
			draw_rect(Rect2(cx, cy, 1, card_h), Color(rc.r, rc.g, rc.b, b_alpha))
			draw_rect(Rect2(cx + card_w - 1, cy, 1, card_h), Color(rc.r, rc.g, rc.b, b_alpha))

			# Rarity stripe
			draw_rect(Rect2(cx, cy, 3, card_h), Color(rc.r, rc.g, rc.b, 0.7 if is_owned else 0.2))

			# Icon area
			var icon_cx = cx + 24.0
			var icon_cy = cy + card_h * 0.5
			draw_circle(Vector2(icon_cx, icon_cy), 14, Color(rc.r, rc.g, rc.b, 0.2 if is_owned else 0.08))
			if not is_owned:
				draw_rect(Rect2(icon_cx - 6, icon_cy - 2, 12, 10), Color(0.3, 0.3, 0.35, 0.4))
				draw_arc(Vector2(icon_cx, icon_cy - 2), 5, PI, TAU, 8, Color(0.3, 0.3, 0.35, 0.4), 1.5)

			# Text
			var name_alpha = 0.9 if is_owned else 0.35
			_udraw(font, Vector2(cx + 44, cy + 18), b["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 90), 12, Color(rc.r, rc.g, rc.b, name_alpha))
			var desc_alpha = 0.65 if is_owned else 0.25
			_udraw(font, Vector2(cx + 44, cy + 34), b["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 50), 11, Color(menu_text.r, menu_text.g, menu_text.b, desc_alpha))

			# Count badge
			if is_owned:
				_udraw(font, Vector2(cx + card_w - 30, cy + 18), "x%d" % count, HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(0.3, 0.8, 0.3))

		var rows_needed = (trinkets.size() + 3) / 4
		var section_height = 24.0 + float(rows_needed) * (card_h + card_gap_y) + 12.0
		section_y += section_height
		total_content_h += section_height

	# Clamp scroll to valid range
	var max_scroll = maxf(0.0, total_content_h - (content_bottom - content_top))
	relic_scroll_offset = clampf(relic_scroll_offset, 0.0, max_scroll)

	# Scroll indicator bar (right edge)
	if max_scroll > 0:
		var bar_x = panel_x + panel_w - 10
		var bar_h = content_bottom - content_top
		var thumb_h = maxf(30.0, bar_h * bar_h / (bar_h + max_scroll))
		var thumb_y = content_top + (relic_scroll_offset / max_scroll) * (bar_h - thumb_h)
		draw_rect(Rect2(bar_x, content_top, 4, bar_h), Color(0.2, 0.2, 0.25, 0.3))
		draw_rect(Rect2(bar_x, thumb_y, 4, thumb_h), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.5))

	# Footer (drawn over content, always visible)
	draw_rect(Rect2(panel_x + 2, panel_y + panel_h - 28, panel_w - 4, 26), Color(0.03, 0.03, 0.06, 0.95))
	var footer_y = panel_y + panel_h - 10
	var total_owned = 0
	for key in owned_bindings:
		total_owned += owned_bindings[key]
	var unique_owned = 0
	for key in owned_bindings:
		if owned_bindings[key] > 0:
			unique_owned += 1
	_udraw(font, Vector2(grid_left + 10, footer_y), "Owned: %d unique (%d total)" % [unique_owned, total_owned], HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6))
	_udraw(font, Vector2(grid_left + 300, footer_y), "Shards: %d" % player_relic_shards, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6))
	_udraw(font, Vector2(grid_left + 450, footer_y), "Quills: %d" % player_quills, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6))

func _draw_emporium() -> void:
	if emporium_sub_open:
		_draw_emporium_sub_panel()
		return
	# === Navy background (same dimensions as survivor grid) ===
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0

	# Navy gradient background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		var grain = sin(float(i) * 2.3) * 0.005
		col.r += grain
		col.b += grain * 1.5
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 55.0 + 1), col)

	# Ornate border — gold double frame
	var emp_outer = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.35)
	var emp_gold = Color(0.54, 0.45, 0.20, 0.2)
	# Outer gold border (3px)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 3), emp_outer)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 3, panel_w, 3), emp_outer)
	draw_rect(Rect2(panel_x, panel_y, 3, panel_h), emp_outer)
	draw_rect(Rect2(panel_x + panel_w - 3, panel_y, 3, panel_h), emp_outer)
	# Inner gold border (1px)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, panel_w - 12, 1), emp_gold)
	draw_rect(Rect2(panel_x + 6, panel_y + panel_h - 7, panel_w - 12, 1), emp_gold)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, 1, panel_h - 12), emp_gold)
	draw_rect(Rect2(panel_x + panel_w - 7, panel_y + 6, 1, panel_h - 12), emp_gold)

	# Corner filigree ornaments (gold only)
	for corner in [Vector2(panel_x + 14, panel_y + 14), Vector2(panel_x + panel_w - 14, panel_y + 14), Vector2(panel_x + 14, panel_y + panel_h - 14), Vector2(panel_x + panel_w - 14, panel_y + panel_h - 14)]:
		draw_circle(corner, 7, Color(0.54, 0.45, 0.20, 0.2))
		draw_circle(corner, 5, Color(0.54, 0.45, 0.20, 0.3))
		draw_circle(corner, 3, Color(0.54, 0.45, 0.20, 0.25))
		draw_arc(corner, 8, 0, TAU, 24, Color(0.54, 0.45, 0.20, 0.15), 1.0)

	# === Title: THE EMPORIUM ===
	var font = game_font
	var title_text = "THE EMPORIUM"
	var title_size = 28
	var title_width = font.get_string_size(title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size).x
	var title_x = panel_x + (panel_w - title_width) * 0.5
	var title_y = panel_y + 38.0
	# Title glow
	_udraw(font, Vector2(title_x, title_y), title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.85, 0.65, 0.1, 0.3))
	_udraw(font, Vector2(title_x - 1, title_y - 1), title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.95, 0.75, 0.2, 0.9))
	# Decorative stars flanking title
	var star_lx = title_x - 25.0
	var star_rx = title_x + title_width + 10.0
	var star_y = title_y - 10.0
	for dx in [-2.0, 0.0, 2.0]:
		draw_circle(Vector2(star_lx + dx, star_y + dx * 0.5), 2.0, Color(0.85, 0.65, 0.1, 0.4))
		draw_circle(Vector2(star_rx + dx, star_y + dx * 0.5), 2.0, Color(0.85, 0.65, 0.1, 0.4))
	# Underline — gold double line
	var line_cx = panel_x + panel_w * 0.5
	draw_line(Vector2(line_cx - 180, title_y + 8), Vector2(line_cx + 180, title_y + 8), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.5)
	draw_line(Vector2(line_cx - 140, title_y + 12), Vector2(line_cx + 140, title_y + 12), Color(0.54, 0.45, 0.20, 0.15), 1.0)

	# === 3x2 Grid of Emporium Tiles ===
	var tile_w = 340.0
	var tile_h = 220.0
	var gap_x = 30.0
	var gap_y = 24.0
	var grid_w = 3.0 * tile_w + 2.0 * gap_x
	var grid_start_x = panel_x + (panel_w - grid_w) * 0.5
	var grid_start_y = panel_y + 58.0

	for i in range(emporium_categories.size()):
		var cat = emporium_categories[i]
		var col_idx = i % 3
		var row = i / 3
		var tx = grid_start_x + float(col_idx) * (tile_w + gap_x)
		var ty = grid_start_y + float(row) * (tile_h + gap_y)
		var is_hovered = (i == emporium_hover_index)

		# Tile shadow (6px offset)
		draw_rect(Rect2(tx + 6, ty + 6, tile_w, tile_h), Color(0.0, 0.0, 0.0, 0.35))

		# Tile background (navy card)
		var bg = menu_bg_card
		if is_hovered:
			bg = menu_bg_card_hover
		draw_rect(Rect2(tx, ty, tile_w, tile_h), bg)

		# Warm amber accent gradient at top
		for g in range(6):
			var gt = float(g) / 5.0
			draw_rect(Rect2(tx, ty + float(g), tile_w, 1), Color(0.54, 0.45, 0.20, 0.12 * (1.0 - gt)))

		# Tile border
		var tile_border = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.3)
		if is_hovered:
			tile_border = Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7)
		draw_rect(Rect2(tx, ty, tile_w, 2), tile_border)
		draw_rect(Rect2(tx, ty + tile_h - 2, tile_w, 2), tile_border)
		draw_rect(Rect2(tx, ty, 2, tile_h), tile_border)
		draw_rect(Rect2(tx + tile_w - 2, ty, 2, tile_h), tile_border)

		# Hover glow (gold tint)
		if is_hovered:
			var glow_a = 0.06 + sin(_time * 3.5) * 0.03
			draw_rect(Rect2(tx - 2, ty - 2, tile_w + 4, tile_h + 4), Color(menu_gold.r, menu_gold.g, menu_gold.b, glow_a))

		# Corner flourishes (gold only)
		var fl = Color(0.54, 0.45, 0.20, 0.15)
		draw_line(Vector2(tx + 6, ty + 6), Vector2(tx + 26, ty + 6), fl, 1.0)
		draw_line(Vector2(tx + 6, ty + 6), Vector2(tx + 6, ty + 26), fl, 1.0)
		draw_line(Vector2(tx + tile_w - 6, ty + 6), Vector2(tx + tile_w - 26, ty + 6), fl, 1.0)
		draw_line(Vector2(tx + tile_w - 6, ty + 6), Vector2(tx + tile_w - 6, ty + 26), fl, 1.0)
		draw_line(Vector2(tx + 6, ty + tile_h - 6), Vector2(tx + 26, ty + tile_h - 6), fl, 1.0)
		draw_line(Vector2(tx + 6, ty + tile_h - 6), Vector2(tx + 6, ty + tile_h - 26), fl, 1.0)
		draw_line(Vector2(tx + tile_w - 6, ty + tile_h - 6), Vector2(tx + tile_w - 26, ty + tile_h - 6), fl, 1.0)
		draw_line(Vector2(tx + tile_w - 6, ty + tile_h - 6), Vector2(tx + tile_w - 6, ty + tile_h - 26), fl, 1.0)

		# === Title text (top) ===
		var name_size = 16
		var name_text = cat["name"]
		var name_w = font.get_string_size(name_text, HORIZONTAL_ALIGNMENT_LEFT, -1, name_size).x
		var name_x = tx + (tile_w - name_w) * 0.5
		var name_y_pos = ty + 28.0
		_udraw(font, Vector2(name_x, name_y_pos), name_text, HORIZONTAL_ALIGNMENT_LEFT, -1, name_size, Color(0.9, 0.72, 0.2, 0.95))

		# === Procedural icon (center) ===
		var icon_cx = tx + tile_w * 0.5
		var icon_cy = ty + tile_h * 0.48
		_draw_emporium_icon(Vector2(icon_cx, icon_cy), cat["icon"], 70.0)

		# === Description text (bottom) ===
		var desc_size = 12
		var desc_text = cat["desc"]
		var desc_w = font.get_string_size(desc_text, HORIZONTAL_ALIGNMENT_LEFT, -1, desc_size).x
		var desc_x = tx + (tile_w - desc_w) * 0.5
		var desc_y = ty + tile_h - 18.0
		_udraw(font, Vector2(desc_x, desc_y), desc_text, HORIZONTAL_ALIGNMENT_LEFT, -1, desc_size, Color(0.65, 0.55, 0.4, 0.8))

		# === Badge ribbon (top-left) ===
		if cat["badge"] != "":
			var badge_text = cat["badge"]
			var badge_font_size = 10
			var badge_w = font.get_string_size(badge_text, HORIZONTAL_ALIGNMENT_LEFT, -1, badge_font_size).x + 16.0
			var badge_h = 20.0
			var badge_x = tx + 8.0
			var badge_y_top = ty + 8.0
			# Badge color: red for SALE!, green for AVAILABLE!
			var badge_col = Color(0.7, 0.15, 0.1, 0.9)
			if badge_text == "AVAILABLE!":
				badge_col = Color(0.15, 0.55, 0.2, 0.9)
			# Ribbon background
			draw_rect(Rect2(badge_x, badge_y_top, badge_w, badge_h), badge_col)
			# Ribbon notch (small triangle cut on right side)
			draw_colored_polygon(PackedVector2Array([
				Vector2(badge_x + badge_w, badge_y_top),
				Vector2(badge_x + badge_w + 6, badge_y_top + badge_h * 0.5),
				Vector2(badge_x + badge_w, badge_y_top + badge_h),
			]), badge_col)
			# Badge border highlight
			draw_rect(Rect2(badge_x, badge_y_top, badge_w, 1), Color(1, 1, 1, 0.2))
			# Badge text
			_udraw(font, Vector2(badge_x + 8.0, badge_y_top + 15.0), badge_text, HORIZONTAL_ALIGNMENT_LEFT, -1, badge_font_size, Color(1, 1, 1, 0.95))

	# === "RESTORE PURCHASES" text (bottom-right corner) ===
	var restore_size = 11
	var restore_text = "RESTORE PURCHASES"
	var restore_w = font.get_string_size(restore_text, HORIZONTAL_ALIGNMENT_LEFT, -1, restore_size).x
	var restore_x = panel_x + panel_w - restore_w - 20.0
	var restore_y = panel_y + panel_h - 12.0
	_udraw(font, Vector2(restore_x, restore_y), restore_text, HORIZONTAL_ALIGNMENT_LEFT, -1, restore_size, Color(0.55, 0.42, 0.25, 0.5))

func _draw_emporium_icon(center: Vector2, icon_key: String, sz: float) -> void:
	var cx = center.x
	var cy = center.y
	var s = sz * 0.5
	match icon_key:
		"emp_gold":
			# Stack of 3 gold coins
			for ci in range(3):
				var off_y = float(ci) * -10.0
				var coin_col = Color(0.85, 0.65, 0.1, 0.85 - float(ci) * 0.08)
				var coin_hi = Color(0.95, 0.78, 0.2, 0.7 - float(ci) * 0.08)
				# Coin ellipse (top face)
				draw_circle(Vector2(cx, cy + off_y), s * 0.42, coin_col)
				# Coin rim (side edge)
				draw_rect(Rect2(cx - s * 0.42, cy + off_y, s * 0.84, s * 0.12), Color(0.7, 0.5, 0.08, 0.7))
				# Highlight arc
				draw_arc(Vector2(cx, cy + off_y), s * 0.3, -PI * 0.8, -PI * 0.2, 8, coin_hi, 2.0)
				# Inner circle detail
				draw_arc(Vector2(cx, cy + off_y), s * 0.18, 0, TAU, 10, Color(0.75, 0.55, 0.1, 0.4), 1.0)
			# Top coin $ symbol
			draw_line(Vector2(cx - s * 0.08, cy - 24), Vector2(cx - s * 0.08, cy - 12), Color(0.95, 0.8, 0.3, 0.5), 2.0)
			draw_line(Vector2(cx + s * 0.08, cy - 24), Vector2(cx + s * 0.08, cy - 12), Color(0.95, 0.8, 0.3, 0.5), 2.0)
		"emp_quills":
			# Purple feather quill
			var quill_col = Color(0.55, 0.2, 0.7, 0.85)
			var quill_hi = Color(0.7, 0.35, 0.85, 0.6)
			# Feather body (main vane) - slightly curved
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.05, cy + s * 0.6),
				Vector2(cx + s * 0.35, cy - s * 0.5),
				Vector2(cx + s * 0.15, cy - s * 0.65),
				Vector2(cx - s * 0.25, cy + s * 0.4),
			]), quill_col)
			# Feather highlight
			draw_line(Vector2(cx - s * 0.12, cy + s * 0.5), Vector2(cx + s * 0.25, cy - s * 0.55), quill_hi, 1.5)
			# Quill shaft
			draw_line(Vector2(cx - s * 0.15, cy + s * 0.55), Vector2(cx - s * 0.45, cy + s * 0.75), Color(0.8, 0.75, 0.65, 0.8), 2.0)
			# Nib tip
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.45, cy + s * 0.75),
				Vector2(cx - s * 0.52, cy + s * 0.85),
				Vector2(cx - s * 0.42, cy + s * 0.82),
			]), Color(0.3, 0.2, 0.1, 0.9))
			# Ink drops
			draw_circle(Vector2(cx - s * 0.55, cy + s * 0.9), 3.0, Color(0.15, 0.05, 0.3, 0.7))
			draw_circle(Vector2(cx - s * 0.42, cy + s * 0.95), 2.0, Color(0.15, 0.05, 0.3, 0.5))
			# Barb lines on feather
			for bi in range(5):
				var bt = float(bi) / 4.0
				var bx = lerp(cx - s * 0.1, cx + s * 0.3, bt)
				var by_pos = lerp(cy + s * 0.45, cy - s * 0.45, bt)
				draw_line(Vector2(bx, by_pos), Vector2(bx - s * 0.15, by_pos + s * 0.08), Color(0.45, 0.15, 0.6, 0.3), 1.0)
		"emp_shards":
			# Glowing crystal fragment cluster
			var shard_col = Color(0.3, 0.7, 0.85, 0.8)
			var shard_glow = Color(0.4, 0.8, 0.95, 0.15)
			# Central glow
			draw_circle(Vector2(cx, cy), s * 0.55, shard_glow)
			draw_circle(Vector2(cx, cy), s * 0.35, Color(0.5, 0.85, 1.0, 0.1))
			# Main shard (tall, center)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.1, cy + s * 0.4),
				Vector2(cx - s * 0.15, cy - s * 0.15),
				Vector2(cx, cy - s * 0.6),
				Vector2(cx + s * 0.12, cy - s * 0.1),
				Vector2(cx + s * 0.08, cy + s * 0.4),
			]), shard_col)
			# Highlight facet
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.12, cy - s * 0.1),
				Vector2(cx, cy - s * 0.55),
				Vector2(cx + s * 0.05, cy - s * 0.05),
			]), Color(0.5, 0.85, 0.95, 0.5))
			# Left shard (smaller, angled)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.35, cy + s * 0.35),
				Vector2(cx - s * 0.4, cy + s * 0.0),
				Vector2(cx - s * 0.2, cy - s * 0.35),
				Vector2(cx - s * 0.12, cy + s * 0.05),
				Vector2(cx - s * 0.18, cy + s * 0.35),
			]), Color(0.25, 0.6, 0.75, 0.7))
			# Right shard (small)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + s * 0.2, cy + s * 0.3),
				Vector2(cx + s * 0.18, cy - s * 0.1),
				Vector2(cx + s * 0.32, cy - s * 0.25),
				Vector2(cx + s * 0.38, cy + s * 0.05),
				Vector2(cx + s * 0.3, cy + s * 0.3),
			]), Color(0.35, 0.65, 0.8, 0.65))
			# Sparkle points
			for sp in [Vector2(cx + s * 0.05, cy - s * 0.5), Vector2(cx - s * 0.3, cy - s * 0.2), Vector2(cx + s * 0.35, cy - s * 0.15)]:
				draw_line(sp + Vector2(-4, 0), sp + Vector2(4, 0), Color(1, 1, 1, 0.5), 1.0)
				draw_line(sp + Vector2(0, -4), sp + Vector2(0, 4), Color(1, 1, 1, 0.5), 1.0)
		"emp_chests":
			# Ornate treasure chest
			var wood_col = Color(0.5, 0.3, 0.12, 0.85)
			var wood_dark = Color(0.35, 0.2, 0.08, 0.85)
			var gold_col = Color(0.85, 0.65, 0.1, 0.9)
			# Chest body (bottom box)
			draw_rect(Rect2(cx - s * 0.5, cy - s * 0.05, s * 1.0, s * 0.55), wood_col)
			# Planks
			draw_line(Vector2(cx - s * 0.5, cy + s * 0.2), Vector2(cx + s * 0.5, cy + s * 0.2), wood_dark, 1.0)
			# Lid (rounded top)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.5, cy - s * 0.05),
				Vector2(cx - s * 0.48, cy - s * 0.3),
				Vector2(cx - s * 0.3, cy - s * 0.48),
				Vector2(cx, cy - s * 0.55),
				Vector2(cx + s * 0.3, cy - s * 0.48),
				Vector2(cx + s * 0.48, cy - s * 0.3),
				Vector2(cx + s * 0.5, cy - s * 0.05),
			]), wood_dark)
			# Gold bands
			draw_line(Vector2(cx - s * 0.5, cy - s * 0.05), Vector2(cx + s * 0.5, cy - s * 0.05), gold_col, 2.5)
			draw_line(Vector2(cx - s * 0.5, cy + s * 0.5), Vector2(cx + s * 0.5, cy + s * 0.5), gold_col, 2.0)
			# Gold latch (center)
			draw_rect(Rect2(cx - s * 0.08, cy - s * 0.12, s * 0.16, s * 0.2), gold_col)
			draw_circle(Vector2(cx, cy + s * 0.02), s * 0.06, Color(0.95, 0.75, 0.2))
			# Glow from opening
			draw_circle(Vector2(cx, cy - s * 0.15), s * 0.3, Color(1.0, 0.85, 0.3, 0.08 + sin(_time * 2.5) * 0.04))
			# Corner reinforcements
			for ccx in [cx - s * 0.48, cx + s * 0.42]:
				draw_rect(Rect2(ccx, cy - s * 0.03, s * 0.06, s * 0.52), gold_col.darkened(0.3))
		"emp_packs":
			# Silhouette of character group / book bundle
			var sil_col = Color(0.55, 0.35, 0.15, 0.7)
			var sil_hi = Color(0.7, 0.5, 0.2, 0.5)
			# Three book shapes (stacked at angle)
			# Book 1 (left, leaning)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx - s * 0.4, cy + s * 0.45),
				Vector2(cx - s * 0.5, cy - s * 0.25),
				Vector2(cx - s * 0.3, cy - s * 0.3),
				Vector2(cx - s * 0.2, cy + s * 0.4),
			]), sil_col)
			draw_line(Vector2(cx - s * 0.48, cy - s * 0.2), Vector2(cx - s * 0.22, cy + s * 0.38), Color(0.85, 0.65, 0.1, 0.3), 1.0)
			# Book 2 (center, upright)
			draw_rect(Rect2(cx - s * 0.15, cy - s * 0.4, s * 0.3, s * 0.85), Color(0.45, 0.25, 0.1, 0.75))
			draw_rect(Rect2(cx - s * 0.12, cy - s * 0.35, s * 0.24, s * 0.08), Color(0.85, 0.65, 0.1, 0.4))
			# Book 3 (right, leaning opposite)
			draw_colored_polygon(PackedVector2Array([
				Vector2(cx + s * 0.2, cy + s * 0.45),
				Vector2(cx + s * 0.3, cy - s * 0.3),
				Vector2(cx + s * 0.5, cy - s * 0.25),
				Vector2(cx + s * 0.4, cy + s * 0.45),
			]), Color(0.5, 0.28, 0.12, 0.7))
			draw_line(Vector2(cx + s * 0.32, cy - s * 0.25), Vector2(cx + s * 0.42, cy + s * 0.4), Color(0.85, 0.65, 0.1, 0.3), 1.0)
			# Character silhouettes peeking above books
			draw_circle(Vector2(cx - s * 0.1, cy - s * 0.52), s * 0.12, Color(0.3, 0.2, 0.1, 0.5))
			draw_circle(Vector2(cx + s * 0.15, cy - s * 0.48), s * 0.1, Color(0.3, 0.2, 0.1, 0.45))
			# Ribbon bookmark
			draw_line(Vector2(cx, cy - s * 0.4), Vector2(cx - s * 0.05, cy + s * 0.55), Color(0.7, 0.15, 0.15, 0.5), 2.0)
		"emp_stars":
			# Cluster of stars with sparkle
			var star_col = Color(0.95, 0.8, 0.2, 0.85)
			var star_glow = Color(1.0, 0.9, 0.4, 0.12)
			# Central glow
			draw_circle(Vector2(cx, cy), s * 0.5, star_glow)
			# Draw 5 stars of varying sizes
			var star_positions = [
				{"pos": Vector2(cx, cy - s * 0.2), "r": s * 0.28},
				{"pos": Vector2(cx - s * 0.35, cy + s * 0.15), "r": s * 0.18},
				{"pos": Vector2(cx + s * 0.35, cy + s * 0.1), "r": s * 0.2},
				{"pos": Vector2(cx - s * 0.15, cy + s * 0.4), "r": s * 0.14},
				{"pos": Vector2(cx + s * 0.2, cy + s * 0.38), "r": s * 0.12},
			]
			for sd in star_positions:
				var sp_center = sd["pos"]
				var sr = sd["r"]
				# 5-point star
				for si in range(5):
					var a1 = -PI / 2.0 + float(si) * TAU / 5.0
					var a2 = -PI / 2.0 + (float(si) + 0.5) * TAU / 5.0
					var p1 = sp_center + Vector2.from_angle(a1) * sr
					var p2 = sp_center + Vector2.from_angle(a2) * sr * 0.4
					var p3 = sp_center + Vector2.from_angle(a1 + TAU / 5.0) * sr
					draw_colored_polygon(PackedVector2Array([sp_center, p1, p2]), star_col)
					draw_colored_polygon(PackedVector2Array([sp_center, p2, p3]), star_col)
			# Cross sparkles on the largest star
			var main_star = star_positions[0]["pos"]
			draw_line(main_star + Vector2(-s * 0.35, 0), main_star + Vector2(s * 0.35, 0), Color(1, 1, 1, 0.3), 1.0)
			draw_line(main_star + Vector2(0, -s * 0.35), main_star + Vector2(0, s * 0.35), Color(1, 1, 1, 0.3), 1.0)
		"emp_trophy":
			# Trophy cup icon
			var trophy_col = Color(0.85, 0.65, 0.1, 0.85)
			# Cup body
			draw_rect(Rect2(cx - s * 0.3, cy - s * 0.3, s * 0.6, s * 0.5), trophy_col)
			# Cup rim
			draw_rect(Rect2(cx - s * 0.35, cy - s * 0.35, s * 0.7, s * 0.08), Color(0.95, 0.78, 0.2, 0.9))
			# Handles
			draw_arc(Vector2(cx - s * 0.35, cy - s * 0.1), s * 0.15, PI * 0.5, PI * 1.5, 8, trophy_col, 3.0)
			draw_arc(Vector2(cx + s * 0.35, cy - s * 0.1), s * 0.15, -PI * 0.5, PI * 0.5, 8, trophy_col, 3.0)
			# Stem
			draw_rect(Rect2(cx - s * 0.06, cy + s * 0.2, s * 0.12, s * 0.2), trophy_col)
			# Base
			draw_rect(Rect2(cx - s * 0.22, cy + s * 0.4, s * 0.44, s * 0.08), trophy_col)
			# Star on cup
			draw_circle(Vector2(cx, cy - s * 0.08), s * 0.1, Color(1.0, 0.9, 0.5, 0.7))

		"emp_powers":
			# Lightning bolt / scroll icon for battle powers
			var pw_col = Color(0.3, 0.7, 0.9, 0.85)
			# Scroll body
			draw_rect(Rect2(cx - s * 0.25, cy - s * 0.3, s * 0.5, s * 0.6), Color(0.85, 0.78, 0.6, 0.8))
			# Scroll top/bottom rolls
			draw_circle(Vector2(cx, cy - s * 0.3), s * 0.08, Color(0.7, 0.6, 0.4, 0.9))
			draw_circle(Vector2(cx, cy + s * 0.3), s * 0.08, Color(0.7, 0.6, 0.4, 0.9))
			# Lightning bolt on scroll
			var bolt_pts = PackedVector2Array([
				Vector2(cx + s * 0.05, cy - s * 0.2),
				Vector2(cx - s * 0.1, cy + s * 0.02),
				Vector2(cx + s * 0.02, cy + s * 0.02),
				Vector2(cx - s * 0.05, cy + s * 0.2),
			])
			for bi in range(bolt_pts.size() - 1):
				draw_line(bolt_pts[bi], bolt_pts[bi + 1], pw_col, 3.0)

func _draw_emporium_sub_panel() -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var font = game_font

	# Navy gradient background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 55.0 + 1), col)

	# Gold double-frame border
	var emp_outer = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.35)
	var emp_gold = Color(0.54, 0.45, 0.20, 0.2)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 3), emp_outer)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 3, panel_w, 3), emp_outer)
	draw_rect(Rect2(panel_x, panel_y, 3, panel_h), emp_outer)
	draw_rect(Rect2(panel_x + panel_w - 3, panel_y, 3, panel_h), emp_outer)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, panel_w - 12, 1), emp_gold)
	draw_rect(Rect2(panel_x + 6, panel_y + panel_h - 7, panel_w - 12, 1), emp_gold)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, 1, panel_h - 12), emp_gold)
	draw_rect(Rect2(panel_x + panel_w - 7, panel_y + 6, 1, panel_h - 12), emp_gold)

	# Category title
	if emporium_sub_category >= 0 and emporium_sub_category < emporium_categories.size():
		var cat = emporium_categories[emporium_sub_category]
		var title_text = cat["name"].to_upper()
		var title_size = 24
		var tw = font.get_string_size(title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size).x
		var tx = panel_x + (panel_w - tw) * 0.5
		_udraw(font, Vector2(tx, panel_y + 36), title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.95, 0.75, 0.2, 0.9))
		# Underline
		var cx = panel_x + panel_w * 0.5
		draw_line(Vector2(cx - 160, panel_y + 44), Vector2(cx + 160, panel_y + 44), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.5)

	# Currency bar
	var bar_y = panel_y + 60.0
	var currencies_text = "Quills: %d    |    Shards: %d    |    Stars: %d    |    Gold: %d" % [player_quills, player_relic_shards, player_storybook_stars, gold]
	var cw = font.get_string_size(currencies_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 13).x
	_udraw(font, Vector2(panel_x + (panel_w - cw) * 0.5, bar_y + 14), currencies_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.7))

	# Chest inventory line
	var chest_text = "Chests:  Bronze: %d  |  Silver: %d  |  Gold: %d" % [treasure_chests_owned["bronze"], treasure_chests_owned["silver"], treasure_chests_owned["gold"]]
	var chest_tw = font.get_string_size(chest_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 11).x
	_udraw(font, Vector2(panel_x + (panel_w - chest_tw) * 0.5, bar_y + 32), chest_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 11, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.7))

	# Separator line
	draw_line(Vector2(panel_x + 40, bar_y + 42), Vector2(panel_x + panel_w - 40, bar_y + 42), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.15), 1.0)

	# 3 item cards
	if emporium_sub_category >= 0 and emporium_items.has(emporium_sub_category):
		var items = emporium_items[emporium_sub_category]
		var item_w = 320.0
		var item_h = 130.0
		var gap = 20.0
		var total_w = 3.0 * item_w + 2.0 * gap
		var start_x = panel_x + (panel_w - total_w) * 0.5
		var start_y = panel_y + 130.0

		var max_cols = 3
		var num_rows = ceili(float(items.size()) / max_cols)
		if num_rows > 1:
			item_h = 110.0
		for i in range(items.size()):
			var item = items[i]
			var row_i = i / max_cols
			var col_i = i % max_cols
			var items_in_row = mini(max_cols, items.size() - row_i * max_cols)
			var row_w = float(items_in_row) * item_w + float(items_in_row - 1) * gap
			var row_start_x = panel_x + (panel_w - row_w) * 0.5
			var ix = row_start_x + float(col_i) * (item_w + gap)
			var iy = start_y + float(row_i) * (item_h + 12.0)
			var is_hovered = (i == emporium_sub_hover)

			# Card shadow
			draw_rect(Rect2(ix + 4, iy + 4, item_w, item_h), Color(0.0, 0.0, 0.0, 0.3))
			# Card background
			var bg = menu_bg_card_hover if is_hovered else menu_bg_card
			draw_rect(Rect2(ix, iy, item_w, item_h), bg)
			# Card border
			var bdr = Color(0.85, 0.65, 0.15, 0.7) if is_hovered else Color(0.55, 0.38, 0.08, 0.35)
			draw_rect(Rect2(ix, iy, item_w, 2), bdr)
			draw_rect(Rect2(ix, iy + item_h - 2, item_w, 2), bdr)
			draw_rect(Rect2(ix, iy, 2, item_h), bdr)
			draw_rect(Rect2(ix + item_w - 2, iy, 2, item_h), bdr)

			# Hover glow
			if is_hovered:
				var ga = 0.06 + sin(_time * 3.5) * 0.03
				draw_rect(Rect2(ix - 2, iy - 2, item_w + 4, item_h + 4), Color(menu_gold.r, menu_gold.g, menu_gold.b, ga))

			# Item name
			var nw = font.get_string_size(item["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 16).x
			_udraw(font, Vector2(ix + (item_w - nw) * 0.5, iy + 28), item["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.9, 0.72, 0.2, 0.95))
			# Item description
			var dw = font.get_string_size(item["desc"], HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x
			_udraw(font, Vector2(ix + (item_w - dw) * 0.5, iy + 50), item["desc"], HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.65, 0.55, 0.4, 0.8))
			# Reward line
			var reward_text = "+%d %s" % [item["amount"], item["reward"].capitalize().replace("_", " ")]
			if item["reward"] == "power":
				var pid = item.get("power_id", "")
				var count = owned_powers.get(pid, 0)
				reward_text = "Owned: %d" % count
			var rw = font.get_string_size(reward_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14).x
			_udraw(font, Vector2(ix + (item_w - rw) * 0.5, iy + 78), reward_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.4, 0.85, 0.4, 0.9))
			# Cost line
			var cost_text = "Cost: %d %s" % [item["cost"], item["currency"].capitalize()]
			var ctw = font.get_string_size(cost_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
			# Check affordability for color
			var can_afford = false
			match item["currency"]:
				"quills": can_afford = player_quills >= item["cost"]
				"shards": can_afford = player_relic_shards >= item["cost"]
				"stars": can_afford = player_storybook_stars >= item["cost"]
			var cost_col = Color(0.9, 0.8, 0.5, 0.8) if can_afford else Color(0.8, 0.3, 0.2, 0.8)
			_udraw(font, Vector2(ix + (item_w - ctw) * 0.5, iy + 100), cost_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, cost_col)
			# "BUY" label at bottom
			var buy_text = "[ BUY ]"
			var bw2 = font.get_string_size(buy_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x
			var buy_col = Color(0.85, 0.65, 0.1, 0.8) if is_hovered else Color(0.55, 0.42, 0.2, 0.5)
			_udraw(font, Vector2(ix + (item_w - bw2) * 0.5, iy + 120), buy_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, buy_col)

	# Open chest buttons (if category is Relic Chests and player has chests)
	if emporium_sub_category == 3:
		var open_y = panel_y + 290.0
		var tier_names = ["Bronze", "Silver", "Gold"]
		var tier_keys = ["bronze", "silver", "gold"]
		var open_total_w = 3.0 * 320.0 + 2.0 * 20.0
		var open_start_x = panel_x + (panel_w - open_total_w) * 0.5
		for ci in range(3):
			var count = treasure_chests_owned[tier_keys[ci]]
			if count > 0:
				var ox = open_start_x + float(ci) * 340.0
				var ow = 320.0
				var oh = 36.0
				draw_rect(Rect2(ox, open_y, ow, oh), Color(0.08, 0.07, 0.18, 0.85))
				draw_rect(Rect2(ox, open_y, ow, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3))
				var ot = "Open %s Chest (%d)" % [tier_names[ci], count]
				var otw = font.get_string_size(ot, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
				_udraw(font, Vector2(ox + (ow - otw) * 0.5, open_y + 24), ot, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.9, 0.75, 0.2, 0.85))

	# Purchase feedback message
	if emporium_sub_message != "":
		var msg_col = Color(0.3, 0.85, 0.3, 0.95) if emporium_sub_message == "Purchased!" else Color(0.9, 0.3, 0.2, 0.95)
		var mw = font.get_string_size(emporium_sub_message, HORIZONTAL_ALIGNMENT_LEFT, -1, 18).x
		_udraw(font, Vector2(panel_x + (panel_w - mw) * 0.5, panel_y + panel_h - 80), emporium_sub_message, HORIZONTAL_ALIGNMENT_LEFT, -1, 18, msg_col)

	# Back button (drawn, detected via click)
	var back_text = "<  BACK"
	var back_x = panel_x + 20.0
	var back_y = panel_y + panel_h - 30.0
	_udraw(font, Vector2(back_x, back_y), back_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7))

func _start_chest_opening(tier: int) -> void:
	chest_opening_active = true
	chest_opening_tier = tier
	chest_opening_phase = 0
	chest_opening_timer = 0.0
	chest_opening_picked = -1
	chest_opening_flip_index = 0
	_generate_chest_cards(tier)
	total_chests_opened += 1
	_check_achievement("chest_collector", 1)
	_save_game()
	queue_redraw()

func _start_victory_chest(difficulty: int, stars: int) -> void:
	victory_chest_active = true
	victory_chest_stars = stars
	victory_trinket_pending = {}
	victory_equip_active = false
	victory_equip_hover = -1
	# Map difficulty to tier colors: Easy=Blue(0), Medium=Purple(1), Hard=Gold(2)
	chest_opening_active = true
	chest_opening_tier = difficulty
	chest_opening_phase = 0
	chest_opening_timer = 0.0
	chest_opening_picked = -1
	chest_opening_flip_index = 0
	_generate_victory_cards(difficulty, stars)
	total_chests_opened += 1
	_check_achievement("chest_collector", 1)
	# Hide all tower nodes so they don't render over the chest overlay
	for tower in get_tree().get_nodes_in_group("towers"):
		tower.visible = false
	# Hide HUD buttons
	start_button.visible = false
	speed_button.visible = false
	return_button.visible = false
	queue_redraw()

func _generate_victory_cards(difficulty: int, stars: int) -> void:
	chest_opening_cards.clear()
	var loot_bonus = 1.0 + _get_knowledge_bonus("chest_loot")
	var chapter = levels[current_level]["chapter"] if current_level >= 0 and current_level < levels.size() else 0
	var chapter_mult = 1.0 + chapter * 0.5
	var prog_chapter = current_level / 3  # World index for drop rate scaling
	var level_char = levels[current_level]["character"] if current_level >= 0 and current_level < levels.size() else -1
	var highest_lv = _get_highest_completed_level()
	# Currency pools by difficulty (harmonized with chest loot values)
	var currency_pools = [
		[{"type": "shards", "min": 2, "max": 8}, {"type": "quills", "min": 1, "max": 2}, {"type": "gold", "min": 8, "max": 25}],
		[{"type": "shards", "min": 5, "max": 15}, {"type": "quills", "min": 2, "max": 4}, {"type": "gold", "min": 18, "max": 50}, {"type": "stars", "min": 1, "max": 2}],
		[{"type": "shards", "min": 10, "max": 30}, {"type": "quills", "min": 4, "max": 8}, {"type": "gold", "min": 30, "max": 90}, {"type": "stars", "min": 1, "max": 3}],
	]
	var pool = currency_pools[mini(difficulty, 2)]
	# Difficulty-exclusive relic tier + act gating
	var trinket_rarity = ["common", "uncommon", "rare"][difficulty]
	var tier_unlocked = true
	if difficulty == 1 and highest_lv < 12:
		tier_unlocked = false  # Purple requires Act 1 complete
	elif difficulty == 2 and highest_lv < 24:
		tier_unlocked = false  # Gold requires Act 2 complete
	# Drop rate: low base + scales with chapter progression
	var trinket_chance = [0.08, 0.12, 0.18][difficulty]
	trinket_chance += [0.01, 0.015, 0.02][difficulty] * prog_chapter
	if stars >= 3:
		trinket_chance += 0.05
	# Generate 3 cards
	for i in range(3):
		if i == 2 and tier_unlocked and randf() < trinket_chance:
			var chosen = _pick_weighted_relic(trinket_rarity, level_char)
			if not chosen.is_empty():
				chest_opening_cards.append({
					"type": "trinket", "amount": 1, "name": chosen["name"],
					"trinket_id": chosen["id"], "trinket_rarity": trinket_rarity,
					"desc": chosen["desc"]
				})
				continue
		# Currency card
		var entry = pool[randi() % pool.size()]
		var amount = randi_range(entry["min"], entry["max"])
		amount = int(float(amount) * loot_bonus * chapter_mult)
		amount = maxi(amount, 1)
		if stars >= 3:
			amount = int(float(amount) * 1.3)
		var card_name = ""
		match entry["type"]:
			"shards": card_name = "Relic Shards"
			"quills": card_name = "Enchanted Quills"
			"gold": card_name = "Gold Sovereigns"
			"stars": card_name = "Storybook Stars"
		# Small chance for battle power on Medium/Hard
		if difficulty >= 1 and randf() < 0.15:
			var bp = battle_power_definitions[randi() % battle_power_definitions.size()]
			var bp_count = 1 if difficulty == 1 else 2
			chest_opening_cards.append({"type": "power", "amount": bp_count, "name": bp["name"], "power_id": bp["id"]})
		else:
			chest_opening_cards.append({"type": entry["type"], "amount": amount, "name": card_name})

func _generate_chest_cards(tier: int) -> void:
	chest_opening_cards.clear()
	# Loot pools by tier: Bronze, Silver, Gold
	var currency_ranges = [
		[{"type": "shards", "min": 5, "max": 15}, {"type": "quills", "min": 1, "max": 3}, {"type": "gold", "min": 20, "max": 60}],
		[{"type": "shards", "min": 15, "max": 40}, {"type": "quills", "min": 3, "max": 8}, {"type": "gold", "min": 50, "max": 150}, {"type": "stars", "min": 1, "max": 1}],
		[{"type": "shards", "min": 30, "max": 80}, {"type": "quills", "min": 8, "max": 20}, {"type": "gold", "min": 100, "max": 300}, {"type": "stars", "min": 1, "max": 3}],
	]
	var pool = currency_ranges[mini(tier, 2)]
	var loot_bonus = 1.0 + _get_knowledge_bonus("chest_loot")
	for i in range(3):
		var entry = pool[randi() % pool.size()]
		var amount = randi_range(entry["min"], entry["max"])
		amount = int(float(amount) * loot_bonus)
		amount = maxi(amount, 1)
		var card_name = ""
		match entry["type"]:
			"shards": card_name = "Relic Shards"
			"quills": card_name = "Enchanted Quills"
			"gold": card_name = "Gold Sovereigns"
			"stars": card_name = "Storybook Stars"
		# Small chance to replace with a battle power (Silver/Gold chests only)
		if tier >= 1 and randf() < 0.2:
			var bp = battle_power_definitions[randi() % battle_power_definitions.size()]
			var bp_count = 1 if tier == 1 else 2
			chest_opening_cards.append({"type": "power", "amount": bp_count, "name": bp["name"], "power_id": bp["id"]})
		else:
			chest_opening_cards.append({"type": entry["type"], "amount": amount, "name": card_name})

func _on_chest_overlay_clicked(mouse_pos: Vector2) -> void:
	# Victory equip overlay intercepts all clicks when active
	if victory_equip_active:
		_on_victory_equip_clicked(mouse_pos)
		return
	# Phase 0 = click to open the chest
	if chest_opening_phase == 0:
		chest_opening_phase = 1
		chest_opening_timer = 0.0
		queue_redraw()
		return
	if chest_opening_phase < 5:
		return  # Still animating (phases 1-4)
	if chest_opening_phase == 6:
		chest_opening_active = false
		# Restore tower visibility
		for tower in get_tree().get_nodes_in_group("towers"):
			tower.visible = true
		if victory_chest_active:
			victory_chest_active = false
			return_button.visible = true
			_queue_post_victory_dialog()
			_save_game()
		queue_redraw()
		return
	# Phase 5 = pick a card
	var cx = 640.0
	var card_w = 170.0
	var card_h = 240.0
	var card_gap = 40.0
	var total = 3.0 * card_w + 2.0 * card_gap
	var start_x = cx - total * 0.5
	var card_y = 220.0
	for i in range(3):
		var card_x = start_x + float(i) * (card_w + card_gap)
		if mouse_pos.x >= card_x and mouse_pos.x <= card_x + card_w and mouse_pos.y >= card_y and mouse_pos.y <= card_y + card_h:
			chest_opening_picked = i
			var card = chest_opening_cards[i]
			# Trinket card — show character equip overlay
			if card.get("type") == "trinket":
				victory_trinket_pending = card
				# Add to owned immediately
				var tid = card.get("trinket_id", "")
				if tid != "":
					owned_bindings[tid] = owned_bindings.get(tid, 0) + 1
				victory_equip_active = true
				victory_equip_hover = -1
				queue_redraw()
				return
			# Grant currency/power reward immediately
			match card["type"]:
				"shards": player_relic_shards += card["amount"]
				"quills": player_quills += card["amount"]
				"gold": player_gold += card["amount"]
				"stars": player_storybook_stars += card["amount"]
				"power":
					var pid = card.get("power_id", "")
					if pid != "":
						owned_powers[pid] = owned_powers.get(pid, 0) + card["amount"]
			chest_opening_phase = 6
			chest_opening_timer = 0.0
			_save_game()
			queue_redraw()
			return

func _on_victory_equip_clicked(mouse_pos: Vector2) -> void:
	# Character selection overlay for equipping a trinket
	var panel_x = 240.0
	var panel_y = 120.0
	var panel_w = 800.0
	var col_w = 145.0
	var col_gap = 10.0
	var row_h = 80.0
	var grid_x = panel_x + 30.0
	var grid_y = panel_y + 90.0
	# 11 characters in 2 rows (6 + 5)
	var tower_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom", "scrooge",
		"sherlock", "tarzan", "dracula", "merlin", "frankenstein"]
	for idx in range(tower_names.size()):
		var row = idx / 6
		var col = idx % 6
		var cx = grid_x + float(col) * (col_w + col_gap)
		var cy = grid_y + float(row) * (row_h + 15.0)
		if mouse_pos.x >= cx and mouse_pos.x <= cx + col_w and mouse_pos.y >= cy and mouse_pos.y <= cy + row_h:
			var tower_type_str = tower_names[idx]
			var slots = _get_binding_slots(tower_type_str)
			if slots <= 0:
				return  # No slots available
			var current = equipped_bindings.get(tower_type_str, [])
			if current.size() >= slots:
				return  # All slots full
			var tid = victory_trinket_pending.get("trinket_id", "")
			if tid != "":
				if not equipped_bindings.has(tower_type_str):
					equipped_bindings[tower_type_str] = []
				equipped_bindings[tower_type_str].append(tid)
				# Apply meta buffs to any placed tower of this type
				for tower in get_tree().get_nodes_in_group("towers"):
					if tower.get("tower_type") != null:
						var tname = _tower_type_to_name(tower.tower_type)
						if tname == tower_type_str:
							_apply_meta_buffs(tower, tower_type_str)
			victory_equip_active = false
			victory_trinket_pending = {}
			chest_opening_phase = 6
			chest_opening_timer = 0.0
			_save_game()
			queue_redraw()
			return
	# "Skip" button at bottom — equip later
	var skip_x = panel_x + (panel_w - 200.0) * 0.5
	var skip_y = panel_y + 310.0
	if mouse_pos.x >= skip_x and mouse_pos.x <= skip_x + 200.0 and mouse_pos.y >= skip_y and mouse_pos.y <= skip_y + 40.0:
		victory_equip_active = false
		victory_trinket_pending = {}
		chest_opening_phase = 6
		chest_opening_timer = 0.0
		_save_game()
		queue_redraw()

func _draw_chest_opening() -> void:
	# Full-screen OPAQUE dark overlay — completely hides everything behind
	draw_rect(Rect2(0, 0, 1280, 720), Color(0.02, 0.01, 0.05, 1.0))
	var font = game_font
	var cx = 640.0
	# Victory chests use difficulty colors; emporium chests use classic tier colors
	var tier_names = ["Apprentice", "Journeyman", "Master"]
	var tier_colors = [Color(0.3, 0.5, 0.85), Color(0.6, 0.3, 0.75), Color(0.85, 0.65, 0.1)]
	if not victory_chest_active:
		tier_names = ["Bronze", "Silver", "Gold"]
		tier_colors = [Color(0.72, 0.50, 0.25), Color(0.75, 0.75, 0.80), Color(0.85, 0.65, 0.1)]
	var tier_col = tier_colors[mini(chest_opening_tier, 2)]
	var glow_col = Color(tier_col.r * 1.2, tier_col.g * 1.2, tier_col.b * 1.0)

	if chest_opening_phase == 0 or chest_opening_phase == 1:
		# === GLOWING TREASURE CHEST ===
		var chest_cy = 300.0
		var shake = 0.0
		if chest_opening_phase == 1:
			shake = sin(chest_opening_timer * 30.0) * (3.0 + chest_opening_timer * 8.0)
		var chest_cx = cx + shake
		var bw = 200.0
		var bh = 120.0
		var pulse = (sin(_time * 2.5) + 1.0) * 0.5

		# Multiple layered glow rings behind chest (bright and dramatic)
		for gi in range(5):
			var gr = 160.0 - float(gi) * 22.0 + pulse * 12.0
			var ga = 0.04 + float(gi) * 0.02 + pulse * 0.02
			draw_circle(Vector2(cx, chest_cy + 20), gr, Color(glow_col.r, glow_col.g, glow_col.b, ga))
		# Outer golden haze
		draw_circle(Vector2(cx, chest_cy + 20), 200.0 + pulse * 20.0, Color(1.0, 0.9, 0.5, 0.03))

		# Floating sparkle particles
		for p in range(16):
			var angle = float(p) * TAU / 16.0 + _time * 0.4
			var dist = 100.0 + sin(_time * 1.5 + float(p) * 2.1) * 40.0
			var px = cx + cos(angle) * dist
			var py = chest_cy + 20.0 + sin(angle) * dist * 0.5
			var sp = (sin(_time * 3.0 + float(p) * 1.3) + 1.0) * 0.5
			var sz = 1.5 + sp * 2.5
			draw_circle(Vector2(px, py), sz, Color(1.0, 0.95, 0.7, sp * 0.5))

		# === Chest shadow on ground ===
		draw_colored_polygon(PackedVector2Array([
			Vector2(chest_cx - bw * 0.6, chest_cy + bh + 6),
			Vector2(chest_cx + bw * 0.6, chest_cy + bh + 6),
			Vector2(chest_cx + bw * 0.45, chest_cy + bh + 18),
			Vector2(chest_cx - bw * 0.45, chest_cy + bh + 18)
		]), Color(0.0, 0.0, 0.0, 0.35))

		# === Chest body ===
		# Dark base
		draw_rect(Rect2(chest_cx - bw * 0.5 - 5, chest_cy - 3, bw + 10, bh + 6), Color(tier_col.r * 0.25, tier_col.g * 0.25, tier_col.b * 0.25))
		# Main body (gradient effect with multiple rects)
		for gi in range(6):
			var t = float(gi) / 5.0
			var yy = chest_cy + t * bh
			var hh = bh / 5.0
			var shade = lerp(0.9, 0.55, t)
			draw_rect(Rect2(chest_cx - bw * 0.5, yy, bw, hh), Color(tier_col.r * shade, tier_col.g * shade, tier_col.b * shade))
		# Horizontal metal bands
		for band_y in [chest_cy + bh * 0.0, chest_cy + bh * 0.45, chest_cy + bh * 0.95]:
			draw_rect(Rect2(chest_cx - bw * 0.54, band_y, bw * 1.08, 5), Color(tier_col.r * 0.35, tier_col.g * 0.35, tier_col.b * 0.35, 0.9))
			draw_rect(Rect2(chest_cx - bw * 0.54, band_y + 1, bw * 1.08, 1), Color(1.0, 0.95, 0.7, 0.15))
		# Vertical center strip
		draw_rect(Rect2(chest_cx - 5, chest_cy, 10, bh), Color(tier_col.r * 0.4, tier_col.g * 0.4, tier_col.b * 0.4, 0.7))
		# Lid (beveled trapezoid)
		draw_colored_polygon(PackedVector2Array([
			Vector2(chest_cx - bw * 0.56, chest_cy), Vector2(chest_cx + bw * 0.56, chest_cy),
			Vector2(chest_cx + bw * 0.46, chest_cy - 45), Vector2(chest_cx - bw * 0.46, chest_cy - 45)
		]), Color(tier_col.r * 0.8, tier_col.g * 0.8, tier_col.b * 0.8))
		# Lid highlight
		draw_colored_polygon(PackedVector2Array([
			Vector2(chest_cx - bw * 0.44, chest_cy - 42), Vector2(chest_cx + bw * 0.44, chest_cy - 42),
			Vector2(chest_cx + bw * 0.40, chest_cy - 30), Vector2(chest_cx - bw * 0.40, chest_cy - 30)
		]), Color(1.0, 1.0, 1.0, 0.08))
		# Golden clasp/lock with glow
		var lock_glow = 0.5 + pulse * 0.5
		draw_circle(Vector2(chest_cx, chest_cy + 10), 18 + pulse * 3, Color(1.0, 0.85, 0.3, 0.15 * lock_glow))
		draw_rect(Rect2(chest_cx - 16, chest_cy - 8, 32, 28), Color(0.90, 0.70, 0.15, 0.95))
		draw_rect(Rect2(chest_cx - 14, chest_cy - 6, 28, 24), Color(1.0, 0.82, 0.25, 0.9))
		draw_circle(Vector2(chest_cx, chest_cy + 8), 8, Color(1.0, 0.90, 0.4, 0.95))
		draw_circle(Vector2(chest_cx, chest_cy + 8), 4, Color(0.35, 0.25, 0.05))
		# Corner rivets with gold gleam
		for corner in [Vector2(-bw*0.48, 4), Vector2(bw*0.48, 4), Vector2(-bw*0.48, bh-4), Vector2(bw*0.48, bh-4)]:
			draw_circle(Vector2(chest_cx + corner.x, chest_cy + corner.y), 5, Color(0.95, 0.75, 0.2, 0.8))
			draw_circle(Vector2(chest_cx + corner.x - 1, chest_cy + corner.y - 1), 2, Color(1.0, 1.0, 0.8, 0.4))

		# === VICTORY text (centered above chest) ===
		if victory_chest_active:
			var vic_text = "VICTORY!"
			var vic_w = font.get_string_size(vic_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 52).x
			# Glow behind text
			draw_circle(Vector2(cx, 125), 80.0, Color(1.0, 0.85, 0.2, 0.08 + pulse * 0.06))
			# Text shadow
			_udraw(font, Vector2(cx - vic_w * 0.5 + 2, 132), vic_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 52, Color(0.0, 0.0, 0.0, 0.7))
			# Text with pulsing gold — large
			var text_bright = 0.85 + pulse * 0.15
			_udraw(font, Vector2(cx - vic_w * 0.5, 130), vic_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 52, Color(text_bright, text_bright * 0.85, 0.2, 0.95))
		# Star display — large, animated victory stars
		if victory_chest_active:
			var star_y = 158.0
			for si in range(3):
				var sx = cx - 60.0 + float(si) * 60.0
				var is_earned = si < victory_chest_stars
				var star_col = Color(1.0, 0.85, 0.15, 0.95) if is_earned else Color(0.3, 0.25, 0.2, 0.35)
				var star_size = 22.0
				# Earned stars glow and pulse
				if is_earned:
					var star_pulse = sin(_time * 2.5 + float(si) * 0.8) * 0.15
					star_size += star_pulse * 4.0
					# Glow halo
					draw_circle(Vector2(sx, star_y), star_size + 8.0, Color(1.0, 0.85, 0.2, 0.15 + star_pulse))
				var star_pts = PackedVector2Array()
				for sp in range(10):
					var sa = float(sp) * TAU / 10.0 - PI / 2.0
					var sr = star_size if sp % 2 == 0 else star_size * 0.45
					star_pts.append(Vector2(sx, star_y) + Vector2(cos(sa), sin(sa)) * sr)
				draw_colored_polygon(star_pts, star_col)
				# White highlight on earned stars
				if is_earned:
					draw_circle(Vector2(sx - 3, star_y - 4), 4.0, Color(1, 1, 1, 0.3))

		# Chest tier name
		var title = "%s Chest" % tier_names[mini(chest_opening_tier, 2)]
		var tw = font.get_string_size(title, HORIZONTAL_ALIGNMENT_CENTER, -1, 20).x
		_udraw(font, Vector2(cx - tw * 0.5, chest_cy + bh + 35), title, HORIZONTAL_ALIGNMENT_LEFT, -1, 20, Color(tier_col.r, tier_col.g, tier_col.b, 0.8))

		# "Tap to Open" prompt (phase 0 only, pulsing)
		if chest_opening_phase == 0:
			var tap_alpha = 0.5 + sin(_time * 3.0) * 0.3
			var tap_text = "Click to Open"
			var tap_w = font.get_string_size(tap_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 18).x
			_udraw(font, Vector2(cx - tap_w * 0.5, chest_cy + bh + 60), tap_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 18, Color(1.0, 0.9, 0.6, tap_alpha))

		# Rising sparkle particles
		for p in range(12):
			var px = cx + sin(_time * 1.1 + float(p) * 2.0) * 130.0
			var py = chest_cy + bh - fmod(_time * 35.0 + float(p) * 45.0, 200.0)
			var pa = clampf(1.0 - (chest_cy + bh - py) / 200.0, 0.0, 0.7)
			var ps = 1.5 + sin(_time * 4.0 + float(p)) * 1.0
			draw_circle(Vector2(px, py), ps, Color(1.0, 0.9, 0.6, pa * 0.5))

	elif chest_opening_phase == 2:
		# === LIGHT BURST when chest opens ===
		var progress = clampf(chest_opening_timer / 0.8, 0.0, 1.0)
		# Radial light rays (more dramatic)
		for r in range(24):
			var angle = float(r) * TAU / 24.0 + _time * 0.3
			var ray_len = 350.0 * progress
			var ray_w = 2.0 + sin(float(r) * 1.5) * 1.5
			var ray_end = Vector2(cx, 310) + Vector2.from_angle(angle) * ray_len
			draw_line(Vector2(cx, 310), ray_end, Color(glow_col.r, glow_col.g, glow_col.b, 0.2 * progress), ray_w)
		# Bright center glows (layered)
		draw_circle(Vector2(cx, 310), 120.0 * progress, Color(1.0, 0.95, 0.8, 0.15 * progress))
		draw_circle(Vector2(cx, 310), 70.0 * progress, Color(1.0, 0.95, 0.85, 0.25 * progress))
		draw_circle(Vector2(cx, 310), 35.0 * progress, Color(1.0, 1.0, 0.9, 0.45 * progress))
		draw_circle(Vector2(cx, 310), 12.0 * progress, Color(1.0, 1.0, 1.0, 0.7 * progress))

	elif chest_opening_phase >= 3 and chest_opening_phase <= 5:
		# === CARDS PHASE (slide, flip, pick) — BRIGHT & EXCITING ===
		var card_w = 170.0
		var card_h = 240.0
		var card_gap = 40.0
		var total_cw = 3.0 * card_w + 2.0 * card_gap
		var start_x = cx - total_cw * 0.5
		var card_y = 220.0
		var pulse = (sin(_time * 2.5) + 1.0) * 0.5

		# Dramatic radial glow behind the entire card area
		for gi in range(6):
			var gr = 380.0 - float(gi) * 50.0 + pulse * 15.0
			draw_circle(Vector2(cx, card_y + card_h * 0.5), gr, Color(glow_col.r, glow_col.g, glow_col.b, 0.02 + float(gi) * 0.008))

		# Ambient floating sparkles across the screen
		for sp in range(20):
			var spx = cx + sin(_time * 0.7 + float(sp) * 1.7) * 500.0
			var spy = 360.0 + cos(_time * 0.9 + float(sp) * 2.3) * 250.0
			var spa = (sin(_time * 3.5 + float(sp) * 1.1) + 1.0) * 0.25
			var sps = 1.0 + sin(_time * 4.0 + float(sp) * 0.8) * 1.0
			draw_circle(Vector2(spx, spy), sps, Color(1.0, 0.95, 0.7, spa))

		for i in range(3):
			var card_x = start_x + float(i) * (card_w + card_gap)
			var ccx = card_x + card_w * 0.5
			var ccy_base = card_y + card_h * 0.5
			# Slide-up animation (phase 3)
			var slide_progress = 1.0
			if chest_opening_phase == 3:
				var per_card_delay = float(i) * 0.2
				slide_progress = clampf((chest_opening_timer - per_card_delay) / 0.4, 0.0, 1.0)
				slide_progress = 1.0 - (1.0 - slide_progress) * (1.0 - slide_progress)
			var actual_y = card_y + (350.0 * (1.0 - slide_progress))
			var alpha = slide_progress
			var card_center = Vector2(ccx, actual_y + card_h * 0.5)

			var is_picked = (chest_opening_picked == i)
			var is_revealed = chest_opening_phase >= 5 or (chest_opening_phase == 4 and i <= chest_opening_flip_index) or is_picked

			# === BRIGHT GLOW HALO behind each card ===
			var halo_pulse = (sin(_time * 3.0 + float(i) * 2.1) + 1.0) * 0.5
			for hi in range(4):
				var hr = 140.0 - float(hi) * 25.0 + halo_pulse * 10.0
				var ha = alpha * (0.04 + float(hi) * 0.015 + halo_pulse * 0.01)
				draw_circle(card_center, hr, Color(glow_col.r, glow_col.g, glow_col.b, ha))

			if not is_revealed:
				# === Face-down card (ornate glowing back) ===
				# Deep shadow
				draw_rect(Rect2(card_x + 5, actual_y + 7, card_w, card_h), Color(0.0, 0.0, 0.0, alpha * 0.6))
				# Outer glow border (bright, pulsing)
				for bi in range(5):
					var bdr_a = alpha * (0.4 - float(bi) * 0.06 + halo_pulse * 0.08)
					draw_rect(Rect2(card_x - float(bi) - 1, actual_y - float(bi) - 1, card_w + float(bi) * 2 + 2, card_h + float(bi) * 2 + 2), Color(tier_col.r, tier_col.g, tier_col.b, bdr_a), false, 2.0)
				# Card back (rich dark)
				draw_rect(Rect2(card_x, actual_y, card_w, card_h), Color(0.06, 0.04, 0.12, alpha))
				# Inner gradient fill
				for gi in range(8):
					var gt = float(gi) / 7.0
					var gy = actual_y + gt * card_h
					var gh = card_h / 7.0
					var shade = 0.08 + sin(gt * PI) * 0.06
					draw_rect(Rect2(card_x + 3, gy, card_w - 6, gh), Color(tier_col.r * shade, tier_col.g * shade, tier_col.b * shade, alpha * 0.8))
				# Bright ornate border lines
				draw_rect(Rect2(card_x, actual_y, card_w, 3), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.8))
				draw_rect(Rect2(card_x, actual_y + card_h - 3, card_w, 3), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.8))
				draw_rect(Rect2(card_x, actual_y, 3, card_h), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.8))
				draw_rect(Rect2(card_x + card_w - 3, actual_y, 3, card_h), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.8))
				# Inner frame highlight
				draw_rect(Rect2(card_x + 6, actual_y + 6, card_w - 12, card_h - 12), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.25), false, 1.0)
				# Diamond pattern (brighter)
				var dcx = card_x + card_w * 0.5
				var dcy = actual_y + card_h * 0.5
				draw_colored_polygon(PackedVector2Array([
					Vector2(dcx, dcy - 50), Vector2(dcx + 40, dcy),
					Vector2(dcx, dcy + 50), Vector2(dcx - 40, dcy)
				]), Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.18))
				draw_colored_polygon(PackedVector2Array([
					Vector2(dcx, dcy - 30), Vector2(dcx + 24, dcy),
					Vector2(dcx, dcy + 30), Vector2(dcx - 24, dcy)
				]), Color(tier_col.r * 1.3, tier_col.g * 1.3, tier_col.b * 1.3, alpha * 0.12))
				# Bright pulsing question mark
				var q_pulse = (sin(_time * 2.5 + float(i) * 1.2) + 1.0) * 0.5
				var qw = font.get_string_size("?", HORIZONTAL_ALIGNMENT_CENTER, -1, 48).x
				draw_circle(Vector2(dcx, dcy), 25.0 + q_pulse * 8.0, Color(tier_col.r, tier_col.g, tier_col.b, alpha * 0.12))
				_udraw(font, Vector2(card_x + (card_w - qw) * 0.5, actual_y + card_h * 0.5 + 18), "?", HORIZONTAL_ALIGNMENT_LEFT, -1, 48, Color(tier_col.r * 1.5, tier_col.g * 1.5, tier_col.b * 1.5, alpha * (0.5 + q_pulse * 0.3)))
				# Corner sparkles
				for ci in range(4):
					var corner_x = card_x + (card_w if ci % 2 == 1 else 0.0)
					var corner_y = actual_y + (card_h if ci >= 2 else 0.0)
					var cs = (sin(_time * 5.0 + float(ci) * 1.5 + float(i) * 2.0) + 1.0) * 0.5
					draw_circle(Vector2(corner_x, corner_y), 3.0 + cs * 2.0, Color(1.0, 0.95, 0.7, alpha * cs * 0.5))
			else:
				# === Face-up card (BRIGHT revealed reward) ===
				# Deep shadow
				draw_rect(Rect2(card_x + 5, actual_y + 7, card_w, card_h), Color(0.0, 0.0, 0.0, alpha * 0.6))
				# Determine card color
				var card_col = glow_col
				if i < chest_opening_cards.size():
					var card = chest_opening_cards[i]
					var is_trinket = card.get("type") == "trinket"
					if is_trinket:
						var rarity = card.get("trinket_rarity", "common")
						if rarity == "common":
							card_col = Color(0.4, 0.6, 1.0)
						elif rarity == "uncommon":
							card_col = Color(0.7, 0.35, 0.9)
						elif rarity == "rare":
							card_col = Color(1.0, 0.8, 0.15)
					else:
						var icon_cols = {"shards": Color(0.7, 0.35, 0.85), "quills": Color(0.35, 0.7, 1.0), "gold": Color(1.0, 0.8, 0.15), "stars": Color(1.0, 0.9, 0.25), "power": Color(1.0, 0.4, 0.25)}
						card_col = icon_cols.get(card.get("type", "gold"), Color(1.0, 0.8, 0.15))

				# Bright outer glow (multiple layers, very visible)
				for bi in range(7):
					var bdr_a = alpha * (0.5 - float(bi) * 0.055 + halo_pulse * 0.06)
					draw_rect(Rect2(card_x - float(bi) - 1, actual_y - float(bi) - 1, card_w + float(bi) * 2 + 2, card_h + float(bi) * 2 + 2), Color(card_col.r, card_col.g, card_col.b, bdr_a), false, 2.5)
				# Card background (subtle gradient)
				draw_rect(Rect2(card_x, actual_y, card_w, card_h), Color(0.04, 0.03, 0.08, alpha))
				for gi in range(6):
					var gt = float(gi) / 5.0
					var gy = actual_y + gt * card_h
					var gh = card_h / 5.0
					var shade = 0.05 + sin(gt * PI) * 0.04
					draw_rect(Rect2(card_x, gy, card_w, gh), Color(card_col.r * shade, card_col.g * shade, card_col.b * shade, alpha * 0.6))
				# Bright border
				draw_rect(Rect2(card_x, actual_y, card_w, card_h), Color(card_col.r, card_col.g, card_col.b, alpha * 0.7), false, 2.0)

				if i < chest_opening_cards.size():
					var card = chest_opening_cards[i]
					var is_trinket = card.get("type") == "trinket"
					if is_trinket:
						var rarity = card.get("trinket_rarity", "common")
						var rarity_col = Color(0.4, 0.6, 1.0)
						if rarity == "uncommon":
							rarity_col = Color(0.7, 0.35, 0.9)
						elif rarity == "rare":
							rarity_col = Color(1.0, 0.8, 0.15)
						# Bright center glow
						draw_circle(card_center, 70, Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.15))
						draw_circle(card_center, 40, Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.1))
						# Gem icon (larger, brighter)
						var gcx = card_x + card_w * 0.5
						var gcy = actual_y + card_h * 0.33
						# Gem glow halo
						draw_circle(Vector2(gcx, gcy), 35 + halo_pulse * 5, Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.2))
						# Gem shape
						draw_colored_polygon(PackedVector2Array([
							Vector2(gcx, gcy - 32), Vector2(gcx + 26, gcy - 12),
							Vector2(gcx + 20, gcy + 24), Vector2(gcx - 20, gcy + 24), Vector2(gcx - 26, gcy - 12)
						]), Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.85))
						# Gem inner highlight
						draw_colored_polygon(PackedVector2Array([
							Vector2(gcx, gcy - 22), Vector2(gcx + 16, gcy - 8),
							Vector2(gcx + 12, gcy + 14), Vector2(gcx - 12, gcy + 14), Vector2(gcx - 16, gcy - 8)
						]), Color(minf(rarity_col.r * 1.5, 1.0), minf(rarity_col.g * 1.5, 1.0), minf(rarity_col.b * 1.5, 1.0), alpha * 0.45))
						# Gem sparkles (multiple, animated)
						for si in range(5):
							var sa = _time * 4.0 + float(si) * 1.3 + float(i) * 2.0
							var ss = (sin(sa) + 1.0) * 0.5
							var sx = gcx + cos(sa * 0.7) * 18.0
							var sy = gcy + sin(sa * 0.5) * 14.0
							draw_circle(Vector2(sx, sy), 1.5 + ss * 2.0, Color(1.0, 1.0, 1.0, alpha * ss * 0.7))
						# Rarity badge (brighter)
						var badge = rarity.to_upper() + " RELIC"
						var badge_w = font.get_string_size(badge, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
						draw_rect(Rect2(card_x + (card_w - badge_w - 16) * 0.5, actual_y + 10, badge_w + 16, 22), Color(rarity_col.r, rarity_col.g, rarity_col.b, alpha * 0.45))
						_udraw(font, Vector2(card_x + (card_w - badge_w) * 0.5, actual_y + 28), badge, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(1.0, 1.0, 1.0, alpha * 0.95))
						# Name (bright white-gold)
						_udraw(font, Vector2(card_x + card_w * 0.5, actual_y + card_h * 0.66), card["name"], HORIZONTAL_ALIGNMENT_CENTER, int(card_w - 16), 13, Color(1.0, 0.95, 0.7, alpha))
						# Description
						_udraw(font, Vector2(card_x + card_w * 0.5, actual_y + card_h * 0.78), card.get("desc", ""), HORIZONTAL_ALIGNMENT_CENTER, int(card_w - 12), 10, Color(0.85, 0.8, 0.65, alpha * 0.9))
					else:
						# === Currency/power card (BRIGHT) ===
						var icon_cols = {"shards": Color(0.7, 0.35, 0.85), "quills": Color(0.35, 0.7, 1.0), "gold": Color(1.0, 0.8, 0.15), "stars": Color(1.0, 0.9, 0.25), "power": Color(1.0, 0.4, 0.25)}
						var icon_col = icon_cols.get(card.get("type", "gold"), Color(1.0, 0.8, 0.15))
						# Center glow
						draw_circle(card_center, 60, Color(icon_col.r, icon_col.g, icon_col.b, alpha * 0.15))
						# Large currency circle icon
						var icx = card_x + card_w * 0.5
						var icy = actual_y + card_h * 0.35
						draw_circle(Vector2(icx, icy), 30 + halo_pulse * 3, Color(icon_col.r, icon_col.g, icon_col.b, alpha * 0.2))
						draw_circle(Vector2(icx, icy), 22, Color(icon_col.r, icon_col.g, icon_col.b, alpha * 0.6))
						draw_circle(Vector2(icx, icy), 16, Color(icon_col.r * 1.3, icon_col.g * 1.3, icon_col.b * 1.3, alpha * 0.35))
						# Currency name (bright)
						_udraw(font, Vector2(card_x + card_w * 0.5, actual_y + card_h * 0.58), card["name"], HORIZONTAL_ALIGNMENT_CENTER, int(card_w - 12), 14, Color(1.0, 0.95, 0.7, alpha))
						# Amount (large, bright green)
						var amt_text = "x%d" % card["amount"]
						var aw = font.get_string_size(amt_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 36).x
						# Amount glow
						draw_circle(Vector2(icx, actual_y + card_h * 0.74), 25, Color(0.3, 1.0, 0.3, alpha * 0.08))
						_udraw(font, Vector2(card_x + (card_w - aw) * 0.5, actual_y + card_h * 0.74 + 12), amt_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 36, Color(0.5, 1.0, 0.5, alpha))
						# Type label
						var type_label = card.get("type", "").to_upper()
						_udraw(font, Vector2(card_x + card_w * 0.5, actual_y + card_h * 0.9), type_label, HORIZONTAL_ALIGNMENT_CENTER, -1, 10, Color(icon_col.r, icon_col.g, icon_col.b, alpha * 0.7))

				# Picked card — bright golden highlight
				if is_picked:
					for bi in range(6):
						var pick_a = 0.35 - float(bi) * 0.05 + halo_pulse * 0.05
						draw_rect(Rect2(card_x - float(bi) * 2 - 2, actual_y - float(bi) * 2 - 2, card_w + float(bi) * 4 + 4, card_h + float(bi) * 4 + 4), Color(1.0, 0.9, 0.3, pick_a), false, 2.5)

				# Shimmer sparkles on each card edge
				for si in range(6):
					var edge_t = fmod(_time * 2.0 + float(si) * 0.5 + float(i) * 1.0, 4.0)
					var ex = card_x
					var ey = actual_y
					if edge_t < 1.0:
						ex = card_x + edge_t * card_w
						ey = actual_y
					elif edge_t < 2.0:
						ex = card_x + card_w
						ey = actual_y + (edge_t - 1.0) * card_h
					elif edge_t < 3.0:
						ex = card_x + card_w - (edge_t - 2.0) * card_w
						ey = actual_y + card_h
					else:
						ex = card_x
						ey = actual_y + card_h - (edge_t - 3.0) * card_h
					var shimmer_a = (sin(_time * 6.0 + float(si) * 2.0) + 1.0) * 0.3
					draw_circle(Vector2(ex, ey), 2.5, Color(1.0, 1.0, 0.9, alpha * shimmer_a))

		# "Choose Your Reward!" instruction (bigger, brighter, pulsing)
		if chest_opening_phase == 5 and chest_opening_picked < 0:
			var inst = "Choose Your Reward!"
			var iw = font.get_string_size(inst, HORIZONTAL_ALIGNMENT_CENTER, -1, 28).x
			var inst_pulse = 0.7 + sin(_time * 3.0) * 0.3
			# Text glow
			draw_circle(Vector2(cx, 180), 80, Color(1.0, 0.9, 0.4, 0.04))
			_udraw(font, Vector2(cx - iw * 0.5 + 2, 192), inst, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(0.0, 0.0, 0.0, 0.4))
			_udraw(font, Vector2(cx - iw * 0.5, 190), inst, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(1.0, 0.95, 0.5, inst_pulse))

	if chest_opening_phase == 6:
		# === RESULT DISPLAY (bright & celebratory) ===
		var res_pulse = (sin(_time * 3.0) + 1.0) * 0.5
		# Radial celebration glow
		for gi in range(5):
			var gr = 200.0 - float(gi) * 30.0 + res_pulse * 10.0
			draw_circle(Vector2(cx, 330), gr, Color(glow_col.r, glow_col.g, glow_col.b, 0.02 + float(gi) * 0.01))
		# Celebration sparkles
		for sp in range(15):
			var spx = cx + sin(_time * 1.2 + float(sp) * 1.5) * 250.0
			var spy = 330.0 + cos(_time * 0.8 + float(sp) * 2.0) * 120.0
			var spa = (sin(_time * 4.0 + float(sp) * 1.3) + 1.0) * 0.3
			draw_circle(Vector2(spx, spy), 1.5 + spa * 1.5, Color(1.0, 0.95, 0.7, spa))
		if chest_opening_picked >= 0 and chest_opening_picked < chest_opening_cards.size():
			var card = chest_opening_cards[chest_opening_picked]
			var is_trinket = card.get("type") == "trinket"
			var res_col = Color(0.7, 0.35, 0.9) if is_trinket else Color(0.5, 1.0, 0.45)
			# Bright glow behind result
			draw_circle(Vector2(cx, 330), 100, Color(res_col.r, res_col.g, res_col.b, 0.1))
			draw_circle(Vector2(cx, 330), 50, Color(res_col.r, res_col.g, res_col.b, 0.06))
			if is_trinket:
				var result = "Relic Acquired!"
				var rw = font.get_string_size(result, HORIZONTAL_ALIGNMENT_CENTER, -1, 32).x
				_udraw(font, Vector2(cx - rw * 0.5 + 2, 302), result, HORIZONTAL_ALIGNMENT_LEFT, -1, 32, Color(0.0, 0.0, 0.0, 0.5))
				_udraw(font, Vector2(cx - rw * 0.5, 300), result, HORIZONTAL_ALIGNMENT_LEFT, -1, 32, Color(1.0, 0.9, 0.35, 0.95))
				var nw = font.get_string_size(card["name"], HORIZONTAL_ALIGNMENT_CENTER, -1, 22).x
				_udraw(font, Vector2(cx - nw * 0.5, 340), card["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 22, Color(1.0, 0.95, 0.7, 0.95))
				var desc = card.get("desc", "")
				var dw = font.get_string_size(desc, HORIZONTAL_ALIGNMENT_CENTER, -1, 16).x
				_udraw(font, Vector2(cx - dw * 0.5, 370), desc, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.85, 0.8, 0.6, 0.85))
			else:
				var result = "You received: %s x%d" % [card["name"], card["amount"]]
				var rw = font.get_string_size(result, HORIZONTAL_ALIGNMENT_CENTER, -1, 28).x
				_udraw(font, Vector2(cx - rw * 0.5 + 2, 332), result, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(0.0, 0.0, 0.0, 0.5))
				_udraw(font, Vector2(cx - rw * 0.5, 330), result, HORIZONTAL_ALIGNMENT_LEFT, -1, 28, Color(0.5, 1.0, 0.5, 0.95))
		var close_alpha = 0.5 + sin(_time * 2.0) * 0.3
		var close_text = "Click anywhere to continue"
		var clw = font.get_string_size(close_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 16).x
		_udraw(font, Vector2(cx - clw * 0.5, 430), close_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.9, 0.8, 0.5, close_alpha))

	# Victory equip overlay (character selection for relic)
	if victory_equip_active:
		_draw_victory_equip_overlay()

func _draw_victory_equip_overlay() -> void:
	# Darken behind
	draw_rect(Rect2(0, 0, 1280, 720), Color(0.0, 0.0, 0.0, 0.7))
	var font = game_font
	var panel_x = 240.0
	var panel_y = 120.0
	var panel_w = 800.0
	var panel_h = 380.0
	# Panel background
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(0.06, 0.04, 0.1, 0.95))
	# Border
	for edge in [Rect2(panel_x, panel_y, panel_w, 2), Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2),
		Rect2(panel_x, panel_y, 2, panel_h), Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h)]:
		draw_rect(edge, Color(0.6, 0.3, 0.75, 0.5))
	# Title
	var title = "Equip Relic: %s" % victory_trinket_pending.get("name", "")
	var tw = font.get_string_size(title, HORIZONTAL_ALIGNMENT_CENTER, -1, 20).x
	_udraw(font, Vector2(panel_x + (panel_w - tw) * 0.5, panel_y + 30), title, HORIZONTAL_ALIGNMENT_CENTER, -1, 20, Color(0.9, 0.75, 0.3, 0.95))
	# Subtitle
	var sub = "Choose a character to equip this relic on:"
	var sw = font.get_string_size(sub, HORIZONTAL_ALIGNMENT_CENTER, -1, 13).x
	_udraw(font, Vector2(panel_x + (panel_w - sw) * 0.5, panel_y + 55), sub, HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(0.7, 0.6, 0.5, 0.7))
	# Relic desc
	var desc = victory_trinket_pending.get("desc", "")
	var dw = font.get_string_size(desc, HORIZONTAL_ALIGNMENT_CENTER, -1, 12).x
	_udraw(font, Vector2(panel_x + (panel_w - dw) * 0.5, panel_y + 72), desc, HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(0.6, 0.5, 0.7, 0.7))
	# Character grid (2 rows: 6 + 5)
	var tower_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom", "scrooge",
		"sherlock", "tarzan", "dracula", "merlin", "frankenstein"]
	var display_names = ["Robin Hood", "Alice", "Wicked Witch", "Peter Pan", "Phantom", "Scrooge",
		"Sherlock", "Tarzan", "Dracula", "Merlin", "Frankenstein"]
	var col_w = 115.0
	var col_gap = 10.0
	var row_h = 80.0
	var grid_x = panel_x + 30.0
	var grid_y = panel_y + 90.0
	var mouse_pos = get_viewport().get_mouse_position()
	for idx in range(tower_names.size()):
		var row = idx / 6
		var col = idx % 6
		var bx = grid_x + float(col) * (col_w + col_gap)
		var by = grid_y + float(row) * (row_h + 15.0)
		var slots = _get_binding_slots(tower_names[idx])
		var current = equipped_bindings.get(tower_names[idx], [])
		var has_room = slots > 0 and current.size() < slots
		var is_hover = mouse_pos.x >= bx and mouse_pos.x <= bx + col_w and mouse_pos.y >= by and mouse_pos.y <= by + row_h
		# Background
		var bg_col = Color(0.12, 0.08, 0.18, 0.8)
		if is_hover and has_room:
			bg_col = Color(0.2, 0.15, 0.3, 0.9)
		elif not has_room:
			bg_col = Color(0.08, 0.06, 0.1, 0.5)
		draw_rect(Rect2(bx, by, col_w, row_h), bg_col)
		if is_hover and has_room:
			draw_rect(Rect2(bx, by, col_w, row_h), Color(0.6, 0.3, 0.75, 0.4), false, 1.5)
		# Mini portrait
		_draw_story_portrait(bx + 5, by + 5, 40.0, tower_names[idx])
		# Name
		_udraw(font, Vector2(bx + 48, by + 22), display_names[idx], HORIZONTAL_ALIGNMENT_LEFT, col_w - 52, 11, Color(0.85, 0.75, 0.4, 0.9 if has_room else 0.4))
		# Slot info
		var slot_text = "%d/%d slots" % [current.size(), slots]
		if slots == 0:
			slot_text = "Lv5 to unlock"
		var slot_col = Color(0.5, 0.7, 0.4, 0.7) if has_room else Color(0.5, 0.35, 0.3, 0.5)
		_udraw(font, Vector2(bx + 48, by + 40), slot_text, HORIZONTAL_ALIGNMENT_LEFT, col_w - 52, 9, slot_col)
		# Level
		var level = survivor_progress.get(tower_names[idx], {}).get("level", 1)
		_udraw(font, Vector2(bx + 48, by + 55), "Lv.%d" % level, HORIZONTAL_ALIGNMENT_LEFT, -1, 9, Color(0.5, 0.45, 0.4, 0.5))
	# Skip / equip later button
	var skip_x = panel_x + (panel_w - 200.0) * 0.5
	var skip_y = panel_y + 310.0
	var skip_hover = mouse_pos.x >= skip_x and mouse_pos.x <= skip_x + 200.0 and mouse_pos.y >= skip_y and mouse_pos.y <= skip_y + 40.0
	draw_rect(Rect2(skip_x, skip_y, 200, 40), Color(0.15, 0.1, 0.08, 0.9 if skip_hover else 0.7))
	draw_rect(Rect2(skip_x, skip_y, 200, 40), Color(0.5, 0.4, 0.3, 0.5 if skip_hover else 0.3), false, 1.0)
	var skip_t = "Equip Later"
	var stw = font.get_string_size(skip_t, HORIZONTAL_ALIGNMENT_CENTER, -1, 14).x
	_udraw(font, Vector2(skip_x + (200 - stw) * 0.5, skip_y + 26), skip_t, HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.7, 0.6, 0.5, 0.85))

func _draw_closed_book() -> void:
	# === STORYBOOK KNOWLEDGE TREE ===
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var font = game_font

	# Navy gradient background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 55.0 + 1), col)

	# Gold double-frame border
	var border_outer = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.35)
	var border_inner = Color(0.54, 0.45, 0.20, 0.2)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 3), border_outer)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 3, panel_w, 3), border_outer)
	draw_rect(Rect2(panel_x, panel_y, 3, panel_h), border_outer)
	draw_rect(Rect2(panel_x + panel_w - 3, panel_y, 3, panel_h), border_outer)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, panel_w - 12, 1), border_inner)
	draw_rect(Rect2(panel_x + 6, panel_y + panel_h - 7, panel_w - 12, 1), border_inner)
	draw_rect(Rect2(panel_x + 6, panel_y + 6, 1, panel_h - 12), border_inner)
	draw_rect(Rect2(panel_x + panel_w - 7, panel_y + 6, 1, panel_h - 12), border_inner)

	# Title
	var title_text = "STORYBOOK KNOWLEDGE"
	var title_size = 24
	var tw = font.get_string_size(title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size).x
	_udraw(font, Vector2(panel_x + (panel_w - tw) * 0.5, panel_y + 34), title_text, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.95, 0.75, 0.2, 0.9))
	# Title underline
	var cx = panel_x + panel_w * 0.5
	draw_line(Vector2(cx - 160, panel_y + 42), Vector2(cx + 160, panel_y + 42), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.5)

	# Knowledge Ink counter
	var ink_text = "Knowledge Ink: %d" % knowledge_ink
	var ink_w = font.get_string_size(ink_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14).x
	_udraw(font, Vector2(panel_x + panel_w - ink_w - 30, panel_y + 34), ink_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.6, 0.45, 0.8, 0.85))

	# 5 branches side by side (compact layout)
	var num_branches = knowledge_branches.size()
	var branch_w = 210.0
	var branch_gap = 14.0
	var total_bw = float(num_branches) * branch_w + float(num_branches - 1) * branch_gap
	var branch_start_x = panel_x + (panel_w - total_bw) * 0.5
	var branch_start_y = panel_y + 62.0
	var node_radius = 16.0
	var node_spacing_y = 52.0

	for bi in range(knowledge_branches.size()):
		var branch = knowledge_branches[bi]
		var bx = branch_start_x + float(bi) * (branch_w + branch_gap)
		var bcol = branch["color"]

		# Branch header
		var bname = branch["name"]
		var bdesc = "(%s)" % branch["desc"]
		var bnw = font.get_string_size(bname, HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x
		_udraw(font, Vector2(bx + (branch_w - bnw) * 0.5, branch_start_y + 14), bname, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(bcol.r, bcol.g, bcol.b, 0.9))
		var bdw = font.get_string_size(bdesc, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x
		_udraw(font, Vector2(bx + (branch_w - bdw) * 0.5, branch_start_y + 26), bdesc, HORIZONTAL_ALIGNMENT_LEFT, -1, 9, Color(bcol.r, bcol.g, bcol.b, 0.5))

		# Nodes (vertical chain)
		var node_cx = bx + branch_w * 0.5
		for ni in range(branch["nodes"].size()):
			var node = branch["nodes"][ni]
			var node_key = "%d_%d" % [bi, ni]
			var is_unlocked = knowledge_tree.get(node_key, false)
			var can_unlock = not is_unlocked and knowledge_ink >= node["cost"]
			if ni > 0:
				can_unlock = can_unlock and knowledge_tree.get("%d_%d" % [bi, ni - 1], false)
			var node_cy = branch_start_y + 60.0 + float(ni) * node_spacing_y
			var is_hovered = (chronicles_hover_branch == bi and chronicles_hover_node == ni)

			# Connection line to previous node
			if ni > 0:
				var prev_y = branch_start_y + 60.0 + float(ni - 1) * node_spacing_y
				var line_col = Color(bcol.r, bcol.g, bcol.b, 0.5) if knowledge_tree.get("%d_%d" % [bi, ni - 1], false) else Color(0.3, 0.3, 0.3, 0.2)
				draw_line(Vector2(node_cx, prev_y + node_radius), Vector2(node_cx, node_cy - node_radius), line_col, 2.0)

			# Node circle
			if is_unlocked:
				# Gold filled (unlocked)
				draw_circle(Vector2(node_cx, node_cy), node_radius, Color(bcol.r * 0.3, bcol.g * 0.3, bcol.b * 0.3, 0.8))
				draw_circle(Vector2(node_cx, node_cy), node_radius - 2, Color(bcol.r, bcol.g, bcol.b, 0.6))
				draw_arc(Vector2(node_cx, node_cy), node_radius, 0, TAU, 24, Color(0.85, 0.65, 0.1, 0.7), 1.5)
				# Checkmark (scaled for smaller radius)
				draw_line(Vector2(node_cx - 5, node_cy), Vector2(node_cx - 1, node_cy + 4), Color(1, 1, 1, 0.8), 2.0)
				draw_line(Vector2(node_cx - 1, node_cy + 4), Vector2(node_cx + 6, node_cy - 4), Color(1, 1, 1, 0.8), 2.0)
			elif can_unlock:
				# Pulsing available
				var pulse = 0.4 + sin(_time * 3.0) * 0.15
				draw_circle(Vector2(node_cx, node_cy), node_radius + 2, Color(bcol.r, bcol.g, bcol.b, pulse * 0.3))
				draw_circle(Vector2(node_cx, node_cy), node_radius, Color(0.08, 0.06, 0.15, 0.9))
				draw_arc(Vector2(node_cx, node_cy), node_radius, 0, TAU, 24, Color(bcol.r, bcol.g, bcol.b, pulse), 1.5)
				# Cost text inside
				var cost_str = "%d" % node["cost"]
				var csw = font.get_string_size(cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
				_udraw(font, Vector2(node_cx - csw * 0.5, node_cy + 4), cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(bcol.r, bcol.g, bcol.b, pulse + 0.3))
			else:
				# Grey locked
				draw_circle(Vector2(node_cx, node_cy), node_radius, Color(0.06, 0.05, 0.10, 0.8))
				draw_arc(Vector2(node_cx, node_cy), node_radius, 0, TAU, 24, Color(0.3, 0.25, 0.2, 0.3), 1.5)
				# Lock icon
				draw_rect(Rect2(node_cx - 5, node_cy - 1, 10, 8), Color(0.3, 0.25, 0.2, 0.5))
				draw_arc(Vector2(node_cx, node_cy - 2), 5, PI, TAU, 8, Color(0.3, 0.25, 0.2, 0.5), 2.0)

			# Hover highlight
			if is_hovered:
				draw_arc(Vector2(node_cx, node_cy), node_radius + 4, 0, TAU, 24, Color(1, 1, 1, 0.3), 1.5)

			# Node name and desc (to the right)
			var text_x = node_cx + node_radius + 8
			var name_col = Color(0.9, 0.8, 0.5, 0.9) if is_unlocked else (Color(bcol.r, bcol.g, bcol.b, 0.7) if can_unlock else Color(0.5, 0.45, 0.4, 0.5))
			_udraw(font, Vector2(text_x, node_cy - 1), node["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 11, name_col)
			_udraw(font, Vector2(text_x, node_cy + 11), node["desc"], HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(name_col.r, name_col.g, name_col.b, name_col.a * 0.7))

func _update_knowledge_hover() -> void:
	var mouse_pos = get_viewport().get_mouse_position()
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var num_branches = knowledge_branches.size()
	var branch_w = 210.0
	var branch_gap = 14.0
	var total_bw = float(num_branches) * branch_w + float(num_branches - 1) * branch_gap
	var branch_start_x = panel_x + (panel_w - total_bw) * 0.5
	var branch_start_y = panel_y + 62.0
	var node_radius = 16.0
	var node_spacing_y = 52.0
	chronicles_hover_branch = -1
	chronicles_hover_node = -1
	for bi in range(knowledge_branches.size()):
		var bx = branch_start_x + float(bi) * (branch_w + branch_gap)
		var node_cx = bx + branch_w * 0.5
		for ni in range(knowledge_branches[bi]["nodes"].size()):
			var node_cy = branch_start_y + 60.0 + float(ni) * node_spacing_y
			if mouse_pos.distance_to(Vector2(node_cx, node_cy)) <= node_radius + 4:
				chronicles_hover_branch = bi
				chronicles_hover_node = ni
				return

func _on_knowledge_tree_clicked(mouse_pos: Vector2) -> void:
	if chronicles_hover_branch < 0 or chronicles_hover_node < 0:
		return
	var bi = chronicles_hover_branch
	var ni = chronicles_hover_node
	var node_key = "%d_%d" % [bi, ni]
	if knowledge_tree.get(node_key, false):
		return  # Already unlocked
	var node = knowledge_branches[bi]["nodes"][ni]
	if knowledge_ink < node["cost"]:
		return  # Can't afford
	# Check prerequisite (previous node in chain must be unlocked)
	if ni > 0 and not knowledge_tree.get("%d_%d" % [bi, ni - 1], false):
		return
	knowledge_ink -= node["cost"]
	knowledge_tree[node_key] = true
	total_knowledge_nodes += 1
	_check_achievement("knowledge_scholar", 1)
	_save_game()
	queue_redraw()

func _draw_daily_reward() -> void:
	# Full-screen dark overlay
	draw_rect(Rect2(0, 0, 1280, 720), Color(0.0, 0.0, 0.02, 0.88))
	var font = game_font
	var cx = 640.0

	# Modal panel
	var modal_w = 700.0
	var modal_h = 380.0
	var modal_x = cx - modal_w * 0.5
	var modal_y = 170.0

	# Panel background
	for i in range(38):
		var t = float(i) / 37.0
		var col = Color(0.08, 0.06, 0.16).lerp(Color(0.05, 0.04, 0.12), t)
		draw_rect(Rect2(modal_x, modal_y + t * modal_h, modal_w, modal_h / 37.0 + 1), col)

	# Gold border
	draw_rect(Rect2(modal_x, modal_y, modal_w, 3), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.5))
	draw_rect(Rect2(modal_x, modal_y + modal_h - 3, modal_w, 3), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.5))
	draw_rect(Rect2(modal_x, modal_y, 3, modal_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.5))
	draw_rect(Rect2(modal_x + modal_w - 3, modal_y, 3, modal_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.5))

	# Title
	var title = "DAILY REWARDS"
	var title_size = 22
	var ttw = font.get_string_size(title, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size).x
	_udraw(font, Vector2(cx - ttw * 0.5, modal_y + 32), title, HORIZONTAL_ALIGNMENT_CENTER, -1, title_size, Color(0.95, 0.75, 0.2, 0.9))
	draw_line(Vector2(cx - 120, modal_y + 40), Vector2(cx + 120, modal_y + 40), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.5)

	# Streak
	var streak_text = "Streak: Day %d" % (daily_streak % 7 + 1)
	var stw = font.get_string_size(streak_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
	_udraw(font, Vector2(cx - stw * 0.5, modal_y + 58), streak_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.6))

	# 7 day cards: row of 4 + row of 3
	var card_w = 130.0
	var card_h = 100.0
	var card_gap = 16.0
	var current_day = daily_streak % 7

	for d in range(7):
		var row = 0 if d < 4 else 1
		var col = d if d < 4 else (d - 4)
		var cards_in_row = 4 if row == 0 else 3
		var row_w = float(cards_in_row) * card_w + float(cards_in_row - 1) * card_gap
		var row_x = cx - row_w * 0.5
		var dx = row_x + float(col) * (card_w + card_gap)
		var dy = modal_y + 75.0 + float(row) * (card_h + 14.0)
		var reward = daily_rewards_schedule[d]
		var is_today = (d == current_day)
		var is_claimed = d < current_day or daily_reward_claimed_today

		# Card background
		var bg_col = Color(0.12, 0.08, 0.22, 0.9) if is_today else Color(0.06, 0.05, 0.14, 0.8)
		if d < current_day:
			bg_col = Color(0.04, 0.10, 0.08, 0.7)  # Completed (green tint)
		draw_rect(Rect2(dx, dy, card_w, card_h), bg_col)

		# Card border
		var bdr = Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7) if is_today else Color(0.3, 0.25, 0.45, 0.3)
		if d < current_day:
			bdr = Color(0.3, 0.6, 0.3, 0.4)
		draw_rect(Rect2(dx, dy, card_w, 2), bdr)
		draw_rect(Rect2(dx, dy + card_h - 2, card_w, 2), bdr)
		draw_rect(Rect2(dx, dy, 2, card_h), bdr)
		draw_rect(Rect2(dx + card_w - 2, dy, 2, card_h), bdr)

		# Today glow
		if is_today and not daily_reward_claimed_today:
			var ga = 0.05 + sin(_time * 3.0) * 0.03
			draw_rect(Rect2(dx - 2, dy - 2, card_w + 4, card_h + 4), Color(menu_gold.r, menu_gold.g, menu_gold.b, ga))

		# Day label
		var day_label = "Day %d" % (d + 1)
		var dlw = font.get_string_size(day_label, HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x
		_udraw(font, Vector2(dx + (card_w - dlw) * 0.5, dy + 18), day_label, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.8))

		# Reward name
		var rname = reward["name"]
		if rname.length() > 16:
			rname = rname.substr(0, 14) + ".."
		var rnw = font.get_string_size(rname, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
		_udraw(font, Vector2(dx + (card_w - rnw) * 0.5, dy + 50), rname, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.9, 0.75, 0.3, 0.85))

		# Amount
		var amt_text = "x%d" % reward["amount"] if reward["type"] != "gold_chest" else "Chest!"
		var aw = font.get_string_size(amt_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16).x
		_udraw(font, Vector2(dx + (card_w - aw) * 0.5, dy + 72), amt_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.4, 0.85, 0.4, 0.9))

		# Claimed checkmark
		if d < current_day:
			draw_line(Vector2(dx + card_w - 22, dy + card_h - 18), Vector2(dx + card_w - 16, dy + card_h - 10), Color(0.3, 0.8, 0.3, 0.7), 2.0)
			draw_line(Vector2(dx + card_w - 16, dy + card_h - 10), Vector2(dx + card_w - 8, dy + card_h - 22), Color(0.3, 0.8, 0.3, 0.7), 2.0)

	# Claim button (only if not yet claimed today)
	if not daily_reward_claimed_today:
		var btn_w = 200.0
		var btn_h = 40.0
		var btn_x = cx - btn_w * 0.5
		var btn_y = modal_y + modal_h - 60.0
		var btn_col = Color(0.54, 0.45, 0.20, 0.8 + sin(_time * 2.5) * 0.1)
		draw_rect(Rect2(btn_x, btn_y, btn_w, btn_h), btn_col)
		draw_rect(Rect2(btn_x, btn_y, btn_w, 2), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.5))
		var claim_text = "CLAIM REWARD"
		var claim_tw = font.get_string_size(claim_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16).x
		_udraw(font, Vector2(btn_x + (btn_w - claim_tw) * 0.5, btn_y + 27), claim_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0.04, 0.04, 0.10, 0.95))
	else:
		var done_text = "Reward claimed! Come back tomorrow."
		var done_w = font.get_string_size(done_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14).x
		_udraw(font, Vector2(cx - done_w * 0.5, modal_y + modal_h - 40), done_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.4, 0.8, 0.4, 0.7))

	# Close button (X in top-right)
	var close_x = modal_x + modal_w - 30
	var close_y = modal_y + 10
	_udraw(font, Vector2(close_x, close_y + 16), "X", HORIZONTAL_ALIGNMENT_LEFT, -1, 18, Color(menu_text.r, menu_text.g, menu_text.b, 0.7))

func _on_daily_reward_clicked(mouse_pos: Vector2) -> void:
	var cx = 640.0
	var modal_w = 700.0
	var modal_h = 380.0
	var modal_x = cx - modal_w * 0.5
	var modal_y = 170.0

	# Close button
	var close_x = modal_x + modal_w - 35
	var close_y = modal_y + 5
	if mouse_pos.x >= close_x and mouse_pos.x <= close_x + 30 and mouse_pos.y >= close_y and mouse_pos.y <= close_y + 25:
		daily_reward_open = false
		queue_redraw()
		return

	# Claim button
	if not daily_reward_claimed_today:
		var btn_w = 200.0
		var btn_h = 40.0
		var btn_x = cx - btn_w * 0.5
		var btn_y = modal_y + modal_h - 60.0
		if mouse_pos.x >= btn_x and mouse_pos.x <= btn_x + btn_w and mouse_pos.y >= btn_y and mouse_pos.y <= btn_y + btn_h:
			_claim_daily_reward()
			return

	# Click outside modal to close
	if mouse_pos.x < modal_x or mouse_pos.x > modal_x + modal_w or mouse_pos.y < modal_y or mouse_pos.y > modal_y + modal_h:
		daily_reward_open = false
		queue_redraw()

func _draw_survivor_grid() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 38.0
	var panel_w = 1140.0
	var panel_h = 570.0

	# Panel background gradient
	for row in range(58):
		var t = float(row) / 57.0
		var bg_col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 57.0 + 1), bg_col)

	# Accent border with inner glow
	var border_col = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.3)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), border_col)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), border_col)
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), border_col)
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), border_col)

	# === "SURVIVORS" title banner ===
	var title_y = panel_y + 6.0
	var title_text = "SURVIVORS"
	var title_w = font.get_string_size(title_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 22).x
	var title_cx = panel_x + panel_w * 0.5
	# Title background bar
	draw_rect(Rect2(title_cx - title_w * 0.5 - 40, title_y, title_w + 80, 28), Color(0.03, 0.03, 0.08, 0.8))
	draw_rect(Rect2(title_cx - title_w * 0.5 - 40, title_y + 27, title_w + 80, 2), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3))
	# Title text with shadow
	_udraw(font, Vector2(title_cx - title_w * 0.5 + 1, title_y + 21), title_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 22, Color(0, 0, 0, 0.5))
	_udraw(font, Vector2(title_cx - title_w * 0.5, title_y + 20), title_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 22, menu_gold)
	# Decorative lines beside title
	draw_line(Vector2(title_cx - title_w * 0.5 - 80, title_y + 14), Vector2(title_cx - title_w * 0.5 - 44, title_y + 14), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.0)
	draw_line(Vector2(title_cx + title_w * 0.5 + 44, title_y + 14), Vector2(title_cx + title_w * 0.5 + 80, title_y + 14), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3), 1.0)

	# === PARTY count badge (top-right) ===
	var party_text = "PARTY: %d/%d" % [survivor_types.size(), survivor_types.size()]
	var party_w = font.get_string_size(party_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
	draw_rect(Rect2(panel_x + panel_w - party_w - 30, title_y + 4, party_w + 20, 20), Color(menu_accent_purple.r, menu_accent_purple.g, menu_accent_purple.b, 0.6))
	draw_rect(Rect2(panel_x + panel_w - party_w - 30, title_y + 4, party_w + 20, 20), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.25), false, 1.0)
	_udraw(font, Vector2(panel_x + panel_w - party_w - 20, title_y + 18), party_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, menu_gold_light)

	var card_colors_grid = [
		Color(0.29, 0.55, 0.25),  # Robin Hood
		Color(0.44, 0.66, 0.86),  # Alice
		Color(0.48, 0.25, 0.63),  # Wicked Witch
		Color(0.90, 0.49, 0.13),  # Peter Pan
		Color(0.75, 0.22, 0.17),  # Phantom
		Color(0.79, 0.66, 0.30),  # Scrooge
		Color(0.20, 0.35, 0.55),  # Sherlock
		Color(0.30, 0.50, 0.20),  # Tarzan
		Color(0.50, 0.10, 0.15),  # Dracula
		Color(0.25, 0.20, 0.55),  # Merlin
		Color(0.35, 0.40, 0.30),  # Frankenstein
	]

	# BATTD-style grid: 2 rows of cards with large character portraits
	# Row 1: 6 cards, Row 2: 5 cards (centered)
	var card_w = 170.0
	var card_h = 230.0
	var gap_x = 12.0
	var gap_y = 12.0
	var grid_start_y = panel_y + 42.0

	for i in range(survivor_types.size()):
		var row_i: int
		var col_i: int
		var cards_in_row: int
		if i < 6:
			row_i = 0
			col_i = i
			cards_in_row = 6
		else:
			row_i = 1
			col_i = i - 6
			cards_in_row = 5
		var row_w = float(cards_in_row) * card_w + float(cards_in_row - 1) * gap_x
		var row_x = panel_x + (panel_w - row_w) * 0.5
		var cx = row_x + float(col_i) * (card_w + gap_x)
		var cy = grid_start_y + float(row_i) * (card_h + gap_y)

		var tower_type = survivor_types[i]
		var info = tower_info[tower_type]
		var accent = card_colors_grid[mini(i, card_colors_grid.size() - 1)]
		var unlocked = _is_character_unlocked(tower_type)
		var is_hovered = (world_map_hover_index == i)
		var speaker_name = _tower_type_to_name(tower_type)

		# === Card shadow ===
		draw_rect(Rect2(cx + 3, cy + 3, card_w, card_h), Color(0.0, 0.0, 0.0, 0.4))

		# === Card background — gradient with character accent ===
		draw_rect(Rect2(cx, cy, card_w, card_h), Color(0.05, 0.05, 0.12))
		# Accent gradient at top
		for gi in range(int(card_h * 0.4)):
			var gt = float(gi) / (card_h * 0.4)
			draw_rect(Rect2(cx, cy + float(gi), card_w, 1), Color(accent.r, accent.g, accent.b, 0.08 * (1.0 - gt)))

		# === Character portrait (large, centered) ===
		var portrait_cx = cx + card_w * 0.5
		var portrait_cy = cy + card_h * 0.42
		if unlocked:
			# Character accent glow
			draw_circle(Vector2(portrait_cx, portrait_cy + 10), 55.0, Color(accent.r, accent.g, accent.b, 0.06))
			# Draw full character portrait using story portrait system
			_draw_story_portrait(portrait_cx, portrait_cy + 30, 130.0, speaker_name)
		else:
			# Dark silhouette placeholder
			draw_circle(Vector2(portrait_cx, portrait_cy), 35.0, Color(0.08, 0.08, 0.15, 0.5))
			_udraw(font, Vector2(portrait_cx - 5, portrait_cy + 5), "?", HORIZONTAL_ALIGNMENT_CENTER, -1, 30, Color(0.3, 0.3, 0.4, 0.5))

		# === Level badge (top-left corner circle) ===
		if unlocked:
			var progress = survivor_progress.get(tower_type, {"level": 1})
			var lvl = progress.get("level", 1)
			var badge_cx = cx + 20.0
			var badge_cy = cy + 20.0
			# Badge circle: dark background + accent ring
			draw_circle(Vector2(badge_cx, badge_cy), 16, Color(0.02, 0.02, 0.06, 0.9))
			draw_circle(Vector2(badge_cx, badge_cy), 14, Color(accent.r, accent.g, accent.b, 0.6))
			draw_circle(Vector2(badge_cx, badge_cy), 11, Color(0.03, 0.03, 0.08))
			# Level number
			var lvl_str = str(lvl)
			var lvl_w = font.get_string_size(lvl_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
			_udraw(font, Vector2(badge_cx - lvl_w * 0.5, badge_cy + 5), lvl_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color.WHITE)

		# === Star rating (top-right) ===
		var stars_earned = 0
		for ls_key in level_stars:
			if typeof(ls_key) == TYPE_STRING and ls_key.begins_with(str(i) + "_"):
				stars_earned += level_stars[ls_key]
		if unlocked:
			var star_x = cx + card_w - 18.0
			var star_y = cy + 16.0
			# Star badge circle
			draw_circle(Vector2(star_x, star_y), 13, Color(0.02, 0.02, 0.06, 0.8))
			draw_circle(Vector2(star_x, star_y), 11, Color(0.85, 0.65, 0.1, 0.7))
			draw_circle(Vector2(star_x, star_y), 9, Color(0.03, 0.03, 0.08))
			# Star icon
			var sp = Vector2(star_x, star_y)
			var sr = 6.0
			var star_pts = PackedVector2Array()
			for si in range(10):
				var sa = -PI * 0.5 + float(si) * TAU / 10.0
				var sd = sr if si % 2 == 0 else sr * 0.45
				star_pts.append(sp + Vector2(cos(sa) * sd, sin(sa) * sd))
			draw_colored_polygon(star_pts, Color(1.0, 0.85, 0.2, 0.9))

		# === Character name plate (bottom) ===
		var name_plate_y = cy + card_h - 38.0
		draw_rect(Rect2(cx, name_plate_y, card_w, 38), Color(0.03, 0.03, 0.08, 0.85))
		draw_rect(Rect2(cx, name_plate_y, card_w, 1), Color(accent.r, accent.g, accent.b, 0.3))
		var name_str: String = info["name"]
		var name_w = font.get_string_size(name_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
		# Name with shadow
		_udraw(font, Vector2(cx + (card_w - name_w) * 0.5 + 1, name_plate_y + 16), name_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0, 0, 0, 0.5))
		_udraw(font, Vector2(cx + (card_w - name_w) * 0.5, name_plate_y + 15), name_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, menu_parchment if unlocked else Color(0.4, 0.38, 0.45))
		# Novel subtitle
		var novel_str = character_novels[i] if i < character_novels.size() else ""
		if novel_str.length() > 22:
			novel_str = novel_str.substr(0, 20) + ".."
		var novel_w = font.get_string_size(novel_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x
		_udraw(font, Vector2(cx + (card_w - novel_w) * 0.5, name_plate_y + 30), novel_str, HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 8), 9, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.6) if unlocked else Color(0.3, 0.28, 0.35, 0.5))

		# === Card border frame ===
		var bdr_col: Color
		if not unlocked:
			bdr_col = Color(0.25, 0.25, 0.35, 0.4)
		elif is_hovered:
			bdr_col = Color(accent.r, accent.g, accent.b, 0.8)
		else:
			bdr_col = Color(accent.r, accent.g, accent.b, 0.4)
		# Outer border (thick frame like BATTD)
		draw_rect(Rect2(cx, cy, card_w, 3), bdr_col)
		draw_rect(Rect2(cx, cy + card_h - 3, card_w, 3), bdr_col)
		draw_rect(Rect2(cx, cy, 3, card_h), bdr_col)
		draw_rect(Rect2(cx + card_w - 3, cy, 3, card_h), bdr_col)

		# === Locked overlay ===
		if not unlocked:
			draw_rect(Rect2(cx + 3, cy + 3, card_w - 6, card_h - 6), Color(0.0, 0.0, 0.02, 0.6))
			# Padlock
			var lock_cx = cx + card_w * 0.5
			var lock_cy = cy + card_h * 0.4
			draw_rect(Rect2(lock_cx - 14, lock_cy, 28, 22), Color(0.3, 0.25, 0.40, 0.7))
			draw_arc(Vector2(lock_cx, lock_cy), 11, PI, TAU, 12, Color(0.35, 0.30, 0.45, 0.7), 3.0)
			draw_circle(Vector2(lock_cx, lock_cy + 10), 3, Color(0.04, 0.04, 0.10))
			draw_rect(Rect2(lock_cx - 1.5, lock_cy + 11, 3, 5), Color(0.04, 0.04, 0.10))

		# === Hover glow ===
		if unlocked and is_hovered:
			var glow_a = 0.10 + 0.05 * sin(_time * 3.0)
			draw_rect(Rect2(cx + 3, cy + 3, card_w - 6, card_h - 6), Color(accent.r, accent.g, accent.b, glow_a))
			# Bright border on hover
			draw_rect(Rect2(cx, cy, card_w, 3), Color(accent.r, accent.g, accent.b, 0.9))
			draw_rect(Rect2(cx, cy + card_h - 3, card_w, 3), Color(accent.r, accent.g, accent.b, 0.9))
			draw_rect(Rect2(cx, cy, 3, card_h), Color(accent.r, accent.g, accent.b, 0.9))
			draw_rect(Rect2(cx + card_w - 3, cy, 3, card_h), Color(accent.r, accent.g, accent.b, 0.9))

func _draw_new_character_portrait(idx: int, center: Vector2, col: Color) -> void:
	var cx = center.x
	var cy = center.y
	var head_y = cy - 20
	var body_y = cy - 8
	# Head
	draw_circle(Vector2(cx, head_y), 8, Color(0.85, 0.72, 0.55, 0.8))
	# Eyes
	draw_circle(Vector2(cx - 3, head_y - 1), 1.5, Color(0.1, 0.1, 0.1, 0.7))
	draw_circle(Vector2(cx + 3, head_y - 1), 1.5, Color(0.1, 0.1, 0.1, 0.7))
	# Body
	draw_colored_polygon(PackedVector2Array([Vector2(cx - 8, body_y), Vector2(cx + 8, body_y), Vector2(cx + 12, body_y + 22), Vector2(cx - 12, body_y + 22)]), Color(col.r, col.g, col.b, 0.7))
	match idx:
		6:  # Sherlock - deerstalker hat + pipe
			draw_rect(Rect2(cx - 8, head_y - 10, 16, 6), Color(0.35, 0.25, 0.15, 0.7))
			draw_rect(Rect2(cx - 10, head_y - 5, 20, 3), Color(0.35, 0.25, 0.15, 0.6))
			# Pipe
			draw_line(Vector2(cx + 5, head_y + 4), Vector2(cx + 15, head_y + 2), Color(0.4, 0.3, 0.15, 0.6), 2.0)
			draw_rect(Rect2(cx + 13, head_y - 4, 5, 6), Color(0.4, 0.3, 0.15, 0.6))
		7:  # Tarzan - wild hair + loincloth
			for hi in range(5):
				var hx = cx - 6 + hi * 3
				var hy = head_y - 8 - (hi % 2) * 3
				draw_line(Vector2(hx, hy), Vector2(hx + 1, head_y - 3), Color(0.35, 0.25, 0.1, 0.6), 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 6, body_y + 16), Vector2(cx + 6, body_y + 16), Vector2(cx + 4, body_y + 24), Vector2(cx - 4, body_y + 24)]), Color(0.5, 0.35, 0.15, 0.6))
		8:  # Dracula - high collar cape
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 12, body_y - 4), Vector2(cx + 12, body_y - 4), Vector2(cx + 20, body_y + 25), Vector2(cx - 20, body_y + 25)]), Color(0.15, 0.02, 0.02, 0.6))
			# High collar
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 6, head_y + 4), Vector2(cx - 10, head_y - 2), Vector2(cx - 8, body_y)]), Color(0.15, 0.02, 0.02, 0.7))
			draw_colored_polygon(PackedVector2Array([Vector2(cx + 6, head_y + 4), Vector2(cx + 10, head_y - 2), Vector2(cx + 8, body_y)]), Color(0.15, 0.02, 0.02, 0.7))
			# Fangs
			draw_line(Vector2(cx - 2, head_y + 4), Vector2(cx - 2, head_y + 7), Color(0.9, 0.9, 0.9, 0.5), 1.0)
			draw_line(Vector2(cx + 2, head_y + 4), Vector2(cx + 2, head_y + 7), Color(0.9, 0.9, 0.9, 0.5), 1.0)
		9:  # Merlin - wizard hat + staff
			draw_colored_polygon(PackedVector2Array([Vector2(cx, head_y - 22), Vector2(cx - 10, head_y - 6), Vector2(cx + 10, head_y - 6)]), Color(0.15, 0.10, 0.40, 0.7))
			draw_rect(Rect2(cx - 12, head_y - 7, 24, 3), Color(0.15, 0.10, 0.40, 0.6))
			# Staff
			draw_line(Vector2(cx + 15, body_y - 5), Vector2(cx + 15, body_y + 24), Color(0.5, 0.35, 0.15, 0.6), 2.0)
			draw_circle(Vector2(cx + 15, body_y - 5), 4, Color(0.4, 0.3, 0.8, 0.5))
		10:  # Frankenstein - flat top head + bolts
			draw_rect(Rect2(cx - 8, head_y - 10, 16, 4), Color(0.3, 0.35, 0.25, 0.7))
			# Neck bolts
			draw_circle(Vector2(cx - 10, head_y + 4), 2, Color(0.5, 0.5, 0.5, 0.6))
			draw_circle(Vector2(cx + 10, head_y + 4), 2, Color(0.5, 0.5, 0.5, 0.6))
			# Stitches on forehead
			draw_line(Vector2(cx - 4, head_y - 5), Vector2(cx + 4, head_y - 5), Color(0.2, 0.2, 0.2, 0.5), 1.0)
			draw_line(Vector2(cx - 2, head_y - 7), Vector2(cx - 2, head_y - 3), Color(0.2, 0.2, 0.2, 0.5), 1.0)
			draw_line(Vector2(cx + 2, head_y - 7), Vector2(cx + 2, head_y - 3), Color(0.2, 0.2, 0.2, 0.5), 1.0)

func _draw_zone_character(idx: int, center: Vector2, col: Color, pulse: float) -> void:
	var cx = center.x
	var cy = center.y + pulse
	var head_y = cy - 20
	var body_y = cy - 8

	# Head
	draw_circle(Vector2(cx, head_y), 8, Color(0.85, 0.72, 0.55, 0.8))
	# Eyes
	draw_circle(Vector2(cx - 3, head_y - 1), 1.5, Color(0.1, 0.1, 0.1, 0.7))
	draw_circle(Vector2(cx + 3, head_y - 1), 1.5, Color(0.1, 0.1, 0.1, 0.7))
	# Body (trapezoid)
	draw_colored_polygon(PackedVector2Array([Vector2(cx - 8, body_y), Vector2(cx + 8, body_y), Vector2(cx + 12, body_y + 22), Vector2(cx - 12, body_y + 22)]), Color(col.r, col.g, col.b, 0.7))

	match idx:
		0:  # Robin Hood - hat + bow
			draw_colored_polygon(PackedVector2Array([Vector2(cx, head_y - 16), Vector2(cx - 10, head_y - 6), Vector2(cx + 6, head_y - 6)]), Color(0.2, 0.4, 0.1, 0.7))
			draw_line(Vector2(cx + 2, head_y - 14), Vector2(cx + 8, head_y - 20), Color(0.8, 0.2, 0.1, 0.5), 1.5)
			draw_arc(Vector2(cx + 20, cy + pulse), 10, -PI * 0.4, PI * 0.4, 12, Color(0.5, 0.35, 0.15, 0.6), 2.0)
		1:  # Alice - hair + cards
			draw_rect(Rect2(cx - 9, head_y - 6, 18, 4), Color(0.9, 0.8, 0.4, 0.6))
			draw_rect(Rect2(cx - 10, head_y - 2, 3, 16), Color(0.9, 0.8, 0.4, 0.5))
			draw_rect(Rect2(cx + 7, head_y - 2, 3, 16), Color(0.9, 0.8, 0.4, 0.5))
			draw_rect(Rect2(cx - 9, head_y - 7, 18, 2), Color(0.3, 0.5, 0.8, 0.6))
			draw_rect(Rect2(cx + 14, body_y + 2, 8, 12), Color(0.9, 0.87, 0.8, 0.5))
			draw_circle(Vector2(cx + 18, body_y + 8), 2, Color(0.8, 0.15, 0.2, 0.5))
		2:  # Wicked Witch - pointy hat + broom
			draw_colored_polygon(PackedVector2Array([Vector2(cx, head_y - 22), Vector2(cx - 10, head_y - 6), Vector2(cx + 10, head_y - 6)]), Color(0.1, 0.1, 0.1, 0.7))
			draw_rect(Rect2(cx - 12, head_y - 7, 24, 3), Color(0.1, 0.1, 0.1, 0.6))
			draw_line(Vector2(cx - 15, body_y + 5), Vector2(cx - 25, body_y + 25), Color(0.5, 0.35, 0.15, 0.6), 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 28, body_y + 22), Vector2(cx - 22, body_y + 22), Vector2(cx - 25, body_y + 32)]), Color(0.4, 0.3, 0.1, 0.5))
			draw_circle(Vector2(cx, head_y), 8, Color(0.3, 0.6, 0.2, 0.15))
		3:  # Peter Pan - cap + dagger
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 8, head_y - 6), Vector2(cx + 8, head_y - 6), Vector2(cx + 12, head_y - 12)]), Color(0.2, 0.5, 0.15, 0.7))
			draw_line(Vector2(cx + 10, head_y - 12), Vector2(cx + 16, head_y - 20), Color(0.9, 0.3, 0.1, 0.5), 1.5)
			draw_line(Vector2(cx + 14, body_y + 4), Vector2(cx + 22, body_y - 2), Color(0.7, 0.72, 0.75, 0.6), 2.0)
			draw_line(Vector2(cx + 13, body_y + 5), Vector2(cx + 16, body_y + 3), Color(0.5, 0.35, 0.15, 0.6), 2.0)
		4:  # Phantom - cape + mask
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 10, body_y - 2), Vector2(cx + 10, body_y - 2), Vector2(cx + 18, body_y + 25), Vector2(cx - 18, body_y + 25)]), Color(0.1, 0.08, 0.08, 0.6))
			draw_arc(Vector2(cx, head_y), 8, PI + 0.2, TAU - 0.2, 12, Color(0.9, 0.88, 0.82, 0.6), 2.5)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - 8, body_y), Vector2(cx + 8, body_y), Vector2(cx + 10, body_y + 20), Vector2(cx - 10, body_y + 20)]), Color(col.r, col.g, col.b, 0.7))
		5:  # Scrooge - top hat + cane
			draw_rect(Rect2(cx - 8, head_y - 18, 16, 14), Color(0.1, 0.1, 0.1, 0.7))
			draw_rect(Rect2(cx - 11, head_y - 5, 22, 3), Color(0.1, 0.1, 0.1, 0.6))
			draw_line(Vector2(cx + 14, body_y + 2), Vector2(cx + 14, body_y + 24), Color(0.4, 0.3, 0.15, 0.6), 2.0)
			draw_arc(Vector2(cx + 14, body_y + 2), 4, PI, TAU, 8, Color(0.4, 0.3, 0.15, 0.6), 2.0)

func _update_world_map_hover() -> void:
	var mouse_pos = get_viewport().get_mouse_position()
	world_map_hover_index = -1
	var panel_x = 70.0
	var panel_w = 1140.0
	var card_w = 170.0
	var card_h = 230.0
	var gap_x = 12.0
	var gap_y = 12.0
	var grid_start_y = 38.0 + 42.0
	for i in range(survivor_types.size()):
		var row_i: int
		var col_i: int
		var cards_in_row: int
		if i < 6:
			row_i = 0
			col_i = i
			cards_in_row = 6
		else:
			row_i = 1
			col_i = i - 6
			cards_in_row = 5
		var row_w = float(cards_in_row) * card_w + float(cards_in_row - 1) * gap_x
		var row_x = panel_x + (panel_w - row_w) * 0.5
		var cx = row_x + float(col_i) * (card_w + gap_x)
		var cy = grid_start_y + float(row_i) * (card_h + gap_y)
		if Rect2(cx, cy, card_w, card_h).has_point(mouse_pos):
			world_map_hover_index = i
			break

func _draw_relic_icon(center: Vector2, icon_key: String, sz: float, accent: Color) -> void:
	var cx = center.x
	var cy = center.y
	var s = sz * 0.5
	match icon_key:
		"green_cloak":
			# Cloak shape - triangular drape
			var cloak_col = Color(0.2, 0.55, 0.15, 0.8)
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy - s * 0.8), Vector2(cx + s * 0.7, cy + s * 0.8), Vector2(cx - s * 0.7, cy + s * 0.8)]), cloak_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.3, cy - s * 0.6), Vector2(cx + s * 0.3, cy - s * 0.6), Vector2(cx + s * 0.15, cy - s * 0.35), Vector2(cx - s * 0.15, cy - s * 0.35)]), Color(0.15, 0.45, 0.1, 0.9))
			# Clasp
			draw_circle(Vector2(cx, cy - s * 0.45), s * 0.12, Color(0.85, 0.65, 0.1))
		"silver_arrow":
			# Arrow pointing right
			var arr_col = Color(0.8, 0.82, 0.85, 0.9)
			draw_line(Vector2(cx - s * 0.8, cy), Vector2(cx + s * 0.5, cy), arr_col, 2.0)
			# Arrowhead
			draw_colored_polygon(PackedVector2Array([Vector2(cx + s * 0.8, cy), Vector2(cx + s * 0.4, cy - s * 0.25), Vector2(cx + s * 0.4, cy + s * 0.25)]), arr_col)
			# Fletching
			draw_line(Vector2(cx - s * 0.8, cy), Vector2(cx - s * 0.6, cy - s * 0.2), Color(0.6, 0.5, 0.4), 1.5)
			draw_line(Vector2(cx - s * 0.8, cy), Vector2(cx - s * 0.6, cy + s * 0.2), Color(0.6, 0.5, 0.4), 1.5)
		"longbow":
			# Curved bow
			var bow_col = Color(0.55, 0.35, 0.15, 0.9)
			draw_arc(Vector2(cx + s * 0.3, cy), s * 0.75, PI * 0.6, PI * 1.4, 12, bow_col, 2.5)
			# String
			draw_line(Vector2(cx + s * 0.3 - s * 0.75 * cos(PI * 0.6), cy - s * 0.75 * sin(PI * 0.6)), Vector2(cx + s * 0.3 - s * 0.75 * cos(PI * 1.4), cy - s * 0.75 * sin(PI * 1.4)), Color(0.7, 0.65, 0.55), 1.0)
		"flask":
			# Bottle shape
			var flask_col = Color(0.5, 0.35, 0.15, 0.7)
			# Neck
			draw_rect(Rect2(cx - s * 0.12, cy - s * 0.7, s * 0.24, s * 0.35), flask_col)
			# Body
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.12, cy - s * 0.35), Vector2(cx + s * 0.12, cy - s * 0.35), Vector2(cx + s * 0.35, cy - s * 0.05), Vector2(cx + s * 0.35, cy + s * 0.65), Vector2(cx - s * 0.35, cy + s * 0.65), Vector2(cx - s * 0.35, cy - s * 0.05)]), flask_col)
			# Liquid
			draw_rect(Rect2(cx - s * 0.3, cy + s * 0.15, s * 0.6, s * 0.45), Color(0.8, 0.6, 0.1, 0.6))
			# Cork
			draw_rect(Rect2(cx - s * 0.15, cy - s * 0.75, s * 0.3, s * 0.1), Color(0.6, 0.45, 0.2))
		"horn":
			# Curved horn
			var horn_col = Color(0.7, 0.55, 0.25, 0.85)
			draw_arc(Vector2(cx, cy + s * 0.3), s * 0.7, PI * 1.2, PI * 1.9, 10, horn_col, 3.5)
			# Bell end
			draw_circle(Vector2(cx + s * 0.55, cy - s * 0.15), s * 0.2, horn_col)
			draw_circle(Vector2(cx + s * 0.55, cy - s * 0.15), s * 0.12, Color(0.3, 0.2, 0.1, 0.5))
			# Mouthpiece
			draw_circle(Vector2(cx - s * 0.45, cy + s * 0.35), s * 0.08, horn_col)
		"gold_crown":
			# Crown
			var crown_col = Color(0.9, 0.7, 0.1, 0.9)
			# Base band
			draw_rect(Rect2(cx - s * 0.55, cy + s * 0.1, s * 1.1, s * 0.35), crown_col)
			# Three points
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.55, cy + s * 0.1), Vector2(cx - s * 0.35, cy - s * 0.5), Vector2(cx - s * 0.15, cy + s * 0.1)]), crown_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.2, cy + s * 0.1), Vector2(cx, cy - s * 0.65), Vector2(cx + s * 0.2, cy + s * 0.1)]), crown_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx + s * 0.15, cy + s * 0.1), Vector2(cx + s * 0.35, cy - s * 0.5), Vector2(cx + s * 0.55, cy + s * 0.1)]), crown_col)
			# Gems
			draw_circle(Vector2(cx, cy + s * 0.25), s * 0.1, Color(0.8, 0.1, 0.1, 0.8))
			draw_circle(Vector2(cx - s * 0.3, cy + s * 0.25), s * 0.07, Color(0.1, 0.4, 0.8, 0.8))
			draw_circle(Vector2(cx + s * 0.3, cy + s * 0.25), s * 0.07, Color(0.1, 0.8, 0.3, 0.8))
		"drink_me":
			# Small bottle with label
			var bottle_col = Color(0.3, 0.5, 0.8, 0.7)
			draw_rect(Rect2(cx - s * 0.1, cy - s * 0.65, s * 0.2, s * 0.3), bottle_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.1, cy - s * 0.35), Vector2(cx + s * 0.1, cy - s * 0.35), Vector2(cx + s * 0.3, cy - s * 0.1), Vector2(cx + s * 0.3, cy + s * 0.65), Vector2(cx - s * 0.3, cy + s * 0.65), Vector2(cx - s * 0.3, cy - s * 0.1)]), bottle_col)
			# Liquid shimmer
			draw_rect(Rect2(cx - s * 0.25, cy + s * 0.2, s * 0.5, s * 0.4), Color(0.4, 0.2, 0.7, 0.5))
			# Label tag
			draw_rect(Rect2(cx - s * 0.18, cy - s * 0.05, s * 0.36, s * 0.18), Color(0.9, 0.85, 0.7, 0.8))
			# Cork
			draw_rect(Rect2(cx - s * 0.12, cy - s * 0.72, s * 0.24, s * 0.1), Color(0.6, 0.45, 0.2))
		"eat_me_cake":
			# Frosted cake
			var cake_col = Color(0.75, 0.55, 0.3, 0.85)
			# Base
			draw_rect(Rect2(cx - s * 0.45, cy + s * 0.1, s * 0.9, s * 0.45), cake_col)
			# Frosting top
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.5, cy + s * 0.1), Vector2(cx + s * 0.5, cy + s * 0.1), Vector2(cx + s * 0.45, cy - s * 0.15), Vector2(cx - s * 0.45, cy - s * 0.15)]), Color(0.95, 0.85, 0.9, 0.9))
			# Cherry on top
			draw_circle(Vector2(cx, cy - s * 0.3), s * 0.12, Color(0.9, 0.15, 0.15, 0.9))
			# Drip frosting
			draw_rect(Rect2(cx - s * 0.15, cy + s * 0.1, s * 0.08, s * 0.15), Color(0.95, 0.85, 0.9, 0.7))
			draw_rect(Rect2(cx + s * 0.12, cy + s * 0.1, s * 0.08, s * 0.2), Color(0.95, 0.85, 0.9, 0.7))
		"vorpal_sword":
			# Jagged blade
			var blade_col = Color(0.75, 0.8, 0.85, 0.9)
			# Blade
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.05, cy + s * 0.5), Vector2(cx + s * 0.05, cy + s * 0.5), Vector2(cx + s * 0.08, cy - s * 0.1), Vector2(cx + s * 0.15, cy - s * 0.25), Vector2(cx + s * 0.05, cy - s * 0.4), Vector2(cx + s * 0.1, cy - s * 0.6), Vector2(cx, cy - s * 0.8), Vector2(cx - s * 0.1, cy - s * 0.6), Vector2(cx - s * 0.05, cy - s * 0.4), Vector2(cx - s * 0.15, cy - s * 0.25), Vector2(cx - s * 0.08, cy - s * 0.1)]), blade_col)
			# Guard
			draw_rect(Rect2(cx - s * 0.25, cy + s * 0.45, s * 0.5, s * 0.08), Color(0.85, 0.65, 0.1, 0.8))
			# Handle
			draw_rect(Rect2(cx - s * 0.06, cy + s * 0.53, s * 0.12, s * 0.25), Color(0.5, 0.3, 0.15, 0.9))
		"heart_scepter":
			# Scepter with heart top
			var scepter_col = Color(0.85, 0.65, 0.1, 0.9)
			# Shaft
			draw_rect(Rect2(cx - s * 0.06, cy - s * 0.15, s * 0.12, s * 0.85), scepter_col)
			# Heart
			var hx = cx
			var hy = cy - s * 0.4
			draw_circle(Vector2(hx - s * 0.12, hy - s * 0.06), s * 0.15, Color(0.9, 0.1, 0.2, 0.9))
			draw_circle(Vector2(hx + s * 0.12, hy - s * 0.06), s * 0.15, Color(0.9, 0.1, 0.2, 0.9))
			draw_colored_polygon(PackedVector2Array([Vector2(hx - s * 0.26, hy), Vector2(hx, hy + s * 0.3), Vector2(hx + s * 0.26, hy)]), Color(0.9, 0.1, 0.2, 0.9))
		"pocket_watch":
			# Pocket watch
			var watch_col = Color(0.85, 0.7, 0.3, 0.85)
			draw_circle(Vector2(cx, cy + s * 0.05), s * 0.55, watch_col)
			draw_circle(Vector2(cx, cy + s * 0.05), s * 0.45, Color(0.95, 0.92, 0.85, 0.9))
			# Clock hands
			draw_line(Vector2(cx, cy + s * 0.05), Vector2(cx, cy - s * 0.2), Color(0.2, 0.15, 0.1), 1.5)
			draw_line(Vector2(cx, cy + s * 0.05), Vector2(cx + s * 0.15, cy + s * 0.15), Color(0.2, 0.15, 0.1), 1.5)
			# Ring at top
			draw_arc(Vector2(cx, cy - s * 0.55), s * 0.12, 0, TAU, 8, watch_col, 2.0)
			# Chain hint
			draw_line(Vector2(cx, cy - s * 0.67), Vector2(cx + s * 0.3, cy - s * 0.75), watch_col, 1.5)
		"cheshire_grin":
			# Floating grin
			var grin_col = Color(0.9, 0.4, 0.8, 0.8)
			draw_arc(Vector2(cx, cy), s * 0.5, 0.15, PI - 0.15, 12, grin_col, 2.5)
			# Teeth
			for ti in range(5):
				var tx = cx - s * 0.35 + float(ti) * s * 0.175
				draw_rect(Rect2(tx, cy - s * 0.04, s * 0.12, s * 0.12), Color(0.95, 0.95, 0.9, 0.8))
			# Eyes (floating above)
			draw_circle(Vector2(cx - s * 0.25, cy - s * 0.35), s * 0.1, grin_col)
			draw_circle(Vector2(cx + s * 0.25, cy - s * 0.35), s * 0.1, grin_col)
			draw_circle(Vector2(cx - s * 0.25, cy - s * 0.35), s * 0.04, Color(0.1, 0.1, 0.1))
			draw_circle(Vector2(cx + s * 0.25, cy - s * 0.35), s * 0.04, Color(0.1, 0.1, 0.1))
		"ruby_slippers":
			# Red shoes
			var shoe_col = Color(0.85, 0.1, 0.15, 0.9)
			# Left shoe
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.6, cy + s * 0.1), Vector2(cx - s * 0.1, cy + s * 0.1), Vector2(cx - s * 0.1, cy + s * 0.4), Vector2(cx - s * 0.7, cy + s * 0.4), Vector2(cx - s * 0.75, cy + s * 0.25)]), shoe_col)
			# Right shoe
			draw_colored_polygon(PackedVector2Array([Vector2(cx + s * 0.1, cy + s * 0.1), Vector2(cx + s * 0.6, cy + s * 0.1), Vector2(cx + s * 0.75, cy + s * 0.25), Vector2(cx + s * 0.7, cy + s * 0.4), Vector2(cx + s * 0.1, cy + s * 0.4)]), shoe_col)
			# Sparkles
			draw_circle(Vector2(cx - s * 0.4, cy + s * 0.2), s * 0.05, Color(1.0, 0.8, 0.8, 0.9))
			draw_circle(Vector2(cx + s * 0.4, cy + s * 0.2), s * 0.05, Color(1.0, 0.8, 0.8, 0.9))
			draw_circle(Vector2(cx - s * 0.25, cy + s * 0.15), s * 0.03, Color(1.0, 1.0, 0.9, 0.7))
			draw_circle(Vector2(cx + s * 0.5, cy + s * 0.3), s * 0.03, Color(1.0, 1.0, 0.9, 0.7))
			# Heels
			draw_rect(Rect2(cx - s * 0.15, cy + s * 0.4, s * 0.08, s * 0.2), shoe_col)
			draw_rect(Rect2(cx + s * 0.55, cy + s * 0.4, s * 0.08, s * 0.2), shoe_col)
		"crystal_ball":
			# Glass orb on stand
			var orb_col = Color(0.6, 0.7, 0.9, 0.5)
			draw_circle(Vector2(cx, cy - s * 0.1), s * 0.45, orb_col)
			draw_arc(Vector2(cx, cy - s * 0.1), s * 0.45, 0, TAU, 16, Color(0.7, 0.8, 1.0, 0.6), 1.5)
			# Inner glow
			draw_circle(Vector2(cx - s * 0.1, cy - s * 0.2), s * 0.12, Color(0.8, 0.9, 1.0, 0.4))
			# Stand
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.2, cy + s * 0.3), Vector2(cx + s * 0.2, cy + s * 0.3), Vector2(cx + s * 0.35, cy + s * 0.6), Vector2(cx - s * 0.35, cy + s * 0.6)]), Color(0.5, 0.4, 0.2, 0.8))
		"monkey_fez":
			# Red fez hat
			var fez_col = Color(0.8, 0.15, 0.1, 0.9)
			# Main body
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.35, cy + s * 0.3), Vector2(cx + s * 0.35, cy + s * 0.3), Vector2(cx + s * 0.25, cy - s * 0.35), Vector2(cx - s * 0.25, cy - s * 0.35)]), fez_col)
			# Flat top
			draw_rect(Rect2(cx - s * 0.28, cy - s * 0.4, s * 0.56, s * 0.08), fez_col)
			# Tassel
			draw_line(Vector2(cx + s * 0.15, cy - s * 0.4), Vector2(cx + s * 0.45, cy - s * 0.15), Color(0.85, 0.7, 0.1), 1.5)
			draw_circle(Vector2(cx + s * 0.45, cy - s * 0.15), s * 0.06, Color(0.85, 0.7, 0.1))
			# Brim
			draw_rect(Rect2(cx - s * 0.4, cy + s * 0.28, s * 0.8, s * 0.06), Color(0.6, 0.1, 0.08, 0.9))
		"poppy_dust":
			# Red flowers
			var poppy_col = Color(0.9, 0.15, 0.1, 0.8)
			# Three poppies
			for pi in range(3):
				var px = cx - s * 0.35 + float(pi) * s * 0.35
				var py = cy - s * 0.1 + sin(float(pi) * 1.5) * s * 0.15
				for petal in range(5):
					var angle = float(petal) * TAU / 5.0
					var ppx = px + cos(angle) * s * 0.15
					var ppy = py + sin(angle) * s * 0.15
					draw_circle(Vector2(ppx, ppy), s * 0.1, poppy_col)
				draw_circle(Vector2(px, py), s * 0.06, Color(0.15, 0.1, 0.05))
			# Dust particles
			draw_circle(Vector2(cx + s * 0.3, cy - s * 0.4), s * 0.04, Color(1.0, 0.8, 0.3, 0.5))
			draw_circle(Vector2(cx - s * 0.2, cy - s * 0.5), s * 0.03, Color(1.0, 0.8, 0.3, 0.4))
		"golden_cap":
			# Gold cap
			var cap_col = Color(0.9, 0.75, 0.15, 0.9)
			# Dome
			draw_arc(Vector2(cx, cy + s * 0.1), s * 0.45, PI, TAU, 12, cap_col, 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.45, cy + s * 0.1), Vector2(cx + s * 0.45, cy + s * 0.1), Vector2(cx + s * 0.3, cy - s * 0.3), Vector2(cx, cy - s * 0.45), Vector2(cx - s * 0.3, cy - s * 0.3)]), cap_col)
			# Brim
			draw_rect(Rect2(cx - s * 0.55, cy + s * 0.08, s * 1.1, s * 0.1), Color(0.85, 0.65, 0.1, 0.9))
			# Center jewel
			draw_circle(Vector2(cx, cy - s * 0.1), s * 0.1, Color(0.6, 0.1, 0.5, 0.9))
			# Rune marks
			draw_line(Vector2(cx - s * 0.2, cy + s * 0.0), Vector2(cx - s * 0.1, cy - s * 0.15), Color(0.5, 0.1, 0.4, 0.5), 1.0)
			draw_line(Vector2(cx + s * 0.1, cy - s * 0.15), Vector2(cx + s * 0.2, cy + s * 0.0), Color(0.5, 0.1, 0.4, 0.5), 1.0)
		"hourglass":
			# Hourglass
			var glass_col = Color(0.7, 0.6, 0.4, 0.8)
			# Top triangle
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.4, cy - s * 0.7), Vector2(cx + s * 0.4, cy - s * 0.7), Vector2(cx, cy)]), Color(0.85, 0.75, 0.55, 0.5))
			# Bottom triangle
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy), Vector2(cx + s * 0.4, cy + s * 0.7), Vector2(cx - s * 0.4, cy + s * 0.7)]), Color(0.85, 0.75, 0.55, 0.5))
			# Sand (bottom fill)
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy + s * 0.2), Vector2(cx + s * 0.3, cy + s * 0.7), Vector2(cx - s * 0.3, cy + s * 0.7)]), Color(0.9, 0.75, 0.3, 0.7))
			# Frame bars
			draw_rect(Rect2(cx - s * 0.45, cy - s * 0.75, s * 0.9, s * 0.08), glass_col)
			draw_rect(Rect2(cx - s * 0.45, cy + s * 0.67, s * 0.9, s * 0.08), glass_col)
		"fairy_vial":
			# Glowing vial
			var vial_col = Color(0.4, 0.8, 0.5, 0.6)
			# Bottle body
			draw_rect(Rect2(cx - s * 0.08, cy - s * 0.6, s * 0.16, s * 0.25), Color(0.6, 0.7, 0.65, 0.6))
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.08, cy - s * 0.35), Vector2(cx + s * 0.08, cy - s * 0.35), Vector2(cx + s * 0.25, cy - s * 0.1), Vector2(cx + s * 0.25, cy + s * 0.6), Vector2(cx - s * 0.25, cy + s * 0.6), Vector2(cx - s * 0.25, cy - s * 0.1)]), vial_col)
			# Glow
			draw_circle(Vector2(cx, cy + s * 0.1), s * 0.3, Color(0.5, 1.0, 0.6, 0.2))
			# Sparkles
			draw_circle(Vector2(cx - s * 0.08, cy), s * 0.04, Color(1.0, 1.0, 0.7, 0.8))
			draw_circle(Vector2(cx + s * 0.1, cy + s * 0.25), s * 0.03, Color(1.0, 1.0, 0.7, 0.7))
			draw_circle(Vector2(cx, cy + s * 0.4), s * 0.035, Color(1.0, 1.0, 0.7, 0.6))
		"iron_hook":
			# Captain Hook's hook
			var hook_col = Color(0.6, 0.62, 0.65, 0.9)
			# Shaft
			draw_rect(Rect2(cx - s * 0.07, cy - s * 0.7, s * 0.14, s * 0.6), hook_col)
			# Curved hook
			draw_arc(Vector2(cx, cy + s * 0.1), s * 0.3, PI * 0.0, PI * 1.3, 10, hook_col, 3.0)
			# Point
			var hook_end_x = cx + s * 0.3 * cos(PI * 1.3)
			var hook_end_y = cy + s * 0.1 + s * 0.3 * sin(PI * 1.3)
			draw_circle(Vector2(hook_end_x, hook_end_y), s * 0.05, hook_col)
			# Guard ring
			draw_arc(Vector2(cx, cy - s * 0.15), s * 0.15, 0, TAU, 8, Color(0.85, 0.65, 0.1, 0.6), 2.0)
		"star_map":
			# Star map / scroll with stars
			var map_col = Color(0.75, 0.7, 0.55, 0.8)
			# Scroll body
			draw_rect(Rect2(cx - s * 0.5, cy - s * 0.45, s * 1.0, s * 0.9), Color(0.15, 0.1, 0.25, 0.8))
			# Scroll rolls
			draw_circle(Vector2(cx - s * 0.5, cy - s * 0.45), s * 0.08, map_col)
			draw_circle(Vector2(cx + s * 0.5, cy - s * 0.45), s * 0.08, map_col)
			draw_circle(Vector2(cx - s * 0.5, cy + s * 0.45), s * 0.08, map_col)
			draw_circle(Vector2(cx + s * 0.5, cy + s * 0.45), s * 0.08, map_col)
			# Stars on map
			var star_positions = [Vector2(-0.2, -0.2), Vector2(0.25, -0.1), Vector2(0.0, 0.15), Vector2(-0.3, 0.1), Vector2(0.3, 0.25)]
			for sp in star_positions:
				draw_circle(Vector2(cx + sp.x * s, cy + sp.y * s), s * 0.06, Color(1.0, 0.9, 0.4, 0.8))
			# Constellation lines
			draw_line(Vector2(cx - s * 0.2, cy - s * 0.2), Vector2(cx + s * 0.25, cy - s * 0.1), Color(0.7, 0.7, 0.9, 0.3), 1.0)
			draw_line(Vector2(cx + s * 0.25, cy - s * 0.1), Vector2(cx, cy + s * 0.15), Color(0.7, 0.7, 0.9, 0.3), 1.0)
		"croc_tooth":
			# Large fang
			var tooth_col = Color(0.9, 0.88, 0.8, 0.9)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.2, cy - s * 0.65), Vector2(cx + s * 0.2, cy - s * 0.65), Vector2(cx + s * 0.12, cy + s * 0.15), Vector2(cx, cy + s * 0.7), Vector2(cx - s * 0.12, cy + s * 0.15)]), tooth_col)
			# Root ridges
			draw_line(Vector2(cx - s * 0.12, cy - s * 0.5), Vector2(cx - s * 0.06, cy - s * 0.1), Color(0.7, 0.65, 0.55, 0.4), 1.0)
			draw_line(Vector2(cx + s * 0.12, cy - s * 0.5), Vector2(cx + s * 0.06, cy - s * 0.1), Color(0.7, 0.65, 0.55, 0.4), 1.0)
			# Blood hint
			draw_circle(Vector2(cx, cy + s * 0.55), s * 0.06, Color(0.7, 0.1, 0.1, 0.4))
		"thimble":
			# Silver thimble
			var thimble_col = Color(0.75, 0.78, 0.82, 0.85)
			# Dome top
			draw_arc(Vector2(cx, cy - s * 0.15), s * 0.3, PI, TAU, 10, thimble_col, 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.3, cy - s * 0.15), Vector2(cx + s * 0.3, cy - s * 0.15), Vector2(cx + s * 0.15, cy - s * 0.4), Vector2(cx, cy - s * 0.48), Vector2(cx - s * 0.15, cy - s * 0.4)]), thimble_col)
			# Cylinder body
			draw_rect(Rect2(cx - s * 0.3, cy - s * 0.15, s * 0.6, s * 0.65), thimble_col)
			# Dimple dots
			for row in range(3):
				for col in range(4):
					var dx = cx - s * 0.2 + float(col) * s * 0.13
					var dy = cy - s * 0.35 + float(row) * s * 0.12
					draw_circle(Vector2(dx, dy), s * 0.03, Color(0.6, 0.62, 0.65, 0.6))
			# Bottom rim
			draw_rect(Rect2(cx - s * 0.33, cy + s * 0.45, s * 0.66, s * 0.06), Color(0.65, 0.68, 0.72, 0.9))
		"shadow_thread":
			# Dark thread / wispy shadow
			var thread_col = Color(0.2, 0.15, 0.3, 0.8)
			# Wavy thread lines
			for ti in range(5):
				var ty_off = -s * 0.6 + float(ti) * s * 0.3
				var pts: Array[Vector2] = []
				for seg in range(8):
					var tx_seg = cx - s * 0.5 + float(seg) * s * 0.14
					var ty_seg = cy + ty_off + sin(float(seg) * 1.2 + float(ti)) * s * 0.1
					pts.append(Vector2(tx_seg, ty_seg))
				for seg in range(pts.size() - 1):
					draw_line(pts[seg], pts[seg + 1], thread_col, 1.5 + float(ti) * 0.3)
			# Needle
			draw_line(Vector2(cx + s * 0.3, cy - s * 0.7), Vector2(cx + s * 0.5, cy - s * 0.3), Color(0.7, 0.7, 0.75, 0.7), 1.5)
			draw_circle(Vector2(cx + s * 0.5, cy - s * 0.3), s * 0.04, Color(0.7, 0.7, 0.75, 0.7))
		"red_rose":
			# Red rose
			var rose_col = Color(0.85, 0.1, 0.15, 0.9)
			# Petals (overlapping circles)
			draw_circle(Vector2(cx, cy - s * 0.25), s * 0.2, rose_col)
			draw_circle(Vector2(cx - s * 0.15, cy - s * 0.1), s * 0.18, rose_col)
			draw_circle(Vector2(cx + s * 0.15, cy - s * 0.1), s * 0.18, rose_col)
			draw_circle(Vector2(cx - s * 0.08, cy + s * 0.05), s * 0.15, rose_col)
			draw_circle(Vector2(cx + s * 0.08, cy + s * 0.05), s * 0.15, rose_col)
			# Center
			draw_circle(Vector2(cx, cy - s * 0.08), s * 0.08, Color(0.6, 0.05, 0.1))
			# Stem
			draw_line(Vector2(cx, cy + s * 0.12), Vector2(cx - s * 0.05, cy + s * 0.7), Color(0.2, 0.5, 0.15), 2.0)
			# Leaf
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.05, cy + s * 0.4), Vector2(cx - s * 0.3, cy + s * 0.3), Vector2(cx - s * 0.05, cy + s * 0.5)]), Color(0.2, 0.5, 0.15, 0.8))
		"punjab_lasso":
			# Coiled rope / lasso
			var rope_col = Color(0.6, 0.5, 0.3, 0.85)
			# Coils
			draw_arc(Vector2(cx, cy - s * 0.1), s * 0.4, 0, TAU, 12, rope_col, 2.5)
			draw_arc(Vector2(cx, cy - s * 0.1), s * 0.28, 0.3, TAU + 0.3, 10, rope_col, 2.0)
			draw_arc(Vector2(cx, cy - s * 0.1), s * 0.16, 0.6, TAU + 0.6, 8, rope_col, 1.5)
			# Hanging end
			draw_line(Vector2(cx + s * 0.4, cy - s * 0.1), Vector2(cx + s * 0.3, cy + s * 0.5), rope_col, 2.0)
			# Knot
			draw_circle(Vector2(cx + s * 0.3, cy + s * 0.5), s * 0.08, rope_col)
		"opera_score":
			# Sheet music
			var paper_col = Color(0.9, 0.85, 0.7, 0.85)
			# Paper
			draw_rect(Rect2(cx - s * 0.45, cy - s * 0.6, s * 0.9, s * 1.2), paper_col)
			# Staff lines
			for li in range(5):
				var ly = cy - s * 0.35 + float(li) * s * 0.15
				draw_line(Vector2(cx - s * 0.38, ly), Vector2(cx + s * 0.38, ly), Color(0.3, 0.25, 0.2, 0.5), 1.0)
			# Music notes
			draw_circle(Vector2(cx - s * 0.2, cy - s * 0.2), s * 0.06, Color(0.2, 0.15, 0.1, 0.8))
			draw_line(Vector2(cx - s * 0.14, cy - s * 0.2), Vector2(cx - s * 0.14, cy - s * 0.5), Color(0.2, 0.15, 0.1, 0.8), 1.0)
			draw_circle(Vector2(cx + s * 0.05, cy - s * 0.05), s * 0.06, Color(0.2, 0.15, 0.1, 0.8))
			draw_line(Vector2(cx + s * 0.11, cy - s * 0.05), Vector2(cx + s * 0.11, cy - s * 0.4), Color(0.2, 0.15, 0.1, 0.8), 1.0)
			draw_circle(Vector2(cx + s * 0.25, cy + s * 0.1), s * 0.06, Color(0.2, 0.15, 0.1, 0.8))
			draw_line(Vector2(cx + s * 0.31, cy + s * 0.1), Vector2(cx + s * 0.31, cy - s * 0.2), Color(0.2, 0.15, 0.1, 0.8), 1.0)
		"chandelier_chain":
			# Chain links
			var chain_col = Color(0.7, 0.65, 0.5, 0.85)
			# Vertical chain of oval links
			for li in range(4):
				var ly = cy - s * 0.55 + float(li) * s * 0.3
				draw_arc(Vector2(cx, ly), s * 0.12, 0, TAU, 8, chain_col, 2.0)
			# Horizontal connector at bottom
			draw_line(Vector2(cx - s * 0.35, cy + s * 0.45), Vector2(cx + s * 0.35, cy + s * 0.45), chain_col, 2.0)
			# Small chandelier shape at bottom
			draw_line(Vector2(cx - s * 0.35, cy + s * 0.45), Vector2(cx - s * 0.25, cy + s * 0.65), chain_col, 1.5)
			draw_line(Vector2(cx + s * 0.35, cy + s * 0.45), Vector2(cx + s * 0.25, cy + s * 0.65), chain_col, 1.5)
			draw_line(Vector2(cx, cy + s * 0.45), Vector2(cx, cy + s * 0.7), chain_col, 1.5)
			# Candle flames
			draw_circle(Vector2(cx - s * 0.25, cy + s * 0.6), s * 0.05, Color(1.0, 0.8, 0.2, 0.7))
			draw_circle(Vector2(cx + s * 0.25, cy + s * 0.6), s * 0.05, Color(1.0, 0.8, 0.2, 0.7))
		"gondola_key":
			# Ornate key
			var key_col = Color(0.75, 0.6, 0.25, 0.9)
			# Bow (circular top)
			draw_arc(Vector2(cx - s * 0.15, cy - s * 0.35), s * 0.25, 0, TAU, 10, key_col, 2.5)
			draw_circle(Vector2(cx - s * 0.15, cy - s * 0.35), s * 0.15, Color(0.08, 0.05, 0.03))
			# Shaft
			draw_rect(Rect2(cx - s * 0.05, cy - s * 0.15, s * 0.1, s * 0.8), key_col)
			# Bit (teeth at bottom)
			draw_rect(Rect2(cx + s * 0.05, cy + s * 0.45, s * 0.2, s * 0.06), key_col)
			draw_rect(Rect2(cx + s * 0.05, cy + s * 0.55, s * 0.15, s * 0.06), key_col)
		"hand_mirror":
			# Hand mirror
			var mirror_col = Color(0.75, 0.6, 0.25, 0.9)
			# Mirror face (oval)
			draw_circle(Vector2(cx, cy - s * 0.2), s * 0.38, mirror_col)
			draw_circle(Vector2(cx, cy - s * 0.2), s * 0.3, Color(0.75, 0.82, 0.9, 0.7))
			# Reflection shine
			draw_circle(Vector2(cx - s * 0.1, cy - s * 0.3), s * 0.08, Color(1.0, 1.0, 1.0, 0.3))
			# Handle
			draw_rect(Rect2(cx - s * 0.08, cy + s * 0.15, s * 0.16, s * 0.55), mirror_col)
			# Handle end
			draw_circle(Vector2(cx, cy + s * 0.7), s * 0.1, mirror_col)
		"heavy_chains":
			# Heavy chains
			var chains_col = Color(0.55, 0.5, 0.45, 0.85)
			# Multiple chain links in a pile
			for ci in range(3):
				var chain_cx = cx - s * 0.25 + float(ci) * s * 0.25
				for li in range(3):
					var chain_cy = cy - s * 0.3 + float(li) * s * 0.25
					draw_arc(Vector2(chain_cx, chain_cy), s * 0.1, 0, TAU, 6, chains_col, 2.5)
			# Padlock at center
			draw_rect(Rect2(cx - s * 0.12, cy + s * 0.2, s * 0.24, s * 0.25), Color(0.5, 0.45, 0.35, 0.9))
			draw_arc(Vector2(cx, cy + s * 0.2), s * 0.1, PI, TAU, 6, chains_col, 2.0)
		"ghost_lantern":
			# Glowing lantern
			var lantern_col = Color(0.6, 0.55, 0.35, 0.85)
			# Handle
			draw_arc(Vector2(cx, cy - s * 0.45), s * 0.15, PI, TAU, 8, lantern_col, 2.0)
			# Body frame
			draw_rect(Rect2(cx - s * 0.25, cy - s * 0.35, s * 0.5, s * 0.7), Color(0.0, 0.0, 0.0, 0.3))
			draw_rect(Rect2(cx - s * 0.25, cy - s * 0.35, s * 0.5, 2), lantern_col)
			draw_rect(Rect2(cx - s * 0.25, cy + s * 0.35 - 2, s * 0.5, 2), lantern_col)
			draw_rect(Rect2(cx - s * 0.25, cy - s * 0.35, 2, s * 0.7), lantern_col)
			draw_rect(Rect2(cx + s * 0.25 - 2, cy - s * 0.35, 2, s * 0.7), lantern_col)
			# Glow inside
			draw_circle(Vector2(cx, cy), s * 0.18, Color(0.5, 0.9, 0.6, 0.3))
			draw_circle(Vector2(cx, cy), s * 0.1, Color(0.6, 1.0, 0.7, 0.4))
			# Base
			draw_rect(Rect2(cx - s * 0.3, cy + s * 0.35, s * 0.6, s * 0.12), lantern_col)
		"brass_key":
			# Brass key (simpler than gondola key)
			var bkey_col = Color(0.8, 0.65, 0.2, 0.9)
			# Bow (diamond shape)
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy - s * 0.6), Vector2(cx + s * 0.2, cy - s * 0.35), Vector2(cx, cy - s * 0.1), Vector2(cx - s * 0.2, cy - s * 0.35)]), bkey_col)
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy - s * 0.5), Vector2(cx + s * 0.1, cy - s * 0.35), Vector2(cx, cy - s * 0.2), Vector2(cx - s * 0.1, cy - s * 0.35)]), Color(0.08, 0.05, 0.03))
			# Shaft
			draw_rect(Rect2(cx - s * 0.05, cy - s * 0.15, s * 0.1, s * 0.75), bkey_col)
			# Teeth
			draw_rect(Rect2(cx + s * 0.05, cy + s * 0.35, s * 0.15, s * 0.06), bkey_col)
			draw_rect(Rect2(cx + s * 0.05, cy + s * 0.48, s * 0.12, s * 0.06), bkey_col)
		"xmas_pudding":
			# Steaming pudding
			var pudding_col = Color(0.45, 0.25, 0.1, 0.9)
			# Bowl
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.45, cy - s * 0.05), Vector2(cx + s * 0.45, cy - s * 0.05), Vector2(cx + s * 0.35, cy + s * 0.55), Vector2(cx - s * 0.35, cy + s * 0.55)]), pudding_col)
			# Pudding dome
			draw_arc(Vector2(cx, cy - s * 0.05), s * 0.45, PI, TAU, 10, pudding_col, 2.0)
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.45, cy - s * 0.05), Vector2(cx + s * 0.45, cy - s * 0.05), Vector2(cx + s * 0.3, cy - s * 0.35), Vector2(cx, cy - s * 0.45), Vector2(cx - s * 0.3, cy - s * 0.35)]), pudding_col)
			# White sauce drip
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.35, cy - s * 0.25), Vector2(cx + s * 0.35, cy - s * 0.25), Vector2(cx + s * 0.3, cy - s * 0.05), Vector2(cx + s * 0.15, cy + s * 0.1), Vector2(cx, cy - s * 0.05), Vector2(cx - s * 0.2, cy + s * 0.15), Vector2(cx - s * 0.3, cy - s * 0.05)]), Color(0.95, 0.92, 0.85, 0.8))
			# Holly on top
			draw_circle(Vector2(cx - s * 0.05, cy - s * 0.35), s * 0.06, Color(0.85, 0.1, 0.1, 0.9))
			draw_circle(Vector2(cx + s * 0.08, cy - s * 0.38), s * 0.06, Color(0.85, 0.1, 0.1, 0.9))
			# Steam wisps
			draw_arc(Vector2(cx - s * 0.15, cy - s * 0.55), s * 0.1, PI * 0.8, PI * 1.8, 6, Color(0.8, 0.8, 0.8, 0.3), 1.0)
			draw_arc(Vector2(cx + s * 0.1, cy - s * 0.6), s * 0.08, PI * 0.7, PI * 1.7, 6, Color(0.8, 0.8, 0.8, 0.25), 1.0)
		"fiddle":
			# Violin/fiddle
			var fiddle_col = Color(0.6, 0.35, 0.12, 0.9)
			# Body (figure-8)
			draw_circle(Vector2(cx, cy + s * 0.15), s * 0.3, fiddle_col)
			draw_circle(Vector2(cx, cy - s * 0.2), s * 0.22, fiddle_col)
			# Waist
			draw_rect(Rect2(cx - s * 0.12, cy - s * 0.1, s * 0.24, s * 0.15), Color(0.08, 0.05, 0.03))
			draw_rect(Rect2(cx - s * 0.15, cy - s * 0.05, s * 0.3, s * 0.08), fiddle_col)
			# Neck
			draw_rect(Rect2(cx - s * 0.05, cy - s * 0.55, s * 0.1, s * 0.35), fiddle_col)
			# Scroll
			draw_arc(Vector2(cx, cy - s * 0.58), s * 0.08, PI * 0.5, PI * 2.0, 6, fiddle_col, 2.0)
			# Strings
			for si_str in range(4):
				var sx_str = cx - s * 0.09 + float(si_str) * s * 0.06
				draw_line(Vector2(sx_str, cy - s * 0.4), Vector2(sx_str, cy + s * 0.35), Color(0.8, 0.75, 0.6, 0.5), 0.8)
			# F-holes
			draw_line(Vector2(cx - s * 0.1, cy + s * 0.0), Vector2(cx - s * 0.1, cy + s * 0.2), Color(0.08, 0.05, 0.03, 0.6), 1.0)
			draw_line(Vector2(cx + s * 0.1, cy + s * 0.0), Vector2(cx + s * 0.1, cy + s * 0.2), Color(0.08, 0.05, 0.03, 0.6), 1.0)
			# Bow (diagonal)
			draw_line(Vector2(cx + s * 0.4, cy - s * 0.6), Vector2(cx - s * 0.3, cy + s * 0.5), Color(0.55, 0.35, 0.15, 0.5), 1.0)
		"church_bell":
			# Church bell
			var bell_col = Color(0.8, 0.65, 0.2, 0.85)
			# Bell body
			draw_colored_polygon(PackedVector2Array([Vector2(cx - s * 0.15, cy - s * 0.55), Vector2(cx + s * 0.15, cy - s * 0.55), Vector2(cx + s * 0.2, cy - s * 0.3), Vector2(cx + s * 0.15, cy + s * 0.1), Vector2(cx + s * 0.4, cy + s * 0.35), Vector2(cx + s * 0.45, cy + s * 0.45), Vector2(cx - s * 0.45, cy + s * 0.45), Vector2(cx - s * 0.4, cy + s * 0.35), Vector2(cx - s * 0.15, cy + s * 0.1), Vector2(cx - s * 0.2, cy - s * 0.3)]), bell_col)
			# Clapper
			draw_line(Vector2(cx, cy - s * 0.2), Vector2(cx, cy + s * 0.3), Color(0.5, 0.4, 0.15), 1.5)
			draw_circle(Vector2(cx, cy + s * 0.32), s * 0.07, Color(0.5, 0.4, 0.15))
			# Top mount
			draw_rect(Rect2(cx - s * 0.1, cy - s * 0.65, s * 0.2, s * 0.12), Color(0.5, 0.4, 0.2))
			draw_arc(Vector2(cx, cy - s * 0.65), s * 0.12, PI, TAU, 6, Color(0.5, 0.4, 0.2), 2.0)
		_:
			# Fallback: diamond icon
			draw_colored_polygon(PackedVector2Array([Vector2(cx, cy - s * 0.5), Vector2(cx + s * 0.35, cy), Vector2(cx, cy + s * 0.5), Vector2(cx - s * 0.35, cy)]), Color(accent.r, accent.g, accent.b, 0.4))

const HERO_ROLE_NAMES: Dictionary = {
	TowerType.ROBIN_HOOD: "Marksman", TowerType.ALICE: "Controller",
	TowerType.WICKED_WITCH: "Summoner", TowerType.PETER_PAN: "Assassin",
	TowerType.PHANTOM: "Artillery", TowerType.SCROOGE: "Economist",
	TowerType.SHERLOCK: "Support", TowerType.TARZAN: "Brawler",
	TowerType.DRACULA: "Drain Tank", TowerType.MERLIN: "Wizard",
	TowerType.FRANKENSTEIN: "Juggernaut",
}

func _get_levelup_cost(level: int) -> int:
	# Accelerating cost curve: early levels cheap, later levels require commitment
	return 5 + level * 3 + int(float(level * level) * 0.5)

func _get_level_rewards(level: int) -> Array:
	var rewards: Array = []
	rewards.append("+2% DMG, +1.5% RNG, +1% SPD")
	if level == 2:
		rewards.append("Weapon Unlocked")
	if level == 3:
		rewards.append("Sidekick Slot #1")
	if level == 4:
		rewards.append("+Relic Slot (3 total)")
	if level == 5:
		rewards.append("+5% DMG Milestone")
		rewards.append("Sidekick Slot #2")
		rewards.append("Tome Binding Slot")
	if level == 7:
		rewards.append("+Relic Slot (4 total)")
	if level == 8:
		rewards.append("Sidekick Slot #3")
	if level == 10:
		rewards.append("+Relic Slot (5 total)")
		rewards.append("Tome Binding Slot #2")
	if level == 15:
		rewards.append("+10% DMG/RNG/SPD Milestone")
	return rewards

func _draw_ability_icon(center: Vector2, tier: int, accent: Color) -> void:
	match tier:
		0:  # Quill icon for T1
			draw_line(center + Vector2(-5, 6), center + Vector2(5, -6), Color(accent.r, accent.g, accent.b, 0.9), 2.0)
			draw_line(center + Vector2(4, -6), center + Vector2(6, -8), Color(accent.r, accent.g, accent.b, 0.7), 1.5)
			draw_line(center + Vector2(-5, 6), center + Vector2(-6, 8), Color(accent.r, accent.g, accent.b, 0.5), 1.0)
		1:  # Sword icon for T2
			draw_line(center + Vector2(0, -8), center + Vector2(0, 7), Color(0.8, 0.82, 0.85, 0.9), 2.5)
			draw_line(center + Vector2(-5, -2), center + Vector2(5, -2), Color(0.7, 0.55, 0.2, 0.9), 2.0)
			draw_circle(center + Vector2(0, -8), 2, Color(0.85, 0.65, 0.1, 0.8))
		2:  # Star icon for T3
			var star_pts = PackedVector2Array()
			for si in range(10):
				var sa = -PI * 0.5 + float(si) * TAU / 10.0
				var sd = 7.0 if si % 2 == 0 else 3.0
				star_pts.append(center + Vector2(cos(sa) * sd, sin(sa) * sd))
			draw_colored_polygon(star_pts, Color(accent.r, accent.g, accent.b, 0.8))
		3:  # Crown icon for T4
			var crown_pts = PackedVector2Array()
			crown_pts.append(center + Vector2(-8, 4))
			crown_pts.append(center + Vector2(-6, -4))
			crown_pts.append(center + Vector2(-2, 0))
			crown_pts.append(center + Vector2(0, -6))
			crown_pts.append(center + Vector2(2, 0))
			crown_pts.append(center + Vector2(6, -4))
			crown_pts.append(center + Vector2(8, 4))
			draw_colored_polygon(crown_pts, Color(0.85, 0.65, 0.1, 0.85))
			draw_rect(Rect2(center.x - 8, center.y + 4, 16, 3), Color(0.85, 0.65, 0.1, 0.85))

func _draw_survivor_detail() -> void:
	if survivor_detail_index < 0 or survivor_detail_index >= survivor_types.size():
		return
	var panel_x = 70.0
	var panel_y = 38.0
	var panel_w = 1140.0
	var panel_h = 570.0
	var tower_type = survivor_types[survivor_detail_index]
	var info = tower_info[tower_type]
	var progress = survivor_progress.get(tower_type, {"level": 1, "xp": 0.0, "xp_next": float(HERO_XP_TABLE[0]), "gear_unlocked": false, "sidekicks_unlocked": [false, false, false], "relics_unlocked": [false, false, false, false, false, false]})
	var speaker_name = _tower_type_to_name(tower_type)
	var font = game_font
	var char_level = progress.get("level", 1)
	var card_colors = [
		Color(0.29, 0.55, 0.25), Color(0.44, 0.66, 0.86), Color(0.48, 0.25, 0.63),
		Color(0.90, 0.49, 0.13), Color(0.75, 0.22, 0.17), Color(0.79, 0.66, 0.30),
		Color(0.20, 0.35, 0.55), Color(0.30, 0.50, 0.20), Color(0.50, 0.10, 0.15),
		Color(0.25, 0.20, 0.55), Color(0.35, 0.40, 0.30),
	]
	var accent = card_colors[mini(survivor_detail_index, card_colors.size() - 1)]

	# === Panel background gradient ===
	for i in range(58):
		var t = float(i) / 57.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 57.0 + 1), col)
	draw_circle(Vector2(panel_x + 200, panel_y + 280), 180, Color(accent.r, accent.g, accent.b, 0.03))
	# Outer border
	var bdr = Color(accent.r, accent.g, accent.b, 0.5)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 3), bdr)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 3, panel_w, 3), bdr)
	draw_rect(Rect2(panel_x, panel_y, 3, panel_h), bdr)
	draw_rect(Rect2(panel_x + panel_w - 3, panel_y, 3, panel_h), bdr)
	draw_rect(Rect2(panel_x + 3, panel_y + 3, panel_w - 6, panel_h - 6), Color(accent.r, accent.g, accent.b, 0.06), false, 1.0)

	# === TOP BAR ===
	var top_y = panel_y + 8.0
	_udraw(font, Vector2(panel_x + 20, top_y + 16), "< SURVIVORS", HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7))
	var char_name = info["name"].to_upper()
	var name_w = font.get_string_size(char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 26).x
	var name_cx = panel_x + panel_w * 0.5
	_udraw(font, Vector2(name_cx - name_w * 0.5 + 1, top_y + 21), char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 26, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(name_cx - name_w * 0.5, top_y + 20), char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 26, menu_parchment)
	# "IN PARTY" badge
	var party_text = "IN PARTY"
	var party_tw = font.get_string_size(party_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
	var party_bx = panel_x + panel_w - party_tw - 40
	draw_rect(Rect2(party_bx, top_y + 4, party_tw + 20, 22), Color(accent.r, accent.g, accent.b, 0.5))
	draw_rect(Rect2(party_bx, top_y + 4, party_tw + 20, 22), Color(accent.r, accent.g, accent.b, 0.7), false, 1.0)
	_udraw(font, Vector2(party_bx + 10, top_y + 18), party_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color.WHITE)
	draw_rect(Rect2(panel_x + 10, top_y + 30, panel_w - 20, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))

	var content_y = top_y + 38.0

	# ================================================================
	# LEFT SIDE: Portrait + XP + Stats + Abilities (BATTD style)
	# ================================================================
	var left_x = panel_x + 20.0
	var port_x = left_x
	var port_y = content_y
	var port_w = 240.0
	var port_h = 250.0
	# Portrait background
	draw_rect(Rect2(port_x, port_y, port_w, port_h), Color(0.03, 0.02, 0.07))
	for gi in range(25):
		var gt = float(gi) / 24.0
		draw_rect(Rect2(port_x, port_y + float(gi), port_w, 1), Color(accent.r, accent.g, accent.b, 0.08 * (1.0 - gt)))
	draw_circle(Vector2(port_x + port_w * 0.5, port_y + port_h * 0.55), 70.0, Color(accent.r, accent.g, accent.b, 0.06))
	_draw_story_portrait(port_x + port_w * 0.5, port_y + port_h * 0.45, 200.0, speaker_name)
	# Portrait frame
	draw_rect(Rect2(port_x, port_y, port_w, 3), Color(accent.r, accent.g, accent.b, 0.6))
	draw_rect(Rect2(port_x, port_y + port_h - 3, port_w, 3), Color(accent.r, accent.g, accent.b, 0.6))
	draw_rect(Rect2(port_x, port_y, 3, port_h), Color(accent.r, accent.g, accent.b, 0.6))
	draw_rect(Rect2(port_x + port_w - 3, port_y, 3, port_h), Color(accent.r, accent.g, accent.b, 0.6))
	draw_rect(Rect2(port_x + 3, port_y + 3, port_w - 6, port_h - 6), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.12), false, 1.0)
	# Level badge star (BATTD style — gold star with level number)
	var badge_cx = port_x + port_w - 20.0
	var badge_cy = port_y + 20.0
	var star_r = 18.0
	var star_pts = PackedVector2Array()
	for si in range(10):
		var sa = -PI * 0.5 + float(si) * TAU / 10.0
		var sd = star_r if si % 2 == 0 else star_r * 0.45
		star_pts.append(Vector2(badge_cx + cos(sa) * sd, badge_cy + sin(sa) * sd))
	draw_colored_polygon(star_pts, Color(0.85, 0.65, 0.1, 0.95))
	draw_circle(Vector2(badge_cx, badge_cy), 10, Color(0.04, 0.03, 0.08))
	var lvl_str = str(char_level)
	var lvl_w = font.get_string_size(lvl_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13).x
	_udraw(font, Vector2(badge_cx - lvl_w * 0.5, badge_cy + 5), lvl_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color.WHITE)
	# Info icon (bottom-left) — highlights on hover
	var info_icon_hover = (detail_hover_type == "info_icon")
	draw_circle(Vector2(port_x + 22, port_y + port_h - 22), 12, Color(0.2, 0.4, 0.8, 0.85 if info_icon_hover else 0.6))
	if info_icon_hover:
		draw_arc(Vector2(port_x + 22, port_y + port_h - 22), 13, 0, TAU, 16, Color(0.4, 0.7, 1.0, 0.6), 1.5)
	_udraw(font, Vector2(port_x + 18, port_y + port_h - 17), "i", HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color.WHITE)

	# --- Right of portrait: NEXT REWARDS roadmap ---
	var info_x = port_x + port_w + 14.0
	var info_y = port_y + 6.0
	_udraw(font, Vector2(info_x, info_y + 12), "NEXT REWARDS", HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7))
	draw_rect(Rect2(info_x, info_y + 16, 80, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.2))
	var roadmap_y = info_y + 24.0
	var rewards_shown = 0
	var check_level = char_level + 1
	while rewards_shown < 3 and check_level <= MAX_SURVIVOR_LEVEL:
		var rewards = _get_level_rewards(check_level)
		if rewards.size() > 1:  # Has special rewards beyond the base stat line
			# Level number badge
			var badge_str = "LV.%d" % check_level
			_udraw(font, Vector2(info_x, roadmap_y + 9), badge_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.85, 0.65, 0.1, 0.8))
			var reward_x = info_x + 36.0
			for ri in range(1, mini(rewards.size(), 3)):  # Skip index 0 (base stats)
				_udraw(font, Vector2(reward_x, roadmap_y + 9), rewards[ri], HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.7))
				roadmap_y += 12.0
			rewards_shown += 1
		check_level += 1
	if char_level >= MAX_SURVIVOR_LEVEL:
		_udraw(font, Vector2(info_x, roadmap_y + 9), "All rewards unlocked!", HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.85, 0.65, 0.1, 0.6))

	# --- XP bar (below portrait) ---
	var xp_y = port_y + port_h + 6.0
	var xp_w = port_w
	var xp_h = 20.0
	var xp_ratio = clamp(progress["xp"] / max(progress["xp_next"], 1.0), 0.0, 1.0)
	draw_rect(Rect2(port_x, xp_y, xp_w, xp_h), Color(0.03, 0.03, 0.08))
	draw_rect(Rect2(port_x, xp_y, xp_w, xp_h), Color(accent.r, accent.g, accent.b, 0.2), false, 1.0)
	if xp_ratio > 0:
		draw_rect(Rect2(port_x + 2, xp_y + 2, (xp_w - 4) * xp_ratio, xp_h - 4), Color(0.85, 0.65, 0.1, 0.8))
		draw_rect(Rect2(port_x + 2, xp_y + 2, (xp_w - 4) * xp_ratio, (xp_h - 4) * 0.35), Color(1, 1, 1, 0.15))
	var xp_text = "%d/%d" % [int(progress["xp"]), int(progress["xp_next"])]
	if char_level >= MAX_SURVIVOR_LEVEL:
		xp_text = "MAX LEVEL"
	var xp_tw = font.get_string_size(xp_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
	_udraw(font, Vector2(port_x + (xp_w - xp_tw) * 0.5, xp_y + 15), xp_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color.WHITE)

	# --- LEVEL UP button (below XP bar) ---
	var levelup_btn_y = xp_y + xp_h
	var levelup_btn_h = 22.0
	if char_level >= MAX_SURVIVOR_LEVEL:
		# MAX LEVEL badge
		draw_rect(Rect2(port_x, levelup_btn_y, xp_w, levelup_btn_h), Color(0.85, 0.65, 0.1, 0.15))
		draw_rect(Rect2(port_x, levelup_btn_y, xp_w, levelup_btn_h), Color(0.85, 0.65, 0.1, 0.3), false, 1.0)
		var max_str = "MAX LEVEL REACHED"
		var max_w = font.get_string_size(max_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 10).x
		_udraw(font, Vector2(port_x + (xp_w - max_w) * 0.5, levelup_btn_y + 15), max_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(0.85, 0.65, 0.1, 0.7))
	else:
		var lvup_cost = _get_levelup_cost(char_level)
		var can_afford = player_quills >= lvup_cost
		var is_lvup_hover = (detail_hover_type == "levelup")
		# Button background
		var btn_bg = Color(0.85, 0.65, 0.1, 0.25 if is_lvup_hover else 0.12) if can_afford else Color(0.3, 0.3, 0.3, 0.15)
		var btn_border = Color(0.85, 0.65, 0.1, 0.7 if is_lvup_hover else 0.4) if can_afford else Color(0.4, 0.4, 0.4, 0.3)
		draw_rect(Rect2(port_x, levelup_btn_y, xp_w, levelup_btn_h), btn_bg)
		draw_rect(Rect2(port_x, levelup_btn_y, xp_w, levelup_btn_h), btn_border, false, 1.5)
		if is_lvup_hover and can_afford:
			draw_rect(Rect2(port_x + 1, levelup_btn_y + 1, xp_w - 2, (levelup_btn_h - 2) * 0.4), Color(1, 1, 1, 0.06))
		var lvup_str = "LEVEL UP  —  %d Quills" % lvup_cost
		var lvup_tw = font.get_string_size(lvup_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 10).x
		var lvup_col = Color(0.85, 0.65, 0.1, 0.9) if can_afford else Color(0.5, 0.48, 0.55, 0.6)
		_udraw(font, Vector2(port_x + (xp_w - lvup_tw) * 0.5, levelup_btn_y + 15), lvup_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, lvup_col)

	# --- Stat bonus pills ---
	var stat_y = xp_y + xp_h + levelup_btn_h + 4.0
	var lvl_b = _get_level_bonuses(tower_type)
	var rel_b = _get_relic_bonuses(tower_type)
	var total_dmg = lvl_b.get("damage", 0.0) + rel_b.get("damage", 0.0) + _get_knowledge_bonus("damage")
	var total_rng = lvl_b.get("range", 0.0) + rel_b.get("range", 0.0) + _get_knowledge_bonus("range")
	var total_spd = lvl_b.get("attack_speed", 0.0) + rel_b.get("attack_speed", 0.0) + _get_knowledge_bonus("attack_speed")
	var pill_x = port_x
	var pill_labels = ["+%d%% DMG" % int(total_dmg * 100), "+%d%% RNG" % int(total_rng * 100), "+%d%% SPD" % int(total_spd * 100)]
	var pill_colors = [Color(0.9, 0.3, 0.2), Color(0.3, 0.7, 0.9), Color(0.3, 0.9, 0.4)]
	for pi in range(3):
		var pw = font.get_string_size(pill_labels[pi], HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x + 12
		draw_rect(Rect2(pill_x, stat_y, pw, 16), Color(pill_colors[pi].r, pill_colors[pi].g, pill_colors[pi].b, 0.12))
		draw_rect(Rect2(pill_x, stat_y, pw, 16), Color(pill_colors[pi].r, pill_colors[pi].g, pill_colors[pi].b, 0.25), false, 1.0)
		_udraw(font, Vector2(pill_x + 6, stat_y + 11), pill_labels[pi], HORIZONTAL_ALIGNMENT_LEFT, -1, 9, Color(pill_colors[pi].r, pill_colors[pi].g, pill_colors[pi].b, 0.9))
		pill_x += pw + 6.0

	# Novel title (below stat pills on the left side)
	var novel_str = character_novels[survivor_detail_index] if survivor_detail_index < character_novels.size() else ""
	_udraw(font, Vector2(port_x, stat_y + 22), novel_str, HORIZONTAL_ALIGNMENT_LEFT, int(port_w + 60), 9, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.5))

	# ================================================================
	# RIGHT SIDE: Weapon + Sidekicks + Relics (BATTD layout)
	# ================================================================
	var right_x = panel_x + 310.0
	var right_w = panel_w - 330.0
	var slot_size = 72.0

	# --- WEAPON section ---
	var weap_y = content_y
	_udraw(font, Vector2(right_x + 1, weap_y + 15), "WEAPON", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(right_x, weap_y + 14), "WEAPON", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_gold)
	var gear_data = survivor_gear.get(tower_type, {"name": "Unknown", "desc": ""})
	var gear_unlocked = progress.get("gear_unlocked", false)
	var gear_sy = weap_y + 24.0
	var gear_hover = (detail_hover_type == "weapon" and detail_hover_index == 0)
	# Weapon slot
	draw_rect(Rect2(right_x, gear_sy, slot_size, slot_size), Color(0.04, 0.04, 0.10))
	var gear_bdr_col = Color(accent.r, accent.g, accent.b, 0.7 if gear_hover else 0.4) if gear_unlocked else Color(0.3, 0.28, 0.40, 0.3)
	draw_rect(Rect2(right_x, gear_sy, slot_size, slot_size), gear_bdr_col, false, 2.5)
	if gear_unlocked:
		draw_circle(Vector2(right_x + slot_size * 0.5, gear_sy + slot_size * 0.5), 24, Color(accent.r, accent.g, accent.b, 0.2))
		draw_arc(Vector2(right_x + slot_size * 0.5, gear_sy + slot_size * 0.5), 20, 0, TAU, 16, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.35), 2.0)
		# Simple weapon icon (sword)
		var wc = Vector2(right_x + slot_size * 0.5, gear_sy + slot_size * 0.5)
		draw_line(wc + Vector2(0, -18), wc + Vector2(0, 14), Color(0.8, 0.82, 0.85, 0.8), 3.0)
		draw_line(wc + Vector2(-9, -5), wc + Vector2(9, -5), Color(0.7, 0.55, 0.2, 0.8), 2.5)
		draw_circle(wc + Vector2(0, -18), 3, Color(0.85, 0.65, 0.1, 0.7))
	else:
		# Locked: padlock
		var lk = Vector2(right_x + slot_size * 0.5, gear_sy + slot_size * 0.4)
		draw_rect(Rect2(lk.x - 12, lk.y + 2, 24, 18), Color(0.35, 0.30, 0.45, 0.6))
		draw_arc(Vector2(lk.x, lk.y + 2), 9, PI, TAU, 12, Color(0.4, 0.35, 0.50, 0.6), 2.5)
		draw_circle(Vector2(lk.x, lk.y + 11), 3, Color(0.04, 0.04, 0.10))
	# Weapon name below slot
	var weap_name = gear_data["name"] if gear_unlocked else "LV.2"
	var weap_nw = font.get_string_size(weap_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
	_udraw(font, Vector2(right_x + (slot_size - weap_nw) * 0.5, gear_sy + slot_size + 14), weap_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, menu_parchment if gear_unlocked else Color(0.5, 0.48, 0.55, 0.6))

	# --- SIDEKICKS section (right of weapon) ---
	var sk_x = right_x + slot_size + 50.0
	var sk_y = content_y
	var sk_data = survivor_sidekicks.get(tower_type, [])
	var sk_unlocked_arr = progress.get("sidekicks_unlocked", [false, false, false])
	var sk_count = 0
	for su in sk_unlocked_arr:
		if su:
			sk_count += 1
	_udraw(font, Vector2(sk_x + 1, sk_y + 15), "SIDEKICKS (%d/3)" % sk_count, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(sk_x, sk_y + 14), "SIDEKICKS (%d/3)" % sk_count, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_gold)
	var sk_slot_y = sk_y + 24.0
	var sk_levels = [3, 5, 8]
	for si in range(3):
		var sx = sk_x + float(si) * (slot_size + 14.0)
		var sy = sk_slot_y
		var sk_unlocked = sk_unlocked_arr[si] if si < sk_unlocked_arr.size() else false
		var sk_hover = (detail_hover_type == "sidekick" and detail_hover_index == si)
		draw_rect(Rect2(sx, sy, slot_size, slot_size), Color(0.04, 0.04, 0.10))
		var sk_bdr = Color(accent.r, accent.g, accent.b, 0.7 if sk_hover else 0.4) if sk_unlocked else Color(0.3, 0.28, 0.40, 0.3)
		draw_rect(Rect2(sx, sy, slot_size, slot_size), sk_bdr, false, 2.5)
		if sk_unlocked and si < sk_data.size():
			# Sidekick portrait silhouette
			var sc = Vector2(sx + slot_size * 0.5, sy + slot_size * 0.4)
			draw_circle(sc + Vector2(0, -8), 14, Color(accent.r, accent.g, accent.b, 0.3))
			draw_rect(Rect2(sc.x - 10, sc.y + 2, 20, 18), Color(accent.r, accent.g, accent.b, 0.2))
			# Name below
			var sk_name = sk_data[si]["name"]
			if sk_name.length() > 10:
				sk_name = sk_name.substr(0, 9) + ".."
			var snw = font.get_string_size(sk_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x
			_udraw(font, Vector2(sx + (slot_size - snw) * 0.5, sy + slot_size + 12), sk_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 9, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.8))
		else:
			if si == 0 or (si > 0 and sk_unlocked_arr[si - 1] if si - 1 < sk_unlocked_arr.size() else false):
				# Next unlockable — show "+" icon
				draw_rect(Rect2(sx + 32, sy + 24, 8, 24), Color(accent.r, accent.g, accent.b, 0.3))
				draw_rect(Rect2(sx + 24, sy + 32, 24, 8), Color(accent.r, accent.g, accent.b, 0.3))
			else:
				# Locked — padlock icon
				var lk = Vector2(sx + slot_size * 0.5, sy + slot_size * 0.4)
				draw_rect(Rect2(lk.x - 10, lk.y + 2, 20, 16), Color(0.35, 0.30, 0.45, 0.5))
				draw_arc(Vector2(lk.x, lk.y + 2), 8, PI, TAU, 10, Color(0.4, 0.35, 0.50, 0.5), 2.5)
				draw_circle(Vector2(lk.x, lk.y + 10), 2.5, Color(0.04, 0.04, 0.10))
			# Level requirement star (bottom-right of slot)
			_draw_detail_level_star(Vector2(sx + slot_size - 2, sy + slot_size - 2), sk_levels[si], font)
	# Sidekick description
	_udraw(font, Vector2(sk_x, sk_slot_y + slot_size + 24), "Sidekicks: Call in extra characters", HORIZONTAL_ALIGNMENT_LEFT, 400, 9, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.5))

	# --- RELICS section (full width of right side, below weapon+sidekicks) ---
	var rel_y = gear_sy + slot_size + 44.0
	var char_relics = survivor_relics.get(tower_type, [])
	var rel_unlocked_arr = progress.get("relics_unlocked", [false, false, false, false, false, false])
	var rel_count = 0
	for ru in rel_unlocked_arr:
		if ru:
			rel_count += 1
	var max_rel_slots = _get_relic_slots(char_level)
	_udraw(font, Vector2(right_x + 1, rel_y + 15), "RELICS (%d/%d)" % [rel_count, char_relics.size()], HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(right_x, rel_y + 14), "RELICS (%d/%d)" % [rel_count, char_relics.size()], HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_gold)
	var relic_slot_y = rel_y + 24.0
	var relic_slot_size = 72.0
	var relic_gap = 12.0
	var relic_earn_levels = [2, 4, 6, 8, 10, 12]
	var relic_purchasable = [false, true, false, true, false, true]
	var relic_costs = [0, 100, 0, 250, 0, 500]
	# 2 rows of 3 relics (like BATTD's 2 rows of 6 trinkets)
	for ri in range(mini(char_relics.size(), 6)):
		var r_row = ri / 3
		var r_col = ri % 3
		var rx = right_x + float(r_col) * (relic_slot_size + relic_gap)
		var ry = relic_slot_y + float(r_row) * (relic_slot_size + 24.0)
		var is_unlocked = rel_unlocked_arr[ri] if ri < rel_unlocked_arr.size() else false
		var is_rel_hover = (detail_hover_type == "relic" and detail_hover_index == ri)
		var relic_data = char_relics[ri] if ri < char_relics.size() else {}
		# Slot bg
		draw_rect(Rect2(rx, ry, relic_slot_size, relic_slot_size), Color(0.04, 0.04, 0.10))
		if is_unlocked:
			var eq_list = equipped_relics.get(tower_type, [])
			var is_equipped = ri in eq_list
			# Equipped = gold border, owned = accent border
			var relic_bdr = Color(0.85, 0.65, 0.1, 0.8 if is_rel_hover else 0.6) if is_equipped else Color(accent.r, accent.g, accent.b, 0.7 if is_rel_hover else 0.4)
			draw_rect(Rect2(rx, ry, relic_slot_size, relic_slot_size), relic_bdr, false, 2.5)
			# Relic icon
			if not relic_data.is_empty():
				_draw_relic_icon(Vector2(rx + relic_slot_size * 0.5, ry + relic_slot_size * 0.4), relic_data.get("icon", ""), relic_slot_size * 0.55, accent)
			# Equipped corner triangle
			if is_equipped:
				draw_colored_polygon(PackedVector2Array([Vector2(rx, ry), Vector2(rx + 18, ry), Vector2(rx, ry + 18)]), Color(0.85, 0.65, 0.1, 0.8))
			# Relic name below
			var rn = relic_data.get("name", "")
			if rn.length() > 11:
				rn = rn.substr(0, 10) + ".."
			var rnw = font.get_string_size(rn, HORIZONTAL_ALIGNMENT_LEFT, -1, 8).x
			_udraw(font, Vector2(rx + (relic_slot_size - rnw) * 0.5, ry + relic_slot_size + 12), rn, HORIZONTAL_ALIGNMENT_LEFT, -1, 8, menu_parchment)
		elif relic_purchasable[ri] and char_level >= relic_earn_levels[ri]:
			# Purchasable with gold — cyan border like BATTD "+" slots
			draw_rect(Rect2(rx, ry, relic_slot_size, relic_slot_size), Color(accent.r, accent.g, accent.b, 0.4 if is_rel_hover else 0.2), false, 2.0)
			# Plus icon
			draw_rect(Rect2(rx + 32, ry + 24, 8, 24), Color(accent.r, accent.g, accent.b, 0.4))
			draw_rect(Rect2(rx + 24, ry + 32, 24, 8), Color(accent.r, accent.g, accent.b, 0.4))
			# Cost label
			var cost_str = "%d GOLD" % relic_costs[ri]
			var cost_w = font.get_string_size(cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 8).x
			_udraw(font, Vector2(rx + (relic_slot_size - cost_w) * 0.5, ry + relic_slot_size + 12), cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.85, 0.65, 0.1, 0.7))
		else:
			# Locked — gray with padlock
			draw_rect(Rect2(rx, ry, relic_slot_size, relic_slot_size), Color(0.2, 0.18, 0.30, 0.2), false, 1.5)
			var lk = Vector2(rx + relic_slot_size * 0.5, ry + relic_slot_size * 0.38)
			draw_rect(Rect2(lk.x - 12, lk.y + 2, 24, 18), Color(0.35, 0.30, 0.45, 0.55))
			draw_arc(Vector2(lk.x, lk.y + 2), 9, PI, TAU, 12, Color(0.4, 0.35, 0.50, 0.55), 2.5)
			draw_circle(Vector2(lk.x, lk.y + 11), 3, Color(0.04, 0.04, 0.10))
			# Level requirement star
			_draw_detail_level_star(Vector2(rx + relic_slot_size - 2, ry + relic_slot_size - 2), relic_earn_levels[ri], font)
	# Relics description
	var relic_desc_y = relic_slot_y + 2.0 * (relic_slot_size + 24.0) + 4.0
	_udraw(font, Vector2(right_x, relic_desc_y), "Relics: Add extra attacks, damage, or effects", HORIZONTAL_ALIGNMENT_LEFT, 500, 11, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.5))

	# --- ABILITIES section (to the right of relics) ---
	var abil_x = right_x + 270.0
	var abil_y = rel_y
	var abil_w = 520.0
	var abil_data = survivor_detail_abilities
	_udraw(font, Vector2(abil_x + 1, abil_y + 15), "ABILITIES", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(0, 0, 0, 0.4))
	_udraw(font, Vector2(abil_x, abil_y + 14), "ABILITIES", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, menu_gold)
	draw_rect(Rect2(abil_x, abil_y + 19, 100, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.3))
	var abil_entry_y = abil_y + 30.0
	var abil_entry_h = 48.0
	for ai in range(mini(abil_data.size(), 4)):
		var ay = abil_entry_y + float(ai) * abil_entry_h
		var is_abil_hover = (detail_hover_type == "ability" and detail_hover_index == ai)
		# Hover highlight bar
		if is_abil_hover:
			draw_rect(Rect2(abil_x - 4, ay - 2, abil_w, abil_entry_h - 4), Color(accent.r, accent.g, accent.b, 0.08))
		# Small icon circle
		var icon_cx = abil_x + 16.0
		var icon_cy = ay + 14.0
		draw_circle(Vector2(icon_cx, icon_cy), 14.0, Color(0.04, 0.04, 0.10))
		var ring_alpha = 0.8 if is_abil_hover else 0.5
		draw_arc(Vector2(icon_cx, icon_cy), 13.0, 0, TAU, 16, Color(0.85, 0.65, 0.1, ring_alpha), 2.0)
		_draw_ability_icon(Vector2(icon_cx, icon_cy), ai, accent)
		# Tier number
		var tier_str = "%d." % (ai + 1)
		_udraw(font, Vector2(abil_x + 36, ay + 12), tier_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.85, 0.65, 0.1, 0.9))
		# Ability name
		var a_name = abil_data[ai].get("name", "Tier %d" % (ai + 1))
		_udraw(font, Vector2(abil_x + 52, ay + 12), a_name, HORIZONTAL_ALIGNMENT_LEFT, int(abil_w - 120), 13, menu_gold)
		# Cost (right-aligned)
		var cost_str = "%dG" % abil_data[ai].get("cost", 0)
		var cost_w = font.get_string_size(cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x
		_udraw(font, Vector2(abil_x + abil_w - cost_w - 10, ay + 12), cost_str, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.85, 0.65, 0.1, 0.7))
		# Description
		var a_desc = abil_data[ai].get("desc", "")
		_udraw(font, Vector2(abil_x + 36, ay + 28), a_desc, HORIZONTAL_ALIGNMENT_LEFT, int(abil_w - 50), 11, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.95))

	# --- Tome Bindings section (below relics, if player has slots) ---
	var bind_slots = _get_binding_slots(tower_type)
	if bind_slots > 0:
		var eq_bindings = equipped_bindings.get(tower_type, [])
		var rarity_colors = {"common": Color(0.6, 0.6, 0.6), "uncommon": Color(0.3, 0.7, 0.3), "rare": Color(0.7, 0.4, 0.9)}
		var tome_y = relic_desc_y + 18.0
		_udraw(font, Vector2(right_x + 1, tome_y + 13), "TOME BINDINGS (%d/%d)" % [eq_bindings.size(), bind_slots], HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0, 0, 0, 0.4))
		_udraw(font, Vector2(right_x, tome_y + 12), "TOME BINDINGS (%d/%d)" % [eq_bindings.size(), bind_slots], HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.7))
		var tome_slot_y = tome_y + 22.0
		var tome_slot_size = 44.0
		for tsi in range(bind_slots):
			var tx = right_x + float(tsi) * (tome_slot_size + 8)
			var ty = tome_slot_y
			draw_rect(Rect2(tx, ty, tome_slot_size, tome_slot_size), Color(0.04, 0.04, 0.10))
			if tsi < eq_bindings.size():
				var binding = _find_binding(eq_bindings[tsi])
				if not binding.is_empty():
					var rc = rarity_colors.get(binding.get("rarity", "common"), Color(0.6, 0.6, 0.6))
					draw_rect(Rect2(tx, ty, tome_slot_size, tome_slot_size), Color(rc.r, rc.g, rc.b, 0.4), false, 1.5)
					draw_circle(Vector2(tx + tome_slot_size * 0.5, ty + tome_slot_size * 0.4), 12, Color(rc.r, rc.g, rc.b, 0.25))
			else:
				draw_rect(Rect2(tx, ty, tome_slot_size, tome_slot_size), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.15), false, 1.0)
				draw_rect(Rect2(tx + 18, ty + 12, 8, 20), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))
				draw_rect(Rect2(tx + 12, ty + 18, 20, 8), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))
		# Owned bindings list (scrollable)
		var browse_y = tome_slot_y + tome_slot_size + 6.0
		var browse_bottom = panel_y + panel_h - 20.0
		var bcol = 0
		var brow = 0
		var card_w = 200.0
		var card_h = 28.0
		for b in TOME_BINDINGS:
			var count = owned_bindings.get(b["id"], 0)
			if count <= 0:
				continue
			var bx = right_x + float(bcol) * (card_w + 8)
			var by = browse_y + float(brow) * (card_h + 3) - detail_binding_scroll
			bcol += 1
			if bcol >= 3:
				bcol = 0
				brow += 1
			# Clip to visible area
			if by + card_h < browse_y or by > browse_bottom:
				continue
			var is_eq = b["id"] in eq_bindings
			var rc = rarity_colors.get(b.get("rarity", "common"), Color(0.6, 0.6, 0.6))
			var bg_c = Color(0.10, 0.08, 0.22, 0.8) if is_eq else Color(0.05, 0.05, 0.14, 0.7)
			draw_rect(Rect2(bx, by, card_w, card_h), bg_c)
			draw_rect(Rect2(bx, by, card_w, card_h), Color(rc.r, rc.g, rc.b, 0.3 if is_eq else 0.15), false, 1.0)
			_udraw(font, Vector2(bx + 6, by + 12), b["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 40), 8, menu_parchment)
			_udraw(font, Vector2(bx + 6, by + 22), b["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 12), 7, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.6))
			var count_label = "EQ" if is_eq else ("x%d" % count)
			_udraw(font, Vector2(bx + card_w - 28, by + 12), count_label, HORIZONTAL_ALIGNMENT_RIGHT, -1, 8, Color(0.3, 0.8, 0.3) if is_eq else Color(0.55, 0.52, 0.50))

	# === TOOLTIP (drawn last, on top) ===
	if detail_hover_type != "" and detail_hover_index >= 0:
		var tt_title = ""
		var tt_lines: Array = []
		match detail_hover_type:
			"ability":
				if detail_hover_index < abil_data.size():
					var ad = abil_data[detail_hover_index]
					tt_title = ad.get("name", "Tier %d" % (detail_hover_index + 1))
					tt_lines.append(ad.get("desc", ""))
					tt_lines.append("In-game cost: %d gold" % ad.get("cost", 0))
			"weapon":
				tt_title = gear_data["name"]
				tt_lines.append(gear_data["desc"])
				if not gear_unlocked:
					tt_lines.append("Unlocks at Level 2")
			"sidekick":
				if detail_hover_index < sk_data.size():
					tt_title = sk_data[detail_hover_index]["name"]
					tt_lines.append(sk_data[detail_hover_index]["desc"])
					var sk_u = sk_unlocked_arr[detail_hover_index] if detail_hover_index < sk_unlocked_arr.size() else false
					if not sk_u:
						tt_lines.append("Unlocks at Level %d" % sk_levels[detail_hover_index])
			"relic":
				if detail_hover_index < char_relics.size():
					var rd = char_relics[detail_hover_index]
					tt_title = rd["name"]
					tt_lines.append(rd["desc"])
					var r_unlocked = rel_unlocked_arr[detail_hover_index] if detail_hover_index < rel_unlocked_arr.size() else false
					if r_unlocked:
						var eq_list = equipped_relics.get(tower_type, [])
						if detail_hover_index in eq_list:
							tt_lines.append("EQUIPPED - Click to unequip")
						elif eq_list.size() < max_rel_slots:
							tt_lines.append("Click to equip")
						else:
							tt_lines.append("Equip slots full (%d/%d)" % [eq_list.size(), max_rel_slots])
					elif relic_purchasable[detail_hover_index] and char_level >= relic_earn_levels[detail_hover_index]:
						tt_lines.append("Click to buy for %d gold" % relic_costs[detail_hover_index])
					else:
						tt_lines.append("Unlocks at Level %d" % relic_earn_levels[detail_hover_index])
		if tt_title != "":
			var mouse_pos = get_viewport().get_mouse_position()
			var tt_w = font.get_string_size(tt_title, HORIZONTAL_ALIGNMENT_LEFT, -1, 12).x + 24
			for tl in tt_lines:
				tt_w = max(tt_w, font.get_string_size(tl, HORIZONTAL_ALIGNMENT_LEFT, -1, 9).x + 24)
			tt_w = clampf(tt_w, 160, 340)
			var tt_h = 22.0 + float(tt_lines.size()) * 14.0
			var tt_x = clampf(mouse_pos.x + 14, panel_x, panel_x + panel_w - tt_w - 4)
			var tt_y_pos = mouse_pos.y - tt_h - 10
			if tt_y_pos < panel_y:
				tt_y_pos = mouse_pos.y + 22
			draw_rect(Rect2(tt_x - 1, tt_y_pos - 1, tt_w + 2, tt_h + 2), Color(0, 0, 0, 0.6))
			draw_rect(Rect2(tt_x, tt_y_pos, tt_w, tt_h), Color(0.04, 0.03, 0.10, 0.95))
			draw_rect(Rect2(tt_x, tt_y_pos, tt_w, tt_h), Color(accent.r, accent.g, accent.b, 0.5), false, 1.5)
			_udraw(font, Vector2(tt_x + 8, tt_y_pos + 14), tt_title, HORIZONTAL_ALIGNMENT_LEFT, int(tt_w - 16), 12, menu_gold)
			for tli in range(tt_lines.size()):
				_udraw(font, Vector2(tt_x + 8, tt_y_pos + 28 + tli * 14), tt_lines[tli], HORIZONTAL_ALIGNMENT_LEFT, int(tt_w - 16), 9, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.85))

	# === INFO OVERLAY (drawn on top of everything when open) ===
	if detail_info_overlay_open:
		_draw_detail_info_overlay(panel_x, panel_y, panel_w, panel_h, tower_type, accent, font, char_level, progress)

func _draw_detail_info_overlay(panel_x: float, panel_y: float, panel_w: float, panel_h: float, tower_type, accent: Color, font: Font, char_level: int, progress: Dictionary) -> void:
	# Semi-transparent backdrop
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(0, 0, 0, 0.6))
	# Overlay panel (centered)
	var ov_w = 700.0
	var ov_h = 400.0
	var ov_x = panel_x + (panel_w - ov_w) * 0.5
	var ov_y = panel_y + (panel_h - ov_h) * 0.5
	# Panel background
	for i in range(40):
		var t = float(i) / 39.0
		var col = Color(0.06, 0.04, 0.12).lerp(Color(0.03, 0.02, 0.08), t)
		draw_rect(Rect2(ov_x, ov_y + t * ov_h, ov_w, ov_h / 39.0 + 1), col)
	# Border
	draw_rect(Rect2(ov_x, ov_y, ov_w, ov_h), Color(accent.r, accent.g, accent.b, 0.6), false, 2.0)
	draw_rect(Rect2(ov_x + 2, ov_y + 2, ov_w - 4, ov_h - 4), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.15), false, 1.0)
	# Close button (X)
	var close_x = ov_x + ov_w - 16.0
	var close_y = ov_y + 16.0
	draw_circle(Vector2(close_x, close_y), 12, Color(0.6, 0.2, 0.2, 0.6))
	_udraw(font, Vector2(close_x - 5, close_y + 5), "X", HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color.WHITE)
	# === Content ===
	var cx = ov_x + 20.0
	var cy = ov_y + 16.0
	# Character name
	var char_name = tower_info[tower_type]["name"].to_upper()
	_udraw(font, Vector2(cx, cy + 14), char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 18, menu_parchment)
	# Role badge
	var role = HERO_ROLE_NAMES.get(tower_type, "Hero")
	var role_w = font.get_string_size(role, HORIZONTAL_ALIGNMENT_LEFT, -1, 11).x + 16
	var role_x = cx + font.get_string_size(char_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 18).x + 14
	draw_rect(Rect2(role_x, cy, role_w, 20), Color(accent.r, accent.g, accent.b, 0.3))
	draw_rect(Rect2(role_x, cy, role_w, 20), Color(accent.r, accent.g, accent.b, 0.5), false, 1.0)
	_udraw(font, Vector2(role_x + 8, cy + 14), role, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(accent.r, accent.g, accent.b, 0.9))
	draw_rect(Rect2(cx, cy + 22, ov_w - 40, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))
	cy += 32.0
	# Character description
	var desc = survivor_descriptions.get(tower_type, "A legendary hero.")
	var desc_lines = desc.split("\n")
	for dl in desc_lines:
		_udraw(font, Vector2(cx, cy + 11), dl, HORIZONTAL_ALIGNMENT_LEFT, int(ov_w - 40), 10, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.8))
		cy += 14.0
	cy += 8.0
	# === Two columns: left = Stats, right = Synergies ===
	var col_w = (ov_w - 60.0) * 0.5
	var left_cx = cx
	var right_cx = cx + col_w + 20.0
	# --- LEFT COLUMN: Combat Stats ---
	_udraw(font, Vector2(left_cx, cy + 12), "COMBAT STATS", HORIZONTAL_ALIGNMENT_LEFT, -1, 12, menu_gold)
	draw_rect(Rect2(left_cx, cy + 16, 100, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.25))
	cy += 24.0
	var stat_left_y = cy
	var total_dmg = progress.get("total_damage", 0.0)
	var est_kills = int(total_dmg / 25.0)  # Rough estimate
	_udraw(font, Vector2(left_cx, stat_left_y + 11), "Total Damage: %s" % _format_number(total_dmg), HORIZONTAL_ALIGNMENT_LEFT, int(col_w), 10, menu_parchment)
	stat_left_y += 16.0
	_udraw(font, Vector2(left_cx, stat_left_y + 11), "Est. Enemies Defeated: %s" % _format_number(float(est_kills)), HORIZONTAL_ALIGNMENT_LEFT, int(col_w), 10, menu_parchment)
	stat_left_y += 16.0
	_udraw(font, Vector2(left_cx, stat_left_y + 11), "Level: %d / %d" % [char_level, MAX_SURVIVOR_LEVEL], HORIZONTAL_ALIGNMENT_LEFT, int(col_w), 10, menu_parchment)
	stat_left_y += 16.0
	# Golden Shields display with upgrade button
	var gs_level = _get_golden_shield_level(tower_type)
	_draw_golden_shield_indicator(Vector2(left_cx + 8, stat_left_y + 6), gs_level, font)
	_udraw(font, Vector2(left_cx + 26, stat_left_y + 11), "Golden Shields: %d / %d" % [gs_level, MAX_GOLDEN_SHIELD], HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 26), 10, Color(0.85, 0.7, 0.2))
	if gs_level < MAX_GOLDEN_SHIELD:
		var gs_cost = GOLDEN_SHIELD_COSTS[gs_level]
		var can_upgrade_gs = player_relic_shards >= gs_cost
		var gs_btn_x = left_cx + col_w - 90.0
		var gs_btn_y = stat_left_y - 2.0
		_gs_upgrade_btn_rect = Rect2(gs_btn_x, gs_btn_y, 86, 18)
		var gs_hover = (detail_hover_type == "golden_shield")
		var gs_bg = Color(0.2, 0.15, 0.05, 0.8) if (can_upgrade_gs and gs_hover) else Color(0.12, 0.08, 0.04, 0.7) if can_upgrade_gs else Color(0.08, 0.06, 0.08, 0.5)
		draw_rect(Rect2(gs_btn_x, gs_btn_y, 86, 18), gs_bg)
		draw_rect(Rect2(gs_btn_x, gs_btn_y, 86, 18), Color(0.85, 0.65, 0.1, 0.5) if can_upgrade_gs else Color(0.3, 0.25, 0.2, 0.3), false, 1.0)
		var gs_text = "UPGRADE %dS" % gs_cost
		_udraw(font, Vector2(gs_btn_x + 43, gs_btn_y + 13), gs_text, HORIZONTAL_ALIGNMENT_CENTER, 82, 9, Color(0.85, 0.7, 0.2) if can_upgrade_gs else Color(0.4, 0.35, 0.3))
	else:
		_udraw(font, Vector2(left_cx + col_w - 60, stat_left_y + 11), "MAXED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 9, Color(0.85, 0.7, 0.2, 0.6))
	stat_left_y += 16.0
	_udraw(font, Vector2(left_cx, stat_left_y + 11), "Slots: %d Gear | %d Sidekick | %d Binding" % [_get_gear_slot_count(tower_type), _get_sidekick_slot_count(tower_type), _get_binding_slot_count(tower_type)], HORIZONTAL_ALIGNMENT_LEFT, int(col_w), 9, menu_text)
	stat_left_y += 20.0
	# Level Bonus Breakdown
	_udraw(font, Vector2(left_cx, stat_left_y + 12), "BONUS BREAKDOWN", HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.8))
	draw_rect(Rect2(left_cx, stat_left_y + 16, 100, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.2))
	stat_left_y += 24.0
	var lvl_b = _get_level_bonuses(tower_type)
	var rel_b = _get_relic_bonuses(tower_type)
	var kb_dmg = _get_knowledge_bonus("damage")
	var kb_rng = _get_knowledge_bonus("range")
	var kb_spd = _get_knowledge_bonus("attack_speed")
	var bonus_lines = [
		["Level DMG", lvl_b.get("damage", 0.0)], ["Level RNG", lvl_b.get("range", 0.0)], ["Level SPD", lvl_b.get("attack_speed", 0.0)],
		["Knowledge DMG", kb_dmg], ["Knowledge RNG", kb_rng], ["Knowledge SPD", kb_spd],
	]
	for bl in bonus_lines:
		if bl[1] > 0:
			_udraw(font, Vector2(left_cx + 6, stat_left_y + 10), "%s: +%d%%" % [bl[0], int(bl[1] * 100)], HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 10), 9, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.7))
			stat_left_y += 13.0
	# --- RIGHT COLUMN: Synergies ---
	var syn_y = cy
	_udraw(font, Vector2(right_cx, syn_y + 12), "SYNERGIES", HORIZONTAL_ALIGNMENT_LEFT, -1, 12, menu_gold)
	draw_rect(Rect2(right_cx, syn_y + 16, 80, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.25))
	syn_y += 24.0
	var syn_count = 0
	for syn in synergy_definitions:
		if syn["tower_a"] == tower_type or syn["tower_b"] == tower_type:
			# Synergy card
			draw_rect(Rect2(right_cx, syn_y, col_w, 36), Color(accent.r, accent.g, accent.b, 0.06))
			draw_rect(Rect2(right_cx, syn_y, col_w, 36), Color(accent.r, accent.g, accent.b, 0.15), false, 1.0)
			_udraw(font, Vector2(right_cx + 6, syn_y + 13), syn["name"], HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 12), 10, Color(0.85, 0.65, 0.1, 0.9))
			_udraw(font, Vector2(right_cx + 6, syn_y + 27), syn["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 12), 8, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.7))
			# Partner name
			var partner = syn["tower_b"] if syn["tower_a"] == tower_type else syn["tower_a"]
			var partner_name = tower_info[partner]["name"]
			var pnw = font.get_string_size("+ " + partner_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 8).x
			_udraw(font, Vector2(right_cx + col_w - pnw - 6, syn_y + 13), "+ " + partner_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(menu_parchment.r, menu_parchment.g, menu_parchment.b, 0.6))
			syn_y += 42.0
			syn_count += 1
	if syn_count == 0:
		_udraw(font, Vector2(right_cx + 6, syn_y + 11), "No synergies discovered", HORIZONTAL_ALIGNMENT_LEFT, int(col_w - 12), 10, Color(menu_text_muted.r, menu_text_muted.g, menu_text_muted.b, 0.5))

func _format_number(value: float) -> String:
	if value >= 1000000:
		return "%.1fM" % (value / 1000000.0)
	elif value >= 1000:
		return "%.1fK" % (value / 1000.0)
	return str(int(value))

func _format_gold(amount: int) -> String:
	if amount < 1000:
		return str(amount)
	var s = str(amount)
	var result = ""
	var count = 0
	for i in range(s.length() - 1, -1, -1):
		if count > 0 and count % 3 == 0:
			result = "," + result
		result = s[i] + result
		count += 1
	return result

func _draw_detail_level_star(center: Vector2, req_level: int, font: Font) -> void:
	var sr = 10.0
	var spts = PackedVector2Array()
	for si in range(10):
		var sa = -PI * 0.5 + float(si) * TAU / 10.0
		var sd = sr if si % 2 == 0 else sr * 0.4
		spts.append(Vector2(center.x + cos(sa) * sd, center.y + sin(sa) * sd))
	draw_colored_polygon(spts, Color(0.85, 0.65, 0.1, 0.85))
	var ls = str(req_level)
	var lw = font.get_string_size(ls, HORIZONTAL_ALIGNMENT_LEFT, -1, 8).x
	_udraw(font, Vector2(center.x - lw * 0.5, center.y + 3), ls, HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.03, 0.03, 0.08))

# Story map node positions — 18 levels in a winding path
var story_map_selected_node: int = -1
var story_map_scroll_y: float = 0.0
var story_map_active_arc: int = -1
var menu_side_panel: String = ""  # "", "deals", "quests", "arena", "odyssey", "endless"

func _get_story_map_node_positions() -> Array:
	# Two-column book spread layout:
	# Left page: Act I (arcs 0-5, levels 0-15)
	# Right page: Act II (arcs 6-11, levels 16-33)
	# Bottom center: Act III / Shadow Author (levels 34-36)
	var nodes: Array = []
	var row_h = 56.0
	var start_y = 95.0
	var lx = [200.0, 310.0, 420.0]  # Left column L→R
	var lx_rev = [420.0, 310.0, 200.0]  # Left column R→L
	var rx = [810.0, 920.0, 1030.0]  # Right column L→R
	var rx_rev = [1030.0, 920.0, 810.0]  # Right column R→L
	# Level 0: Prologue — centered in left column
	nodes.append(Vector2(310.0, start_y))
	# Levels 1-15: Left column arcs 1-5 (Sherlock → Frankenstein)
	for r in range(5):
		var y = start_y + float(r + 1) * row_h
		var xs = lx if r % 2 == 0 else lx_rev
		nodes.append(Vector2(xs[0], y))
		nodes.append(Vector2(xs[1], y))
		nodes.append(Vector2(xs[2], y))
	# Levels 16-33: Right column arcs 6-11 (Robin Hood → Scrooge)
	for r in range(6):
		var y = start_y + float(r) * row_h
		var xs = rx if r % 2 == 0 else rx_rev
		nodes.append(Vector2(xs[0], y))
		nodes.append(Vector2(xs[1], y))
		nodes.append(Vector2(xs[2], y))
	# Levels 34-36: Shadow Author — centered bottom
	var shadow_y = start_y + 6.0 * row_h + 18.0
	nodes.append(Vector2(460.0, shadow_y))
	nodes.append(Vector2(640.0, shadow_y))
	nodes.append(Vector2(820.0, shadow_y))
	return nodes

var chapters_hover_level: int = -1

func _draw_story_map() -> void:
	var font = game_font
	var list_x = 40.0
	var list_y = 36.0
	var list_w = 1200.0
	var list_h = 610.0
	var row_h = 82.0
	var header_h = 32.0
	var arc_gap = 6.0

	# --- Background panel ---
	draw_rect(Rect2(list_x, list_y, list_w, list_h), Color(0.05, 0.04, 0.08, 0.95))
	draw_rect(Rect2(list_x, list_y, list_w, 2), Color(0.54, 0.45, 0.20, 0.4))
	draw_rect(Rect2(list_x, list_y + list_h - 2, list_w, 2), Color(0.54, 0.45, 0.20, 0.25))

	# --- Title bar ---
	draw_rect(Rect2(list_x, list_y, list_w, 36), Color(0.08, 0.06, 0.12, 0.9))
	_udraw(font, Vector2(list_x + list_w * 0.35, list_y + 25), "THE TOME OF SHADOWS", HORIZONTAL_ALIGNMENT_CENTER, list_w - 40, 16, Color(0.85, 0.70, 0.28))
	# Level progress indicator
	var num_completed = completed_levels.size()
	var num_total = levels.size()
	var progress_text = "%d/%d Levels" % [num_completed, num_total]
	_udraw(font, Vector2(list_x + list_w - 160, list_y + 25), progress_text, HORIZONTAL_ALIGNMENT_RIGHT, 150, 12, Color(0.7, 0.65, 0.5, 0.8))
	# Mini progress bar
	var pb_x = list_x + list_w - 155
	var pb_w = 105.0
	draw_rect(Rect2(pb_x, list_y + 28, pb_w, 4), Color(0.2, 0.18, 0.25, 0.6))
	var pb_fill = pb_w * clampf(float(num_completed) / float(maxi(num_total, 1)), 0.0, 1.0)
	draw_rect(Rect2(pb_x, list_y + 28, pb_fill, 4), Color(0.85, 0.70, 0.28, 0.8))
	draw_rect(Rect2(list_x, list_y + 36, list_w, 1), Color(0.54, 0.45, 0.20, 0.3))

	var content_top = list_y + 40.0
	var content_h = list_h - 40.0

	# --- Calculate total content height ---
	var total_h = 0.0
	for arc in arc_data:
		total_h += header_h + arc_gap
		total_h += float(arc["levels"].size()) * row_h
	total_h += 10.0  # Bottom padding
	var max_scroll = maxf(0.0, total_h - content_h)
	story_map_scroll_y = clampf(story_map_scroll_y, 0.0, max_scroll)

	# --- Clip region (draw only within visible area) ---
	var scroll_y = story_map_scroll_y
	var cursor_y = content_top - scroll_y
	var mouse_pos = get_viewport().get_mouse_position()

	var arc_color_map = {
		"Prologue": Color(0.45, 0.30, 0.55),
		"Sherlock Holmes": Color(0.50, 0.50, 0.62),
		"Merlin": Color(0.30, 0.50, 0.72),
		"Tarzan": Color(0.25, 0.60, 0.25),
		"Dracula": Color(0.65, 0.18, 0.22),
		"Frankenstein": Color(0.42, 0.52, 0.32),
		"Robin Hood": Color(0.32, 0.58, 0.28),
		"Alice": Color(0.46, 0.68, 0.88),
		"Wicked Witch": Color(0.52, 0.28, 0.66),
		"Peter Pan": Color(0.92, 0.52, 0.16),
		"Phantom": Color(0.78, 0.25, 0.20),
		"Scrooge": Color(0.82, 0.68, 0.32),
		"Shadow Author": Color(0.25, 0.10, 0.30),
	}

	for ai in range(arc_data.size()):
		var arc = arc_data[ai]
		var arc_name = arc["name"]
		var arc_col = arc_color_map.get(arc_name, Color(0.5, 0.5, 0.5))
		var arc_levels = arc["levels"]

		# --- Arc completion ---
		var arc_done = 0
		var arc_total = arc_levels.size()
		for lvl_idx in arc_levels:
			if lvl_idx in completed_levels:
				arc_done += 1
		var arc_pct = 0
		if arc_total > 0:
			arc_pct = int(float(arc_done) / float(arc_total) * 100.0)

		# --- Arc header ---
		if cursor_y + header_h > content_top and cursor_y < content_top + content_h:
			var hy = maxf(cursor_y, content_top)
			draw_rect(Rect2(list_x + 4, hy, list_w - 8, header_h), Color(arc_col.r * 0.3, arc_col.g * 0.3, arc_col.b * 0.3, 0.8))
			draw_rect(Rect2(list_x + 4, hy, 4, header_h), Color(arc_col.r, arc_col.g, arc_col.b, 0.8))
			_udraw(font, Vector2(list_x + 18, hy + 22), arc_name.to_upper(), HORIZONTAL_ALIGNMENT_LEFT, 400, 14, Color(0.92, 0.78, 0.28))
			if arc_done == arc_total:
				_udraw(font, Vector2(list_x + list_w - 20, hy + 22), "COMPLETE", HORIZONTAL_ALIGNMENT_RIGHT, 200, 12, Color(0.45, 0.80, 0.30))
			else:
				_udraw(font, Vector2(list_x + list_w - 20, hy + 22), "%d%% Complete" % arc_pct, HORIZONTAL_ALIGNMENT_RIGHT, 200, 12, Color(0.60, 0.52, 0.38))
		cursor_y += header_h + arc_gap

		# --- Level rows ---
		for li in range(arc_levels.size()):
			var lvl_idx = arc_levels[li]
			if lvl_idx >= levels.size():
				cursor_y += row_h
				continue
			var level = levels[lvl_idx]
			var is_unlocked = _is_level_unlocked(lvl_idx)
			var is_complete = lvl_idx in completed_levels
			var stars = level_stars.get(lvl_idx, 0)

			# Skip rows outside visible area
			if cursor_y + row_h < content_top or cursor_y > content_top + content_h:
				cursor_y += row_h
				continue

			var ry = cursor_y
			var rx = list_x + 8.0
			var rw = list_w - 16.0

			# --- Row background ---
			var is_hovered = Rect2(rx, maxf(ry, content_top), rw, row_h).has_point(mouse_pos) and ry >= content_top
			var row_bg = Color(0.10, 0.08, 0.06, 0.5) if not is_hovered else Color(0.15, 0.12, 0.08, 0.7)
			if not is_unlocked:
				row_bg = Color(0.06, 0.05, 0.04, 0.4)
			draw_rect(Rect2(rx, ry, rw, row_h - 2), row_bg)
			# Left accent bar
			var accent_col = arc_col if is_unlocked else Color(0.3, 0.25, 0.2, 0.3)
			draw_rect(Rect2(rx, ry, 3, row_h - 2), accent_col)

			# --- Mini map thumbnail (70x52) ---
			var thumb_x = rx + 12.0
			var thumb_y = ry + 8.0
			var thumb_w = 70.0
			var thumb_h = 52.0
			var sky = level["sky_color"] if is_unlocked else Color(0.15, 0.12, 0.10)
			var gnd = level["ground_color"] if is_unlocked else Color(0.10, 0.08, 0.06)
			draw_rect(Rect2(thumb_x, thumb_y, thumb_w, thumb_h * 0.5), sky)
			draw_rect(Rect2(thumb_x, thumb_y + thumb_h * 0.5, thumb_w, thumb_h * 0.5), gnd)
			# Terrain detail dots (subtle background)
			for ti in range(5):
				var tx = thumb_x + float(ti) * 16.0 + 4.0
				var ty = thumb_y + thumb_h * 0.48 + sin(float(ti + lvl_idx) * 1.3) * 4.0
				draw_circle(Vector2(tx, ty), 3.0, Color(gnd.r * 1.2, gnd.g * 1.2, gnd.b * 1.2, 0.25))
			# Path preview in thumbnail
			if _path_thumbnail_cache.has(lvl_idx) and is_unlocked:
				var pts = _path_thumbnail_cache[lvl_idx]
				if pts.size() >= 2:
					var min_p = Vector2(1e9, 1e9)
					var max_p = Vector2(-1e9, -1e9)
					for p in pts:
						min_p.x = minf(min_p.x, p.x)
						min_p.y = minf(min_p.y, p.y)
						max_p.x = maxf(max_p.x, p.x)
						max_p.y = maxf(max_p.y, p.y)
					var range_p = max_p - min_p
					if range_p.x < 1: range_p.x = 1
					if range_p.y < 1: range_p.y = 1
					var margin = 4.0
					var draw_w = thumb_w - margin * 2
					var draw_h = thumb_h - margin * 2
					var scaled: PackedVector2Array = PackedVector2Array()
					for p in pts:
						var nx = thumb_x + margin + ((p.x - min_p.x) / range_p.x) * draw_w
						var ny = thumb_y + margin + ((p.y - min_p.y) / range_p.y) * draw_h
						scaled.append(Vector2(nx, ny))
					var path_col = Color(0.85, 0.75, 0.45, 0.7)
					for pi in range(scaled.size() - 1):
						draw_line(scaled[pi], scaled[pi + 1], path_col, 1.5)
					draw_circle(scaled[0], 2.5, Color(0.3, 0.8, 0.3, 0.8))
					draw_circle(scaled[scaled.size() - 1], 2.5, Color(0.8, 0.2, 0.2, 0.8))
			draw_rect(Rect2(thumb_x, thumb_y, thumb_w, thumb_h), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
			# Level number badge
			draw_circle(Vector2(thumb_x + 12, thumb_y + 12), 10, Color(0.0, 0.0, 0.0, 0.6))
			_udraw(font, Vector2(thumb_x + 12, thumb_y + 16), str(lvl_idx + 1), HORIZONTAL_ALIGNMENT_CENTER, 20, 10, Color(0.90, 0.82, 0.55))

			# --- Text info ---
			var text_x = thumb_x + thumb_w + 14.0
			var name_col = Color(0.92, 0.80, 0.35) if is_unlocked else Color(0.45, 0.38, 0.28, 0.6)
			var sub_col = Color(0.70, 0.60, 0.42) if is_unlocked else Color(0.35, 0.30, 0.22, 0.5)
			var stat_col = Color(0.55, 0.70, 0.45) if is_unlocked else Color(0.30, 0.28, 0.22, 0.4)
			_udraw(font, Vector2(text_x, ry + 22), level["name"], HORIZONTAL_ALIGNMENT_LEFT, 440, 14, name_col)
			_udraw(font, Vector2(text_x, ry + 38), level["subtitle"], HORIZONTAL_ALIGNMENT_LEFT, 440, 10, sub_col)
			_udraw(font, Vector2(text_x, ry + 54), "Waves: %d  |  Gold: %d  |  Lives: %d" % [level["waves"], level["gold"], level["lives"]], HORIZONTAL_ALIGNMENT_LEFT, 440, 9, stat_col)

			# --- Stars / medals ---
			var star_x = rx + rw - 220.0
			for si in range(3):
				var sc = Vector2(star_x + float(si) * 24.0, ry + 24.0)
				if si < stars:
					_draw_mini_star(sc, 8.0, Color(1, 0.88, 0.32, 0.9))
				else:
					_draw_mini_star(sc, 7.0, Color(0.35, 0.28, 0.18, 0.3))

			# --- GO / PLAY button or LOCKED ---
			var btn_x = rx + rw - 100.0
			var btn_y2 = ry + 14.0
			var btn_w2 = 80.0
			var btn_h2 = 38.0
			if is_unlocked:
				var btn_hover = Rect2(btn_x, btn_y2, btn_w2, btn_h2).has_point(mouse_pos) and ry >= content_top
				var btn_pulse = 0.85 + sin(_time * 3.0) * 0.15 if not is_complete else 0.7
				var btn_col = Color(0.20, 0.58, 0.15, btn_pulse) if not btn_hover else Color(0.25, 0.68, 0.18, 1.0)
				if is_complete:
					btn_col = Color(0.15, 0.40, 0.12, 0.6) if not btn_hover else Color(0.20, 0.50, 0.15, 0.8)
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, btn_h2), btn_col)
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, 2), Color(0.4, 0.8, 0.3, 0.3))
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, btn_h2), Color(0.54, 0.45, 0.20, 0.4), false, 1.0)
				_udraw(font, Vector2(btn_x + btn_w2 * 0.5, btn_y2 + 25), "GO", HORIZONTAL_ALIGNMENT_CENTER, btn_w2 - 8, 14, Color(1, 1, 1, 0.95))
			else:
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, btn_h2), Color(0.12, 0.10, 0.08, 0.5))
				draw_rect(Rect2(btn_x, btn_y2, btn_w2, btn_h2), Color(0.3, 0.25, 0.18, 0.3), false, 1.0)
				# Lock icon
				var lc = Vector2(btn_x + btn_w2 * 0.5, btn_y2 + btn_h2 * 0.5)
				draw_rect(Rect2(lc.x - 5, lc.y - 1, 10, 9), Color(0.40, 0.32, 0.20, 0.5))
				draw_arc(Vector2(lc.x, lc.y - 3), 5.0, PI, TAU, 10, Color(0.40, 0.32, 0.20, 0.5), 1.5)

			# --- Bottom separator ---
			draw_line(Vector2(rx + 8, ry + row_h - 2), Vector2(rx + rw - 8, ry + row_h - 2), Color(0.54, 0.45, 0.20, 0.08), 1.0)

			cursor_y += row_h

	# --- Scroll bar ---
	if max_scroll > 0:
		var bar_x = list_x + list_w - 8
		var bar_h_vis = content_h * (content_h / total_h)
		var bar_y_pos = content_top + (scroll_y / max_scroll) * (content_h - bar_h_vis)
		draw_rect(Rect2(bar_x, content_top, 4, content_h), Color(0.2, 0.15, 0.10, 0.15))
		draw_rect(Rect2(bar_x, bar_y_pos, 4, bar_h_vis), Color(0.54, 0.45, 0.20, 0.35))

func _on_story_map_clicked(mouse_pos: Vector2) -> void:
	var list_x = 40.0
	var list_y = 36.0
	var list_w = 1200.0
	var list_h = 610.0
	var row_h = 82.0
	var header_h = 32.0
	var arc_gap = 6.0
	var content_top = list_y + 40.0
	var content_h = list_h - 40.0
	var scroll_y = story_map_scroll_y

	# Only process clicks within the list area
	if not Rect2(list_x, content_top, list_w, content_h).has_point(mouse_pos):
		return

	var cursor_y = content_top - scroll_y
	for ai in range(arc_data.size()):
		var arc = arc_data[ai]
		cursor_y += header_h + arc_gap
		for li in range(arc["levels"].size()):
			var lvl_idx = arc["levels"][li]
			if lvl_idx >= levels.size():
				cursor_y += row_h
				continue
			var ry = cursor_y
			var rx = list_x + 8.0
			var rw = list_w - 16.0

			if ry + row_h >= content_top and ry <= content_top + content_h:
				# Check GO button click
				var btn_x = rx + rw - 100.0
				var btn_y2 = ry + 14.0
				var btn_w2 = 80.0
				var btn_h2 = 38.0
				if Rect2(btn_x, btn_y2, btn_w2, btn_h2).has_point(mouse_pos):
					if _is_level_unlocked(lvl_idx):
						_on_level_selected(lvl_idx)
						return

			cursor_y += row_h

func _draw_chapters_badges() -> void:
	var font = game_font
	var mouse_pos = get_viewport().get_mouse_position()
	# 5 floating animated badge circles along the right edge of the chapter view
	var badges = [
		{"id": "deals", "label": "DEALS", "col": Color(0.85, 0.70, 0.28)},
		{"id": "quests", "label": "QUESTS", "col": Color(0.4, 0.8, 0.3)},
		{"id": "arena", "label": "ARENA", "col": Color(0.7, 0.3, 0.9)},
		{"id": "odyssey", "label": "ODYSSEY", "col": Color(0.82, 0.62, 0.92)},
		{"id": "endless", "label": "ENDLESS", "col": Color(0.52, 0.62, 0.92)},
	]
	var badge_x = 1222.0
	var badge_start_y = 85.0
	var badge_spacing = 68.0
	var badge_r = 24.0

	for i in range(badges.size()):
		var badge = badges[i]
		var tc = badge["col"]
		var bob = sin(_time * 1.5 + float(i) * 1.2) * 2.5
		var cx = badge_x
		var cy = badge_start_y + float(i) * badge_spacing + bob
		var is_hovered = mouse_pos.distance_to(Vector2(cx, cy)) < badge_r + 5
		var pulse = 0.12 + sin(_time * 3.0 + float(i) * 0.8) * 0.08

		# Outer glow halo
		var glow_r = badge_r + 8 + sin(_time * 2.0 + float(i)) * 3.0
		draw_circle(Vector2(cx, cy), glow_r, Color(tc.r, tc.g, tc.b, pulse * (1.8 if is_hovered else 1.0)))
		# Dark background circle
		draw_circle(Vector2(cx, cy), badge_r, Color(0.05, 0.03, 0.07, 0.93))
		# Inner gradient shine
		draw_circle(Vector2(cx, cy - 3), badge_r * 0.6, Color(tc.r * 0.15, tc.g * 0.15, tc.b * 0.15, 0.3))
		# Animated border ring
		var border_a = 0.85 if is_hovered else 0.45
		draw_arc(Vector2(cx, cy), badge_r, 0, TAU, 32, Color(tc.r, tc.g, tc.b, border_a), 2.5)
		if is_hovered:
			draw_arc(Vector2(cx, cy), badge_r + 3, 0, TAU, 32, Color(tc.r, tc.g, tc.b, 0.2), 1.0)

		# Per-badge procedural icon
		var ic = Color(tc.r, tc.g, tc.b, 0.9)
		if i == 0:  # DEALS — coin with dollar sign
			draw_circle(Vector2(cx, cy), 10, Color(tc.r, tc.g, tc.b, 0.35))
			draw_arc(Vector2(cx, cy), 10, 0, TAU, 16, Color(tc.r, tc.g, tc.b, 0.5), 1.5)
			_udraw(font, Vector2(cx, cy + 5), "$", HORIZONTAL_ALIGNMENT_CENTER, -1, 13, ic)
		elif i == 1:  # QUESTS — scroll with lines
			draw_rect(Rect2(cx - 7, cy - 10, 14, 20), Color(tc.r, tc.g, tc.b, 0.3))
			draw_arc(Vector2(cx, cy - 10), 7, PI, TAU, 8, ic, 1.5)
			draw_arc(Vector2(cx, cy + 10), 7, 0, PI, 8, ic, 1.5)
			for li in range(3):
				var ly = cy - 4.0 + float(li) * 5.0
				draw_line(Vector2(cx - 5, ly), Vector2(cx + 5, ly), Color(tc.r, tc.g, tc.b, 0.6), 1.0)
		elif i == 2:  # ARENA — crossed swords
			draw_line(Vector2(cx - 9, cy + 9), Vector2(cx + 9, cy - 9), ic, 2.5)
			draw_line(Vector2(cx + 9, cy + 9), Vector2(cx - 9, cy - 9), ic, 2.5)
			draw_circle(Vector2(cx, cy), 3.5, Color(tc.r, tc.g, tc.b, 0.5))
		elif i == 3:  # ODYSSEY — compass rose
			for si in range(4):
				var sa = float(si) * TAU / 4.0 - PI * 0.25
				var tip = Vector2(cx + cos(sa) * 10, cy + sin(sa) * 10)
				draw_line(Vector2(cx, cy), tip, ic, 1.5)
				draw_circle(tip, 1.5, ic)
			draw_circle(Vector2(cx, cy), 3, Color(tc.r, tc.g, tc.b, 0.6))
		elif i == 4:  # ENDLESS — infinity symbol
			draw_arc(Vector2(cx - 5, cy), 6, -PI * 0.75, PI * 0.75, 12, ic, 2.0)
			draw_arc(Vector2(cx + 5, cy), 6, PI * 0.25, PI * 1.75, 12, ic, 2.0)

		# Label below badge
		var lbl_a = 0.85 if is_hovered else 0.5
		_udraw(font, Vector2(cx, cy + badge_r + 13), badge["label"], HORIZONTAL_ALIGNMENT_CENTER, -1, 8, Color(tc.r, tc.g, tc.b, lbl_a))

		# Orbiting sparkles on hover
		if is_hovered:
			for si in range(3):
				var sa = _time * 3.0 + float(si) * TAU / 3.0
				var sp = Vector2(cx + cos(sa) * (badge_r + 5), cy + sin(sa) * (badge_r + 5))
				draw_circle(sp, 1.5, Color(tc.r, tc.g, tc.b, 0.45 + sin(_time * 4.0 + float(si)) * 0.2))

		# Notification dot (red pulsing) for actionable items
		var show_dot = false
		if i == 0:  # Deals — any unpurchased
			for di in range(daily_deals_purchased.size()):
				if not daily_deals_purchased[di]:
					show_dot = true
					break
		elif i == 1:  # Quests — any completed but unclaimed
			for q in active_quests:
				if q.get("completed", false) and not q.get("claimed", false):
					show_dot = true
					break
		if show_dot:
			var dot_pos = Vector2(cx + badge_r * 0.55, cy - badge_r * 0.55)
			draw_circle(dot_pos, 6, Color(0.85, 0.15, 0.1, 0.9))
			draw_circle(dot_pos, 3.5, Color(1.0, 0.35, 0.25, 0.6 + sin(_time * 5.0) * 0.3))

func _draw_chapters_overlay() -> void:
	if menu_side_panel == "":
		return
	var font = game_font
	# Dark dimming overlay behind the panel
	draw_rect(Rect2(0, 0, 1280, 620), Color(0, 0, 0, 0.65))
	# Panel dimensions (centered)
	var panel_x = 250.0
	var panel_y = 55.0
	var panel_w = 780.0
	var panel_h = 520.0
	var content_y = panel_y + 52.0
	var content_h = panel_h - 60.0
	# Panel theme color
	var color_map = {"deals": Color(0.85, 0.70, 0.28), "quests": Color(0.4, 0.8, 0.3), "arena": Color(0.7, 0.3, 0.9), "odyssey": Color(0.82, 0.62, 0.92), "endless": Color(0.52, 0.62, 0.92)}
	var tc = color_map.get(menu_side_panel, menu_gold)
	# Panel background with subtle gradient
	for gi in range(52):
		var t = float(gi) / 51.0
		var col = Color(0.06, 0.04, 0.08).lerp(Color(0.03, 0.02, 0.05), t)
		draw_rect(Rect2(panel_x, panel_y + t * panel_h, panel_w, panel_h / 51.0 + 1), col)
	# Animated glowing gold border
	var bp = 0.5 + sin(_time * 2.0) * 0.15
	var bc = Color(tc.r, tc.g, tc.b, bp)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), bc)
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), bc)
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), bc)
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), bc)
	# Second inner border (double-line effect)
	draw_rect(Rect2(panel_x + 4, panel_y + 4, panel_w - 8, 1), Color(tc.r, tc.g, tc.b, bp * 0.3))
	draw_rect(Rect2(panel_x + 4, panel_y + panel_h - 5, panel_w - 8, 1), Color(tc.r, tc.g, tc.b, bp * 0.3))
	draw_rect(Rect2(panel_x + 4, panel_y + 4, 1, panel_h - 8), Color(tc.r, tc.g, tc.b, bp * 0.3))
	draw_rect(Rect2(panel_x + panel_w - 5, panel_y + 4, 1, panel_h - 8), Color(tc.r, tc.g, tc.b, bp * 0.3))
	# Corner flourish decorations
	var corners = [Vector2(panel_x, panel_y), Vector2(panel_x + panel_w, panel_y), Vector2(panel_x, panel_y + panel_h), Vector2(panel_x + panel_w, panel_y + panel_h)]
	for ci in range(4):
		var cp = corners[ci]
		var dxf = 1.0 if ci % 2 == 0 else -1.0
		var dyf = 1.0 if ci < 2 else -1.0
		draw_line(cp, cp + Vector2(dxf * 25, 0), Color(tc.r, tc.g, tc.b, 0.5), 2.0)
		draw_line(cp, cp + Vector2(0, dyf * 25), Color(tc.r, tc.g, tc.b, 0.5), 2.0)
		# Small decorative curl
		draw_arc(cp + Vector2(dxf * 12, dyf * 12), 8, 0, TAU * 0.5, 8, Color(tc.r, tc.g, tc.b, 0.15), 1.0)
	# Title bar with glow
	draw_rect(Rect2(panel_x + 2, panel_y + 2, panel_w - 4, 48), Color(tc.r * 0.08, tc.g * 0.08, tc.b * 0.08, 0.6))
	var title_map = {"deals": "DAILY DEALS", "quests": "DAILY QUESTS", "arena": "SHADOW ARENA", "odyssey": "ODYSSEY MODE", "endless": "THE ETERNAL CHAPTER"}
	var title = title_map.get(menu_side_panel, "")
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 34), title, HORIZONTAL_ALIGNMENT_CENTER, int(panel_w - 100), 20, tc)
	# Title underline with glow
	draw_rect(Rect2(panel_x + 20, panel_y + 50, panel_w - 40, 1), Color(tc.r, tc.g, tc.b, 0.4))
	# Subtle glow beneath title line
	draw_rect(Rect2(panel_x + 40, panel_y + 51, panel_w - 80, 2), Color(tc.r, tc.g, tc.b, 0.08))
	# Close button (X) — top right
	var close_x = panel_x + panel_w - 42.0
	var close_y = panel_y + 10.0
	var mouse_pos = get_viewport().get_mouse_position()
	var close_hov = Rect2(close_x, close_y, 30, 30).has_point(mouse_pos)
	draw_rect(Rect2(close_x, close_y, 30, 30), Color(0.6, 0.1, 0.1, 0.55 if close_hov else 0.2))
	draw_rect(Rect2(close_x, close_y, 30, 30), Color(0.9, 0.3, 0.3, 0.5 if close_hov else 0.2), false, 1.0)
	var xc = Color(0.95, 0.35, 0.3, 0.95 if close_hov else 0.6)
	draw_line(Vector2(close_x + 8, close_y + 8), Vector2(close_x + 22, close_y + 22), xc, 2.5)
	draw_line(Vector2(close_x + 22, close_y + 8), Vector2(close_x + 8, close_y + 22), xc, 2.5)
	# Draw the selected panel content (reuses existing sidebar draw functions)
	if menu_side_panel == "deals":
		_draw_daily_deals_sidebar(panel_x, content_y, panel_w, content_h)
	elif menu_side_panel == "quests":
		_draw_quest_panel_sidebar(panel_x, content_y, panel_w, content_h)
	elif menu_side_panel == "arena":
		_draw_shadow_arena_sidebar(panel_x, content_y, panel_w, content_h)
	elif menu_side_panel == "odyssey":
		_draw_odyssey_sidebar(panel_x, content_y, panel_w, content_h)
	elif menu_side_panel == "endless":
		_draw_endless_sidebar(panel_x, content_y, panel_w, content_h)

func _on_chapters_sidebar_clicked(mouse_pos: Vector2) -> void:
	# Overlay panel coordinates (must match _draw_chapters_overlay)
	var panel_x = 250.0
	var panel_y = 55.0
	var panel_w = 780.0
	var panel_h = 520.0
	var content_y = panel_y + 52.0

	if menu_side_panel != "":
		# --- Overlay is open: handle close + content clicks ---
		# Close button
		var close_x = panel_x + panel_w - 42.0
		var close_y_btn = panel_y + 10.0
		if Rect2(close_x, close_y_btn, 30, 30).has_point(mouse_pos):
			menu_side_panel = ""
			queue_redraw()
			return
		# Click outside panel closes it
		if not Rect2(panel_x, panel_y, panel_w, panel_h).has_point(mouse_pos):
			menu_side_panel = ""
			queue_redraw()
			return
		# Content-specific clicks
		if menu_side_panel == "deals":
			_on_overlay_deals_clicked(mouse_pos, panel_x, content_y, panel_w)
		elif menu_side_panel == "arena":
			_on_overlay_arena_clicked(mouse_pos, panel_x, content_y, panel_w)
		elif menu_side_panel == "odyssey":
			if not odyssey_completed_this_week:
				if Rect2(panel_x + panel_w * 0.5 - 60, content_y + 120, 120, 40).has_point(mouse_pos):
					menu_side_panel = ""
					_start_odyssey()
		elif menu_side_panel == "endless":
			if Rect2(panel_x + panel_w * 0.5 - 60, content_y + 145, 120, 40).has_point(mouse_pos):
				menu_side_panel = ""
				_start_endless_mode()
		return

	# --- No overlay: check badge clicks ---
	var badge_x = 1222.0
	var badge_start_y = 85.0
	var badge_spacing = 68.0
	var badge_r = 28.0  # Click radius slightly larger than visual
	var badge_ids = ["deals", "quests", "arena", "odyssey", "endless"]

	for i in range(badge_ids.size()):
		var bob = sin(_time * 1.5 + float(i) * 1.2) * 2.5
		var cy = badge_start_y + float(i) * badge_spacing + bob
		if mouse_pos.distance_to(Vector2(badge_x, cy)) < badge_r:
			menu_side_panel = badge_ids[i]
			queue_redraw()
			return

func _on_overlay_deals_clicked(mouse_pos: Vector2, px: float, py: float, pw: float) -> void:
	for i in range(min(3, daily_deals.size())):
		if daily_deals_purchased[i]:
			continue
		var deal = daily_deals[i]
		var ix = px + 10
		var iy = py + 42 + float(i) * 58.0
		var iw = pw - 20
		if mouse_pos.x >= ix + iw - 100 and mouse_pos.x <= ix + iw - 12 and mouse_pos.y >= iy + 8 and mouse_pos.y <= iy + 42:
			var cost = deal.get("cost", 0)
			var cost_type = deal.get("cost_type", "")
			var can_afford = false
			match cost_type:
				"quills": can_afford = player_quills >= cost
				"shards": can_afford = player_relic_shards >= cost
				"stars": can_afford = player_storybook_stars >= cost
				"gold": can_afford = player_gold >= cost
			if not can_afford:
				return
			match cost_type:
				"quills": player_quills -= cost
				"shards": player_relic_shards -= cost
				"stars": player_storybook_stars -= cost
				"gold": player_gold -= cost
			match deal.get("type", ""):
				"binding":
					var b = deal.get("item", {})
					if b.has("id"):
						owned_bindings[b["id"]] = owned_bindings.get(b["id"], 0) + 1
				"power":
					var pid = deal.get("power_id", "")
					var amt = deal.get("amount", 1)
					if pid != "":
						owned_powers[pid] = owned_powers.get(pid, 0) + amt
				"currency":
					var ctype = deal.get("currency_type", "")
					var camt = deal.get("amount", 0)
					match ctype:
						"quills": player_quills += camt
						"shards": player_relic_shards += camt
						"stars": player_storybook_stars += camt
						"gold": player_gold += camt
						"ink": knowledge_ink += camt
			daily_deals_purchased[i] = true
			total_emporium_purchases += 1
			_save_game()
			queue_redraw()
			return

func _on_overlay_arena_clicked(mouse_pos: Vector2, px: float, py: float, pw: float) -> void:
	var shop_items = _get_arena_shop_items()
	# Enter button
	var enter_y = py + 54 + 16 + float(shop_items.size()) * 42.0 + 10 + 210
	if Rect2(px + pw * 0.5 - 60, enter_y, 120, 36).has_point(mouse_pos):
		menu_side_panel = ""
		_start_shadow_arena()
		return
	# Crystal shop item clicks
	for si in range(shop_items.size()):
		var item = shop_items[si]
		var iy = py + 280 + 16 + float(si) * 42.0
		if mouse_pos.x >= px + 8 and mouse_pos.x <= px + pw - 8 and mouse_pos.y >= iy and mouse_pos.y <= iy + 36:
			if arena_crystals >= item["cost"]:
				arena_crystals -= item["cost"]
				match item["type"]:
					"shards": player_relic_shards += item["amount"]
					"quills": player_quills += item["amount"]
					"stars": player_storybook_stars += item["amount"]
					"gold": player_gold += item["amount"]
					"ink": knowledge_ink += item["amount"]
				queue_redraw()
			break

# --- Sidebar panel draw functions (repositioned versions) ---

func _draw_daily_deals_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 18), "DAILY DEALS", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.85, 0.70, 0.28))
	_udraw(font, Vector2(px + pw * 0.5, py + 34), "Refreshes at midnight", HORIZONTAL_ALIGNMENT_CENTER, -1, 9, menu_text_muted)
	for i in range(min(3, daily_deals.size())):
		var deal = daily_deals[i]
		var ix = px + 10
		var iy = py + 42 + float(i) * 58.0
		var iw = pw - 20
		var ih = 52.0
		var purchased = daily_deals_purchased[i] if i < daily_deals_purchased.size() else false
		var bg_col = Color(0.05, 0.15, 0.05, 0.6) if purchased else Color(0.08, 0.06, 0.12, 0.7)
		draw_rect(Rect2(ix, iy, iw, ih), bg_col)
		draw_rect(Rect2(ix, iy, iw, ih), Color(0.4, 0.35, 0.2, 0.3), false, 1.0)
		_udraw(font, Vector2(ix + 10, iy + 18), deal.get("name", "Deal"), HORIZONTAL_ALIGNMENT_LEFT, int(iw - 120), 12, Color(0.85, 0.75, 0.5))
		_udraw(font, Vector2(ix + 10, iy + 36), deal.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(iw - 120), 9, menu_text_muted)
		if purchased:
			_udraw(font, Vector2(ix + iw - 60, iy + 28), "SOLD", HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(0.4, 0.7, 0.3))
		else:
			var cost_str = "%d %s" % [deal.get("cost", 0), deal.get("cost_type", "").capitalize()]
			draw_rect(Rect2(ix + iw - 100, iy + 8, 88, 34), Color(0.15, 0.12, 0.08, 0.8))
			_udraw(font, Vector2(ix + iw - 56, iy + 30), cost_str, HORIZONTAL_ALIGNMENT_CENTER, -1, 11, Color(0.85, 0.70, 0.28))

func _draw_quest_panel_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 18), "DAILY QUESTS", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.4, 0.8, 0.3))
	_udraw(font, Vector2(px + pw * 0.5, py + 34), "Complete for rewards!", HORIZONTAL_ALIGNMENT_CENTER, -1, 9, menu_text_muted)
	for i in range(min(3, active_quests.size())):
		var q = active_quests[i]
		var iy = py + 44 + float(i) * 58.0
		var completed = q.get("completed", false)
		var bg = Color(0.05, 0.12, 0.05, 0.6) if completed else Color(0.06, 0.06, 0.08, 0.6)
		draw_rect(Rect2(px + 8, iy, pw - 16, 50), bg)
		draw_rect(Rect2(px + 8, iy, pw - 16, 50), Color(0.3, 0.6, 0.3, 0.25), false, 1.0)
		_udraw(font, Vector2(px + 16, iy + 16), q.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 130), 11, Color(0.8, 0.75, 0.6))
		# Progress bar
		var pct = float(q.get("progress", 0)) / float(max(1, q.get("target", 1)))
		var bar_w = 100.0
		draw_rect(Rect2(px + pw - 120, iy + 6, bar_w, 12), Color(0.15, 0.15, 0.15))
		draw_rect(Rect2(px + pw - 120, iy + 6, bar_w * pct, 12), Color(0.3, 0.8, 0.3) if not completed else Color(0.2, 0.6, 0.2))
		_udraw(font, Vector2(px + pw - 70, iy + 16), "%d/%d" % [q.get("progress", 0), q.get("target", 1)], HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(0.8, 0.8, 0.8))
		# Reward
		var reward_str = "+%d %s" % [q.get("reward_amount", 0), q.get("reward_type", "").capitalize()]
		if completed:
			_udraw(font, Vector2(px + pw - 70, iy + 40), "DONE!", HORIZONTAL_ALIGNMENT_CENTER, -1, 11, Color(0.4, 0.8, 0.3))
		else:
			_udraw(font, Vector2(px + pw - 70, iy + 40), reward_str, HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(0.85, 0.70, 0.28))

func _draw_shadow_arena_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 18), "SHADOW ARENA", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.7, 0.3, 0.9))
	_udraw(font, Vector2(px + pw * 0.5, py + 36), "Weekly competitive challenge", HORIZONTAL_ALIGNMENT_CENTER, -1, 10, menu_text_muted)
	# Modifiers
	var mod_str = ""
	for m in shadow_arena_modifiers:
		mod_str += m.replace("_", " ").capitalize() + "  "
	_udraw(font, Vector2(px + pw * 0.5, py + 54), "Modifiers: " + mod_str, HORIZONTAL_ALIGNMENT_CENTER, int(pw - 20), 10, Color(0.8, 0.5, 0.3))
	# Leaderboard
	_udraw(font, Vector2(px + 15, py + 74), "LEADERBOARD", HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.85, 0.70, 0.28))
	for i in range(min(8, arena_leaderboard.size())):
		var entry = arena_leaderboard[i]
		var ey = py + 90 + float(i) * 20.0
		var name_col = Color(0.9, 0.8, 0.3) if entry["name"] == "YOU" else menu_text
		_udraw(font, Vector2(px + 15, ey), "#%d  %s" % [i + 1, entry["name"]], HORIZONTAL_ALIGNMENT_LEFT, int(pw * 0.6), 10, name_col)
		_udraw(font, Vector2(px + pw - 15, ey), "Wave %d" % entry["score"], HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, menu_text_muted)
	# Your best + crystals
	var info_y = py + 260
	_udraw(font, Vector2(px + 15, info_y), "Your Best: Wave %d" % shadow_arena_high_score, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.7, 0.7, 0.9))
	_udraw(font, Vector2(px + 15, info_y + 18), "Arena Crystals: %d" % arena_crystals, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.6, 0.3, 0.9))
	# Crystal Shop
	var shop_y = info_y + 44
	_udraw(font, Vector2(px + pw * 0.5, shop_y), "CRYSTAL SHOP", HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(0.6, 0.3, 0.9))
	var shop_items = _get_arena_shop_items()
	for si in range(shop_items.size()):
		var item = shop_items[si]
		var iy = shop_y + 16 + float(si) * 42.0
		var can_buy = arena_crystals >= item["cost"]
		var item_col = Color(0.9, 0.85, 1.0) if can_buy else Color(0.5, 0.4, 0.5)
		draw_rect(Rect2(px + 8, iy, pw - 16, 36), Color(0.15, 0.08, 0.2, 0.6))
		_udraw(font, Vector2(px + 14, iy + 14), item["name"], HORIZONTAL_ALIGNMENT_LEFT, int(pw - 100), 10, item_col)
		_udraw(font, Vector2(px + 14, iy + 28), item["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(pw - 100), 8, Color(0.5, 0.45, 0.55))
		_udraw(font, Vector2(px + pw - 20, iy + 20), "%d" % item["cost"], HORIZONTAL_ALIGNMENT_RIGHT, -1, 12, Color(0.6, 0.3, 0.9) if can_buy else Color(0.4, 0.3, 0.4))
	# Enter button
	var enter_y = shop_y + 16 + float(shop_items.size()) * 42.0 + 10
	draw_rect(Rect2(px + pw * 0.5 - 60, enter_y, 120, 36), Color(0.30, 0.15, 0.50, 0.75))
	draw_rect(Rect2(px + pw * 0.5 - 60, enter_y, 120, 2), Color(0.5, 0.3, 0.7, 0.5))
	_udraw(font, Vector2(px + pw * 0.5, enter_y + 24), "ENTER", HORIZONTAL_ALIGNMENT_CENTER, 108, 14, Color(0.88, 0.78, 0.98))

func _draw_odyssey_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 20), "ODYSSEY MODE", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 15, Color(0.82, 0.62, 0.92))
	draw_rect(Rect2(px + 10, py + 30, pw - 20, 1), Color(0.5, 0.3, 0.7, 0.3))
	if odyssey_completed_this_week:
		_udraw(font, Vector2(px + pw * 0.5, py + 55), "Completed this week!", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 12, Color(0.5, 0.8, 0.3))
		_udraw(font, Vector2(px + pw * 0.5, py + 75), "Resets Monday", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 10, Color(0.4, 0.6, 0.3))
	else:
		var map_names = ""
		for mi in range(odyssey_maps.size()):
			if mi > 0: map_names += " > "
			if odyssey_maps[mi] < levels.size():
				map_names += levels[odyssey_maps[mi]]["name"]
		_udraw(font, Vector2(px + pw * 0.5, py + 55), "Journey through:", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 10, Color(0.6, 0.5, 0.7))
		_udraw(font, Vector2(px + pw * 0.5, py + 75), map_names, HORIZONTAL_ALIGNMENT_CENTER, int(pw - 30), 9, Color(0.7, 0.6, 0.5))
		_udraw(font, Vector2(px + pw * 0.5, py + 100), "Trophies: %d | Reward: 10-30" % trophy_currency, HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 10, Color(0.85, 0.70, 0.28))
		# Start button
		draw_rect(Rect2(px + pw * 0.5 - 60, py + 120, 120, 40), Color(0.30, 0.15, 0.50, 0.75))
		draw_rect(Rect2(px + pw * 0.5 - 60, py + 120, 120, 2), Color(0.6, 0.3, 0.8, 0.6))
		_udraw(font, Vector2(px + pw * 0.5, py + 146), "START", HORIZONTAL_ALIGNMENT_CENTER, 108, 14, Color(0.88, 0.78, 0.98))

func _draw_endless_sidebar(px: float, py: float, pw: float, ph: float) -> void:
	var font = game_font
	_udraw(font, Vector2(px + pw * 0.5, py + 20), "THE ETERNAL CHAPTER", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 15, Color(0.52, 0.62, 0.92))
	draw_rect(Rect2(px + 10, py + 30, pw - 20, 1), Color(0.3, 0.4, 0.7, 0.3))
	_udraw(font, Vector2(px + pw * 0.5, py + 55), "Infinite scaling waves.", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 11, Color(0.6, 0.6, 0.75))
	_udraw(font, Vector2(px + pw * 0.5, py + 73), "How far can you go?", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 11, Color(0.6, 0.6, 0.75))
	if endless_high_wave > 0:
		_udraw(font, Vector2(px + pw * 0.5, py + 100), "Best: Wave %d" % endless_high_wave, HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(0.85, 0.70, 0.28))
	_udraw(font, Vector2(px + pw * 0.5, py + 125), "Hard difficulty | Random themes", HORIZONTAL_ALIGNMENT_CENTER, pw - 20, 9, Color(0.45, 0.45, 0.55))
	# Start button
	draw_rect(Rect2(px + pw * 0.5 - 60, py + 145, 120, 40), Color(0.15, 0.20, 0.48, 0.75))
	draw_rect(Rect2(px + pw * 0.5 - 60, py + 145, 120, 2), Color(0.3, 0.4, 0.7, 0.6))
	_udraw(font, Vector2(px + pw * 0.5, py + 171), "START", HORIZONTAL_ALIGNMENT_CENTER, 108, 14, Color(0.72, 0.82, 0.98))

func _draw_story_map_OLD() -> void:
	var font = game_font
	var map_x = 30.0
	var map_y = 10.0
	var map_w = 1220.0
	var map_h = 500.0

	# === PARCHMENT BACKGROUND (full width) ===
	for i in range(50):
		var t = float(i) / 49.0
		var parch_col = Color(0.88, 0.82, 0.70).lerp(Color(0.82, 0.76, 0.63), t)
		var grain = sin(float(i) * 2.3) * 0.01
		parch_col.r += grain
		parch_col.g += grain
		draw_rect(Rect2(map_x, map_y + t * map_h, map_w, map_h / 49.0 + 1), parch_col)
	# Ink stain texture (deterministic spots for aged parchment feel)
	var stain_spots = [Vector2(150, 180), Vector2(500, 350), Vector2(900, 120), Vector2(1100, 400), Vector2(300, 420)]
	for spot in stain_spots:
		draw_circle(Vector2(map_x + spot.x, map_y + spot.y), 25.0, Color(0.72, 0.65, 0.52, 0.08))
		draw_circle(Vector2(map_x + spot.x + 8, map_y + spot.y - 5), 15.0, Color(0.72, 0.65, 0.52, 0.05))

	# === ORNATE BORDER ===
	# Outer dark border
	draw_rect(Rect2(map_x, map_y, map_w, 3), Color(0.35, 0.25, 0.12, 0.7))
	draw_rect(Rect2(map_x, map_y + map_h - 3, map_w, 3), Color(0.35, 0.25, 0.12, 0.7))
	draw_rect(Rect2(map_x, map_y, 3, map_h), Color(0.35, 0.25, 0.12, 0.7))
	draw_rect(Rect2(map_x + map_w - 3, map_y, 3, map_h), Color(0.35, 0.25, 0.12, 0.7))
	# Inner gold frame
	draw_rect(Rect2(map_x + 6, map_y + 6, map_w - 12, 1), Color(0.65, 0.50, 0.20, 0.4))
	draw_rect(Rect2(map_x + 6, map_y + map_h - 7, map_w - 12, 1), Color(0.65, 0.50, 0.20, 0.4))
	draw_rect(Rect2(map_x + 6, map_y + 6, 1, map_h - 12), Color(0.65, 0.50, 0.20, 0.4))
	draw_rect(Rect2(map_x + map_w - 7, map_y + 6, 1, map_h - 12), Color(0.65, 0.50, 0.20, 0.4))
	# Corner ornaments (L-shaped gold accents)
	for corner in [Vector2(map_x + 4, map_y + 4), Vector2(map_x + map_w - 24, map_y + 4), Vector2(map_x + 4, map_y + map_h - 24), Vector2(map_x + map_w - 24, map_y + map_h - 24)]:
		draw_rect(Rect2(corner.x, corner.y, 20, 2), Color(0.70, 0.55, 0.22, 0.5))
		draw_rect(Rect2(corner.x, corner.y, 2, 20), Color(0.70, 0.55, 0.22, 0.5))

	# === TITLE ===
	_udraw(font, Vector2(641, map_y + 29), "The Tome of Shadows", HORIZONTAL_ALIGNMENT_CENTER, map_w - 40, 18, Color(0.25, 0.15, 0.05, 0.4))
	_udraw(font, Vector2(640, map_y + 28), "The Tome of Shadows", HORIZONTAL_ALIGNMENT_CENTER, map_w - 40, 18, Color(0.35, 0.22, 0.08, 0.9))
	# Decorative flourish under title
	draw_line(Vector2(420, map_y + 35), Vector2(610, map_y + 35), Color(0.54, 0.45, 0.20, 0.35), 1.0)
	draw_line(Vector2(670, map_y + 35), Vector2(860, map_y + 35), Color(0.54, 0.45, 0.20, 0.35), 1.0)
	draw_circle(Vector2(640, map_y + 35), 3.0, Color(0.65, 0.50, 0.20, 0.4))

	# === BOOK SPINE (center divider) ===
	var spine_x = 625.0
	draw_rect(Rect2(spine_x - 1, map_y + 40, 3, map_h - 60), Color(0.35, 0.25, 0.12, 0.15))
	for sy in range(0, int(map_h - 60), 8):
		var spine_dot_a = 0.10 + sin(float(sy) * 0.15) * 0.04
		draw_circle(Vector2(spine_x, map_y + 42 + float(sy)), 1.0, Color(0.35, 0.25, 0.12, spine_dot_a))

	# === ACT HEADERS ===
	_udraw(font, Vector2(310, map_y + 52), "ACT I: INTO THE PAGES", HORIZONTAL_ALIGNMENT_CENTER, 500, 12, Color(0.40, 0.28, 0.10, 0.75))
	draw_line(Vector2(80, map_y + 58), Vector2(560, map_y + 58), Color(0.54, 0.45, 0.20, 0.3), 1.0)
	_udraw(font, Vector2(930, map_y + 52), "ACT II: THE ORIGINAL TALES", HORIZONTAL_ALIGNMENT_CENTER, 500, 12, Color(0.40, 0.28, 0.10, 0.75))
	draw_line(Vector2(690, map_y + 58), Vector2(1200, map_y + 58), Color(0.54, 0.45, 0.20, 0.3), 1.0)

	var nodes = _get_story_map_node_positions()
	# Build per-level colors from arc_data
	var char_colors: Array = []
	var arc_color_map = {
		"Prologue": Color(0.45, 0.30, 0.55),
		"Sherlock Holmes": Color(0.50, 0.50, 0.62),
		"Merlin": Color(0.30, 0.50, 0.72),
		"Tarzan": Color(0.25, 0.60, 0.25),
		"Dracula": Color(0.65, 0.18, 0.22),
		"Frankenstein": Color(0.42, 0.52, 0.32),
		"Robin Hood": Color(0.32, 0.58, 0.28),
		"Alice": Color(0.46, 0.68, 0.88),
		"Wicked Witch": Color(0.52, 0.28, 0.66),
		"Peter Pan": Color(0.92, 0.52, 0.16),
		"Phantom": Color(0.78, 0.25, 0.20),
		"Scrooge": Color(0.82, 0.68, 0.32),
		"Shadow Author": Color(0.25, 0.10, 0.30),
	}
	for arc in arc_data:
		var arc_col = arc_color_map.get(arc["name"], Color(0.5, 0.5, 0.5))
		for _lvl in arc["levels"]:
			char_colors.append(arc_col)

	# === ARC LABEL RIBBONS ===
	# Each arc gets a colored name label to the left of its node row
	var arc_row_y_map: Dictionary = {}  # arc_index → y position
	var arc_label_data = []  # [{ai, label_x, label_y, is_left}]
	for ai in range(arc_data.size()):
		if arc_data[ai]["levels"].size() == 0:
			continue
		var first_lvl = arc_data[ai]["levels"][0]
		var row_y = nodes[first_lvl].y
		arc_row_y_map[ai] = row_y
		var is_left = (ai <= 5)  # arcs 0-5 left, 6-11 right, 12 center
		var is_center = (ai == 12)
		var lbl_x = 48.0 if is_left else (658.0 if not is_center else 520.0)
		arc_label_data.append({"ai": ai, "x": lbl_x, "y": row_y, "left": is_left, "center": is_center})

	var arc_short_labels = ["Prologue", "Sherlock", "Merlin", "Tarzan", "Dracula", "Frankenstein", "Robin Hood", "Alice", "Wicked Witch", "Peter Pan", "Phantom", "Scrooge", "Shadow Author"]
	for ld in arc_label_data:
		var ai = ld["ai"]
		var lx = ld["x"]
		var ly = ld["y"]
		var arc_name = arc_data[ai]["name"]
		var arc_col = arc_color_map.get(arc_name, Color(0.5, 0.5, 0.5))
		var is_active = (story_map_active_arc == ai)
		# Check completion status
		var arc_complete = true
		var arc_has_unlocked = false
		for lvl_idx in arc_data[ai]["levels"]:
			if not lvl_idx in completed_levels:
				arc_complete = false
			if _is_level_unlocked(lvl_idx):
				arc_has_unlocked = true
		var is_locked = not arc_has_unlocked and not arc_complete
		# Ribbon background
		var ribbon_w = 130.0 if not ld["center"] else 220.0
		var ribbon_h = 28.0
		var ribbon_y = ly - 14.0
		var ribbon_alpha = 0.55 if is_active else (0.15 if is_locked else 0.30)
		# Ribbon shape (colored bar with shadow)
		draw_rect(Rect2(lx + 1, ribbon_y + 1, ribbon_w, ribbon_h), Color(0.0, 0.0, 0.0, 0.08))
		draw_rect(Rect2(lx, ribbon_y, ribbon_w, ribbon_h), Color(arc_col.r, arc_col.g, arc_col.b, ribbon_alpha))
		# Active glow
		if is_active:
			draw_rect(Rect2(lx, ribbon_y, ribbon_w, ribbon_h), Color(1, 0.9, 0.5, 0.12))
			draw_rect(Rect2(lx, ribbon_y, ribbon_w, ribbon_h), Color(arc_col.r, arc_col.g, arc_col.b, 0.8), false, 2.0)
			draw_rect(Rect2(lx, ribbon_y, 3, ribbon_h), Color(1, 0.9, 0.4, 0.9))
		else:
			draw_rect(Rect2(lx, ribbon_y, ribbon_w, ribbon_h), Color(0.35, 0.25, 0.12, 0.25), false, 1.0)
		# Arc name
		var name_col = Color(0.95, 0.9, 0.8) if is_active else (Color(0.5, 0.4, 0.3, 0.5) if is_locked else Color(0.85, 0.78, 0.6))
		_udraw(font, Vector2(lx + 8, ly + 1), arc_short_labels[ai], HORIZONTAL_ALIGNMENT_LEFT, ribbon_w - 50, 11, name_col)
		# Status on right side of ribbon
		var status_x = lx + ribbon_w - 38
		if arc_complete:
			_udraw(font, Vector2(status_x, ly + 1), "CLEAR", HORIZONTAL_ALIGNMENT_CENTER, 36, 9, Color(0.85, 0.75, 0.25, 0.9))
		elif is_locked:
			_udraw(font, Vector2(status_x, ly + 1), "LOCKED", HORIZONTAL_ALIGNMENT_CENTER, 36, 7, Color(0.45, 0.35, 0.25, 0.5))
		else:
			var arc_done = 0
			for lvl_idx in arc_data[ai]["levels"]:
				if lvl_idx in completed_levels:
					arc_done += 1
			_udraw(font, Vector2(status_x, ly + 1), "%d/%d" % [arc_done, arc_data[ai]["levels"].size()], HORIZONTAL_ALIGNMENT_CENTER, 36, 9, Color(0.6, 0.5, 0.3, 0.8))

	# === ACTIVE ARC HIGHLIGHT STRIP ===
	if story_map_active_arc >= 0 and story_map_active_arc < arc_data.size():
		var active_arc = arc_data[story_map_active_arc]
		var active_col = arc_color_map.get(active_arc["name"], Color(0.5, 0.5, 0.5))
		if active_arc["levels"].size() > 0:
			var first_node = nodes[active_arc["levels"][0]]
			var is_left = (story_map_active_arc <= 5)
			var is_center = (story_map_active_arc == 12)
			var strip_x = 45.0 if is_left else (655.0 if not is_center else 400.0)
			var strip_w = 570.0 if not is_center else 480.0
			var strip_y = first_node.y - 20.0
			var strip_h = 40.0
			var strip_pulse = 0.10 + sin(_time * 2.0) * 0.03
			draw_rect(Rect2(strip_x, strip_y, strip_w, strip_h), Color(active_col.r, active_col.g, active_col.b, strip_pulse))
			draw_rect(Rect2(strip_x, strip_y, strip_w, 1), Color(active_col.r, active_col.g, active_col.b, 0.25))
			draw_rect(Rect2(strip_x, strip_y + strip_h - 1, strip_w, 1), Color(active_col.r, active_col.g, active_col.b, 0.25))

	# === FINAL CHAPTER DIVIDER (before Shadow Author) ===
	if nodes.size() > 34:
		var div_y = (nodes[33].y + nodes[34].y) * 0.5 if story_map_active_arc != 12 else nodes[34].y - 30.0
		div_y = minf(div_y, nodes[34].y - 22.0)
		draw_line(Vector2(map_x + 100, div_y), Vector2(map_x + map_w - 100, div_y), Color(0.30, 0.15, 0.08, 0.35), 1.0)
		_udraw(font, Vector2(640, div_y - 3), "~ THE FINAL CHAPTER ~", HORIZONTAL_ALIGNMENT_CENTER, 300, 10, Color(0.35, 0.18, 0.08, 0.6))

	# === CONNECTION LINES (within each arc only) ===
	for arc in arc_data:
		var lvls = arc["levels"]
		var arc_col = arc_color_map.get(arc["name"], Color(0.5, 0.5, 0.5))
		for j in range(lvls.size() - 1):
			var from_idx = lvls[j]
			var to_idx = lvls[j + 1]
			if from_idx >= nodes.size() or to_idx >= nodes.size():
				continue
			var from_p = nodes[from_idx]
			var to_p = nodes[to_idx]
			var is_done = from_idx in completed_levels
			# Golden path with arc color tint
			var path_col = Color(0.65, 0.50, 0.18, 0.55) if is_done else Color(0.50, 0.40, 0.18, 0.25)
			draw_line(from_p, to_p, path_col, 2.5 if is_done else 1.5)
			# Subtle arc-colored glow on completed paths
			if is_done:
				draw_line(from_p, to_p, Color(arc_col.r, arc_col.g, arc_col.b, 0.15), 5.0)

	# === INTER-ARC DASHED CONNECTIONS (within same column) ===
	for ai in range(arc_data.size() - 1):
		var curr_arc = arc_data[ai]
		var next_arc = arc_data[ai + 1]
		if curr_arc["levels"].size() == 0 or next_arc["levels"].size() == 0:
			continue
		var last_lvl = curr_arc["levels"][curr_arc["levels"].size() - 1]
		var first_lvl = next_arc["levels"][0]
		# Only connect arcs in the same column (0-5 left, 6-11 right)
		var same_col = (ai <= 4 and ai + 1 <= 5) or (ai >= 6 and ai + 1 >= 6 and ai + 1 <= 11)
		if not same_col:
			continue
		var from_p = nodes[last_lvl]
		var to_p = nodes[first_lvl]
		# Dashed golden line
		var dash_steps = 8
		for ds in range(dash_steps):
			if ds % 2 != 0:
				continue
			var t1 = float(ds) / float(dash_steps)
			var t2 = float(ds + 1) / float(dash_steps)
			draw_line(from_p.lerp(to_p, t1), from_p.lerp(to_p, t2), Color(0.54, 0.45, 0.20, 0.2), 1.0)

	# === LEVEL NODES ===
	var next_unlocked: int = -1
	for i in range(nodes.size()):
		var npos = nodes[i]
		var is_complete = i in completed_levels
		var is_unlocked = _is_level_unlocked(i)
		var is_selected = (story_map_selected_node == i)
		var is_chapter_end = false
		for arc in arc_data:
			if arc["levels"].size() > 0 and i == arc["levels"][arc["levels"].size() - 1]:
				is_chapter_end = true
				break
		var node_r = 17.0 if is_chapter_end else 13.0

		if is_unlocked and not is_complete and next_unlocked < 0:
			next_unlocked = i

		# Drop shadow
		draw_circle(npos + Vector2(2, 2), node_r + 2, Color(0.0, 0.0, 0.0, 0.12))

		if is_complete:
			# Outer gold ring
			draw_circle(npos, node_r + 2, Color(0.70, 0.55, 0.15, 0.6))
			# Main body — gradient effect (arc color)
			draw_circle(npos, node_r, Color(char_colors[i].r * 0.8, char_colors[i].g * 0.8, char_colors[i].b * 0.8, 0.9))
			draw_circle(npos + Vector2(0, -2), node_r - 3, Color(char_colors[i].r, char_colors[i].g, char_colors[i].b, 0.9))
			# Inner highlight
			draw_circle(npos + Vector2(-2, -3), node_r * 0.4, Color(1, 1, 1, 0.12))
			# Gold star center
			_draw_mini_star(npos, 6.0, Color(1, 0.9, 0.35, 0.95))
			# Stars below
			var stars = level_stars.get(i, 0)
			for si in range(3):
				var star_pos = npos + Vector2(-10 + si * 10, node_r + 8)
				if si < stars:
					_draw_mini_star(star_pos, 4.0, Color(1, 0.85, 0.3, 0.9))
				else:
					_draw_mini_star(star_pos, 3.5, Color(0.5, 0.4, 0.25, 0.3))
		elif is_unlocked:
			# Pulsing available node
			var pulse = 0.7 + sin(_time * 3.0) * 0.3
			# Glow halo
			draw_circle(npos, node_r + 5, Color(0.75, 0.55, 0.15, 0.08 * pulse))
			# Main body
			draw_circle(npos, node_r, Color(char_colors[i].r, char_colors[i].g, char_colors[i].b, 0.25 * pulse))
			draw_arc(npos, node_r, 0, TAU, 32, Color(0.75, 0.55, 0.15, 0.6 * pulse), 2.5)
			# Inner highlight
			draw_circle(npos + Vector2(-2, -2), node_r * 0.35, Color(1, 1, 1, 0.06 * pulse))
			# Level number (large, readable)
			_udraw(font, Vector2(npos.x, npos.y + 5), str(i + 1), HORIZONTAL_ALIGNMENT_CENTER, 30, 12, Color(0.30, 0.20, 0.08, 0.85))
		else:
			# Locked node — muted
			draw_circle(npos, node_r, Color(0.45, 0.38, 0.30, 0.25))
			draw_arc(npos, node_r, 0, TAU, 24, Color(0.35, 0.28, 0.18, 0.35), 1.5)
			# Lock icon (bigger, more visible)
			draw_rect(Rect2(npos.x - 4, npos.y, 8, 7), Color(0.45, 0.35, 0.22, 0.5))
			draw_arc(Vector2(npos.x, npos.y - 2), 4.0, PI, TAU, 10, Color(0.45, 0.35, 0.22, 0.5), 1.5)

		# Story sparkle on nodes with unseen content
		var pre_key = "pre_level_" + str(i)
		if story_dialogs.has(pre_key) and not pre_key in story_seen and is_unlocked:
			var sparkle_t = fmod(_time * 2.0 + float(i) * 0.7, 1.0)
			var sparkle_a = sin(sparkle_t * PI)
			draw_circle(npos + Vector2(node_r + 5, -node_r - 3), 3.0, Color(1.0, 0.85, 0.3, sparkle_a * 0.85))
			draw_circle(npos + Vector2(node_r + 5, -node_r - 3), 5.0, Color(1.0, 0.85, 0.3, sparkle_a * 0.2))

		# Selection highlight — dramatic pulsing double ring
		if is_selected and is_unlocked:
			var sel_pulse = 0.7 + sin(_time * 4.0) * 0.3
			draw_arc(npos, node_r + 5, 0, TAU, 32, Color(1, 0.85, 0.3, sel_pulse), 3.0)
			draw_arc(npos, node_r + 9, 0, TAU, 32, Color(1, 0.85, 0.3, sel_pulse * 0.35), 2.0)
			# Golden rays
			for ray in range(8):
				var ray_angle = float(ray) * TAU / 8.0 + _time * 0.5
				var ray_start = npos + Vector2.from_angle(ray_angle) * (node_r + 10)
				var ray_end = npos + Vector2.from_angle(ray_angle) * (node_r + 16)
				draw_line(ray_start, ray_end, Color(1, 0.85, 0.3, sel_pulse * 0.3), 1.5)

	# === QUILL PEN MARKER on next available level ===
	if next_unlocked >= 0:
		var qpos = nodes[next_unlocked] + Vector2(0, -25)
		var bob = sin(_time * 2.0) * 4.0
		qpos.y += bob
		# Quill feather
		draw_line(qpos + Vector2(2, 0), qpos + Vector2(6, 18), Color(0.45, 0.30, 0.10, 0.8), 2.0)
		draw_colored_polygon(PackedVector2Array([qpos, qpos + Vector2(-6, -14), qpos + Vector2(4, -7)]), Color(0.88, 0.78, 0.52, 0.7))
		draw_colored_polygon(PackedVector2Array([qpos + Vector2(-1, -2), qpos + Vector2(-8, -12), qpos + Vector2(-3, -8)]), Color(0.82, 0.72, 0.48, 0.5))

	# === LEVEL DETAIL PANEL ===
	if story_map_selected_node >= 0 and story_map_selected_node < levels.size():
		_draw_story_map_detail_panel_OLD(nodes)

	# === BOTTOM BAR: Odyssey + Endless + Prisoners ===
	var bar_y = map_y + map_h + 8.0
	var bar_h = 90.0
	# Dark bar background
	draw_rect(Rect2(map_x, bar_y, map_w, bar_h), Color(0.04, 0.03, 0.08, 0.92))
	draw_rect(Rect2(map_x, bar_y, map_w, 2), Color(0.54, 0.45, 0.20, 0.3))

	# --- Shadow Prisoners (right third) ---
	var pris_x = 840.0
	_udraw(font, Vector2(pris_x + 200, bar_y + 16), "Shadow Prisoners", HORIZONTAL_ALIGNMENT_CENTER, 380, 12, Color(0.80, 0.60, 0.30, 0.9))
	draw_rect(Rect2(pris_x, bar_y + 22, 380, 1), Color(0.54, 0.45, 0.20, 0.25))
	var unlock_info = [
		{"id": "sherlock", "name": "Sherlock", "needs": [0,1,2]},
		{"id": "tarzan", "name": "Tarzan", "needs": [3,4,5]},
		{"id": "dracula", "name": "Dracula", "needs": [6,7,8]},
		{"id": "merlin", "name": "Merlin", "needs": [9,10,11]},
		{"id": "frankenstein", "name": "Monster", "needs": [12,13,14]},
	]
	for ui in range(unlock_info.size()):
		var info = unlock_info[ui]
		var px = pris_x + float(ui) * 76.0
		var py = bar_y + 32.0
		var is_free = info["id"] in unlocked_characters
		var all_done = true
		for nl in info["needs"]:
			if not nl in completed_levels:
				all_done = false
				break
		if is_free:
			draw_circle(Vector2(px + 10, py + 10), 7, Color(0.3, 0.7, 0.2, 0.6))
			_udraw(font, Vector2(px + 10, py + 30), info["name"], HORIZONTAL_ALIGNMENT_CENTER, 70, 9, Color(0.4, 0.7, 0.3, 0.9))
			_udraw(font, Vector2(px + 10, py + 42), "FREE", HORIZONTAL_ALIGNMENT_CENTER, 50, 7, Color(0.5, 0.8, 0.3, 0.7))
		elif all_done:
			draw_circle(Vector2(px + 10, py + 10), 7, Color(0.8, 0.7, 0.2, 0.6))
			_udraw(font, Vector2(px + 10, py + 30), info["name"], HORIZONTAL_ALIGNMENT_CENTER, 70, 9, Color(0.8, 0.65, 0.2, 0.9))
			_udraw(font, Vector2(px + 10, py + 42), "READY!", HORIZONTAL_ALIGNMENT_CENTER, 50, 7, Color(0.9, 0.8, 0.3, 0.8))
		else:
			draw_circle(Vector2(px + 10, py + 10), 7, Color(0.35, 0.28, 0.20, 0.35))
			var done_count = 0
			for nl in info["needs"]:
				if nl in completed_levels:
					done_count += 1
			_udraw(font, Vector2(px + 10, py + 30), info["name"], HORIZONTAL_ALIGNMENT_CENTER, 70, 9, Color(0.45, 0.38, 0.28, 0.6))
			_udraw(font, Vector2(px + 10, py + 42), "%d/3" % done_count, HORIZONTAL_ALIGNMENT_CENTER, 50, 7, Color(0.4, 0.3, 0.2, 0.5))

func _draw_mini_star(center: Vector2, size: float, color: Color) -> void:
	var pts = PackedVector2Array()
	for i in range(10):
		var angle = -PI / 2.0 + float(i) * TAU / 10.0
		var r = size if i % 2 == 0 else size * 0.4
		pts.append(center + Vector2.from_angle(angle) * r)
	draw_colored_polygon(pts, color)

func _draw_story_map_detail_panel_OLD(nodes: Array) -> void:
	var font = game_font
	var idx = story_map_selected_node
	if idx < 0 or idx >= levels.size():
		return
	var level = levels[idx]
	var npos = nodes[idx]
	var is_unlocked = _is_level_unlocked(idx)

	# Panel in center gap between columns (always readable)
	var panel_w = 250.0
	var panel_h = 185.0
	var panel_x = 490.0  # Center gap between columns
	# For Shadow Author (centered nodes), move panel far left to avoid overlapping nodes at x=460,640,820
	if idx >= 34:
		panel_x = 140.0
	var panel_y = clampf(npos.y - 55.0, 20.0, 360.0)

	# Panel shadow
	draw_rect(Rect2(panel_x + 3, panel_y + 3, panel_w, panel_h), Color(0.0, 0.0, 0.0, 0.2))
	# Dark panel background with gradient
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(0.06, 0.04, 0.02, 0.95))
	# Top accent — gold gradient bar
	draw_rect(Rect2(panel_x, panel_y, panel_w, 4), Color(0.75, 0.55, 0.15, 0.7))
	draw_rect(Rect2(panel_x, panel_y + 4, panel_w, 2), Color(0.75, 0.55, 0.15, 0.3))
	# Side and bottom borders
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(0.75, 0.55, 0.15, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(0.75, 0.55, 0.15, 0.35))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(0.75, 0.55, 0.15, 0.35))

	# Connecting line from node to panel
	var connect_x = panel_x if npos.x < panel_x else panel_x + panel_w
	draw_line(npos, Vector2(connect_x, panel_y + 30), Color(0.75, 0.55, 0.15, 0.25), 1.5)

	# Level name (large, gold)
	_udraw(font, Vector2(panel_x + 12, panel_y + 24), level["name"], HORIZONTAL_ALIGNMENT_LEFT, panel_w - 24, 15, Color(0.92, 0.78, 0.32))
	# Subtitle
	_udraw(font, Vector2(panel_x + 12, panel_y + 42), level["subtitle"], HORIZONTAL_ALIGNMENT_LEFT, panel_w - 24, 10, Color(0.70, 0.60, 0.42))
	# Stars (visual star icons)
	var stars = level_stars.get(idx, 0)
	for si in range(3):
		var sx = panel_x + 14 + float(si) * 22
		var sy = panel_y + 58
		if si < stars:
			_draw_mini_star(Vector2(sx, sy), 7.0, Color(1, 0.88, 0.32, 0.9))
		else:
			_draw_mini_star(Vector2(sx, sy), 6.0, Color(0.4, 0.32, 0.18, 0.35))
	# Difficulty indicator
	_udraw(font, Vector2(panel_x + panel_w - 12, panel_y + 62), "Lv. %d" % (idx + 1), HORIZONTAL_ALIGNMENT_RIGHT, 60, 10, Color(0.55, 0.45, 0.30, 0.7))

	# Description (word-wrapped)
	var desc = level["description"]
	var desc_words = desc.split(" ")
	var desc_line = ""
	var desc_y = panel_y + 80
	var max_desc_y = panel_y + panel_h - 48
	for word in desc_words:
		var test = desc_line + (" " if desc_line != "" else "") + word
		if font.get_string_size(test, HORIZONTAL_ALIGNMENT_LEFT, -1, 10).x > panel_w - 28:
			if desc_y < max_desc_y:
				_udraw(font, Vector2(panel_x + 14, desc_y), desc_line, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(0.68, 0.62, 0.50))
			desc_y += 14
			desc_line = word
		else:
			desc_line = test
	if desc_line != "" and desc_y < max_desc_y:
		_udraw(font, Vector2(panel_x + 14, desc_y), desc_line, HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(0.68, 0.62, 0.50))

	# PLAY button (large, prominent)
	if is_unlocked:
		var btn_w = 120.0
		var btn_h = 34.0
		var btn_x = panel_x + panel_w * 0.5 - btn_w * 0.5
		var btn_y = panel_y + panel_h - btn_h - 8
		var btn_pulse = 0.85 + sin(_time * 3.0) * 0.15
		# Button shadow
		draw_rect(Rect2(btn_x + 2, btn_y + 2, btn_w, btn_h), Color(0.0, 0.0, 0.0, 0.15))
		# Button fill
		draw_rect(Rect2(btn_x, btn_y, btn_w, btn_h), Color(0.18, 0.55, 0.12, btn_pulse))
		# Button highlight (top edge)
		draw_rect(Rect2(btn_x, btn_y, btn_w, 2), Color(0.4, 0.8, 0.3, 0.4))
		# Button border
		draw_rect(Rect2(btn_x, btn_y, btn_w, btn_h), Color(0.75, 0.55, 0.15, 0.5), false, 1.5)
		# Button text
		_udraw(font, Vector2(btn_x + btn_w * 0.5, btn_y + 23), "PLAY", HORIZONTAL_ALIGNMENT_CENTER, btn_w - 10, 15, Color(1, 1, 1, 0.97))

func _on_story_map_clicked_OLD(mouse_pos: Vector2) -> void:
	var nodes = _get_story_map_node_positions()
	# === ARC RIBBON LABEL CLICKS ===
	# Match the ribbon positions from _draw_story_map
	for ai in range(arc_data.size()):
		if arc_data[ai]["levels"].size() == 0:
			continue
		var first_lvl = arc_data[ai]["levels"][0]
		var row_y = nodes[first_lvl].y
		var is_left = (ai <= 5)
		var is_center = (ai == 12)
		var lbl_x = 48.0 if is_left else (658.0 if not is_center else 520.0)
		var ribbon_w = 130.0 if not is_center else 220.0
		var ribbon_h = 28.0
		var ribbon_y = row_y - 14.0
		if Rect2(lbl_x, ribbon_y, ribbon_w, ribbon_h).has_point(mouse_pos):
			if story_map_active_arc == ai:
				story_map_active_arc = -1
			else:
				story_map_active_arc = ai
				# Auto-select first incomplete level in this arc
				for lvl_idx in arc_data[ai]["levels"]:
					if _is_level_unlocked(lvl_idx) and not lvl_idx in completed_levels:
						story_map_selected_node = lvl_idx
						break
			queue_redraw()
			return
	# === PLAY BUTTON in detail panel ===
	if story_map_selected_node >= 0 and story_map_selected_node < levels.size():
		var panel_w = 250.0
		var panel_h = 185.0
		var panel_x = 490.0
		if story_map_selected_node >= 34:
			panel_x = 140.0
		var npos = nodes[story_map_selected_node]
		var panel_y = clampf(npos.y - 55.0, 20.0, 360.0)
		var btn_w = 120.0
		var btn_h = 34.0
		var btn_x = panel_x + panel_w * 0.5 - btn_w * 0.5
		var btn_y = panel_y + panel_h - btn_h - 8
		if Rect2(btn_x, btn_y, btn_w, btn_h).has_point(mouse_pos) and _is_level_unlocked(story_map_selected_node):
			_on_level_selected(story_map_selected_node)
			story_map_selected_node = -1
			return
	# === NODE CLICKS ===
	for i in range(nodes.size()):
		if nodes[i].distance_to(mouse_pos) < 22.0:
			if story_map_selected_node == i:
				# Double-tap to play
				if _is_level_unlocked(i):
					_on_level_selected(i)
					story_map_selected_node = -1
			else:
				story_map_selected_node = i
				# Set the arc for this node
				for ai in range(arc_data.size()):
					if i in arc_data[ai]["levels"]:
						story_map_active_arc = ai
						break
			queue_redraw()
			return
	# Click elsewhere — deselect
	story_map_selected_node = -1
	queue_redraw()

func _draw_open_book() -> void:
	# === Open book (two-page spread) ===
	var bx = 70.0
	var by = 45.0
	var pw = 560.0  # page width
	var ph = 555.0  # page height
	var spine_x = bx + pw + 10  # spine center

	# Book shadow
	draw_rect(Rect2(bx - 5 + 8, by - 5 + 8, pw * 2 + 30, ph + 10), Color(0.02, 0.02, 0.06, 0.35))

	# Left page (aged cream paper)
	for i in range(55):
		var t = float(i) / 54.0
		var col = Color(0.88, 0.82, 0.70).lerp(Color(0.85, 0.78, 0.65), t)
		var grain = sin(float(i) * 2.3) * 0.01
		col.r += grain
		col.g += grain
		draw_rect(Rect2(bx, by + t * ph, pw, ph / 54.0 + 1), col)

	# Right page
	for i in range(55):
		var t = float(i) / 54.0
		var col = Color(0.86, 0.80, 0.68).lerp(Color(0.83, 0.76, 0.63), t)
		var grain = sin(float(i) * 2.7 + 1.0) * 0.01
		col.r += grain
		col.g += grain
		draw_rect(Rect2(spine_x + 10, by + t * ph, pw, ph / 54.0 + 1), col)

	# Spine (leather center with gold bands)
	draw_rect(Rect2(spine_x - 5, by - 8, 20, ph + 16), Color(0.22, 0.10, 0.04))
	for i in range(5):
		var sy = by + 60.0 + float(i) * 100.0
		# All gold bands
		draw_line(Vector2(spine_x - 5, sy), Vector2(spine_x + 15, sy), Color(0.54, 0.45, 0.20, 0.35), 2.0)
		# Embossed diamond shapes on spine
		var diamond_cx = spine_x + 5.0
		var diamond_cy = sy + 50.0
		draw_colored_polygon(PackedVector2Array([Vector2(diamond_cx, diamond_cy - 6), Vector2(diamond_cx + 4, diamond_cy), Vector2(diamond_cx, diamond_cy + 6), Vector2(diamond_cx - 4, diamond_cy)]), Color(0.54, 0.45, 0.20, 0.2))
	# Spine shadow gradient
	for i in range(15):
		var t = float(i) / 14.0
		draw_line(Vector2(spine_x + 15 + t * 8, by), Vector2(spine_x + 15 + t * 8, by + ph), Color(0.0, 0.0, 0.0, 0.06 * (1.0 - t)), 1.0)
		draw_line(Vector2(spine_x - 5 - t * 8, by), Vector2(spine_x - 5 - t * 8, by + ph), Color(0.0, 0.0, 0.0, 0.06 * (1.0 - t)), 1.0)

	# Page borders — gold outer frame (3px) + gold inner frame (1px) — left page
	var outer_border = Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.3)
	var gold_border = Color(0.54, 0.45, 0.20, 0.2)
	# Left page outer gold border (3px)
	draw_rect(Rect2(bx + 8, by + 8, pw - 16, 3), outer_border)
	draw_rect(Rect2(bx + 8, by + ph - 11, pw - 16, 3), outer_border)
	draw_rect(Rect2(bx + 8, by + 8, 3, ph - 16), outer_border)
	draw_rect(Rect2(bx + pw - 11, by + 8, 3, ph - 16), outer_border)
	# Left page inner gold border (1px)
	draw_rect(Rect2(bx + 14, by + 14, pw - 28, 1), gold_border)
	draw_rect(Rect2(bx + 14, by + ph - 15, pw - 28, 1), gold_border)
	draw_rect(Rect2(bx + 14, by + 14, 1, ph - 28), gold_border)
	draw_rect(Rect2(bx + pw - 15, by + 14, 1, ph - 28), gold_border)

	# Right page double border
	var rx = spine_x + 10
	draw_rect(Rect2(rx + 8, by + 8, pw - 16, 3), outer_border)
	draw_rect(Rect2(rx + 8, by + ph - 11, pw - 16, 3), outer_border)
	draw_rect(Rect2(rx + 8, by + 8, 3, ph - 16), outer_border)
	draw_rect(Rect2(rx + pw - 11, by + 8, 3, ph - 16), outer_border)
	draw_rect(Rect2(rx + 14, by + 14, pw - 28, 1), gold_border)
	draw_rect(Rect2(rx + 14, by + ph - 15, pw - 28, 1), gold_border)
	draw_rect(Rect2(rx + 14, by + 14, 1, ph - 28), gold_border)
	draw_rect(Rect2(rx + pw - 15, by + 14, 1, ph - 28), gold_border)

	# Page edge glow — subtle gold line along outer page edges
	draw_rect(Rect2(bx, by, pw, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08))
	draw_rect(Rect2(bx, by + ph - 1, pw, 1), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08))
	draw_rect(Rect2(bx, by, 1, ph), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08))
	draw_rect(Rect2(rx + pw - 1, by, 1, ph), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.08))

	# L-bracket corner ornaments (left page — gold only)
	for corner in [Vector2(bx + 18, by + 18), Vector2(bx + pw - 18, by + 18), Vector2(bx + 18, by + ph - 18), Vector2(bx + pw - 18, by + ph - 18)]:
		var dx_sign = 1.0 if corner.x < bx + pw * 0.5 else -1.0
		var dy_sign = 1.0 if corner.y < by + ph * 0.5 else -1.0
		draw_line(corner, corner + Vector2(12 * dx_sign, 0), Color(0.54, 0.45, 0.20, 0.25), 1.0)
		draw_line(corner, corner + Vector2(0, 12 * dy_sign), Color(0.54, 0.45, 0.20, 0.25), 1.0)
		draw_line(corner + Vector2(12 * dx_sign, 0), corner + Vector2(12 * dx_sign, 4 * dy_sign), Color(0.54, 0.45, 0.20, 0.2), 1.0)
		draw_line(corner + Vector2(0, 12 * dy_sign), corner + Vector2(4 * dx_sign, 12 * dy_sign), Color(0.54, 0.45, 0.20, 0.2), 1.0)
		draw_circle(corner, 5, Color(0.54, 0.45, 0.20, 0.2))
		draw_circle(corner, 3.5, Color(0.54, 0.45, 0.20, 0.15))
		draw_circle(corner, 2, Color(0.54, 0.45, 0.20, 0.25))

	# L-bracket corner ornaments (right page — gold only)
	for corner in [Vector2(rx + 18, by + 18), Vector2(rx + pw - 18, by + 18), Vector2(rx + 18, by + ph - 18), Vector2(rx + pw - 18, by + ph - 18)]:
		var dx_sign2 = 1.0 if corner.x < rx + pw * 0.5 else -1.0
		var dy_sign2 = 1.0 if corner.y < by + ph * 0.5 else -1.0
		draw_line(corner, corner + Vector2(12 * dx_sign2, 0), Color(0.54, 0.45, 0.20, 0.25), 1.0)
		draw_line(corner, corner + Vector2(0, 12 * dy_sign2), Color(0.54, 0.45, 0.20, 0.25), 1.0)
		draw_line(corner + Vector2(12 * dx_sign2, 0), corner + Vector2(12 * dx_sign2, 4 * dy_sign2), Color(0.54, 0.45, 0.20, 0.2), 1.0)
		draw_line(corner + Vector2(0, 12 * dy_sign2), corner + Vector2(4 * dx_sign2, 12 * dy_sign2), Color(0.54, 0.45, 0.20, 0.2), 1.0)
		draw_circle(corner, 5, Color(0.54, 0.45, 0.20, 0.2))
		draw_circle(corner, 3.5, Color(0.54, 0.45, 0.20, 0.15))
		draw_circle(corner, 2, Color(0.54, 0.45, 0.20, 0.25))

	# Ink blot decorations (right page corners)
	draw_circle(Vector2(rx + pw - 40, by + ph - 40), 6.0, Color(0.2, 0.15, 0.1, 0.06))
	draw_circle(Vector2(rx + pw - 35, by + ph - 45), 4.0, Color(0.2, 0.15, 0.1, 0.04))

	# Left page: character preview area (tower preview is placed by menu system)
	if menu_current_view == "chapters":
		var char_idx = menu_character_index
		# Character-themed decorative motif on left page
		var motif_y = by + 160.0
		var motif_x = bx + pw * 0.5
		# Draw a simple emblem/crest area
		draw_circle(Vector2(motif_x, motif_y + 80), 60, Color(0.54, 0.45, 0.20, 0.04))
		draw_arc(Vector2(motif_x, motif_y + 80), 55, 0, TAU, 48, Color(0.54, 0.45, 0.20, 0.12), 1.5)
		draw_arc(Vector2(motif_x, motif_y + 80), 45, 0, TAU, 48, Color(0.54, 0.45, 0.20, 0.08), 1.0)

		# Character emblem icons (simple procedural)
		match char_idx:
			0:  # Robin Hood - bow and arrow
				draw_arc(Vector2(motif_x, motif_y + 80), 25, 1.0, 5.3, 32, Color(0.4, 0.25, 0.08, 0.35), 2.5)
				draw_line(Vector2(motif_x - 20, motif_y + 60), Vector2(motif_x + 20, motif_y + 100), Color(0.4, 0.25, 0.08, 0.3), 1.5)
				draw_colored_polygon(PackedVector2Array([Vector2(motif_x + 18, motif_y + 96), Vector2(motif_x + 24, motif_y + 100), Vector2(motif_x + 20, motif_y + 104)]), Color(0.4, 0.25, 0.08, 0.3))
			1:  # Alice - playing card (heart)
				draw_rect(Rect2(motif_x - 18, motif_y + 58, 36, 44), Color(0.9, 0.87, 0.8, 0.3))
				draw_rect(Rect2(motif_x - 16, motif_y + 60, 32, 40), Color(0.95, 0.92, 0.88, 0.2))
				# Heart shape
				draw_circle(Vector2(motif_x - 6, motif_y + 73), 6, Color(0.8, 0.15, 0.15, 0.3))
				draw_circle(Vector2(motif_x + 6, motif_y + 73), 6, Color(0.8, 0.15, 0.15, 0.3))
				draw_colored_polygon(PackedVector2Array([Vector2(motif_x - 11, motif_y + 76), Vector2(motif_x + 11, motif_y + 76), Vector2(motif_x, motif_y + 92)]), Color(0.8, 0.15, 0.15, 0.3))
			2:  # Oz - emerald
				draw_colored_polygon(PackedVector2Array([Vector2(motif_x, motif_y + 58), Vector2(motif_x + 18, motif_y + 72), Vector2(motif_x + 14, motif_y + 95), Vector2(motif_x - 14, motif_y + 95), Vector2(motif_x - 18, motif_y + 72)]), Color(0.15, 0.6, 0.2, 0.3))
				draw_circle(Vector2(motif_x, motif_y + 78), 8, Color(0.3, 0.8, 0.4, 0.15))
			3:  # Peter Pan - star
				for s in range(5):
					var a1 = -PI / 2.0 + float(s) * TAU / 5.0
					var a2 = -PI / 2.0 + (float(s) + 0.5) * TAU / 5.0
					draw_line(Vector2(motif_x, motif_y + 80) + Vector2.from_angle(a1) * 22, Vector2(motif_x, motif_y + 80) + Vector2.from_angle(a2) * 10, Color(0.65, 0.55, 0.1, 0.3), 2.0)
					draw_line(Vector2(motif_x, motif_y + 80) + Vector2.from_angle(a2) * 10, Vector2(motif_x, motif_y + 80) + Vector2.from_angle(a1 + TAU / 5.0) * 22, Color(0.65, 0.55, 0.1, 0.3), 2.0)
			4:  # Phantom - mask
				draw_arc(Vector2(motif_x, motif_y + 72), 18, PI + 0.3, TAU - 0.3, 32, Color(0.9, 0.88, 0.82, 0.35), 3.0)
				draw_circle(Vector2(motif_x - 7, motif_y + 70), 4, Color(0.1, 0.08, 0.06, 0.3))
				draw_circle(Vector2(motif_x + 7, motif_y + 70), 4, Color(0.1, 0.08, 0.06, 0.3))
				draw_line(Vector2(motif_x, motif_y + 55), Vector2(motif_x, motif_y + 62), Color(0.9, 0.88, 0.82, 0.25), 2.0)
			5:  # Scrooge - coin
				draw_circle(Vector2(motif_x, motif_y + 80), 18, Color(0.75, 0.6, 0.1, 0.3))
				draw_circle(Vector2(motif_x, motif_y + 80), 15, Color(0.85, 0.7, 0.15, 0.2))
				draw_circle(Vector2(motif_x, motif_y + 80), 6, Color(0.54, 0.45, 0.20, 0.15))

		# Decorative line under character quote
		draw_line(Vector2(bx + 80, by + ph - 100), Vector2(bx + pw - 80, by + ph - 100), Color(0.54, 0.45, 0.20, 0.1), 1.0)

	# Right page: chapter separator lines (between the 3 cards)
	if menu_current_view == "chapters":
		for i in range(2):
			var sep_y = by + 190.0 + float(i) * 165.0
			draw_line(Vector2(rx + 30, sep_y), Vector2(rx + pw - 30, sep_y), Color(0.5, 0.4, 0.25, 0.15), 1.0)
			# Decorative diamond at center of separator
			var sep_cx = rx + pw * 0.5
			draw_colored_polygon(PackedVector2Array([Vector2(sep_cx, sep_y - 4), Vector2(sep_cx + 4, sep_y), Vector2(sep_cx, sep_y + 4), Vector2(sep_cx - 4, sep_y)]), Color(0.54, 0.45, 0.20, 0.15))
			# Small gold dots at ends of separator
			draw_circle(Vector2(rx + 30, sep_y), 2.0, Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))
			draw_circle(Vector2(rx + pw - 30, sep_y), 2.0, Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.2))

	# Page tab bookmarks on right edge (character quick nav) — enhanced gothic
	var tab_colors = [Color(0.29, 0.55, 0.25), Color(0.44, 0.66, 0.86), Color(0.48, 0.25, 0.63), Color(0.90, 0.49, 0.13), Color(0.75, 0.22, 0.17), Color(0.79, 0.66, 0.30)]
	if menu_current_view == "chapters":
		for i in range(6):
			var tab_y = by + 30.0 + float(i) * 80.0
			var tab_x = rx + pw - 5
			var is_active = (i == menu_character_index)
			var tab_w = 24.0 if is_active else 16.0
			var tab_alpha = (0.7 + sin(_time * 2.0) * 0.15) if is_active else 0.25
			var tab_h = 50.0
			var tc = Color(tab_colors[i].r, tab_colors[i].g, tab_colors[i].b, tab_alpha)
			# Glow effect behind active tab
			if is_active:
				draw_circle(Vector2(tab_x + tab_w * 0.5, tab_y + tab_h * 0.5), 30.0, Color(tab_colors[i].r, tab_colors[i].g, tab_colors[i].b, 0.08))
			# Tab rectangle
			draw_rect(Rect2(tab_x, tab_y, tab_w, tab_h), tc)
			# Gothic pointed bottom edge (triangle)
			draw_colored_polygon(PackedVector2Array([Vector2(tab_x, tab_y + tab_h), Vector2(tab_x + tab_w, tab_y + tab_h), Vector2(tab_x + tab_w * 0.5, tab_y + tab_h + 8)]), tc)
			# Thin gold border on inner edge
			draw_line(Vector2(tab_x, tab_y), Vector2(tab_x, tab_y + tab_h), Color(0.54, 0.45, 0.20, 0.3), 1.0)

# ============================================================
# GAME LOOP
# ============================================================

func _process(delta: float) -> void:
	_time += delta
	# Story dialog typewriter
	_process_story_typewriter(delta)
	# Musical beat clock (140 BPM)
	_music_beat_accum += delta
	while _music_beat_accum >= MUSIC_BEAT_INTERVAL:
		_music_beat_accum -= MUSIC_BEAT_INTERVAL
		music_beat_index += 1
	# Ability popup freeze
	if _ability_popup_freeze > 0.0:
		_ability_popup_freeze -= delta
		_ability_popup_timer -= delta
		if _ability_popup_timer <= 0.0:
			_ability_popup_timer = 0.0
		queue_redraw()
		return
	if _ability_popup_timer > 0.0:
		_ability_popup_timer -= delta
	# Synergy banner timer
	if synergy_banner_timer > 0.0:
		synergy_banner_timer -= delta
	# Achievement popup timer
	if achievement_popup_timer > 0.0:
		achievement_popup_timer -= delta
	if game_state != GameState.PLAYING:
		# Chest opening animation (phase 0=idle/click to open, 1=shake, 2=burst, 3=slide, 4=flip, 5=pick, 6=done)
		if chest_opening_active:
			chest_opening_timer += delta
			# Phase 0: idle, waiting for click (no auto-advance)
			if chest_opening_phase == 1 and chest_opening_timer >= 1.2:
				chest_opening_phase = 2
				chest_opening_timer = 0.0
			elif chest_opening_phase == 2 and chest_opening_timer >= 0.8:
				chest_opening_phase = 3
				chest_opening_timer = 0.0
			elif chest_opening_phase == 3 and chest_opening_timer >= 1.0:
				chest_opening_phase = 4
				chest_opening_timer = 0.0
				chest_opening_flip_index = 0
			elif chest_opening_phase == 4:
				var flip_speed = 0.3
				if chest_opening_timer >= flip_speed:
					chest_opening_timer = 0.0
					chest_opening_flip_index += 1
					if chest_opening_flip_index >= 3:
						chest_opening_phase = 5
						chest_opening_timer = 0.0
						# Award base chest loot (guaranteed rewards)
						_award_chest_loot()
		# Emporium sub-panel message timer
		if emporium_sub_message_timer > 0.0:
			emporium_sub_message_timer -= delta
			if emporium_sub_message_timer <= 0.0:
				emporium_sub_message = ""
		if _emporium_confirm_timer > 0.0:
			_emporium_confirm_timer -= delta
			if _emporium_confirm_timer <= 0.0:
				_emporium_confirm_index = -1
		# Hover updates
		if not chest_opening_active and not daily_reward_open:
			if survivor_detail_open:
				_update_detail_hover()
			elif menu_current_view == "survivors":
				_update_world_map_hover()
			elif menu_current_view == "relics":
				_update_relics_tab_hover()
			elif menu_current_view == "emporium":
				_update_emporium_hover()
			elif menu_current_view == "chronicles":
				_update_knowledge_hover()
		queue_redraw()
		return
	ghost_position = get_global_mouse_position()
	_update_branch_hover(get_viewport().get_mouse_position())
	_update_spawn_debuffs()
	# Battle power timed effects
	if active_power_effects.has("ink_freeze"):
		active_power_effects["ink_freeze"] -= delta
		if active_power_effects["ink_freeze"] <= 0.0:
			active_power_effects.erase("ink_freeze")
			for enemy in get_tree().get_nodes_in_group("enemies"):
				if is_instance_valid(enemy):
					enemy.set("speed_multiplier", 1.0)
	if active_power_effects.has("enchanted_towers"):
		active_power_effects["enchanted_towers"] -= delta
		if active_power_effects["enchanted_towers"] <= 0.0:
			active_power_effects.erase("enchanted_towers")
			power_enchanted_timer = 0.0
			for tower in get_tree().get_nodes_in_group("towers"):
				if "power_damage_mult" in tower:
					tower.power_damage_mult = 1.0
		else:
			power_enchanted_timer = active_power_effects["enchanted_towers"]
			for tower in get_tree().get_nodes_in_group("towers"):
				if "power_damage_mult" in tower:
					tower.power_damage_mult = 1.5
	# Odyssey transition
	if odyssey_transition_active:
		odyssey_transition_timer -= delta
		if odyssey_transition_timer <= 0.0:
			odyssey_transition_active = false
			_start_odyssey_map(odyssey_current_map)
	# Boss rescue animation
	_process_boss_rescue(delta)
	if is_wave_active:
		_handle_spawning(delta)
		_check_wave_complete()
	elif wave_auto_timer > 0.0:
		wave_auto_timer -= delta
		start_button.text = "  NEXT IN %.0fs  " % maxf(wave_auto_timer, 0.0)
		if wave_auto_timer <= 0.0:
			wave_auto_timer = -1.0
			_start_next_wave()
	# Fighting voice-over catchphrases (every 20-30s during combat)
	if placed_tower_positions.size() > 0:
		_fighting_quote_timer -= delta
		# Shadow Author taunts in his domain (levels 34-36) on separate timer
		if current_level >= 34 and shadow_author_fight_clips.size() > 0:
			shadow_author_taunt_timer -= delta
			if shadow_author_taunt_timer <= 0.0 and not catchphrase_player.playing:
				_play_shadow_author_taunt()
				shadow_author_taunt_timer = randf_range(25.0, 40.0)
		if _fighting_quote_timer <= 0.0 and not catchphrase_player.playing:
			_play_random_fighting_quote()
			_fighting_quote_timer = randf_range(20.0, 30.0)
	# Update floating texts
	var ft_i = _floating_texts.size() - 1
	while ft_i >= 0:
		var ft = _floating_texts[ft_i]
		ft["timer"] -= delta
		ft["vel_y"] *= 0.96  # decelerate
		ft["pos"].y += ft["vel_y"] * delta
		if ft["timer"] <= 0.0:
			_floating_texts.remove_at(ft_i)
		ft_i -= 1
	# Update gold flash
	if _insufficient_gold_flash > 0.0:
		_insufficient_gold_flash -= delta * 3.0
	# Update boss alert
	if _boss_alert_timer > 0.0:
		_boss_alert_timer -= delta
	# Update wave clear popup
	if _wave_clear_timer > 0.0:
		_wave_clear_timer -= delta
	# Update screen shake
	if _screen_shake_timer > 0.0:
		_screen_shake_timer -= delta
		var shake_strength = _screen_shake_intensity * (_screen_shake_timer / 0.5)
		_screen_shake_offset = Vector2(randf_range(-shake_strength, shake_strength), randf_range(-shake_strength, shake_strength))
	else:
		_screen_shake_offset = Vector2.ZERO
	# Update ink splatters
	var sp_i = _ink_splatters.size() - 1
	while sp_i >= 0:
		var sp = _ink_splatters[sp_i]
		sp["timer"] -= delta
		sp["vel"] *= 0.92  # friction
		sp["pos"] += sp["vel"] * delta
		if sp["timer"] <= 0.0:
			_ink_splatters.remove_at(sp_i)
		sp_i -= 1
	# Update death flash
	if _death_flash_timer > 0.0:
		_death_flash_timer -= delta
	queue_redraw()

func _handle_spawning(delta: float) -> void:
	if enemies_to_spawn <= 0:
		return
	spawn_timer -= delta
	if spawn_timer <= 0.0:
		_spawn_enemy()
		spawn_timer = spawn_interval

func _spawn_enemy() -> void:
	var enemy = enemy_scene.instantiate()
	enemy.add_to_group("enemies")

	# Set enemy theme and tier
	if endless_mode:
		enemy.enemy_theme = randi() % 13
	else:
		enemy.enemy_theme = levels[current_level].get("enemy_theme", levels[current_level]["character"]) if current_level >= 0 and current_level < levels.size() else 0
	var wave_progress = float(wave) / float(max(1, total_waves))
	if endless_mode:
		var w = wave
		if w < 10:
			enemy.enemy_tier = 0
		elif w < 25:
			enemy.enemy_tier = 1
		elif w < 50:
			enemy.enemy_tier = 2
		else:
			enemy.enemy_tier = 3
	elif wave_progress <= 0.25:
		enemy.enemy_tier = 0
	elif wave_progress <= 0.5:
		enemy.enemy_tier = 1
	elif wave_progress <= 0.75:
		enemy.enemy_tier = 2
	else:
		enemy.enemy_tier = 3

	# Endless mode scaling — sub-exponential to stay playable at high waves
	if endless_mode:
		var w = wave
		# Health: polynomial+log scaling instead of pure exponential
		# wave 10: ~600, wave 25: ~3k, wave 50: ~18k, wave 100: ~110k
		var base_hp = 80.0 + w * 30.0 + pow(w, 2.2) * 2.0
		if w > 20:
			base_hp *= 1.0 + log(float(w - 19)) * 0.5
		enemy.max_health = base_hp
		enemy.speed = minf(80.0 + w * 2.0, 260.0)  # Cap speed to keep game playable
		# Gold scales with health so economy stays viable
		enemy.gold_reward = 5 + w / 2 + int(base_hp / 200.0)
		# Boss every 10 waves
		if w > 0 and w % 10 == 0:
			enemy.boss_scale = 1.8 + float(w) / 50.0
			enemy.max_health *= 4.0
			enemy.speed *= 0.65
			enemy.gold_reward += 15 + w / 5
		enemy.health = enemy.max_health
		_apply_enemy_modifiers(enemy, w, enemy.boss_scale > 1.0)
		enemy_path.add_child(enemy)
		enemies_to_spawn -= 1
		enemies_alive += 1
		return

	# Progressive difficulty scaling (supports 20-40 waves)
	# Balanced: +25% HP vs old values, gold reward reduced ~30% in mid/late game
	var w = wave
	if w <= 5:
		# Phase 1: Gentle introduction (unchanged — let new players learn)
		enemy.max_health = 60.0 + w * 18.0
		enemy.speed = 65.0 + w * 4.0
		enemy.gold_reward = 2 + w * 1
	elif w <= 10:
		# Phase 2: Building pressure (+15% HP, same gold)
		enemy.max_health = 165.0 + (w - 5) * 42.0
		enemy.speed = 80.0 + (w - 5) * 5.0
		enemy.gold_reward = 4 + (w - 5) * 1
	elif w <= 16:
		# Phase 3: Challenging (+25% HP, slightly less gold)
		enemy.max_health = 380.0 + (w - 10) * 65.0
		enemy.speed = 100.0 + (w - 10) * 4.0
		enemy.gold_reward = 6 + (w - 10) * 1
	elif w <= 24:
		# Phase 4: Hard (+30% HP, reduced gold growth)
		enemy.max_health = 760.0 + (w - 16) * 90.0
		enemy.speed = 115.0 + (w - 16) * 4.0
		enemy.gold_reward = 10 + (w - 16) * 1
	elif w <= 32:
		# Phase 5: Very hard (+25% HP, tighter gold)
		enemy.max_health = 1400.0 + (w - 24) * 130.0
		enemy.speed = 130.0 + (w - 24) * 3.0
		enemy.gold_reward = 16 + (w - 24) * 1
	else:
		# Phase 6: Brutal (waves 33-40) (+20% HP, capped gold)
		enemy.max_health = 2200.0 + (w - 32) * 180.0
		enemy.speed = 145.0 + (w - 32) * 3.0
		enemy.gold_reward = 22 + (w - 32) * 2

	# === MOAB Villain waves ===
	# MOAB at wave 15 (tier 0), 25 (tier 1), 35 (tier 2) on Medium/Hard
	var theme = levels[current_level].get("enemy_theme", 0) if current_level >= 0 and current_level < levels.size() else 0
	if selected_difficulty >= 1 and enemies_to_spawn == _get_wave_enemy_count(w):
		# First enemy of the wave — check if MOAB wave
		if w == 15 and selected_difficulty >= 1:
			_spawn_moab_wave(theme, 0)
		elif w == 25 and selected_difficulty >= 1:
			_spawn_moab_wave(theme, 1)
		elif w == 35 and selected_difficulty >= 1:
			_spawn_moab_wave(theme, 2)

	# === Boss wave modifiers ===
	# Milestone bosses at waves 20, 25, 30, 35 — bigger, tougher, slower
	var is_boss_wave = w in [20, 25, 30, 35]
	var is_final_villain = w >= 39 and selected_difficulty == 2  # Hard mode waves 39-40
	var is_last_wave = w == total_waves

	if is_final_villain:
		# Final villain — extremely strong, very large
		enemy.max_health *= 8.0
		enemy.speed *= 0.55
		enemy.gold_reward += 25
		enemy.enemy_tier = 3
		enemy.boss_scale = 2.5
	elif is_boss_wave:
		# Milestone boss — much stronger, larger
		var boss_mult = 1.0 + float(w) / 20.0  # 2.0x at w20, 2.25x at w25, etc.
		enemy.max_health *= 3.5 * boss_mult
		enemy.speed *= 0.65
		enemy.gold_reward += 10 + w / 4
		enemy.boss_scale = 1.8
	elif is_last_wave:
		# Final wave — single named boss villain
		enemy.is_named_boss = true
		enemy.boss_name = BOSS_VILLAIN_NAMES.get(enemy.enemy_theme, "The Villain")
		enemy.enemy_tier = 3
		enemy.boss_scale = 3.5
		enemy.max_health *= 12.0
		enemy.speed *= 0.45
		enemy.gold_reward += 30

	# Variety waves (fast rushes and swarms between bosses)
	if not is_boss_wave and not is_final_villain and not is_last_wave:
		var quarter = max(1, int(total_waves * 0.25))
		var half_w = max(1, int(total_waves * 0.5))
		var three_q = max(1, int(total_waves * 0.75))
		if w == quarter:
			enemy.speed *= 1.6
			enemy.max_health *= 0.6
		elif w == half_w:
			enemy.max_health *= 2.0
			enemy.speed *= 0.7
			enemy.gold_reward += 3
		elif w == three_q:
			enemy.max_health *= 0.5
			enemy.speed *= 1.3

	# Difficulty mode multiplier (Easy=0.85, Medium=1.0, Hard=1.2)
	var diff_mult = [0.85, 1.0, 1.2][selected_difficulty]
	enemy.max_health *= diff_mult
	enemy.speed *= (0.9 + selected_difficulty * 0.05)

	# Level difficulty multiplier
	if current_level >= 0 and current_level < levels.size():
		var diff = levels[current_level]["difficulty"]
		enemy.max_health *= diff
		enemy.speed = enemy.speed * (1.0 + (diff - 1.0) * 0.3)

	# Cap enemy speed to prevent unplayable situations
	enemy.speed = minf(enemy.speed, 280.0)

	# Apply spawn debuffs from progressive abilities
	if spawn_hp_reduction > 0.0:
		enemy.max_health *= (1.0 - spawn_hp_reduction)
	# Apply Knowledge Tree enemy debuffs (Dark Passages branch)
	var kt_hp_reduce = _get_knowledge_bonus("enemy_hp_reduce")
	if kt_hp_reduce > 0.0:
		enemy.max_health *= (1.0 - kt_hp_reduce)
	var kt_boss_hp_reduce = _get_knowledge_bonus("boss_hp_reduce")
	if kt_boss_hp_reduce > 0.0 and (is_boss_wave or is_final_villain or is_last_wave):
		enemy.max_health *= (1.0 - kt_boss_hp_reduce)
	var kt_half_hp = _get_knowledge_bonus("enemy_half_hp")
	if kt_half_hp > 0.0 and randf() < kt_half_hp:
		enemy.max_health *= 0.5
	enemy.health = enemy.max_health
	var kt_enemy_slow = _get_knowledge_bonus("enemy_slow")
	if spawn_permanent_slow < 1.0:
		enemy.apply_permanent_slow(spawn_permanent_slow)
	if kt_enemy_slow > 0.0:
		enemy.apply_permanent_slow(1.0 - kt_enemy_slow)
	# Apply cursed passages modifiers
	_apply_enemy_modifiers(enemy, w, is_boss_wave or is_final_villain or is_last_wave)
	enemy_path.add_child(enemy)
	enemies_to_spawn -= 1
	enemies_alive += 1

func _get_wave_enemy_count(w: int) -> int:
	if endless_mode:
		if w > 0 and w % 10 == 0:
			return 3  # Boss waves: fewer enemies
		return 6 + w * 2 + w / 3
	var base = 4 + w * 2
	# Boss waves: fewer but much stronger enemies
	if w in [20, 25, 30, 35]:
		return max(3, base / 3)
	# Final villain waves (Hard 39-40): very few, very strong
	if w >= 39 and selected_difficulty == 2:
		return 2 if w == 40 else 3
	# Last wave of any difficulty: single named boss villain
	if w == total_waves:
		return 1
	# Variety waves
	var q = max(1, int(total_waves * 0.25))
	var h = max(1, int(total_waves * 0.5))
	var tq = max(1, int(total_waves * 0.75))
	if w == q: return base + 8   # Fast rush — lots of enemies
	if w == h: return base - 4   # Tank wave — fewer enemies
	if w == tq: return base + 12 # Swarm
	return base

func _get_wave_spawn_interval(w: int) -> float:
	# Boss waves spawn slower (dramatic pacing)
	if w in [20, 25, 30, 35] or w == total_waves:
		return 2.0
	if w >= 39 and selected_difficulty == 2:
		return 3.0  # Final villains — very slow, dramatic
	var progress = float(w) / float(max(1, total_waves))
	if progress <= 0.33:
		return 0.9 - progress * 0.3
	elif progress <= 0.6:
		return 0.78 - (progress - 0.33) * 0.5
	elif progress <= 0.8:
		return 0.6 - (progress - 0.6) * 0.5
	else:
		return max(0.25, 0.48 - (progress - 0.8) * 0.3)

func _get_wave_name(w: int) -> String:
	var q = max(1, int(total_waves * 0.25))
	var h = max(1, int(total_waves * 0.5))
	var tq = max(1, int(total_waves * 0.75))
	var char_idx = levels[current_level].get("enemy_theme", levels[current_level]["character"]) if current_level >= 0 and current_level < levels.size() else 0
	var chap_idx = levels[current_level]["chapter"] if current_level >= 0 and current_level < levels.size() else 0

	# === Boss milestone wave names (override regular names) ===
	var boss_names = {
		0: {  # Robin Hood
			20: "BOSS — The Sheriff's Champion!",
			25: "BOSS — The Black Knight!",
			30: "BOSS — Sir Guy of Gisbourne!",
			35: "BOSS — Prince John's Warlord!",
			39: "FINAL VILLAIN — Prince John Arrives!",
			40: "FINAL VILLAIN — The Crown's Vengeance!",
		},
		1: {  # Alice
			20: "BOSS — The Jabberwock Awakens!",
			25: "BOSS — The Red Queen's Champion!",
			30: "BOSS — The Bandersnatch!",
			35: "BOSS — The Vorpal Beast!",
			39: "FINAL VILLAIN — The Queen of Hearts!",
			40: "FINAL VILLAIN — Off With ALL Their Heads!",
		},
		2: {  # Wicked Witch
			20: "BOSS — The Winkie Warlord!",
			25: "BOSS — The King of the Flying Monkeys!",
			30: "BOSS — The Great and Terrible Oz!",
			35: "BOSS — The Nome King's General!",
			39: "FINAL VILLAIN — The Nome King Rises!",
			40: "FINAL VILLAIN — The Throne of Stone!",
		},
		3: {  # Peter Pan
			20: "BOSS — The Pirate Quartermaster!",
			25: "BOSS — The Crocodile Hunter!",
			30: "BOSS — Blackbeard's Ghost!",
			35: "BOSS — Hook's Right Hand!",
			39: "FINAL VILLAIN — Captain Hook!",
			40: "FINAL VILLAIN — The Jolly Roger's Last Stand!",
		},
		4: {  # Phantom
			20: "BOSS — The Grand Chandelier Falls!",
			25: "BOSS — The Mirror Shade!",
			30: "BOSS — The Opera Gargoyle!",
			35: "BOSS — The Masked Maestro!",
			39: "FINAL VILLAIN — The Phantom Unmasked!",
			40: "FINAL VILLAIN — The Phantom's Requiem!",
		},
		5: {  # Scrooge
			20: "BOSS — Marley's Ghost!",
			25: "BOSS — The Ghost of Christmas Past!",
			30: "BOSS — The Ghost of Christmas Present!",
			35: "BOSS — The Ghost of Christmas Future!",
			39: "FINAL VILLAIN — Death's Shadow!",
			40: "FINAL VILLAIN — Scrooge's Final Reckoning!",
		},
		6: {  # Shadow Entities (Prologue)
			8: "BOSS — The Shadow Sentinel!",
			10: "BOSS — The Ink Lord!",
		},
		7: {  # Sherlock Criminals
			20: "BOSS — The Crime Lord!",
			25: "BOSS — Moriarty's Right Hand!",
			39: "FINAL VILLAIN — Professor Moriarty!",
			40: "FINAL VILLAIN — The Napoleon of Crime!",
		},
		8: {  # Merlin Dark Sorcery
			20: "BOSS — The Dark Enchantress!",
			25: "BOSS — The Black Knight!",
			39: "FINAL VILLAIN — Morgan le Fay!",
			40: "FINAL VILLAIN — The Sorceress Supreme!",
		},
		9: {  # Tarzan Hunters
			20: "BOSS — The Head Poacher!",
			25: "BOSS — The Safari King!",
			39: "FINAL VILLAIN — Clayton!",
			40: "FINAL VILLAIN — The Hunter Becomes the Hunted!",
		},
		10: {  # Dracula Undead
			20: "BOSS — The Vampire Bride!",
			25: "BOSS — The Alpha Wolf!",
			28: "BOSS — The Elder Vampire!",
			39: "FINAL VILLAIN — Count Dracula Awakens!",
			40: "FINAL VILLAIN — The Eternal Night!",
		},
		11: {  # Frankenstein Experiments
			20: "BOSS — The Failed Experiment!",
			25: "BOSS — The Homunculus King!",
			28: "BOSS — Victor's Shadow!",
			39: "FINAL VILLAIN — Igor the Mad!",
			40: "FINAL VILLAIN — The Creator's Revenge!",
		},
		12: {  # Shadow Author
			25: "BOSS — The Ink Colossus!",
			30: "BOSS — The Corrupted Narrator!",
			35: "BOSS — The Eraser!",
			39: "FINAL VILLAIN — The Shadow Author!",
			40: "FINAL VILLAIN — THE END!",
		},
	}
	# Check for boss/final villain waves
	if char_idx in boss_names and w in boss_names[char_idx]:
		if w >= 39 and selected_difficulty < 2:
			pass  # Only show final villain names on Hard
		elif w > total_waves:
			pass  # Don't show boss names beyond the wave count
		else:
			return boss_names[char_idx][w]

	match char_idx:
		0: # Robin Hood
			match chap_idx:
				0: # Ch1 — Tax collectors, early Sherwood
					if w == q: return "FAST RUSH — Swift tax riders!"
					if w == h: return "TANK WAVE — Armored revenue cart!"
					if w == tq: return "SWARM — Tax collector stampede!"
					if w == total_waves: return "BOSS — The Royal Tax Master!"
					var n = ["Tax collectors spotted!", "Revenue patrol incoming", "More tax men approach",
						"Sherwood road toll guards", "Tax wagon escort", "Sheriff's informants",
						"Tax assessor squad", "Coin purse snatchers", "Tithe enforcers march",
						"Ledger-bearing clerks", "Treasury scouts advance", "Royal tax decree!",
						"Debt warrant officers", "Gold cart guardsmen"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Sheriff's soldiers, escalation
					if w == q: return "FAST RUSH — Mounted sheriff's scouts!"
					if w == h: return "TANK WAVE — Armored knights ride forth!"
					if w == tq: return "SWARM — The Sheriff's full garrison!"
					if w == total_waves: return "BOSS — The Sheriff of Nottingham!"
					var n = ["Sheriff's patrol spotted!", "Soldiers from the castle", "Crossbow sentries advance",
						"Nottingham cavalry scouts", "Castle garrison deploys", "Sheriff's archers march",
						"Knight errant vanguard", "Pikemen hold the line", "Sheriff's war hounds",
						"Battering ram escort", "Armored lance brigade", "Castle wall defenders",
						"The Sheriff's elite guard", "Siege tower builders"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Siege of Nottingham, climax
					if w == q: return "FAST RUSH — Siege scouts sprint ahead!"
					if w == h: return "TANK WAVE — Castle siege engines!"
					if w == tq: return "SWARM — All of Nottingham marches!"
					if w == total_waves: return "BOSS — Prince John's Royal Army!"
					var n = ["Siege vanguard approaches!", "Trebuchet operators advance", "Battering ram crews",
						"Castle wall breakers", "Prince John's heralds", "Royal decree enforcers",
						"Flaming arrow brigade", "Fortress sappers tunnel in", "War elephant handlers",
						"Crown loyalist knights", "The Prince's iron guard", "Nottingham's last stand",
						"Throne room defenders", "The final siege wave"]
					return n[(w - 1) % n.size()]
		1: # Alice
			match chap_idx:
				0: # Ch1 — Card scouts, early Wonderland
					if w == q: return "FAST RUSH — Card scouts scramble!"
					if w == h: return "TANK WAVE — Armored ace of spades!"
					if w == tq: return "SWARM — Full deck deployed!"
					if w == total_waves: return "BOSS — The Knave of Hearts!"
					var n = ["Card soldiers spotted!", "Numbered cards march", "Spade patrol incoming",
						"Diamond sentries glitter", "Club enforcers stomp", "Two of hearts scouts",
						"Shuffled patrol advance", "Card painters approach", "Rose garden guards",
						"Croquet ground wardens", "Hedge maze sentries", "Deck reshuffled!",
						"Wild card scouts", "Joker's little helpers"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Mad tea party & chess pieces
					if w == q: return "FAST RUSH — March Hare's stampede!"
					if w == h: return "TANK WAVE — The Jabberwock stirs!"
					if w == tq: return "SWARM — Chess pieces flood the board!"
					if w == total_waves: return "BOSS — The Red Queen!"
					var n = ["Mad tea party crashers!", "Dormouse sleeper agents", "March Hare's militia",
						"Cheshire grin stalkers", "Looking glass scouts", "Chess pawn advance",
						"Rook towers roll forward", "Knight pieces gallop", "Bishop diagonal assault",
						"Tweedledee & Tweedledum", "Bandersnatch sighting!", "Mock turtle brigade",
						"Vorpal blade seekers", "Through the looking glass"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Queen's court, climax
					if w == q: return "FAST RUSH — Queen's swift executioners!"
					if w == h: return "TANK WAVE — Jabberwock unleashed!"
					if w == tq: return "SWARM — The entire court attacks!"
					if w == total_waves: return "BOSS — The Queen of Hearts!"
					var n = ["Royal court assembles!", "Queen's herald sounds", "Executioner's guard",
						"Flamingo cavalry charge", "The Queen's croquet army", "Painting roses red!",
						"Throne room champions", "Crown jewel defenders", "Off with their heads!",
						"Jabberwock's brood descends", "Royal flush assault", "The Queen's ultimatum",
						"Wonderland unravels!", "Final verdict approaches"]
					return n[(w - 1) % n.size()]
		2: # Wicked Witch / Oz
			match chap_idx:
				0: # Ch1 — Winkie guards, early Oz
					if w == q: return "FAST RUSH — Winkie scouts dash!"
					if w == h: return "TANK WAVE — Armored Winkie captain!"
					if w == tq: return "SWARM — Winkie regiment marches!"
					if w == total_waves: return "BOSS — The Winkie General!"
					var n = ["Winkie guards spotted!", "Yellow uniform patrol", "Western frontier scouts",
						"Poppy field lurkers", "Winkie spear carriers", "Emerald road blockers",
						"Yellow brick sentries", "Winkie drum corps", "Witch's errand runners",
						"Tin whistle scouts", "Scarecrow field watchers", "Winkie border patrol",
						"Golden cap seekers", "Oz perimeter guards"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Flying monkeys & the Witch rises
					if w == q: return "FAST RUSH — Flying monkeys swoop!"
					if w == h: return "TANK WAVE — Armored gorilla guard!"
					if w == tq: return "SWARM — Monkey horde darkens the sky!"
					if w == total_waves: return "BOSS — The Wicked Witch of the West!"
					var n = ["Flying monkeys approach!", "Monkey squadron descends", "Winged ambush party",
						"Witch's cauldron brew stirs", "Broom-riding scouts", "Monkey bombardiers",
						"Crystal ball spies", "Enchanted forest walkers", "Tornado debris creatures",
						"Silver shoe seekers", "Witch's shadow minions", "Dark spell weavers",
						"Monkey king's vanguard", "The Witch's cackle echoes"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Nome King & Emerald City siege
					if w == q: return "FAST RUSH — Nome tunnelers burst forth!"
					if w == h: return "TANK WAVE — Rock titan advances!"
					if w == tq: return "SWARM — Underground legion surfaces!"
					if w == total_waves: return "BOSS — The Nome King!"
					var n = ["Nome tunnelers emerge!", "Crystal cave raiders", "Rock soldiers march",
						"Underground sappers dig in", "Gemstone golem patrol", "Emerald City spies",
						"Nome King's heralds", "Quartz shard throwers", "Obsidian knight brigade",
						"Magma core dwellers", "The Nome King stirs!", "Jewel-encrusted sentinels",
						"Earthquake brigade", "The throne room trembles"]
					return n[(w - 1) % n.size()]
		3: # Peter Pan
			match chap_idx:
				0: # Ch1 — Pirate scouts, Neverland shores
					if w == q: return "FAST RUSH — Pirate scouts sprint!"
					if w == h: return "TANK WAVE — Powder keg haulers!"
					if w == tq: return "SWARM — Shore landing party!"
					if w == total_waves: return "BOSS — The Pirate Bosun!"
					var n = ["Pirate deckhands arrive!", "Swabbie patrol incoming", "Buccaneer scouts",
						"Cutlass-wielding mates", "Crow's nest lookouts", "Plank walkers march",
						"Powder monkey brigade", "Rum barrel rollers", "Anchor chain draggers",
						"Dinghy landing crew", "Treasure map hunters", "Skull Rock sentries",
						"Parrot messenger scouts", "Neverland shore patrol"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Pirate officers & jungle dangers
					if w == q: return "FAST RUSH — Jungle ambush runners!"
					if w == h: return "TANK WAVE — Pirate cannon crew!"
					if w == tq: return "SWARM — Lost Boys besieged!"
					if w == total_waves: return "BOSS — The Pirate First Mate!"
					var n = ["Pirate officers advance!", "Boarding party inbound", "Cannon crew approaches",
						"First mate's detachment", "Jungle vine swingers", "Mermaid Lagoon assault",
						"Crocodile handlers march", "Boatswain's brigade", "Musket-bearing pirates",
						"Jungle trap setters", "Tiger Lily's warning!", "Neverland fog creepers",
						"Pirate war drummers", "The jungle closes in"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Captain Hook & the Jolly Roger
					if w == q: return "FAST RUSH — Hook's fastest cutthroats!"
					if w == h: return "TANK WAVE — Ironclad pirate warship!"
					if w == tq: return "SWARM — The entire Jolly Roger crew!"
					if w == total_waves: return "BOSS — Captain Hook!"
					var n = ["Hook sends his vanguard!", "Jolly Roger's finest", "The Black Spot cometh",
						"Hook's elite swordsmen", "Cannonball barrage crew", "All hands on deck!",
						"Pirate armada sails forth", "Hook's personal guard", "Tick-Tock draws near!",
						"Gangplank executioners", "The captain's ultimatum", "Jolly Roger broadside!",
						"Hook's final gambit", "Neverland's darkest hour"]
					return n[(w - 1) % n.size()]
		4: # Phantom
			match chap_idx:
				0: # Ch1 — Stagehands & shadows, opera house
					if w == q: return "FAST RUSH — Shadow dancers dart!"
					if w == h: return "TANK WAVE — Heavy curtain golem!"
					if w == tq: return "SWARM — Backstage mob floods out!"
					if w == total_waves: return "BOSS — The Stage Manager!"
					var n = ["Stagehands scurry forth!", "The orchestra stirs", "Shadows in the wings",
						"Prop room escapees", "Spotlight chasers", "Rats from below the stage",
						"Costume rack lurkers", "Sandbag droppers above", "Makeup room horrors",
						"Backstage frenzy builds", "Rigging rope swingers", "Prompt box whisperers",
						"Curtain pullers advance", "The overture begins"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Labyrinth & mirrors, deeper opera
					if w == q: return "FAST RUSH — Mirror shards scatter!"
					if w == h: return "TANK WAVE — Gargoyle sentinels descend!"
					if w == tq: return "SWARM — Labyrinth spawns endlessly!"
					if w == total_waves: return "BOSS — The Mirror Phantom!"
					var n = ["The masquerade begins!", "Mirror maze madness", "Trapdoor ambush below",
						"Labyrinth of mirrors", "Candelabra ghosts flicker", "Phantom copycats emerge",
						"Gargoyle watchers stir", "Chandelier chain rattlers", "Opera ghost sightings",
						"Box Five awakens!", "Falling curtain shades", "Hall of echoes patrol",
						"Wax figure sentries", "The organ's fury builds"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Underground lair, climax
					if w == q: return "FAST RUSH — Lair bats swarm the exits!"
					if w == h: return "TANK WAVE — The organ colossus!"
					if w == tq: return "SWARM — Underground phantoms pour forth!"
					if w == total_waves: return "BOSS — The Phantom of the Opera!"
					var n = ["Underground lake patrol!", "Christine's nightmare stirs", "Lair entrance guardians",
						"Sewer tunnel crawlers", "Subterranean echo shades", "Candle-lit crypt walkers",
						"The Phantom's music swells", "Torture chamber sentinels", "Lasso-wielding shadows",
						"Pipe organ resonators", "Lake of fire boatmen", "Mask fragment seekers",
						"The final act begins!", "Beneath the opera forever"]
					return n[(w - 1) % n.size()]
		5: # Scrooge
			match chap_idx:
				0: # Ch1 — Street urchins & carolers, London streets
					if w == q: return "FAST RUSH — Pickpocket dash!"
					if w == h: return "TANK WAVE — Workhouse bruiser!"
					if w == tq: return "SWARM — Street mob riots!"
					if w == total_waves: return "BOSS — The Debt Collector General!"
					var n = ["Street urchins scuttle!", "Chimney sweepers march", "Pickpocket gang approaches",
						"Workhouse escapees shamble", "Carolers gone wrong", "Fog-born shadows creep",
						"Lamplighter scouts", "Cobblestone prowlers", "Penny-pincher patrol",
						"Beggar brigade advances", "Newspaper boy ambush", "Coal dust sneakers",
						"Frostbitten vagrants", "London's forgotten ones"]
					return n[(w - 1) % n.size()]
				1: # Ch2 — Spirits & ghosts, hauntings
					if w == q: return "FAST RUSH — Spirit wisps scatter!"
					if w == h: return "TANK WAVE — Ghosts of Christmas Past!"
					if w == tq: return "SWARM — Spectral procession floods in!"
					if w == total_waves: return "BOSS — Ghost of Christmas Present!"
					var n = ["Debt collectors approach!", "Chain rattlers march", "Marley's associates",
						"Counting house guards", "Ghostly apparitions drift", "Spirit wisps gather",
						"Ledger keepers advance", "Top hat enforcers", "Spectral procession forms",
						"Frost wraiths howl!", "Candle flame phantoms", "Clock tower bell shades",
						"Memory lane specters", "The spirits converge"]
					return n[(w - 1) % n.size()]
				2: # Ch3 — Army of despair, climax
					if w == q: return "FAST RUSH — Despair's swift heralds!"
					if w == h: return "TANK WAVE — Marley's iron chains!"
					if w == tq: return "SWARM — The army of despair marches!"
					if w == total_waves: return "BOSS — Ghost of Christmas Yet to Come!"
					var n = ["Blizzard brigade advances!", "Frozen specters shamble", "Winter wolves howl",
						"Grave diggers march forth", "Tombstone sentinels rise", "The chains grow heavier",
						"Midnight bell tolls!", "Shadow of the future looms", "Despair's vanguard",
						"Headstone inscription crawlers", "Unmarked grave keepers", "The final Christmas Eve",
						"Bells toll midnight!", "Dawn must break"]
					return n[(w - 1) % n.size()]
		6: # Shadow Entities (Prologue)
			if w == q: return "FAST RUSH — Ink wisps scatter!"
			if w == h: return "TANK WAVE — Shadow beast looms!"
			if w == tq: return "SWARM — The ink floods in!"
			if w == total_waves: return "BOSS — The Ink Lord!"
			var n = ["Shadow wisps emerge!", "Ink blots crawl forth", "Dark page fragments",
				"Quill scratch soldiers", "Torn page ghosts", "Ink puddle lurkers",
				"Shadow puppets advance", "Blotted word wraiths", "Spine-crack crawlers",
				"Margin creepers", "Footnote phantoms", "Chapter end shadows",
				"Bookmark sentinels", "The pages darken"]
			return n[(w - 1) % n.size()]
		7: # Sherlock Criminals
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Pickpocket sprint!"
					if w == h: return "TANK WAVE — Armored bruiser!"
					if w == tq: return "SWARM — Street gang swarms!"
					if w == total_waves: return "BOSS — The Crime Boss!"
					var n = ["Street thugs spotted!", "Alley lurkers emerge", "Pickpocket gang approaches",
						"Baker Street irregulars", "Opium den enforcers", "Dockland brawlers",
						"Whitechapel stalkers", "Underground fighters", "Fence operation crew",
						"Black market dealers", "Safecracker squad", "Informant hunters",
						"Scotland Yard imposters", "The fog thickens"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Assassin blades flash!"
					if w == h: return "TANK WAVE — Criminal mastermind's guard!"
					if w == tq: return "SWARM — The underworld mobilizes!"
					if w == total_waves: return "BOSS — Moriarty's Lieutenant!"
					var n = ["Assassins in the fog!", "Garrote wire specialists", "Poison dart blowers",
						"Moriarty's spies advance", "Criminal network agents", "Coded message runners",
						"Disguised operatives", "The web tightens!", "Sniper nest sighters",
						"Explosive experts approach", "Criminal syndicate elite", "Shadow organization",
						"Double agent ambush", "The game is afoot"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Moriarty's fastest!"
					if w == h: return "TANK WAVE — The Professor's machine!"
					if w == tq: return "SWARM — All of London's criminals!"
					if w == total_waves: return "BOSS — Professor Moriarty!"
					var n = ["Reichenbach approaches!", "The falls thunder", "Mathematical assassins",
						"Moriarty's chess pieces", "The final problem begins", "Crime empire remnants",
						"Waterfall mist soldiers", "Cliffside ambushers", "The professor's gambit",
						"Criminal masterwork!", "Deduction vs destruction", "The Napoleon of Crime stirs",
						"Elementary, my dear enemy", "The final deduction"]
					return n[(w - 1) % n.size()]
		8: # Merlin Dark Sorcery
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Squire scouts charge!"
					if w == h: return "TANK WAVE — Corrupted knight!"
					if w == tq: return "SWARM — The dark army forms!"
					if w == total_waves: return "BOSS — The Black Knight!"
					var n = ["Dark squires march!", "Rusted armor clanks", "Corrupted page boys",
						"Shadow lance bearers", "Cursed shield walls", "Enchanted sentries",
						"Round Table traitors", "Morgana's scouts", "Dark spell apprentices",
						"Camelot's fallen", "Cursed banner carriers", "Iron golem guards",
						"Blackened sword knights", "The corruption spreads"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Forest spirits charge!"
					if w == h: return "TANK WAVE — Ancient tree golem!"
					if w == tq: return "SWARM — The enchanted forest rises!"
					if w == total_waves: return "BOSS — The Warlock!"
					var n = ["Enchanted forest stirs!", "Standing stone guardians", "Rune circle warriors",
						"Dark druid summoners", "Celtic curse weavers", "Ancient oak sentinels",
						"Mushroom ring crawlers", "Fairy circle traps!", "Moss golem patrol",
						"Stone circle shamans", "Forest wraith ambush", "Ley line channelers",
						"Crystal shard throwers", "The old magic awakens"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Crystal shards fly!"
					if w == h: return "TANK WAVE — Crystal golem!"
					if w == tq: return "SWARM — The cave erupts!"
					if w == total_waves: return "BOSS — Morgan le Fay!"
					var n = ["Crystal cave defenders!", "Gemstone sentinels", "Cave stalactite warriors",
						"Morgan's enchantresses", "Dark crystal resonators", "Spell-forged knights",
						"The cave pulses!", "Arcane rune soldiers", "Merlin's prison guards",
						"Excalibur seekers", "Holy Grail protectors", "The sorceress stirs!",
						"Final enchantment wave", "Break the crystal prison!"]
					return n[(w - 1) % n.size()]
		9: # Tarzan Hunters
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Poachers sprint!"
					if w == h: return "TANK WAVE — Caged beast hauler!"
					if w == tq: return "SWARM — Hunting party swarms!"
					if w == total_waves: return "BOSS — The Head Poacher!"
					var n = ["Poachers spotted!", "Net-carrying trappers", "Jungle path cutters",
						"Pith helmet scouts", "Trophy hunters advance", "Canopy vine cutters",
						"Animal cage haulers", "Snare wire layers", "Ivory seekers march",
						"Jungle map readers", "Exotic pet catchers", "Tranquilizer dart squad",
						"Campsite builders", "The hunt begins"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Mounted hunters charge!"
					if w == h: return "TANK WAVE — Armored safari vehicle!"
					if w == tq: return "SWARM — The graveyard awakens!"
					if w == total_waves: return "BOSS — The Safari King!"
					var n = ["Big game hunters advance!", "Elephant gun carriers", "Safari jeep scouts",
						"Bone collectors march", "Graveyard dust seekers", "Tusk pry-bar squad",
						"Trophy wall builders", "Taxidermy experts", "Quicksand pathfinders",
						"Jungle ambush unit", "Rhino horn raiders", "The bones rattle!",
						"Ancient burial guardians", "The dead remember"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Mercenary scouts!"
					if w == h: return "TANK WAVE — Fortress siege ram!"
					if w == tq: return "SWARM — Clayton's full army!"
					if w == total_waves: return "BOSS — Clayton!"
					var n = ["Mercenary vanguard!", "Combat gear soldiers", "Machete-wielding scouts",
						"Fortress gate guards", "Watchtower snipers", "Barbed wire layers",
						"Explosive ordinance team", "Clayton's elite guard", "Jungle clearers",
						"Cage key holders", "The fortress trembles!", "Tarzan's rage builds!",
						"Freedom fighters", "Break the chains!"]
					return n[(w - 1) % n.size()]
		10: # Dracula Undead
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Thralls sprint!"
					if w == h: return "TANK WAVE — Dire wolf alpha!"
					if w == tq: return "SWARM — The village is overrun!"
					if w == total_waves: return "BOSS — The Village Elder!"
					var n = ["Thralls shamble forth!", "Pale villagers march", "Hypnotized peasants",
						"Garlic-proof scouts", "Wolfbane carriers", "Night patrol guards",
						"Graveyard shift workers", "Blood offering bearers", "Cross-resistant thralls",
						"Moonlit ambushers", "Fog-shrouded stalkers", "The village bell tolls!",
						"Midnight processioners", "Dawn never comes"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Bat swarm descends!"
					if w == h: return "TANK WAVE — Castle knight rises!"
					if w == tq: return "SWARM — The castle awakens!"
					if w == total_waves: return "BOSS — The Vampire Bride!"
					var n = ["Castle corridor stalkers!", "Armor suit animations", "Bat swarm scouts",
						"Coffin lid pushers", "Dining hall servants", "Bloodstain trail followers",
						"Tower staircase guards", "Chandelier chain swingers", "Portrait eye watchers",
						"Crypt key seekers", "The brides stir!", "Dire wolf pack howls",
						"Castle wall crawlers", "The Count watches"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Blood mist rushers!"
					if w == h: return "TANK WAVE — Ancient vampire!"
					if w == tq: return "SWARM — The crypt erupts!"
					if w == total_waves: return "BOSS — Count Dracula!"
					var n = ["Crypt guardians rise!", "Blood pool swimmers", "Ancient coffin dwellers",
						"Stake-proof elders", "Crimson mist walkers", "Blood chalice bearers",
						"The undead army marches!", "Shadow form shifters", "Nosferatu's children",
						"The crypt pulses red!", "Eternal night soldiers", "Dracula's chains rattle!",
						"Freedom through blood!", "Break the blood seal!"]
					return n[(w - 1) % n.size()]
		11: # Frankenstein Experiments
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Lab rats scatter!"
					if w == h: return "TANK WAVE — Failed experiment!"
					if w == tq: return "SWARM — The lab overflows!"
					if w == total_waves: return "BOSS — The Head Scientist!"
					var n = ["Lab rats scurry!", "Homunculus crawlers", "Beaker-born creatures",
						"Tesla coil sparkers", "Formaldehyde floaters", "Stitch-mark soldiers",
						"Lightning rod channelers", "Electrode head walkers", "Test tube terrors",
						"Galvanic cell chargers", "The lab sparks!", "Surgical tool wielders",
						"Brain jar carriers", "The experiment continues"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Torch runners!"
					if w == h: return "TANK WAVE — Pitchfork mob leader!"
					if w == tq: return "SWARM — The whole village attacks!"
					if w == total_waves: return "BOSS — The Village Magistrate!"
					var n = ["Angry villagers approach!", "Torch-bearing mob", "Pitchfork wielders march",
						"Millstone throwers", "Tavern brawler squad", "Church bell ringers",
						"Holy water throwers", "Wooden stake carriers", "The mob grows louder!",
						"Blacksmith hammer squad", "Hay cart barricaders", "Fire brigade arsonists",
						"Town crier warnings!", "The village burns!"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Ice shard runners!"
					if w == h: return "TANK WAVE — Frost golem!"
					if w == tq: return "SWARM — The arctic army!"
					if w == total_waves: return "BOSS — Igor!"
					var n = ["Arctic wind howlers!", "Frost-bitten soldiers", "Ice pick wielders",
						"Sled dog pack hunters", "Snowblind scouts", "Frozen chain draggers",
						"Igor's assistants march!", "Cryogenic capsule guards", "The ice cracks!",
						"Blizzard born warriors", "Glacier path breakers", "The Monster's chains rattle!",
						"Promethean spark seekers", "Shatter the ice prison!"]
					return n[(w - 1) % n.size()]
		12: # Shadow Author
			match chap_idx:
				0:
					if w == q: return "FAST RUSH — Ink soldiers charge!"
					if w == h: return "TANK WAVE — Ink colossus!"
					if w == tq: return "SWARM — The ink realm floods!"
					if w == total_waves: return "BOSS — The Ink Titan!"
					var n = ["Ink soldiers form!", "Dripping word warriors", "Quill-forged knights",
						"Paragraph golems march", "Sentence serpents slither", "Plot hole abominations",
						"Narrative thread weavers", "Exposition crawlers", "Red ink editors",
						"Footnote assassins", "The ink flows faster!", "Manuscript shredders",
						"Prologue phantoms", "The Author writes"]
					return n[(w - 1) % n.size()]
				1:
					if w == q: return "FAST RUSH — Corrupted heroes sprint!"
					if w == h: return "TANK WAVE — Corrupted champion!"
					if w == tq: return "SWARM — All stories collapse!"
					if w == total_waves: return "BOSS — The Corrupted Narrator!"
					var n = ["Corrupted characters emerge!", "Twisted fairy tales", "Dark adaptations march",
						"Rewritten heroes attack!", "Genre-bent warriors", "Sequel shadow soldiers",
						"Plagiarized phantoms", "Adaptation aberrations", "The pages go blank!",
						"Retcon shock troops", "Unreliable narrators", "Cliffhanger ambushers",
						"Deus ex machina soldiers", "The story unravels!"]
					return n[(w - 1) % n.size()]
				_:
					if w == q: return "FAST RUSH — Eraser blades sweep!"
					if w == h: return "TANK WAVE — The Eraser!"
					if w == tq: return "SWARM — THE END approaches!"
					if w == total_waves: return "BOSS — THE SHADOW AUTHOR!"
					var n = ["The final chapter begins!", "Every villain returns!", "All stories converge!",
						"The Author's masterwork!", "Ink tsunami approaches!", "Characters dissolve!",
						"The quill strikes!", "Reality rewrites itself!", "THE END is written!",
						"But the heroes resist!", "Stories fight back!", "Every page turns!",
						"The climax crescendos!", "REWRITE THE ENDING!"]
					return n[(w - 1) % n.size()]
	return "Wave %d" % w

func _check_wave_complete() -> void:
	if boss_rescue_active:
		return
	if enemies_to_spawn <= 0 and enemies_alive <= 0:
		is_wave_active = false
		game_paused = false
		start_button.disabled = false
		# Wave clear popup + sound
		_wave_clear_timer = 1.5
		_wave_clear_num = wave
		_play_sfx(_sfx_wave_complete)
		if not endless_mode and not shadow_arena_active and wave >= total_waves:
			_victory()
		else:
			# Endless bonus gold every 5 waves — scales with wave number
			if endless_mode and wave > 0 and wave % 5 == 0:
				var endless_bonus = 50 + wave * 3
				add_gold(endless_bonus)
				spawn_floating_text(Vector2(640, 300), "+%dG Endless Bonus!" % endless_bonus, Color(1.0, 0.9, 0.2), 18.0, 1.5)
			start_button.text = "  START WAVE  "
			# Bonus gold between waves — scales with progression
			var bonus = 5 + wave * 2 + int(wave / 10) * 5
			add_gold(bonus)
			spawn_floating_text(Vector2(640, 340), "+%dG Wave Bonus" % bonus, Color(1.0, 0.85, 0.2), 14.0, 1.0)
			# Knowledge tree: life regen per wave
			var life_regen = int(_get_knowledge_bonus("life_regen"))
			if life_regen > 0:
				lives += life_regen
				spawn_floating_text(Vector2(640, 370), "+%d Lives" % life_regen, Color(0.3, 1.0, 0.4), 13.0, 1.0)
			update_hud()
			# Auto-wave: start countdown timer for next wave
			if auto_wave_enabled:
				wave_auto_timer = auto_wave_delay
				start_button.text = "  NEXT IN %.0fs  " % auto_wave_delay
			info_label.text = "Wave %d cleared! +%dG bonus. Ready for next wave!" % [wave, bonus]

func _input(event: InputEvent) -> void:
	# Scroll wheel handling for scrollable views
	if event is InputEventMouseButton and event.pressed and game_state == GameState.MENU:
		if menu_current_view == "chapters" and (event.button_index == MOUSE_BUTTON_WHEEL_UP or event.button_index == MOUSE_BUTTON_WHEEL_DOWN):
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				story_map_scroll_y = maxf(0.0, story_map_scroll_y - 60.0)
			else:
				story_map_scroll_y += 60.0
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "relics" and (event.button_index == MOUSE_BUTTON_WHEEL_UP or event.button_index == MOUSE_BUTTON_WHEEL_DOWN):
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				relic_scroll_offset = maxf(0.0, relic_scroll_offset - 30.0)
			else:
				relic_scroll_offset = minf(relic_scroll_offset + 30.0, 1200.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "emporium" and emporium_sub_category == 8 and (event.button_index == MOUSE_BUTTON_WHEEL_UP or event.button_index == MOUSE_BUTTON_WHEEL_DOWN):
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				binding_shop_scroll = maxf(0.0, binding_shop_scroll - 30.0)
			else:
				binding_shop_scroll = minf(binding_shop_scroll + 30.0, 1200.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "survivors" and survivor_detail_open and (event.button_index == MOUSE_BUTTON_WHEEL_UP or event.button_index == MOUSE_BUTTON_WHEEL_DOWN):
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				detail_binding_scroll = maxf(0.0, detail_binding_scroll - 30.0)
			else:
				detail_binding_scroll = minf(detail_binding_scroll + 30.0, 600.0)
			queue_redraw()
			get_viewport().set_input_as_handled()
			return
	if not (event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT):
		return
	var mouse_pos = get_viewport().get_mouse_position()
	# Overlays must intercept before Control nodes consume the event
	if daily_reward_open:
		_on_daily_reward_clicked(mouse_pos)
		get_viewport().set_input_as_handled()
		return
	if chest_opening_active:
		_on_chest_overlay_clicked(mouse_pos)
		get_viewport().set_input_as_handled()
		return
	if story_state.active:
		_on_story_dialog_clicked(mouse_pos)
		get_viewport().set_input_as_handled()
		return
	# Menu clicks (must be in _input because menu_overlay eats events before _unhandled_input)
	# But let clicks on the nav bar (y >= 620) pass through to buttons
	if game_state == GameState.MENU and mouse_pos.y < 620:
		if menu_current_view == "chapters":
			_on_chapters_sidebar_clicked(mouse_pos)
			if menu_side_panel == "":
				_on_story_map_clicked(mouse_pos)
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "survivors":
			if survivor_detail_open:
				_on_detail_item_clicked(mouse_pos)
			elif world_map_hover_index >= 0:
				_on_survivor_card_pressed(world_map_hover_index)
			get_viewport().set_input_as_handled()
			return
		elif menu_current_view == "emporium":
			if emporium_sub_category == 6:
				_on_trophy_store_clicked(mouse_pos)
			elif emporium_sub_category == 8:
				_on_binding_shop_clicked(mouse_pos)
			elif emporium_sub_category == 9:
				_on_salvage_clicked(mouse_pos)
			elif emporium_sub_category == 10:
				_on_chest_crafting_clicked(mouse_pos)
			elif emporium_sub_category == 11:
				_on_instrument_shop_clicked(mouse_pos)
			elif emporium_sub_open:
				_on_emporium_sub_input(mouse_pos)
			elif emporium_hover_index >= 0:
				if emporium_hover_index == 6:
					emporium_sub_category = 6
				elif emporium_hover_index == 8:
					emporium_sub_category = 8
				elif emporium_hover_index == 9:
					emporium_sub_category = 9
				elif emporium_hover_index == 10:
					emporium_sub_category = 10
				elif emporium_hover_index == 11:
					emporium_sub_category = 11
				else:
					_on_emporium_tile_clicked(emporium_hover_index)
			get_viewport().set_input_as_handled()
			queue_redraw()
			return
		elif menu_current_view == "chronicles":
			_on_knowledge_tree_clicked(mouse_pos)
			get_viewport().set_input_as_handled()
			return

func _unhandled_input(event: InputEvent) -> void:
	if game_state != GameState.PLAYING:
		if not (event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT):
			return
		var mouse_pos = get_viewport().get_mouse_position()
		# === Overlays first (chest opening, daily rewards) ===
		if chest_opening_active:
			_on_chest_overlay_clicked(mouse_pos)
			return
		if daily_reward_open:
			_on_daily_reward_clicked(mouse_pos)
			return
		if game_state != GameState.MENU:
			return
		# Handle clicks in survivor detail view (BATTD-style)
		if survivor_detail_open:
			_on_detail_item_clicked(mouse_pos)
		# Handle world map zone clicks
		elif menu_current_view == "survivors" and not survivor_detail_open:
			if world_map_hover_index >= 0:
				_on_survivor_card_pressed(world_map_hover_index)
		# Handle emporium clicks
		elif menu_current_view == "emporium":
			if emporium_sub_category == 6:
				_on_trophy_store_clicked(mouse_pos)
			elif emporium_sub_category == 8:
				_on_binding_shop_clicked(mouse_pos)
			elif emporium_sub_category == 9:
				_on_salvage_clicked(mouse_pos)
			elif emporium_sub_category == 10:
				_on_chest_crafting_clicked(mouse_pos)
			elif emporium_sub_category == 11:
				_on_instrument_shop_clicked(mouse_pos)
			elif emporium_sub_open:
				_on_emporium_sub_input(mouse_pos)
			elif emporium_hover_index >= 0:
				if emporium_hover_index == 6:
					emporium_sub_category = 6
					queue_redraw()
				elif emporium_hover_index == 8:
					emporium_sub_category = 8
					queue_redraw()
				elif emporium_hover_index == 9:
					emporium_sub_category = 9
					queue_redraw()
				elif emporium_hover_index == 10:
					emporium_sub_category = 10
					queue_redraw()
				elif emporium_hover_index == 11:
					emporium_sub_category = 11
					queue_redraw()
				else:
					_on_emporium_tile_clicked(emporium_hover_index)
		# Handle chronicles/knowledge tree clicks
		elif menu_current_view == "chronicles":
			_on_knowledge_tree_clicked(mouse_pos)
		# Handle chapters view — badges/overlay first, then story map
		elif menu_current_view == "chapters":
			_on_chapters_sidebar_clicked(mouse_pos)
			if menu_side_panel == "":
				_on_story_map_clicked(mouse_pos)
		return
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			# Power selection overlay
			if power_selection_open:
				_on_power_selection_clicked(event.position)
				return
			if placing_tower:
				_try_place_tower(event.position)
			elif _handle_branch_panel_click(event.position):
				pass  # Branch panel consumed the click
			elif _handle_instrument_placement_click(event.position):
				pass  # Instrument placement consumed the click
			else:
				var tower = _find_tower_at(event.position)
				if tower:
					_select_tower(tower)
				else:
					_deselect_tower()
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			if _placing_instrument != "":
				_placing_instrument = ""
				_instrument_picker_open = false
				info_label.text = "Instrument placement cancelled."
				queue_redraw()
			elif placing_tower:
				placing_tower = false
				cancel_button.visible = false
				info_label.text = "Placement cancelled."
			else:
				_deselect_tower()
	elif event is InputEventScreenTouch and event.pressed:
		if placing_tower:
			_try_place_tower(event.position)
		else:
			var tower = _find_tower_at(event.position)
			if tower:
				_select_tower(tower)
			else:
				_deselect_tower()
	elif event is InputEventScreenDrag:
		ghost_position = event.position

func _dist_to_path(pos: Vector2) -> float:
	var min_dist: float = 99999.0
	for p in path_points:
		var d = pos.distance_to(p)
		if d < min_dist:
			min_dist = d
	return min_dist

func _is_valid_placement(pos: Vector2) -> bool:
	if pos.y < 55 or pos.y > 622:
		return false
	if pos.x < 5 or pos.x > 1275:
		return false
	if _dist_to_path(pos) < MIN_PATH_DIST:
		return false
	for tp in placed_tower_positions:
		if pos.distance_to(tp) < MIN_TOWER_DIST:
			return false
	return true

func _get_discounted_cost(tower_type) -> int:
	var base_cost = tower_info[tower_type]["cost"]
	var discount = clampf(_get_knowledge_bonus("tower_discount") + _get_knowledge_bonus("upgrade_discount"), 0.0, 0.5)
	return int(base_cost * (1.0 - discount))

func _try_place_tower(pos: Vector2) -> void:
	if not _is_valid_placement(pos):
		info_label.text = "Can't place there!"
		return
	var cost = _get_discounted_cost(selected_tower)
	if not spend_gold(cost):
		info_label.text = "Need %dG! (Have %dG)" % [cost, gold]
		_insufficient_gold_flash = 1.0
		return

	var tower = tower_scenes[selected_tower].instantiate()
	tower.position = pos
	tower.base_cost = cost
	tower.set_meta("tower_type_enum", selected_tower)
	towers_node.add_child(tower)
	# Apply meta-progression buffs (level + knowledge + relics)
	_apply_meta_buffs(tower, selected_tower)

	placed_tower_positions.append(pos)
	purchased_towers[selected_tower] = true
	var tname = tower_info[selected_tower]["name"]

	# Disable the button — one purchase per tower
	if tower_buttons.has(selected_tower):
		tower_buttons[selected_tower].text = "PLACED"
		tower_buttons[selected_tower].disabled = true

	placing_tower = false
	cancel_button.visible = false
	var quote = _play_placement_catchphrase(selected_tower)
	info_label.text = "%s: \"%s\"" % [tname, quote]
	# Track achievements + quests
	total_towers_placed += 1
	_check_achievement("novice_builder", 1)
	_check_achievement("master_builder", 1)
	_update_quest_progress("place_towers", 1)
	# Check full roster (all 6 types placed this game)
	_check_achievement("full_roster", purchased_towers.size())
	# Check synergies
	_check_synergies()

# ============================================================
# Helper: draw string in Cinzel uppercase
func _udraw(fnt: Font, pos: Vector2, text: String, halign: HorizontalAlignment = HORIZONTAL_ALIGNMENT_LEFT, width = -1, size: int = 16, color: Color = Color.WHITE) -> void:
	draw_string(fnt, pos, text.to_upper(), halign, width, size, color)

# DRAW — Level-specific backgrounds
# ============================================================
func _draw() -> void:
	if game_state == GameState.MENU:
		_draw_menu_background()
		# Menu view transition fade
		if menu_transition_alpha < 1.0:
			menu_transition_alpha = minf(menu_transition_alpha + 0.06, 1.0)
			draw_rect(Rect2(0, 35, 1280, 585), Color(0.03, 0.02, 0.06, 1.0 - menu_transition_alpha))
			queue_redraw()
		if chest_opening_active:
			_draw_chest_opening()
		if daily_reward_open:
			_draw_daily_reward()
		# Story dialog overlay (draws on top of everything in menu)
		if story_state.active:
			_draw_story_dialog()
		# Achievement popup in menu
		if achievement_popup_timer > 0.0:
			var font = game_font
			var a_alpha = clampf(achievement_popup_timer, 0.0, 1.0)
			draw_rect(Rect2(340, 20, 600, 40), Color(0.08, 0.12, 0.04, 0.85 * a_alpha))
			draw_rect(Rect2(340, 20, 600, 40), Color(0.4, 0.8, 0.2, 0.5 * a_alpha), false, 1.0)
			_udraw(font, Vector2(640, 37), achievement_popup_text, HORIZONTAL_ALIGNMENT_CENTER, 580, 14, Color(0.85, 0.75, 0.4, a_alpha))
			_udraw(font, Vector2(640, 53), achievement_popup_reward, HORIZONTAL_ALIGNMENT_CENTER, -1, 11, Color(0.5, 0.8, 0.3, a_alpha))
		return

	var sky_color = Color(0.04, 0.06, 0.14)
	var ground_color = Color(0.08, 0.18, 0.06)
	if current_level >= 0 and current_level < levels.size():
		sky_color = levels[current_level]["sky_color"]
		ground_color = levels[current_level]["ground_color"]

	match current_level:
		0: _draw_prologue(sky_color, ground_color)
		1: _draw_sherlock_ch1(sky_color, ground_color)
		2: _draw_sherlock_ch2(sky_color, ground_color)
		3: _draw_sherlock_ch3(sky_color, ground_color)
		4: _draw_merlin_ch1(sky_color, ground_color)
		5: _draw_merlin_ch2(sky_color, ground_color)
		6: _draw_merlin_ch3(sky_color, ground_color)
		7: _draw_tarzan_ch1(sky_color, ground_color)
		8: _draw_tarzan_ch2(sky_color, ground_color)
		9: _draw_tarzan_ch3(sky_color, ground_color)
		10: _draw_dracula_ch1(sky_color, ground_color)
		11: _draw_dracula_ch2(sky_color, ground_color)
		12: _draw_dracula_ch3(sky_color, ground_color)
		13: _draw_frankenstein_ch1(sky_color, ground_color)
		14: _draw_frankenstein_ch2(sky_color, ground_color)
		15: _draw_frankenstein_ch3(sky_color, ground_color)
		16: _draw_robin_ch1(sky_color, ground_color)
		17: _draw_robin_ch2(sky_color, ground_color)
		18: _draw_robin_ch3(sky_color, ground_color)
		19: _draw_alice_ch1(sky_color, ground_color)
		20: _draw_alice_ch2(sky_color, ground_color)
		21: _draw_alice_ch3(sky_color, ground_color)
		22: _draw_oz_ch1(sky_color, ground_color)
		23: _draw_oz_ch2(sky_color, ground_color)
		24: _draw_oz_ch3(sky_color, ground_color)
		25: _draw_peter_ch1(sky_color, ground_color)
		26: _draw_peter_ch2(sky_color, ground_color)
		27: _draw_peter_ch3(sky_color, ground_color)
		28: _draw_phantom_ch1(sky_color, ground_color)
		29: _draw_phantom_ch2(sky_color, ground_color)
		30: _draw_phantom_ch3(sky_color, ground_color)
		31: _draw_scrooge_ch1(sky_color, ground_color)
		32: _draw_scrooge_ch2(sky_color, ground_color)
		33: _draw_scrooge_ch3(sky_color, ground_color)
		34: _draw_shadow_author_ch1(sky_color, ground_color)
		35: _draw_shadow_author_ch2(sky_color, ground_color)
		36: _draw_shadow_author_ch3(sky_color, ground_color)

	# Apply screen shake
	if _screen_shake_timer > 0.0:
		draw_set_transform(_screen_shake_offset, 0.0, Vector2.ONE)

	# === Universal path overlay with direction arrows ===
	_draw_path_overlay()

	# === Draw placed Literary Instruments ===
	_draw_placed_instruments()

	# === Ghost tower preview (shared) ===
	if placing_tower:
		var valid = _is_valid_placement(ghost_position)
		var color = Color(0.2, 0.8, 0.2, 0.35) if valid else Color(0.9, 0.2, 0.2, 0.35)
		draw_circle(ghost_position, 24.0, color)
		if valid:
			var preview_range = tower_info[selected_tower]["range"]
			draw_arc(ghost_position, preview_range, 0, TAU, 64, Color(1, 1, 1, 0.12), 4.0)
			draw_arc(ghost_position, preview_range, 0, TAU, 64, Color(1, 1, 1, 0.3), 2.0)

	# === Pulsing gold indicators on affordable-to-upgrade towers ===
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.upgrade_tier < 4 and tower.has_method("get_next_upgrade_info"):
			var info = tower.get_next_upgrade_info()
			if not info.is_empty() and gold >= info["cost"]:
				var pulse = (sin(_time * 4.0) + 1.0) * 0.5
				var dot_pos = tower.global_position + Vector2(0, -48)
				draw_circle(dot_pos, 6.0 + pulse * 3.0, Color(1.0, 0.84, 0.0, 0.6 + pulse * 0.3))
				draw_circle(dot_pos, 12.0 + pulse * 4.0, Color(1.0, 0.84, 0.0, 0.15 + pulse * 0.1))

	# === SYNERGY GLOW RINGS ON TOWERS ===
	if active_synergies.size() > 0:
		for tower in get_tree().get_nodes_in_group("towers"):
			if tower.has_method("has_synergy_buff") and tower.has_synergy_buff():
				var pulse = (sin(_time * 3.0) + 1.0) * 0.5
				draw_arc(tower.global_position, 30.0 + pulse * 5.0, 0, TAU, 32, Color(1.0, 0.84, 0.0, 0.25 + pulse * 0.2), 2.5)
				draw_arc(tower.global_position, 36.0 + pulse * 5.0, 0, TAU, 32, Color(1.0, 0.84, 0.0, 0.15 + pulse * 0.1), 1.5)

	# === SELECTED TOWER HIGHLIGHT & RANGE ===
	if selected_tower_node and is_instance_valid(selected_tower_node) and not placing_tower:
		var sel_pos = selected_tower_node.global_position
		var sel_pulse = (sin(_time * 4.0) + 1.0) * 0.5
		# Bright selection ring
		draw_arc(sel_pos, 22.0, 0, TAU, 32, Color(1.0, 1.0, 1.0, 0.5 + sel_pulse * 0.3), 2.5)
		draw_arc(sel_pos, 26.0, 0, TAU, 32, Color(1.0, 0.9, 0.5, 0.15 + sel_pulse * 0.1), 1.5)
		# Range indicator
		if selected_tower_node.has_method("get_attack_range"):
			var sel_range = selected_tower_node.get_attack_range()
			draw_arc(sel_pos, sel_range, 0, TAU, 64, Color(1, 1, 1, 0.08 + sel_pulse * 0.06), 3.0)
			draw_arc(sel_pos, sel_range, 0, TAU, 64, Color(1, 1, 1, 0.2 + sel_pulse * 0.1), 1.5)

	# === TOWER AURA COSMETICS ===
	var equipped_aura = equipped_cosmetics.get("auras", "")
	if equipped_aura != "":
		var aura_col = Color(0.5, 0.5, 0.5, 0.2)
		for cat_items in trophy_store_items.get("auras", []):
			if cat_items["id"] == equipped_aura:
				if equipped_aura == "aura_prismatic":
					aura_col = Color.from_hsv(fmod(_time * 0.4, 1.0), 0.6, 0.9, 0.25)
				else:
					aura_col = cat_items["color"]
				break
		for tower in get_tree().get_nodes_in_group("towers"):
			var aura_pulse = (sin(_time * 2.0 + tower.global_position.x * 0.01) + 1.0) * 0.5
			draw_arc(tower.global_position, 26.0 + aura_pulse * 4.0, 0, TAU, 32, aura_col, 2.5)

	# === BOSS RESCUE ANIMATION ===
	_draw_boss_rescue()

	# === STORYBOOK SHIELD INDICATOR ===
	if storybook_shield_charges > 0:
		var font = game_font
		_udraw(font, Vector2(700, 35), "Shield: %d" % storybook_shield_charges, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.3, 0.7, 0.9))

	# === ENCHANTED TOWERS INDICATOR ===
	if power_enchanted_timer > 0.0:
		var font = game_font
		_udraw(font, Vector2(820, 35), "Enchanted: %.0fs" % power_enchanted_timer, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.65, 0.1))

	# === SYNERGY BANNER ===
	if synergy_banner_timer > 0.0:
		var font = game_font
		var s_alpha = clampf(synergy_banner_timer, 0.0, 1.0)
		draw_rect(Rect2(240, 55, 800, 30), Color(0.1, 0.06, 0.02, 0.8 * s_alpha))
		draw_rect(Rect2(240, 55, 800, 30), Color(0.85, 0.65, 0.1, 0.5 * s_alpha), false, 1.0)
		_udraw(font, Vector2(640, 76), synergy_banner_text, HORIZONTAL_ALIGNMENT_CENTER, 780, 13, Color(1.0, 0.9, 0.5, s_alpha))

	# === ACHIEVEMENT POPUP ===
	if achievement_popup_timer > 0.0:
		var font = game_font
		var a_alpha = clampf(achievement_popup_timer, 0.0, 1.0)
		var a_y = 90.0
		draw_rect(Rect2(340, a_y, 600, 40), Color(0.08, 0.12, 0.04, 0.85 * a_alpha))
		draw_rect(Rect2(340, a_y, 600, 40), Color(0.4, 0.8, 0.2, 0.5 * a_alpha), false, 1.0)
		_udraw(font, Vector2(640, a_y + 17), achievement_popup_text, HORIZONTAL_ALIGNMENT_CENTER, 580, 14, Color(0.85, 0.75, 0.4, a_alpha))
		_udraw(font, Vector2(640, a_y + 33), achievement_popup_reward, HORIZONTAL_ALIGNMENT_CENTER, -1, 11, Color(0.5, 0.8, 0.3, a_alpha))

	# === ODYSSEY PROGRESS INDICATOR ===
	if odyssey_active:
		var font = game_font
		_udraw(font, Vector2(580, 35), "ODYSSEY %d/3" % (odyssey_current_map + 1), HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.7, 0.5, 0.9))

	# === ODYSSEY TRANSITION OVERLAY ===
	if odyssey_transition_active:
		var font = game_font
		draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.7))
		_udraw(font, Vector2(640, 340), "ODYSSEY — Next Map in %.0fs..." % odyssey_transition_timer, HORIZONTAL_ALIGNMENT_CENTER, -1, 24, Color(0.85, 0.7, 0.2))
		if odyssey_current_map < odyssey_maps.size():
			var next_name = levels[odyssey_maps[odyssey_current_map]]["name"] if odyssey_maps[odyssey_current_map] < levels.size() else "?"
			_udraw(font, Vector2(640, 380), next_name, HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.7, 0.6, 0.4))

	# === POWER SELECTION OVERLAY ===
	if power_selection_open:
		_draw_power_selection()

	# === VICTORY FANFARE COSMETICS ===
	if chest_open:
		var fanfare = equipped_cosmetics.get("fanfares", "")
		if fanfare == "fanfare_confetti":
			for ci in range(40):
				var cx = fmod(ci * 97.0 + _time * (80.0 + ci * 3.0), 1280.0)
				var cy = fmod(ci * 53.0 + _time * (60.0 + ci * 2.0), 720.0)
				var cc = Color.from_hsv(fmod(float(ci) * 0.07, 1.0), 0.8, 0.95, 0.7)
				draw_rect(Rect2(cx, cy, 6, 4), cc)
		elif fanfare == "fanfare_fireworks":
			for fi in range(6):
				var fx = 200.0 + fi * 170.0
				var fy = 120.0 + sin(_time * 1.5 + fi) * 60.0
				var burst_t = fmod(_time * 0.8 + fi * 0.5, 2.0)
				if burst_t < 1.2:
					var fc = Color.from_hsv(fmod(float(fi) * 0.15, 1.0), 0.7, 1.0, clampf(1.2 - burst_t, 0.0, 1.0))
					for ri in range(12):
						var ra = TAU * float(ri) / 12.0
						var rd = burst_t * 60.0
						draw_circle(Vector2(fx + cos(ra) * rd, fy + sin(ra) * rd), 3.0, fc)
		elif fanfare == "fanfare_ovation":
			var font = game_font
			var clap_alpha = 0.5 + sin(_time * 6.0) * 0.3
			_udraw(font, Vector2(640, 250), "BRAVO!", HORIZONTAL_ALIGNMENT_CENTER, -1, 32, Color(1.0, 0.85, 0.3, clap_alpha))
			for oi in range(8):
				var ox = 100.0 + oi * 140.0
				var oy = 680.0 + sin(_time * 4.0 + oi * 0.8) * 8.0
				draw_circle(Vector2(ox, oy), 10.0, Color(0.8, 0.6, 0.4, 0.5))
				draw_circle(Vector2(ox, oy - 15), 7.0, Color(0.9, 0.7, 0.5, 0.5))

	# Reset transform (screen shake should not affect UI overlays)
	if _screen_shake_timer > 0.0:
		draw_set_transform(Vector2.ZERO, 0.0, Vector2.ONE)

	# === FLOATING DAMAGE TEXTS ===
	if _floating_texts.size() > 0:
		var ft_font = game_font
		for ft in _floating_texts:
			var ft_alpha = clampf(ft["timer"] / ft["duration"], 0.0, 1.0)
			var ft_col = ft["color"]
			ft_col.a *= ft_alpha
			# Drop shadow for readability
			var shadow_col = Color(0.0, 0.0, 0.0, ft_alpha * 0.7)
			draw_string(ft_font, ft["pos"] + Vector2(1, 2), ft["text"].to_upper(), HORIZONTAL_ALIGNMENT_CENTER, -1, int(ft["size"]), shadow_col)
			draw_string(ft_font, ft["pos"], ft["text"].to_upper(), HORIZONTAL_ALIGNMENT_CENTER, -1, int(ft["size"]), ft_col)

	# === INK SPLATTERS ===
	for sp in _ink_splatters:
		var sp_alpha = clampf(sp["timer"] / 1.2, 0.0, 1.0)
		var sp_col = sp["color"]
		sp_col.a *= sp_alpha
		draw_circle(sp["pos"], sp["radius"], sp_col)

	# === LIFE LOSS FLASH (red screen flash) ===
	if _death_flash_timer > 0.0:
		var flash_a = clampf(_death_flash_timer / 0.15, 0.0, 1.0) * 0.5
		draw_rect(Rect2(0, 0, 1280, 720), Color(0.9, 0.1, 0.05, flash_a))
		# Red border vignette — thicker, more dramatic
		for bi in range(3):
			var b_alpha = flash_a * (0.8 - float(bi) * 0.2)
			var b_thick = 4.0 + float(bi) * 6.0
			draw_rect(Rect2(0, 0, 1280, b_thick), Color(1.0, 0.0, 0.0, b_alpha))
			draw_rect(Rect2(0, 720 - b_thick, 1280, b_thick), Color(1.0, 0.0, 0.0, b_alpha))
			draw_rect(Rect2(0, 0, b_thick, 720), Color(1.0, 0.0, 0.0, b_alpha))
			draw_rect(Rect2(1280 - b_thick, 0, b_thick, 720), Color(1.0, 0.0, 0.0, b_alpha))

	# === WAVE CLEAR POPUP (with glow) ===
	if _wave_clear_timer > 0.0 and not victory_chest_active:
		var wc_alpha = clampf(_wave_clear_timer / 1.5, 0.0, 1.0)
		var wc_slide = (1.0 - wc_alpha) * 30.0
		var font = game_font
		var wc_text = "WAVE %d CLEAR!" % _wave_clear_num
		var wc_y = 280 - wc_slide
		# Expanding burst particles
		var burst_progress = 1.0 - wc_alpha
		for pi in range(8):
			var p_angle = float(pi) * TAU / 8.0
			var p_dist = burst_progress * 160.0
			var p_pos = Vector2(640 + cos(p_angle) * p_dist, wc_y - 6 + sin(p_angle) * p_dist * 0.5)
			draw_circle(p_pos, (4.0 - burst_progress * 3.0) * wc_alpha, Color(0.4, 1.0, 0.5, wc_alpha * 0.5))
		# Glow backdrop — larger and brighter
		draw_circle(Vector2(640, wc_y - 6), 160.0, Color(0.2, 0.9, 0.3, wc_alpha * 0.12))
		draw_circle(Vector2(640, wc_y - 6), 80.0, Color(0.3, 1.0, 0.4, wc_alpha * 0.18))
		# Shadow text
		_udraw(font, Vector2(642, wc_y + 2), wc_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 40, Color(0, 0, 0, wc_alpha * 0.6))
		# Main text — bigger, bright green
		_udraw(font, Vector2(640, wc_y), wc_text, HORIZONTAL_ALIGNMENT_CENTER, -1, 40, Color(0.3, 1.0, 0.4, wc_alpha))

	# === BOSS WAVE ALERT (with glow) ===
	if _boss_alert_timer > 0.0:
		var ba_alpha = clampf(_boss_alert_timer / 2.5, 0.0, 1.0)
		var ba_scale = 1.0 + (1.0 - ba_alpha) * 0.3
		# Dark vignette
		draw_rect(Rect2(0, 240, 1280, 120), Color(0.0, 0.0, 0.0, ba_alpha * 0.7))
		# Red glow behind text
		draw_circle(Vector2(640, 305), 180.0, Color(0.9, 0.1, 0.05, ba_alpha * 0.08))
		draw_circle(Vector2(640, 305), 90.0, Color(1.0, 0.15, 0.05, ba_alpha * 0.12))
		# Red border flash — thicker
		draw_rect(Rect2(0, 240, 1280, 4), Color(0.9, 0.15, 0.1, ba_alpha * 0.9))
		draw_rect(Rect2(0, 356, 1280, 4), Color(0.9, 0.15, 0.1, ba_alpha * 0.9))
		# Alert text with shadow
		var font = game_font
		var alert_size = int(44.0 * ba_scale)
		_udraw(font, Vector2(642, 312), _boss_alert_text, HORIZONTAL_ALIGNMENT_CENTER, -1, alert_size, Color(0, 0, 0, ba_alpha * 0.5))
		_udraw(font, Vector2(640, 310), _boss_alert_text, HORIZONTAL_ALIGNMENT_CENTER, -1, alert_size, Color(1.0, 0.2, 0.1, ba_alpha))
		# Subtitle — larger for mobile
		_udraw(font, Vector2(640, 344), "Prepare your defenses!", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(1.0, 0.7, 0.5, ba_alpha * 0.8))

	# === PAUSED OVERLAY ===
	if game_paused:
		draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.45))
		var font = game_font
		_udraw(font, Vector2(640, 340), "PAUSED", HORIZONTAL_ALIGNMENT_CENTER, -1, 48, Color(1.0, 1.0, 1.0, 0.85))
		_udraw(font, Vector2(640, 380), "Click Resume or press Start Wave to continue", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.8, 0.8, 0.8, 0.6))

	# === ABILITY UNLOCK POPUP ===
	if _ability_popup_timer > 0.0:
		_draw_ability_popup()

	# === INSTRUMENT PLACEMENT HUD ===
	_draw_instrument_hud()

	# === BRANCH UPGRADE DISPLAY (on selected tower with tier 4) ===
	if selected_tower_node and is_instance_valid(selected_tower_node) and upgrade_panel.visible:
		_draw_branch_upgrade_panel()

	# === VICTORY CHEST OVERLAY (draws over everything in GAME_OVER too) ===
	if chest_opening_active and victory_chest_active:
		_draw_chest_opening()
	# Story dialog in GAME_OVER state
	if story_state.active:
		_draw_story_dialog()

func _draw_ability_popup() -> void:
	var alpha = clampf(_ability_popup_timer, 0.0, 1.0)
	var cx = 640.0
	var cy = 360.0
	var pw = 500.0
	var ph = 120.0
	# Dark translucent background
	draw_rect(Rect2(cx - pw / 2, cy - ph / 2, pw, ph), Color(0.05, 0.03, 0.08, 0.85 * alpha))
	# Gold ornate border
	draw_rect(Rect2(cx - pw / 2, cy - ph / 2, pw, ph), Color(0.85, 0.7, 0.2, 0.9 * alpha), false, 3.0)
	draw_rect(Rect2(cx - pw / 2 + 4, cy - ph / 2 + 4, pw - 8, ph - 8), Color(0.7, 0.55, 0.15, 0.4 * alpha), false, 1.0)
	# Title
	_udraw(game_font, Vector2(cx - 120, cy - 25), "NEW ABILITY UNLOCKED!", HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color(1.0, 0.85, 0.3, alpha))
	# Character name + ability name
	var char_name = character_names[_ability_popup_tower_type] if _ability_popup_tower_type >= 0 and _ability_popup_tower_type < character_names.size() else ""
	_udraw(game_font, Vector2(cx - 140, cy + 5), char_name + " — " + _ability_popup_name, HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(1.0, 1.0, 0.9, alpha))
	# Description
	if _ability_popup_desc != "":
		_udraw(game_font, Vector2(cx - 140, cy + 28), _ability_popup_desc, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.8, 0.8, 0.75, alpha * 0.8))
	# Glow effect
	var glow_pulse = (sin(_time * 5.0) + 1.0) * 0.5
	draw_circle(Vector2(cx - pw / 2 + 40, cy), 15.0 + glow_pulse * 5.0, Color(1.0, 0.85, 0.3, 0.1 * alpha))

# =============================================================================
# UNIVERSAL PATH DRAWING — themed road + BTD6-style entry/exit arrows
# =============================================================================

func _draw_path_overlay() -> void:
	if not enemy_path:
		return
	var curve = enemy_path.curve
	if not curve or curve.point_count < 2:
		return
	var pts = curve.tessellate(6, 2.0)
	if pts.size() < 2:
		return

	# Determine path theme from current_level
	var path_style = _get_path_style()
	var road_w = path_style["width"]
	var road_col = path_style["road_color"]
	var edge_col = path_style["edge_color"]
	var detail_col = path_style["detail_color"]
	var border_w = path_style["border_width"]

	# --- PASS 1: Outer border/shadow (widest) ---
	for k in range(pts.size() - 1):
		draw_line(pts[k], pts[k + 1], Color(0.0, 0.0, 0.0, 0.6), road_w + 10.0)

	# --- PASS 2: Edge trim (cobblestone border, grass, etc.) ---
	for k in range(pts.size() - 1):
		draw_line(pts[k], pts[k + 1], edge_col, road_w + 4.0)

	# --- PASS 3: Main road surface ---
	for k in range(pts.size() - 1):
		draw_line(pts[k], pts[k + 1], road_col, road_w)

	# --- PASS 4: Center line / detail texture ---
	if path_style.get("center_line", false):
		for k in range(pts.size() - 1):
			draw_line(pts[k], pts[k + 1], detail_col, 2.0)

	# --- PASS 5: Surface detail (cracks, bricks, cobbles, etc.) ---
	_draw_path_surface_detail(pts, path_style)

	# --- PASS 6: Edge detail lines ---
	for k in range(pts.size() - 1):
		var dir = (pts[k + 1] - pts[k]).normalized()
		var n = Vector2(-dir.y, dir.x)
		var half_w = road_w * 0.5
		draw_line(pts[k] + n * half_w, pts[k + 1] + n * half_w, Color(edge_col.r * 0.5, edge_col.g * 0.5, edge_col.b * 0.5, 0.5), border_w)
		draw_line(pts[k] - n * half_w, pts[k + 1] - n * half_w, Color(edge_col.r * 0.5, edge_col.g * 0.5, edge_col.b * 0.5, 0.5), border_w)

	# --- PASS 7: Directional arrows along path (BTD6-style) ---
	_draw_path_arrows(pts, path_style)

	# --- PASS 8: Entry and Exit markers ---
	_draw_entry_exit_markers(pts)

func _get_path_style() -> Dictionary:
	# Default road: sandy-brown dirt road
	var style = {
		"width": 36.0,
		"road_color": Color(0.25, 0.20, 0.14, 0.92),
		"edge_color": Color(0.18, 0.14, 0.08, 0.85),
		"detail_color": Color(0.30, 0.25, 0.18, 0.4),
		"border_width": 1.5,
		"center_line": false,
		"detail_type": "dirt",  # dirt, cobble, brick, tile, plank, ice, lab, jungle, ink
	}
	match current_level:
		0:  # Prologue — glowing ink
			style["road_color"] = Color(0.12, 0.06, 0.20, 0.92)
			style["edge_color"] = Color(0.20, 0.10, 0.35, 0.85)
			style["detail_color"] = Color(0.40, 0.20, 0.65, 0.35)
			style["detail_type"] = "ink"
		1, 2, 3:  # Sherlock — grimy London cobblestone
			style["road_color"] = Color(0.22, 0.18, 0.15, 0.95)
			style["edge_color"] = Color(0.14, 0.10, 0.08, 0.90)
			style["detail_color"] = Color(0.30, 0.24, 0.18, 0.45)
			style["detail_type"] = "cobble"
			style["width"] = 38.0
		4, 5, 6:  # Merlin — ancient stone flagstones
			style["road_color"] = Color(0.20, 0.22, 0.18, 0.92)
			style["edge_color"] = Color(0.12, 0.15, 0.08, 0.85)
			style["detail_color"] = Color(0.25, 0.30, 0.20, 0.4)
			style["detail_type"] = "stone"
			style["width"] = 36.0
		7, 8, 9:  # Tarzan — jungle dirt trail
			style["road_color"] = Color(0.22, 0.16, 0.08, 0.90)
			style["edge_color"] = Color(0.10, 0.14, 0.04, 0.80)
			style["detail_color"] = Color(0.28, 0.20, 0.10, 0.35)
			style["detail_type"] = "jungle"
			style["width"] = 34.0
		10, 11, 12:  # Dracula — dark stone
			style["road_color"] = Color(0.18, 0.12, 0.14, 0.95)
			style["edge_color"] = Color(0.10, 0.06, 0.08, 0.90)
			style["detail_color"] = Color(0.25, 0.15, 0.18, 0.4)
			style["detail_type"] = "cobble"
			style["width"] = 36.0
		13, 14, 15:  # Frankenstein — lab metal grating
			style["road_color"] = Color(0.20, 0.20, 0.22, 0.95)
			style["edge_color"] = Color(0.12, 0.12, 0.14, 0.90)
			style["detail_color"] = Color(0.28, 0.28, 0.32, 0.4)
			style["detail_type"] = "lab"
			style["width"] = 38.0
		16, 17, 18:  # Robin Hood — forest dirt path
			style["road_color"] = Color(0.24, 0.18, 0.10, 0.90)
			style["edge_color"] = Color(0.12, 0.16, 0.06, 0.80)
			style["detail_color"] = Color(0.30, 0.22, 0.12, 0.35)
			style["detail_type"] = "dirt"
			style["width"] = 34.0
		19, 20, 21:  # Alice — whimsical checkerboard
			style["road_color"] = Color(0.30, 0.22, 0.35, 0.92)
			style["edge_color"] = Color(0.22, 0.15, 0.28, 0.85)
			style["detail_color"] = Color(0.40, 0.30, 0.50, 0.4)
			style["detail_type"] = "tile"
			style["width"] = 36.0
		22, 23, 24:  # Oz — yellow brick road
			style["road_color"] = Color(0.50, 0.42, 0.12, 0.95)
			style["edge_color"] = Color(0.35, 0.28, 0.06, 0.90)
			style["detail_color"] = Color(0.60, 0.50, 0.15, 0.5)
			style["detail_type"] = "brick"
			style["width"] = 38.0
		25, 26, 27:  # Peter Pan — sandy/wooden
			style["road_color"] = Color(0.30, 0.24, 0.14, 0.90)
			style["edge_color"] = Color(0.20, 0.16, 0.08, 0.85)
			style["detail_color"] = Color(0.36, 0.28, 0.16, 0.4)
			style["detail_type"] = "plank"
			style["width"] = 36.0
		28, 29, 30:  # Phantom — dark opera stone
			style["road_color"] = Color(0.16, 0.14, 0.18, 0.95)
			style["edge_color"] = Color(0.10, 0.08, 0.12, 0.90)
			style["detail_color"] = Color(0.22, 0.18, 0.26, 0.4)
			style["detail_type"] = "stone"
			style["width"] = 36.0
		31, 32, 33:  # Scrooge — snowy cobblestone
			style["road_color"] = Color(0.28, 0.28, 0.30, 0.92)
			style["edge_color"] = Color(0.20, 0.20, 0.24, 0.85)
			style["detail_color"] = Color(0.40, 0.40, 0.45, 0.4)
			style["detail_type"] = "ice"
			style["width"] = 36.0
		34, 35, 36:  # Shadow Author — dark void
			style["road_color"] = Color(0.10, 0.06, 0.16, 0.95)
			style["edge_color"] = Color(0.06, 0.03, 0.10, 0.90)
			style["detail_color"] = Color(0.18, 0.10, 0.28, 0.4)
			style["detail_type"] = "ink"
			style["width"] = 38.0
	return style

func _draw_path_surface_detail(pts: PackedVector2Array, style: Dictionary) -> void:
	var detail_type = style.get("detail_type", "dirt")
	var road_w = style["width"]
	var half_w = road_w * 0.5

	match detail_type:
		"cobble":
			# Cobblestone grid pattern
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 12.0:
					step -= 12.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Cross lines (mortar)
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.08, 0.06, 0.04, 0.3), 1.0)
					# Offset bricks
					if int(step * 10) % 2 == 0:
						var mid = p + n * (half_w * 0.3)
						draw_line(mid + dir * 4, mid - dir * 4, Color(0.08, 0.06, 0.04, 0.25), 1.0)
		"brick":
			# Brick pattern (yellow brick road style)
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 14.0:
					step -= 14.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Mortar lines
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.35, 0.28, 0.06, 0.35), 1.0)
					# Vertical mortar (offset alternating)
					var row_offset = half_w * 0.5 if int(step * 5) % 2 == 0 else 0.0
					draw_line(p + n * row_offset + dir * 1, p + n * row_offset - dir * 1, Color(0.35, 0.28, 0.06, 0.25), 1.0)
		"stone":
			# Irregular stone flagstones
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 18.0:
					step -= 18.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Irregular cracks
					var crack_off = sin(float(k) * 1.7) * half_w * 0.4
					draw_line(p + n * (half_w - 2), p + n * crack_off, Color(0.06, 0.06, 0.04, 0.25), 1.0)
					draw_line(p - n * (half_w - 2), p - n * crack_off, Color(0.06, 0.06, 0.04, 0.25), 1.0)
					# Cross joint
					draw_line(p + n * (half_w - 3), p - n * (half_w - 3), Color(0.06, 0.06, 0.04, 0.2), 1.0)
		"dirt":
			# Dirt path — ruts and pebbles
			for k in range(0, pts.size() - 1, 6):
				var p = pts[k]
				var dir = (pts[k + 1] - pts[k]).normalized()
				var n = Vector2(-dir.y, dir.x)
				# Wheel ruts
				draw_line(p + n * 6, p + dir * 8 + n * 6, Color(0.18, 0.14, 0.08, 0.3), 2.0)
				draw_line(p - n * 6, p + dir * 8 - n * 6, Color(0.18, 0.14, 0.08, 0.3), 2.0)
			# Scattered pebbles
			for k in range(0, pts.size() - 1, 10):
				var p = pts[k]
				var off = Vector2(sin(float(k) * 2.3) * half_w * 0.6, cos(float(k) * 1.8) * 4.0)
				draw_circle(p + off, 2.0, Color(0.30, 0.24, 0.16, 0.3))
		"jungle":
			# Jungle trail — roots and mud
			for k in range(0, pts.size() - 1, 8):
				var p = pts[k]
				var dir = (pts[k + 1] - pts[k]).normalized()
				var n = Vector2(-dir.y, dir.x)
				# Root lines crossing path
				var root_w = half_w * (0.4 + sin(float(k) * 1.3) * 0.3)
				draw_line(p + n * root_w, p - n * root_w, Color(0.14, 0.10, 0.04, 0.25), 2.0)
			# Mud patches
			for k in range(0, pts.size() - 1, 14):
				var p = pts[k]
				var off = Vector2(sin(float(k) * 3.1) * 8.0, cos(float(k) * 2.7) * 5.0)
				draw_circle(p + off, 4.0 + sin(float(k)) * 2.0, Color(0.16, 0.12, 0.06, 0.2))
		"tile":
			# Alice tile pattern — alternating light/dark squares
			var step = 0.0
			var tile_idx = 0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 16.0:
					step -= 16.0
					tile_idx += 1
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Grid lines
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.20, 0.14, 0.25, 0.3), 1.0)
					# Alternating shade
					if tile_idx % 2 == 0:
						draw_line(p, p + dir * 8, Color(0.35, 0.25, 0.42, 0.15), road_w * 0.8)
		"plank":
			# Wooden planks
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 20.0:
					step -= 20.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Plank gap
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.12, 0.08, 0.04, 0.4), 1.5)
					# Wood grain
					draw_line(p + n * 4, p + dir * 12 + n * 4, Color(0.24, 0.18, 0.10, 0.15), 1.0)
					draw_line(p - n * 6, p + dir * 10 - n * 6, Color(0.24, 0.18, 0.10, 0.15), 1.0)
		"ice":
			# Icy cobblestone — frost lines
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 14.0:
					step -= 14.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.35, 0.38, 0.45, 0.25), 1.0)
			# Frost sparkles
			for k in range(0, pts.size() - 1, 8):
				var p = pts[k]
				var off = Vector2(sin(float(k) * 2.7) * half_w * 0.5, cos(float(k) * 1.9) * 3.0)
				var sparkle = (sin(_time * 4.0 + float(k) * 0.7) + 1.0) * 0.5
				draw_circle(p + off, 1.5, Color(0.7, 0.8, 1.0, sparkle * 0.3))
		"lab":
			# Metal grating — cross-hatch
			var step = 0.0
			for k in range(pts.size() - 1):
				var seg_len = pts[k].distance_to(pts[k + 1])
				step += seg_len
				if step >= 12.0:
					step -= 12.0
					var p = pts[k]
					var dir = (pts[k + 1] - pts[k]).normalized()
					var n = Vector2(-dir.y, dir.x)
					# Grid
					draw_line(p + n * (half_w - 2), p - n * (half_w - 2), Color(0.15, 0.15, 0.18, 0.3), 1.0)
					# Bolts at intersections
					if int(step * 3) % 2 == 0:
						draw_circle(p + n * (half_w * 0.5), 1.5, Color(0.30, 0.30, 0.35, 0.4))
						draw_circle(p - n * (half_w * 0.5), 1.5, Color(0.30, 0.30, 0.35, 0.4))
		"ink":
			# Ink/shadow — swirling particles
			for k in range(0, pts.size() - 1, 5):
				var p = pts[k]
				var off_x = sin(float(k) * 1.7 + _time * 0.5) * half_w * 0.5
				var off_y = cos(float(k) * 2.1 + _time * 0.3) * 4.0
				var glow = (sin(_time * 2.0 + float(k) * 0.4) + 1.0) * 0.5
				draw_circle(p + Vector2(off_x, off_y), 2.0 + glow, Color(0.40, 0.20, 0.65, 0.15 + glow * 0.15))
			# Center glow line
			for k in range(pts.size() - 1):
				var glow = (sin(_time * 1.5 + float(k) * 0.1) + 1.0) * 0.5
				draw_line(pts[k], pts[k + 1], Color(0.30, 0.15, 0.50, 0.08 + glow * 0.06), 4.0)

func _draw_path_arrows(pts: PackedVector2Array, style: Dictionary) -> void:
	# Draw chevron arrows along the path every ~120px showing direction of travel
	if pts.size() < 2:
		return
	var arrow_spacing = 120.0
	var half_w = style["width"] * 0.35
	var accumulated = 0.0
	var arrow_col = Color(1.0, 1.0, 1.0, 0.18)
	for k in range(pts.size() - 1):
		var seg_len = pts[k].distance_to(pts[k + 1])
		accumulated += seg_len
		if accumulated >= arrow_spacing:
			accumulated -= arrow_spacing
			var p = pts[k]
			var dir = (pts[k + 1] - pts[k]).normalized()
			var n = Vector2(-dir.y, dir.x)
			# Draw chevron (> shape pointing in travel direction)
			var tip = p + dir * 6.0
			var left = p - dir * 4.0 + n * half_w
			var right = p - dir * 4.0 - n * half_w
			draw_line(left, tip, arrow_col, 2.0)
			draw_line(right, tip, arrow_col, 2.0)

func _draw_entry_exit_markers(pts: PackedVector2Array) -> void:
	if pts.size() < 2:
		return
	# === ENTRY marker (green, pulsing) ===
	var entry = pts[0]
	var entry_dir = (pts[1] - pts[0]).normalized()
	var entry_pulse = 0.6 + sin(_time * 3.0) * 0.2
	# Green glow
	draw_circle(entry, 22.0, Color(0.1, 0.7, 0.2, entry_pulse * 0.2))
	draw_circle(entry, 14.0, Color(0.1, 0.8, 0.2, entry_pulse * 0.35))
	# Arrow pointing inward
	var e_tip = entry + entry_dir * 18.0
	var e_n = Vector2(-entry_dir.y, entry_dir.x)
	var e_base_l = entry - entry_dir * 4.0 + e_n * 10.0
	var e_base_r = entry - entry_dir * 4.0 - e_n * 10.0
	draw_colored_polygon(PackedVector2Array([e_tip, e_base_l, e_base_r]), Color(0.2, 0.9, 0.3, entry_pulse * 0.7))
	# "ENTER" label
	var font = game_font
	var lbl_pos = entry - entry_dir * 12.0 + e_n * 20.0
	# Position label based on entry direction to stay on-screen
	if entry.x < 50:
		lbl_pos = entry + Vector2(24, -8)
	elif entry.y < 80:
		lbl_pos = entry + Vector2(-16, 24)
	elif entry.x > 1230:
		lbl_pos = entry + Vector2(-50, -8)
	else:
		lbl_pos = entry + Vector2(-16, -22)
	_udraw(font, lbl_pos + Vector2(1, 1), "ENTER", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.0, 0.0, 0.0, entry_pulse * 0.5))
	_udraw(font, lbl_pos, "ENTER", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.3, 1.0, 0.4, entry_pulse * 0.7))

	# === EXIT marker (red, pulsing) ===
	var exit_pt = pts[pts.size() - 1]
	var exit_dir = (pts[pts.size() - 1] - pts[pts.size() - 2]).normalized()
	var exit_pulse = 0.6 + sin(_time * 3.0 + 1.5) * 0.2
	# Red glow
	draw_circle(exit_pt, 22.0, Color(0.7, 0.1, 0.1, exit_pulse * 0.2))
	draw_circle(exit_pt, 14.0, Color(0.8, 0.15, 0.1, exit_pulse * 0.35))
	# Arrow pointing outward
	var x_tip = exit_pt + exit_dir * 18.0
	var x_n = Vector2(-exit_dir.y, exit_dir.x)
	var x_base_l = exit_pt - exit_dir * 4.0 + x_n * 10.0
	var x_base_r = exit_pt - exit_dir * 4.0 - x_n * 10.0
	draw_colored_polygon(PackedVector2Array([x_tip, x_base_l, x_base_r]), Color(0.9, 0.2, 0.15, exit_pulse * 0.7))
	# "EXIT" label
	var xlbl_pos = exit_pt + exit_dir * 12.0 + x_n * 20.0
	if exit_pt.x > 1230:
		xlbl_pos = exit_pt + Vector2(-44, -8)
	elif exit_pt.y > 640:
		xlbl_pos = exit_pt + Vector2(-14, -22)
	elif exit_pt.x < 50:
		xlbl_pos = exit_pt + Vector2(24, -8)
	else:
		xlbl_pos = exit_pt + Vector2(-14, 22)
	_udraw(font, xlbl_pos + Vector2(1, 1), "EXIT", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.0, 0.0, 0.0, exit_pulse * 0.5))
	_udraw(font, xlbl_pos, "EXIT", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(1.0, 0.35, 0.3, exit_pulse * 0.7))

# =============================================================================
# NEW BACKGROUND FUNCTIONS FOR LEVELS 0-15 AND 34-36
# =============================================================================

func _draw_prologue(sky_color: Color, ground_color: Color) -> void:
	# Deep purple sky with swirling ink
	var sky_top := Color(0.02, 0.01, 0.06)
	var sky_bottom := Color(0.06, 0.03, 0.12)
	for i in range(30):
		var t := float(i) / 29.0
		var col := sky_top.lerp(sky_bottom, t)
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), col)
	# Dark ink ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.03, 0.02, 0.05))
	draw_rect(Rect2(0, 510, 1280, 15), Color(0.04, 0.03, 0.07))
	# Ink spirals
	for sp in range(6):
		var cx := 100.0 + float(sp) * 200.0
		var cy := 300.0 + sin(float(sp) * 1.7) * 80.0
		for r in range(12):
			var angle := float(r) * 0.55 + _time * 0.3 + float(sp) * 1.2
			var radius := 8.0 + float(r) * 4.5
			var px := cx + cos(angle) * radius
			var py := cy + sin(angle) * radius
			var alpha := 0.4 - float(r) * 0.03
			draw_circle(Vector2(px, py), 3.0 - float(r) * 0.15, Color(0.3, 0.1, 0.5, clampf(alpha, 0.05, 0.4)))
	# Torn page shapes
	for pg in range(5):
		var pgx := 80.0 + float(pg) * 260.0
		var pgy := 400.0 + sin(float(pg) * 2.1) * 40.0
		var page_col := Color(0.12, 0.10, 0.08, 0.15 + 0.05 * sin(_time * 0.8 + float(pg)))
		var pts := PackedVector2Array()
		pts.append(Vector2(pgx, pgy))
		pts.append(Vector2(pgx + 40, pgy - 20))
		pts.append(Vector2(pgx + 60, pgy - 15 + sin(float(pg) * 3.0) * 10.0))
		pts.append(Vector2(pgx + 80, pgy - 25))
		pts.append(Vector2(pgx + 70, pgy + 30))
		pts.append(Vector2(pgx + 20, pgy + 25))
		draw_colored_polygon(pts, page_col)
	# Glowing book edges
	for bk in range(4):
		var bx := 200.0 + float(bk) * 250.0
		var by := 460.0 + float(bk) * 15.0
		var glow := 0.3 + 0.2 * sin(_time * 1.5 + float(bk) * 0.9)
		draw_rect(Rect2(bx, by, 60, 8), Color(0.5, 0.3, 0.8, glow))
		draw_rect(Rect2(bx - 2, by + 8, 64, 35), Color(0.06, 0.04, 0.08))
		draw_rect(Rect2(bx, by + 10, 60, 3), Color(0.4, 0.25, 0.6, glow * 0.5))
		draw_rect(Rect2(bx, by + 16, 60, 3), Color(0.4, 0.25, 0.6, glow * 0.3))
	# Floating ink drops
	for dr in range(10):
		var dx := fmod(float(dr) * 137.5, 1280.0)
		var dy := 150.0 + fmod(float(dr) * 89.3, 350.0) + sin(_time * 0.7 + float(dr)) * 20.0
		var ds := 2.0 + sin(float(dr) * 2.3) * 1.5
		draw_circle(Vector2(dx, dy), ds, Color(0.15, 0.05, 0.25, 0.5))

func _draw_sherlock_ch1(sky_color: Color, ground_color: Color) -> void:
	# Foggy gray London sky
	var sky_top := Color(0.04, 0.04, 0.06)
	var sky_bottom := Color(0.10, 0.10, 0.12)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Cobblestone ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.12, 0.10, 0.08))
	for cx in range(40):
		for cy in range(3):
			var off := 16.0 if cy % 2 == 1 else 0.0
			var bx := float(cx) * 32.0 + off
			var by := 525.0 + float(cy) * 30.0
			draw_rect(Rect2(bx, by, 30, 28), Color(0.10, 0.08, 0.06))
			draw_rect(Rect2(bx, by, 30, 28), Color(0.06, 0.05, 0.04), false, 1.0)
	# Rooftop silhouettes
	var roof_col := Color(0.03, 0.03, 0.05)
	for rt in range(8):
		var rx := float(rt) * 165.0
		var rh := 180.0 + sin(float(rt) * 2.7) * 60.0
		draw_rect(Rect2(rx, 520.0 - rh, 80, rh), roof_col)
		draw_colored_polygon(PackedVector2Array([Vector2(rx - 5, 520.0 - rh), Vector2(rx + 40, 520.0 - rh - 30 - sin(float(rt)) * 15.0), Vector2(rx + 85, 520.0 - rh)]), roof_col)
		# Chimney
		draw_rect(Rect2(rx + 15 + float(rt) * 3.0, 520.0 - rh - 25, 12, 25), roof_col)
	# Gas lamps
	for gl in range(5):
		var gx := 120.0 + float(gl) * 250.0
		draw_rect(Rect2(gx, 440, 4, 80), Color(0.08, 0.07, 0.05))
		draw_rect(Rect2(gx - 6, 435, 16, 10), Color(0.10, 0.08, 0.06))
		var flicker := 0.5 + 0.4 * sin(_time * 5.0 + float(gl) * 2.1)
		draw_circle(Vector2(gx + 2, 433), 6.0, Color(0.9, 0.7, 0.2, flicker))
		draw_circle(Vector2(gx + 2, 433), 14.0, Color(0.9, 0.6, 0.1, flicker * 0.2))
	# Fog layers
	for fl in range(4):
		var fy := 350.0 + float(fl) * 50.0
		var fog_shift := sin(_time * 0.2 + float(fl) * 1.5) * 40.0
		draw_rect(Rect2(-20 + fog_shift, fy, 1320, 20), Color(0.15, 0.15, 0.17, 0.08 + float(fl) * 0.02))
	# Brick wall section
	for bw in range(6):
		var wx := 50.0 + float(bw) * 40.0
		var wy := 430.0 + sin(float(bw) * 1.5) * 5.0
		draw_rect(Rect2(wx, wy, 35, 15), Color(0.14, 0.06, 0.04, 0.6))

func _draw_sherlock_ch2(sky_color: Color, ground_color: Color) -> void:
	# Darker fog - deeper into London
	var sky_top := Color(0.03, 0.03, 0.05)
	var sky_bottom := Color(0.08, 0.08, 0.10)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.10, 0.08, 0.07))
	for cx in range(40):
		for cy in range(3):
			var off := 16.0 if cy % 2 == 1 else 0.0
			draw_rect(Rect2(float(cx) * 32.0 + off, 525.0 + float(cy) * 30.0, 30, 28), Color(0.08, 0.07, 0.05))
			draw_rect(Rect2(float(cx) * 32.0 + off, 525.0 + float(cy) * 30.0, 30, 28), Color(0.05, 0.04, 0.03), false, 1.0)
	# Rooftops with more detail
	var roof_col := Color(0.02, 0.02, 0.04)
	for rt in range(10):
		var rx := float(rt) * 135.0 - 20.0
		var rh := 150.0 + sin(float(rt) * 3.1) * 70.0
		draw_rect(Rect2(rx, 520.0 - rh, 70, rh), roof_col)
		draw_colored_polygon(PackedVector2Array([Vector2(rx - 5, 520.0 - rh), Vector2(rx + 35, 520.0 - rh - 35), Vector2(rx + 75, 520.0 - rh)]), roof_col)
		# Windows with yellow glow
		if rt % 2 == 0:
			var wy := 520.0 - rh + 30.0
			for w in range(2):
				var wx := rx + 15.0 + float(w) * 30.0
				var wglow := 0.3 + 0.2 * sin(_time * 2.0 + float(rt) + float(w))
				draw_rect(Rect2(wx, wy, 12, 15), Color(0.7, 0.55, 0.15, wglow))
	# Gas lamps
	for gl in range(4):
		var gx := 180.0 + float(gl) * 280.0
		draw_rect(Rect2(gx, 440, 4, 80), Color(0.08, 0.07, 0.05))
		var flicker := 0.5 + 0.4 * sin(_time * 6.0 + float(gl) * 1.8)
		draw_circle(Vector2(gx + 2, 435), 7.0, Color(0.9, 0.65, 0.15, flicker))
		draw_circle(Vector2(gx + 2, 435), 18.0, Color(0.8, 0.5, 0.1, flicker * 0.15))
	# Heavy fog
	for fl in range(6):
		var fy := 280.0 + float(fl) * 45.0
		var fog_shift := sin(_time * 0.15 + float(fl) * 1.1) * 60.0
		draw_rect(Rect2(-40 + fog_shift, fy, 1360, 25), Color(0.14, 0.14, 0.16, 0.06 + float(fl) * 0.015))
	# Magnifying glass detail (Sherlock theme)
	var mg_x := 1100.0
	var mg_y := 200.0
	draw_arc(Vector2(mg_x, mg_y), 20.0, 0, TAU, 32, Color(0.6, 0.5, 0.2, 0.3), 2.0)
	draw_line(Vector2(mg_x + 14, mg_y + 14), Vector2(mg_x + 30, mg_y + 30), Color(0.5, 0.4, 0.15, 0.3), 3.0)

func _draw_sherlock_ch3(sky_color: Color, ground_color: Color) -> void:
	# Night scene - Reichenbach
	var sky_top := Color(0.02, 0.02, 0.04)
	var sky_bottom := Color(0.06, 0.06, 0.08)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.08, 0.06, 0.06))
	# Cobblestones
	for cx in range(40):
		for cy in range(3):
			var off := 16.0 if cy % 2 == 1 else 0.0
			draw_rect(Rect2(float(cx) * 32.0 + off, 525.0 + float(cy) * 30.0, 30, 28), Color(0.06, 0.05, 0.05))
			draw_rect(Rect2(float(cx) * 32.0 + off, 525.0 + float(cy) * 30.0, 30, 28), Color(0.04, 0.03, 0.03), false, 1.0)
	# Big Ben silhouette
	var ben_col := Color(0.02, 0.02, 0.03)
	draw_rect(Rect2(1050, 150, 50, 370), ben_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1045, 150), Vector2(1075, 90), Vector2(1105, 150)]), ben_col)
	draw_rect(Rect2(1055, 100, 40, 10), ben_col)
	# Clock face
	var clock_glow := 0.4 + 0.15 * sin(_time * 1.0)
	draw_circle(Vector2(1075, 200), 18.0, Color(0.8, 0.75, 0.5, clock_glow))
	draw_circle(Vector2(1075, 200), 16.0, Color(0.03, 0.03, 0.04))
	draw_line(Vector2(1075, 200), Vector2(1075, 188), Color(0.7, 0.65, 0.4, clock_glow), 1.5)
	draw_line(Vector2(1075, 200), Vector2(1083, 196), Color(0.7, 0.65, 0.4, clock_glow), 1.5)
	# More rooftops
	for rt in range(7):
		var rx := float(rt) * 150.0
		var rh := 120.0 + sin(float(rt) * 2.5) * 50.0
		draw_rect(Rect2(rx, 520.0 - rh, 80, rh), Color(0.02, 0.02, 0.04))
	# Gas lamps with red tint
	for gl in range(4):
		var gx := 150.0 + float(gl) * 240.0
		draw_rect(Rect2(gx, 445, 4, 75), Color(0.07, 0.06, 0.05))
		var flicker := 0.5 + 0.4 * sin(_time * 7.0 + float(gl) * 2.5)
		draw_circle(Vector2(gx + 2, 440), 6.0, Color(0.9, 0.5, 0.15, flicker))
		draw_circle(Vector2(gx + 2, 440), 16.0, Color(0.8, 0.4, 0.1, flicker * 0.15))
	# Dense fog
	for fl in range(8):
		var fy := 200.0 + float(fl) * 45.0
		var fog_shift := sin(_time * 0.18 + float(fl) * 0.8) * 50.0
		draw_rect(Rect2(-50 + fog_shift, fy, 1380, 20), Color(0.12, 0.12, 0.14, 0.05 + float(fl) * 0.012))

func _draw_merlin_ch1(sky_color: Color, ground_color: Color) -> void:
	# Enchanted forest green sky
	var sky_top := Color(0.01, 0.04, 0.02)
	var sky_bottom := Color(0.04, 0.12, 0.06)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Earth ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.10, 0.08, 0.04))
	draw_rect(Rect2(0, 515, 1280, 8), Color(0.06, 0.10, 0.03))
	# Standing stones
	var stone_col := Color(0.08, 0.08, 0.07)
	for st in range(7):
		var sx := 80.0 + float(st) * 180.0
		var sh := 80.0 + sin(float(st) * 2.3) * 30.0
		var sw := 25.0 + sin(float(st) * 1.7) * 8.0
		draw_rect(Rect2(sx - sw / 2, 520.0 - sh, sw, sh), stone_col)
		draw_colored_polygon(PackedVector2Array([Vector2(sx - sw / 2 - 3, 520.0 - sh), Vector2(sx, 520.0 - sh - 15), Vector2(sx + sw / 2 + 3, 520.0 - sh)]), stone_col)
		# Rune glow on stones
		var rune_glow := 0.2 + 0.3 * sin(_time * 1.5 + float(st) * 0.8)
		draw_circle(Vector2(sx, 520.0 - sh / 2), 4.0, Color(0.2, 0.8, 0.3, rune_glow))
		draw_line(Vector2(sx - 5, 520.0 - sh / 2 - 8), Vector2(sx + 5, 520.0 - sh / 2 + 8), Color(0.2, 0.7, 0.3, rune_glow * 0.7), 1.0)
		draw_line(Vector2(sx + 5, 520.0 - sh / 2 - 8), Vector2(sx - 5, 520.0 - sh / 2 + 8), Color(0.2, 0.7, 0.3, rune_glow * 0.7), 1.0)
	# Rune circle on ground
	var rune_cx := 640.0
	var rune_cy := 480.0
	var rune_pulse := 0.15 + 0.1 * sin(_time * 1.2)
	draw_arc(Vector2(rune_cx, rune_cy), 60.0, 0, TAU, 48, Color(0.3, 0.9, 0.4, rune_pulse), 1.5)
	draw_arc(Vector2(rune_cx, rune_cy), 45.0, 0, TAU, 36, Color(0.2, 0.7, 0.3, rune_pulse * 0.7), 1.0)
	for r in range(6):
		var ra := float(r) * TAU / 6.0 + _time * 0.2
		var rx := rune_cx + cos(ra) * 52.0
		var ry := rune_cy + sin(ra) * 25.0
		draw_circle(Vector2(rx, ry), 3.0, Color(0.3, 0.9, 0.4, rune_pulse))
	# Mystical forest trees
	for tr in range(12):
		var tx := float(tr) * 110.0 + 20.0
		var th := 120.0 + sin(float(tr) * 1.9) * 40.0
		draw_rect(Rect2(tx - 4, 520.0 - th, 8, th), Color(0.04, 0.06, 0.02))
		draw_circle(Vector2(tx, 520.0 - th - 15), 22.0 + sin(float(tr)) * 8.0, Color(0.02, 0.06, 0.02, 0.7))
		# Mystical glow in canopy
		var t_glow := 0.1 + 0.1 * sin(_time * 2.0 + float(tr) * 1.3)
		draw_circle(Vector2(tx, 520.0 - th - 10), 5.0, Color(0.3, 0.9, 0.5, t_glow))

func _draw_merlin_ch2(sky_color: Color, ground_color: Color) -> void:
	# Deeper enchanted forest
	var sky_top := Color(0.01, 0.05, 0.03)
	var sky_bottom := Color(0.03, 0.10, 0.05)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.08, 0.07, 0.03))
	draw_rect(Rect2(0, 515, 1280, 8), Color(0.05, 0.08, 0.03))
	# Standing stones with lintel
	var stone_col := Color(0.07, 0.07, 0.06)
	for st in range(4):
		var sx := 200.0 + float(st) * 250.0
		draw_rect(Rect2(sx - 15, 380, 30, 140), stone_col)
		draw_rect(Rect2(sx + 55, 380, 30, 140), stone_col)
		draw_rect(Rect2(sx - 20, 370, 110, 15), stone_col)
		# Rune inscriptions
		var rg := 0.2 + 0.25 * sin(_time * 1.3 + float(st) * 1.1)
		for ri in range(3):
			draw_line(Vector2(sx - 5, 400 + float(ri) * 25), Vector2(sx + 5, 410 + float(ri) * 25), Color(0.1, 0.6, 0.3, rg), 1.5)
	# Mystical orbs floating
	for orb in range(8):
		var ox := 100.0 + float(orb) * 150.0
		var oy := 200.0 + sin(_time * 0.8 + float(orb) * 1.5) * 40.0
		var orb_alpha := 0.3 + 0.2 * sin(_time * 2.0 + float(orb))
		draw_circle(Vector2(ox, oy), 4.0, Color(0.4, 1.0, 0.5, orb_alpha))
		draw_circle(Vector2(ox, oy), 10.0, Color(0.3, 0.8, 0.4, orb_alpha * 0.3))
	# Mushrooms on ground
	for mu in range(10):
		var mx := fmod(float(mu) * 131.0, 1200.0) + 40.0
		var ms := 6.0 + sin(float(mu)) * 3.0
		draw_rect(Rect2(mx - 2, 510, 4, 10), Color(0.15, 0.12, 0.06))
		draw_arc(Vector2(mx, 510), ms, PI, TAU, 12, Color(0.6, 0.15, 0.1, 0.5), ms * 0.6)
	# Forest canopy
	for tr in range(15):
		var tx := float(tr) * 90.0
		var th := 100.0 + sin(float(tr) * 2.1) * 35.0
		draw_rect(Rect2(tx - 3, 520.0 - th, 6, th), Color(0.03, 0.05, 0.02))
		draw_circle(Vector2(tx, 520.0 - th - 12), 20.0 + sin(float(tr) * 1.3) * 6.0, Color(0.02, 0.05, 0.02, 0.65))

func _draw_merlin_ch3(sky_color: Color, ground_color: Color) -> void:
	# Camelot approach - magical night
	var sky_top := Color(0.01, 0.03, 0.02)
	var sky_bottom := Color(0.05, 0.10, 0.06)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.09, 0.07, 0.04))
	# Camelot castle silhouette in distance
	var cas_col := Color(0.03, 0.04, 0.03)
	draw_colored_polygon(PackedVector2Array([Vector2(900, 350), Vector2(950, 280), Vector2(1000, 260), Vector2(1080, 250), Vector2(1150, 270), Vector2(1200, 300), Vector2(1280, 340), Vector2(1280, 520), Vector2(900, 520)]), cas_col)
	draw_rect(Rect2(1020, 180, 40, 80), cas_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1015, 180), Vector2(1040, 140), Vector2(1065, 180)]), cas_col)
	# Pennant on tower
	var pennant_sway := sin(_time * 3.0) * 5.0
	draw_colored_polygon(PackedVector2Array([Vector2(1040, 142), Vector2(1040 + 15 + pennant_sway, 148), Vector2(1040, 155)]), Color(0.6, 0.1, 0.1, 0.5))
	# Magic particles rising
	for mp in range(15):
		var px := fmod(float(mp) * 97.0, 1200.0) + 40.0
		var py := 500.0 - fmod(_time * 30.0 + float(mp) * 40.0, 400.0)
		var mp_alpha := clampf(1.0 - (500.0 - py) / 400.0, 0.0, 0.5)
		draw_circle(Vector2(px, py), 2.0, Color(0.3, 0.9, 0.5, mp_alpha))
	# Large rune circle
	var rc_x := 400.0
	var rc_y := 470.0
	var rc_pulse := 0.12 + 0.08 * sin(_time * 1.0)
	draw_arc(Vector2(rc_x, rc_y), 80.0, 0, TAU, 64, Color(0.2, 0.8, 0.4, rc_pulse), 2.0)
	for r in range(8):
		var ra := float(r) * TAU / 8.0 + _time * 0.15
		draw_circle(Vector2(rc_x + cos(ra) * 70.0, rc_y + sin(ra) * 35.0), 3.5, Color(0.3, 1.0, 0.5, rc_pulse * 1.5))
	# Standing stones flanking
	for st in range(5):
		var sx := float(st) * 160.0 + 50.0
		var sh := 70.0 + sin(float(st) * 2.0) * 20.0
		draw_rect(Rect2(sx - 12, 520.0 - sh, 24, sh), Color(0.06, 0.06, 0.05))

func _draw_tarzan_ch1(sky_color: Color, ground_color: Color) -> void:
	# Tropical blue sky
	var sky_top := Color(0.02, 0.06, 0.12)
	var sky_bottom := Color(0.06, 0.14, 0.18)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Jungle green ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.04, 0.14, 0.02))
	draw_rect(Rect2(0, 515, 1280, 8), Color(0.03, 0.10, 0.02))
	# Vines hanging from top
	for v in range(12):
		var vx := float(v) * 110.0 + 30.0
		var vlen := 100.0 + sin(float(v) * 1.9) * 60.0
		var sway := sin(_time * 1.2 + float(v) * 0.7) * 8.0
		for seg in range(int(vlen / 8.0)):
			var sy := 50.0 + float(seg) * 8.0
			var sx := vx + sin(float(seg) * 0.3 + _time * 0.5) * sway * (float(seg) / (vlen / 8.0))
			draw_rect(Rect2(sx - 1.5, sy, 3, 9), Color(0.1, 0.25, 0.05, 0.7))
		# Leaf at bottom of vine
		var leaf_y := 50.0 + vlen
		var leaf_x := vx + sway * 0.8
		draw_colored_polygon(PackedVector2Array([Vector2(leaf_x, leaf_y), Vector2(leaf_x + 8, leaf_y + 5), Vector2(leaf_x, leaf_y + 12), Vector2(leaf_x - 8, leaf_y + 5)]), Color(0.15, 0.35, 0.05, 0.6))
	# Canopy leaves at top
	for cl in range(20):
		var cx := float(cl) * 68.0
		var cs := 30.0 + sin(float(cl) * 2.3) * 12.0
		draw_circle(Vector2(cx, 55.0 + sin(float(cl) * 1.5) * 15.0), cs, Color(0.02, 0.08, 0.02, 0.5))
		draw_circle(Vector2(cx + 20, 70.0 + sin(float(cl) * 2.1) * 10.0), cs * 0.7, Color(0.03, 0.10, 0.03, 0.4))
	# Exotic flowers
	for fl in range(8):
		var fx := fmod(float(fl) * 167.0, 1200.0) + 40.0
		var fy := 500.0 + sin(float(fl) * 2.5) * 15.0
		draw_rect(Rect2(fx - 1, fy - 20, 2, 22), Color(0.08, 0.20, 0.04))
		var petal_col := Color(0.8, 0.2 + sin(float(fl)) * 0.3, 0.3, 0.6)
		for p in range(5):
			var pa := float(p) * TAU / 5.0
			draw_circle(Vector2(fx + cos(pa) * 5.0, fy - 22 + sin(pa) * 5.0), 3.0, petal_col)
		draw_circle(Vector2(fx, fy - 22), 2.5, Color(0.9, 0.8, 0.2, 0.7))
	# Tree trunks
	for tr in range(6):
		var tx := float(tr) * 220.0 + 50.0
		draw_rect(Rect2(tx - 8, 350, 16, 170), Color(0.12, 0.07, 0.03))
		draw_rect(Rect2(tx - 6, 355, 4, 160), Color(0.10, 0.06, 0.02, 0.5))

func _draw_tarzan_ch2(sky_color: Color, ground_color: Color) -> void:
	# Deeper jungle
	var sky_top := Color(0.02, 0.05, 0.10)
	var sky_bottom := Color(0.04, 0.12, 0.14)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.03, 0.12, 0.02))
	# Dense canopy
	for cl in range(25):
		var cx := float(cl) * 55.0
		var cs := 35.0 + sin(float(cl) * 1.7) * 10.0
		draw_circle(Vector2(cx, 60.0 + sin(float(cl) * 2.0) * 12.0), cs, Color(0.02, 0.07, 0.02, 0.55))
	# Thick vines
	for v in range(8):
		var vx := float(v) * 165.0 + 50.0
		var sway := sin(_time * 0.9 + float(v) * 0.9) * 12.0
		for seg in range(20):
			var sy := 50.0 + float(seg) * 12.0
			var sx := vx + sin(float(seg) * 0.25 + _time * 0.4) * sway * (float(seg) / 20.0)
			draw_rect(Rect2(sx - 2, sy, 4, 13), Color(0.08, 0.20, 0.04, 0.65))
	# Waterfall in background
	var wf_x := 900.0
	for ws in range(15):
		var wy := 200.0 + float(ws) * 22.0
		var wobble := sin(_time * 4.0 + float(ws) * 0.5) * 3.0
		draw_rect(Rect2(wf_x - 8 + wobble, wy, 16, 24), Color(0.3, 0.5, 0.7, 0.15))
	# Pool at bottom of waterfall
	draw_arc(Vector2(wf_x, 520), 30.0, PI, TAU, 24, Color(0.2, 0.4, 0.6, 0.2), 2.0)
	# Exotic flowers
	for fl in range(10):
		var fx := fmod(float(fl) * 131.0, 1200.0) + 40.0
		var fy := 505.0 + sin(float(fl) * 1.8) * 10.0
		draw_rect(Rect2(fx - 1, fy - 15, 2, 17), Color(0.06, 0.18, 0.03))
		var pcol := Color(0.9, 0.4 + sin(float(fl) * 0.7) * 0.3, 0.1, 0.5)
		for p in range(4):
			var pa := float(p) * TAU / 4.0 + 0.4
			draw_circle(Vector2(fx + cos(pa) * 4.0, fy - 17 + sin(pa) * 4.0), 2.5, pcol)
	# Parrots (simple colored dots on branches)
	for bird in range(3):
		var bx := 200.0 + float(bird) * 350.0
		var by := 150.0 + float(bird) * 30.0
		draw_circle(Vector2(bx, by), 5.0, Color(0.8, 0.2, 0.1, 0.6))
		draw_circle(Vector2(bx + 3, by - 4), 3.0, Color(0.2, 0.7, 0.1, 0.6))

func _draw_tarzan_ch3(sky_color: Color, ground_color: Color) -> void:
	# Jungle summit - sunset hues
	var sky_top := Color(0.03, 0.07, 0.14)
	var sky_bottom := Color(0.10, 0.15, 0.08)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.05, 0.14, 0.03))
	# Treehouse platform silhouette
	var th_col := Color(0.06, 0.04, 0.02)
	draw_rect(Rect2(600, 300, 200, 12), th_col)
	draw_rect(Rect2(640, 312, 10, 208), th_col)
	draw_rect(Rect2(760, 312, 10, 208), th_col)
	# Ladder
	for ld in range(8):
		draw_rect(Rect2(645, 320 + float(ld) * 25, 120, 3), Color(0.08, 0.05, 0.02, 0.5))
	# Rope bridge
	for rb in range(20):
		var rx := 300.0 + float(rb) * 15.0
		var ry := 350.0 + sin(float(rb) * 0.3) * 15.0
		draw_rect(Rect2(rx, ry, 14, 3), Color(0.10, 0.06, 0.03, 0.5))
	# Heavy vines
	for v in range(10):
		var vx := float(v) * 135.0 + 20.0
		var sway := sin(_time * 1.0 + float(v) * 1.1) * 10.0
		for seg in range(18):
			var sy := 50.0 + float(seg) * 10.0
			var sx := vx + sin(float(seg) * 0.3) * sway * (float(seg) / 18.0)
			draw_rect(Rect2(sx - 2, sy, 4, 11), Color(0.08, 0.22, 0.04, 0.6))
	# Canopy
	for cl in range(22):
		var cx := float(cl) * 62.0
		draw_circle(Vector2(cx, 55.0 + sin(float(cl) * 1.8) * 12.0), 28.0 + sin(float(cl)) * 8.0, Color(0.02, 0.07, 0.02, 0.5))
	# Exotic flowers on ground
	for fl in range(6):
		var fx := fmod(float(fl) * 197.0, 1200.0) + 40.0
		draw_rect(Rect2(fx - 1, 500, 2, 20), Color(0.06, 0.15, 0.03))
		for p in range(5):
			var pa := float(p) * TAU / 5.0
			draw_circle(Vector2(fx + cos(pa) * 5.0, 498.0 + sin(pa) * 5.0), 3.0, Color(0.9, 0.6, 0.1, 0.5))

func _draw_dracula_ch1(sky_color: Color, ground_color: Color) -> void:
	# Blood red-black sky
	var sky_top := Color(0.03, 0.01, 0.02)
	var sky_bottom := Color(0.10, 0.03, 0.06)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Dark earth ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.06, 0.04, 0.04))
	# Blood moon
	draw_circle(Vector2(200, 140), 45.0, Color(0.6, 0.1, 0.08, 0.15))
	draw_circle(Vector2(200, 140), 35.0, Color(0.7, 0.15, 0.1))
	draw_circle(Vector2(193, 135), 32.0, Color(0.6, 0.12, 0.08))
	# Moon craters
	draw_circle(Vector2(210, 130), 5.0, Color(0.5, 0.08, 0.06, 0.4))
	draw_circle(Vector2(195, 148), 4.0, Color(0.5, 0.08, 0.06, 0.3))
	# Bat silhouettes
	for bt in range(8):
		var bx := fmod(float(bt) * 173.0 + _time * 20.0, 1400.0) - 60.0
		var by := 100.0 + sin(_time * 1.5 + float(bt) * 1.3) * 30.0 + float(bt) * 20.0
		var wing := sin(_time * 6.0 + float(bt) * 2.0) * 8.0
		draw_line(Vector2(bx - 10, by + wing), Vector2(bx, by), Color(0.05, 0.02, 0.03, 0.7), 1.5)
		draw_line(Vector2(bx, by), Vector2(bx + 10, by + wing), Color(0.05, 0.02, 0.03, 0.7), 1.5)
		draw_circle(Vector2(bx, by), 2.5, Color(0.04, 0.02, 0.03, 0.7))
	# Crosses / gravestones
	for cr in range(6):
		var cx := 100.0 + float(cr) * 200.0
		var cy := 510.0
		draw_rect(Rect2(cx - 3, cy - 30, 6, 35), Color(0.08, 0.06, 0.05))
		draw_rect(Rect2(cx - 10, cy - 22, 20, 5), Color(0.08, 0.06, 0.05))
	# Castle silhouette in distance
	var cas_col := Color(0.03, 0.01, 0.02)
	draw_colored_polygon(PackedVector2Array([Vector2(950, 350), Vector2(1000, 250), Vector2(1050, 230), Vector2(1100, 220), Vector2(1180, 240), Vector2(1250, 280), Vector2(1280, 320), Vector2(1280, 520), Vector2(950, 520)]), cas_col)
	# Castle towers
	draw_rect(Rect2(1060, 150, 35, 80), cas_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1055, 150), Vector2(1077, 110), Vector2(1100, 150)]), cas_col)
	# Red fog
	for fl in range(4):
		var fy := 380.0 + float(fl) * 35.0
		var fog_shift := sin(_time * 0.2 + float(fl) * 1.0) * 30.0
		draw_rect(Rect2(-20 + fog_shift, fy, 1320, 18), Color(0.15, 0.03, 0.05, 0.06))

func _draw_dracula_ch2(sky_color: Color, ground_color: Color) -> void:
	# Inside the castle approach
	var sky_top := Color(0.04, 0.01, 0.03)
	var sky_bottom := Color(0.08, 0.02, 0.05)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.05, 0.03, 0.03))
	# Gothic arches
	for arch in range(5):
		var ax := float(arch) * 270.0 + 80.0
		var arch_col := Color(0.04, 0.02, 0.03)
		draw_rect(Rect2(ax - 30, 320, 10, 200), arch_col)
		draw_rect(Rect2(ax + 30, 320, 10, 200), arch_col)
		draw_arc(Vector2(ax + 5, 320), 35.0, PI, TAU, 24, arch_col, 10.0)
	# Candelabras
	for cn in range(4):
		var cx := 200.0 + float(cn) * 280.0
		draw_rect(Rect2(cx - 2, 420, 4, 100), Color(0.08, 0.06, 0.04))
		for c in range(3):
			var coff := float(c - 1) * 12.0
			var flicker := 0.5 + 0.4 * sin(_time * 5.5 + float(cn) * 2.0 + float(c))
			draw_circle(Vector2(cx + coff, 415), 4.0, Color(0.9, 0.4, 0.1, flicker))
			draw_circle(Vector2(cx + coff, 415), 10.0, Color(0.8, 0.3, 0.05, flicker * 0.15))
	# More bats
	for bt in range(6):
		var bx := fmod(float(bt) * 211.0 + _time * 15.0, 1400.0) - 60.0
		var by := 120.0 + sin(_time * 2.0 + float(bt) * 1.8) * 25.0 + float(bt) * 15.0
		var wing := sin(_time * 7.0 + float(bt) * 2.5) * 7.0
		draw_line(Vector2(bx - 9, by + wing), Vector2(bx, by), Color(0.04, 0.01, 0.02, 0.6), 1.5)
		draw_line(Vector2(bx, by), Vector2(bx + 9, by + wing), Color(0.04, 0.01, 0.02, 0.6), 1.5)
		draw_circle(Vector2(bx, by), 2.0, Color(0.03, 0.01, 0.02, 0.6))
	# Red mist
	for fl in range(5):
		var fy := 350.0 + float(fl) * 35.0
		var fog_shift := sin(_time * 0.15 + float(fl) * 0.9) * 40.0
		draw_rect(Rect2(-30 + fog_shift, fy, 1340, 20), Color(0.12, 0.02, 0.04, 0.05 + float(fl) * 0.01))
	# Coffins on ground
	for cf in range(3):
		var cfx := 300.0 + float(cf) * 300.0
		draw_rect(Rect2(cfx, 508, 40, 12), Color(0.07, 0.04, 0.03))
		draw_rect(Rect2(cfx + 2, 505, 36, 5), Color(0.08, 0.04, 0.03))

func _draw_dracula_ch3(sky_color: Color, ground_color: Color) -> void:
	# Dracula's throne room approach
	var sky_top := Color(0.05, 0.01, 0.03)
	var sky_bottom := Color(0.10, 0.03, 0.06)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.05, 0.03, 0.04))
	# Large blood moon behind clouds
	draw_circle(Vector2(640, 120), 55.0, Color(0.5, 0.08, 0.06, 0.12))
	draw_circle(Vector2(640, 120), 40.0, Color(0.65, 0.12, 0.08))
	# Clouds over moon
	for mc in range(3):
		var mcx := 600.0 + float(mc) * 35.0 + sin(_time * 0.3) * 10.0
		draw_circle(Vector2(mcx, 110.0 + float(mc) * 8.0), 20.0, Color(0.04, 0.02, 0.03, 0.6))
	# Gothic windows
	for gw in range(4):
		var wx := 150.0 + float(gw) * 300.0
		draw_rect(Rect2(wx, 250, 40, 100), Color(0.03, 0.01, 0.02))
		draw_arc(Vector2(wx + 20, 250), 20.0, PI, TAU, 16, Color(0.03, 0.01, 0.02), 20.0)
		var red_glow := 0.15 + 0.1 * sin(_time * 1.5 + float(gw))
		draw_rect(Rect2(wx + 3, 260, 34, 85), Color(0.4, 0.05, 0.08, red_glow))
	# Bats swarm
	for bt in range(12):
		var bx := fmod(float(bt) * 113.0 + _time * 25.0, 1500.0) - 100.0
		var by := 80.0 + sin(_time * 1.8 + float(bt) * 1.0) * 40.0 + float(bt) * 12.0
		var wing := sin(_time * 8.0 + float(bt) * 3.0) * 6.0
		draw_line(Vector2(bx - 8, by + wing), Vector2(bx, by), Color(0.03, 0.01, 0.02, 0.65), 1.5)
		draw_line(Vector2(bx, by), Vector2(bx + 8, by + wing), Color(0.03, 0.01, 0.02, 0.65), 1.5)
	# Crosses and gravestones
	for cr in range(8):
		var cx := 60.0 + float(cr) * 160.0
		draw_rect(Rect2(cx - 3, 490, 6, 30), Color(0.07, 0.05, 0.04))
		draw_rect(Rect2(cx - 9, 498, 18, 4), Color(0.07, 0.05, 0.04))
	# Red fog thicker
	for fl in range(6):
		var fy := 320.0 + float(fl) * 35.0
		var fog_shift := sin(_time * 0.12 + float(fl) * 0.7) * 50.0
		draw_rect(Rect2(-40 + fog_shift, fy, 1360, 22), Color(0.14, 0.02, 0.04, 0.05 + float(fl) * 0.01))

func _draw_frankenstein_ch1(sky_color: Color, ground_color: Color) -> void:
	# Storm gray sky
	var sky_top := Color(0.02, 0.02, 0.04)
	var sky_bottom := Color(0.06, 0.06, 0.08)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Stone floor
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.08, 0.08, 0.08))
	for sx in range(20):
		for sy in range(2):
			var off := 32.0 if sy % 2 == 1 else 0.0
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.07, 0.07, 0.07))
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.05, 0.05, 0.05), false, 1.0)
	# Tesla coils
	for tc in range(4):
		var tx := 150.0 + float(tc) * 280.0
		# Coil base
		draw_rect(Rect2(tx - 8, 430, 16, 90), Color(0.10, 0.08, 0.06))
		draw_rect(Rect2(tx - 15, 425, 30, 8), Color(0.12, 0.10, 0.08))
		# Coil rings
		for ring in range(5):
			var ry := 440.0 + float(ring) * 15.0
			draw_arc(Vector2(tx, ry), 10.0, 0, TAU, 16, Color(0.15, 0.12, 0.08), 2.0)
		# Sparks from top
		var spark_active := sin(_time * 8.0 + float(tc) * 2.5)
		if spark_active > 0.0:
			var spark_alpha := spark_active * 0.7
			for sp in range(3):
				var sa := float(sp) * TAU / 3.0 + _time * 5.0
				var sr := 15.0 + float(sp) * 8.0
				var sx2 := tx + cos(sa) * sr
				var sy2 := 420.0 + sin(sa) * sr * 0.5
				draw_line(Vector2(tx, 425), Vector2(sx2, sy2), Color(0.5, 0.6, 1.0, spark_alpha), 1.5)
				draw_circle(Vector2(sx2, sy2), 2.0, Color(0.6, 0.7, 1.0, spark_alpha))
	# Lightning bolts in sky
	var bolt_timer := fmod(_time * 0.5, 3.0)
	if bolt_timer < 0.15:
		var bolt_alpha := 0.6 - bolt_timer * 4.0
		var bx := 400.0 + sin(_time * 7.0) * 300.0
		draw_line(Vector2(bx, 50), Vector2(bx + 20, 150), Color(0.7, 0.75, 1.0, bolt_alpha), 2.0)
		draw_line(Vector2(bx + 20, 150), Vector2(bx - 10, 250), Color(0.7, 0.75, 1.0, bolt_alpha), 2.0)
		draw_line(Vector2(bx - 10, 250), Vector2(bx + 15, 350), Color(0.6, 0.65, 1.0, bolt_alpha * 0.7), 1.5)
	# Beakers on tables
	for bk in range(3):
		var bkx := 350.0 + float(bk) * 250.0
		draw_rect(Rect2(bkx - 15, 490, 30, 5), Color(0.10, 0.09, 0.08))
		# Beaker shape
		draw_rect(Rect2(bkx - 5, 470, 10, 20), Color(0.2, 0.3, 0.4, 0.3))
		var bubble := sin(_time * 3.0 + float(bk) * 1.5) * 0.3
		draw_circle(Vector2(bkx, 475), 3.0, Color(0.3, 0.8, 0.2, 0.3 + bubble))

func _draw_frankenstein_ch2(sky_color: Color, ground_color: Color) -> void:
	# Deeper into the lab
	var sky_top := Color(0.03, 0.03, 0.05)
	var sky_bottom := Color(0.05, 0.05, 0.07)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.07, 0.07, 0.07))
	# Stone floor tiles
	for sx in range(20):
		for sy in range(2):
			var off := 32.0 if sy % 2 == 1 else 0.0
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.06, 0.06, 0.06))
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.04, 0.04, 0.04), false, 1.0)
	# Operating table silhouette
	draw_rect(Rect2(500, 460, 200, 10), Color(0.10, 0.08, 0.06))
	draw_rect(Rect2(520, 470, 8, 50), Color(0.08, 0.06, 0.05))
	draw_rect(Rect2(680, 470, 8, 50), Color(0.08, 0.06, 0.05))
	# Chains from ceiling
	for ch in range(6):
		var cx := 100.0 + float(ch) * 200.0
		var sway := sin(_time * 1.5 + float(ch) * 1.0) * 5.0
		for link in range(8):
			var ly := 50.0 + float(link) * 18.0
			var lx := cx + sway * (float(link) / 8.0)
			draw_rect(Rect2(lx - 2, ly, 4, 8), Color(0.12, 0.10, 0.08, 0.5))
			draw_rect(Rect2(lx - 3, ly + 6, 6, 4), Color(0.10, 0.08, 0.07, 0.5))
	# Tesla coils (bigger)
	for tc in range(3):
		var tx := 200.0 + float(tc) * 350.0
		draw_rect(Rect2(tx - 12, 400, 24, 120), Color(0.10, 0.08, 0.06))
		draw_rect(Rect2(tx - 20, 395, 40, 10), Color(0.12, 0.10, 0.08))
		for ring in range(7):
			draw_arc(Vector2(tx, 410.0 + float(ring) * 14.0), 14.0, 0, TAU, 16, Color(0.14, 0.11, 0.08), 2.0)
		# Electric arcs between coils
		if tc < 2:
			var next_x := 200.0 + float(tc + 1) * 350.0
			var arc_on := sin(_time * 6.0 + float(tc) * 3.0)
			if arc_on > 0.3:
				var arc_alpha := (arc_on - 0.3) * 0.8
				var mid_x := (tx + next_x) / 2.0
				var mid_y := 395.0 + sin(_time * 4.0) * 20.0
				draw_line(Vector2(tx, 400), Vector2(mid_x, mid_y), Color(0.5, 0.6, 1.0, arc_alpha), 1.5)
				draw_line(Vector2(mid_x, mid_y), Vector2(next_x, 400), Color(0.5, 0.6, 1.0, arc_alpha), 1.5)
	# Green bubbling liquid
	for bk in range(5):
		var bkx := 80.0 + float(bk) * 250.0
		draw_rect(Rect2(bkx - 8, 480, 16, 25), Color(0.15, 0.25, 0.1, 0.3))
		var bub_y := 480.0 - fmod(_time * 15.0 + float(bk) * 10.0, 20.0)
		draw_circle(Vector2(bkx, bub_y), 2.0, Color(0.3, 0.8, 0.2, 0.4))

func _draw_frankenstein_ch3(sky_color: Color, ground_color: Color) -> void:
	# The creation scene - storm at peak
	var sky_top := Color(0.03, 0.02, 0.05)
	var sky_bottom := Color(0.06, 0.05, 0.08)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.08, 0.08, 0.08))
	# Stone floor
	for sx in range(20):
		for sy in range(2):
			var off := 32.0 if sy % 2 == 1 else 0.0
			draw_rect(Rect2(float(sx) * 64.0 + off, 525.0 + float(sy) * 40.0, 62, 38), Color(0.06, 0.06, 0.06))
	# Giant apparatus in center
	draw_rect(Rect2(560, 250, 160, 8), Color(0.12, 0.10, 0.08))
	draw_rect(Rect2(580, 258, 8, 262), Color(0.10, 0.08, 0.06))
	draw_rect(Rect2(692, 258, 8, 262), Color(0.10, 0.08, 0.06))
	# Gear/wheel
	draw_arc(Vector2(640, 300), 25.0, 0, TAU, 24, Color(0.12, 0.10, 0.08), 3.0)
	for g in range(8):
		var ga := float(g) * TAU / 8.0 + _time * 0.5
		draw_line(Vector2(640 + cos(ga) * 20.0, 300 + sin(ga) * 20.0), Vector2(640 + cos(ga) * 30.0, 300 + sin(ga) * 30.0), Color(0.12, 0.10, 0.08), 2.0)
	# Multiple lightning bolts
	for bolt in range(3):
		var bolt_timer := fmod(_time * 0.8 + float(bolt) * 1.0, 2.5)
		if bolt_timer < 0.12:
			var ba := 0.7 - bolt_timer * 5.5
			var bx := 200.0 + float(bolt) * 350.0 + sin(_time * 5.0 + float(bolt)) * 50.0
			draw_line(Vector2(bx, 50), Vector2(bx + 15, 130), Color(0.7, 0.8, 1.0, ba), 2.5)
			draw_line(Vector2(bx + 15, 130), Vector2(bx - 10, 220), Color(0.7, 0.8, 1.0, ba), 2.0)
			draw_line(Vector2(bx - 10, 220), Vector2(bx + 5, 310), Color(0.6, 0.7, 1.0, ba * 0.7), 1.5)
	# Tesla coils with heavy sparks
	for tc in range(2):
		var tx := 100.0 + float(tc) * 1000.0
		draw_rect(Rect2(tx - 10, 380, 20, 140), Color(0.10, 0.08, 0.06))
		draw_rect(Rect2(tx - 18, 375, 36, 10), Color(0.12, 0.10, 0.08))
		for ring in range(8):
			draw_arc(Vector2(tx, 390.0 + float(ring) * 14.0), 12.0, 0, TAU, 16, Color(0.14, 0.11, 0.08), 2.0)
		# Constant sparks
		for sp in range(4):
			var sa := float(sp) * TAU / 4.0 + _time * 7.0 + float(tc) * 1.5
			var sr := 20.0 + sin(_time * 3.0 + float(sp)) * 8.0
			var spark_a := 0.3 + 0.3 * sin(_time * 5.0 + float(sp) + float(tc))
			draw_line(Vector2(tx, 378), Vector2(tx + cos(sa) * sr, 378 + sin(sa) * sr * 0.6), Color(0.5, 0.6, 1.0, clampf(spark_a, 0.0, 0.6)), 1.5)
	# Bubbling vats
	for vat in range(4):
		var vx := 250.0 + float(vat) * 220.0
		draw_rect(Rect2(vx - 12, 485, 24, 35), Color(0.12, 0.20, 0.08, 0.35))
		for bub in range(3):
			var by := 485.0 - fmod(_time * 12.0 + float(vat) * 8.0 + float(bub) * 5.0, 25.0)
			draw_circle(Vector2(vx + sin(float(bub) * 2.0) * 5.0, by), 1.5, Color(0.3, 0.7, 0.2, 0.4))

func _draw_shadow_author_ch1(sky_color: Color, ground_color: Color) -> void:
	# Pure black sky with ink
	var sky_top := Color(0.01, 0.005, 0.02)
	var sky_bottom := Color(0.03, 0.02, 0.04)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	# Ink pool ground
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.02, 0.02, 0.04))
	# Ink ripples on ground
	for rp in range(6):
		var rx := 100.0 + float(rp) * 200.0
		var ry := 550.0
		var ripple_r := 20.0 + sin(_time * 1.0 + float(rp) * 1.5) * 10.0
		draw_arc(Vector2(rx, ry), ripple_r, 0, TAU, 24, Color(0.08, 0.05, 0.12, 0.15), 1.0)
		draw_arc(Vector2(rx, ry), ripple_r * 0.6, 0, TAU, 16, Color(0.08, 0.05, 0.12, 0.1), 1.0)
	# Dripping ink from top
	for dr in range(15):
		var dx := fmod(float(dr) * 89.0, 1280.0)
		var drip_speed := 40.0 + float(dr) * 5.0
		var dy := fmod(_time * drip_speed + float(dr) * 50.0, 520.0) + 50.0
		var drip_len := 15.0 + sin(float(dr)) * 8.0
		draw_rect(Rect2(dx - 1.5, dy, 3, drip_len), Color(0.05, 0.02, 0.08, 0.4))
		draw_circle(Vector2(dx, dy + drip_len), 2.5, Color(0.06, 0.03, 0.10, 0.5))
	# Floating quills
	for q in range(5):
		var qx := 100.0 + float(q) * 250.0
		var qy := 200.0 + sin(_time * 0.6 + float(q) * 1.2) * 30.0
		var qa := sin(_time * 0.3 + float(q)) * 0.3
		# Quill shaft
		draw_line(Vector2(qx - 15, qy + 10), Vector2(qx + 15, qy - 10), Color(0.4, 0.3, 0.2, 0.4), 1.5)
		# Feather
		draw_colored_polygon(PackedVector2Array([Vector2(qx + 10, qy - 8), Vector2(qx + 20, qy - 15), Vector2(qx + 18, qy - 3)]), Color(0.3, 0.2, 0.15, 0.35))
		# Nib
		draw_line(Vector2(qx - 15, qy + 10), Vector2(qx - 20, qy + 15), Color(0.5, 0.4, 0.1, 0.5), 1.0)
	# Open books on ground
	for bk in range(4):
		var bx := 150.0 + float(bk) * 280.0
		var by := 500.0
		# Book covers
		draw_colored_polygon(PackedVector2Array([Vector2(bx - 25, by), Vector2(bx - 5, by - 5), Vector2(bx, by + 2), Vector2(bx - 20, by + 8)]), Color(0.08, 0.04, 0.02, 0.5))
		draw_colored_polygon(PackedVector2Array([Vector2(bx, by + 2), Vector2(bx + 5, by - 5), Vector2(bx + 25, by), Vector2(bx + 20, by + 8)]), Color(0.07, 0.03, 0.02, 0.5))
		# Page glow
		var pg := 0.1 + 0.05 * sin(_time * 1.5 + float(bk))
		draw_rect(Rect2(bx - 18, by + 1, 16, 5), Color(0.3, 0.25, 0.15, pg))
		draw_rect(Rect2(bx + 2, by + 1, 16, 5), Color(0.3, 0.25, 0.15, pg))
	# Text fragments floating
	for tf in range(8):
		var tx := fmod(float(tf) * 163.0 + _time * 8.0, 1400.0) - 60.0
		var ty := 300.0 + sin(float(tf) * 2.0) * 100.0 + sin(_time * 0.5 + float(tf)) * 15.0
		draw_rect(Rect2(tx, ty, 20 + float(tf) * 3, 2), Color(0.25, 0.20, 0.15, 0.2))
		draw_rect(Rect2(tx, ty + 4, 15 + float(tf) * 2, 2), Color(0.25, 0.20, 0.15, 0.15))

func _draw_shadow_author_ch2(sky_color: Color, ground_color: Color) -> void:
	# Deeper into shadow realm
	var sky_top := Color(0.01, 0.005, 0.015)
	var sky_bottom := Color(0.025, 0.015, 0.035)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.02, 0.015, 0.035))
	# Ink waterfalls from edges
	for wf in range(3):
		var wx := float(wf) * 500.0 + 150.0
		for ws in range(12):
			var wy := 50.0 + float(ws) * 40.0
			var wobble := sin(_time * 3.0 + float(ws) * 0.6 + float(wf)) * 4.0
			draw_rect(Rect2(wx - 5 + wobble, wy, 10, 42), Color(0.04, 0.02, 0.06, 0.2))
	# Shadow tendrils rising from ground
	for st in range(10):
		var sx := float(st) * 130.0 + 40.0
		var sway := sin(_time * 0.8 + float(st) * 0.9) * 15.0
		for seg in range(10):
			var sy := 520.0 - float(seg) * 15.0
			var sx2 := sx + sway * (float(seg) / 10.0)
			draw_rect(Rect2(sx2 - 2, sy, 4, 16), Color(0.03, 0.01, 0.05, 0.4 - float(seg) * 0.035))
	# Scattered pages
	for pg in range(6):
		var px := fmod(float(pg) * 197.0 + sin(_time * 0.4 + float(pg)) * 20.0, 1200.0) + 40.0
		var py := 250.0 + sin(float(pg) * 1.7) * 80.0 + sin(_time * 0.5 + float(pg)) * 10.0
		var rot := sin(_time * 0.3 + float(pg)) * 0.2
		draw_rect(Rect2(px, py, 20, 26), Color(0.12, 0.10, 0.08, 0.15))
		draw_rect(Rect2(px + 2, py + 3, 16, 2), Color(0.08, 0.06, 0.04, 0.1))
		draw_rect(Rect2(px + 2, py + 7, 14, 2), Color(0.08, 0.06, 0.04, 0.1))
		draw_rect(Rect2(px + 2, py + 11, 16, 2), Color(0.08, 0.06, 0.04, 0.1))
	# Giant quill in background
	draw_line(Vector2(900, 100), Vector2(1050, 400), Color(0.15, 0.10, 0.06, 0.2), 3.0)
	draw_colored_polygon(PackedVector2Array([Vector2(880, 90), Vector2(900, 100), Vector2(870, 130), Vector2(860, 110)]), Color(0.12, 0.08, 0.04, 0.2))
	# Ink drips (heavier)
	for dr in range(20):
		var dx := fmod(float(dr) * 67.0, 1280.0)
		var drip_speed := 35.0 + float(dr) * 4.0
		var dy := fmod(_time * drip_speed + float(dr) * 40.0, 520.0) + 50.0
		draw_rect(Rect2(dx - 1, dy, 2, 12 + sin(float(dr)) * 5.0), Color(0.04, 0.02, 0.07, 0.35))
	# Glowing runes on ground (shadow magic)
	for rn in range(5):
		var rx := 120.0 + float(rn) * 240.0
		var rg := 0.1 + 0.08 * sin(_time * 1.2 + float(rn) * 1.0)
		draw_arc(Vector2(rx, 530), 15.0, 0, TAU, 16, Color(0.3, 0.1, 0.5, rg), 1.5)

func _draw_shadow_author_ch3(sky_color: Color, ground_color: Color) -> void:
	# Final confrontation - pure darkness
	var sky_top := Color(0.008, 0.004, 0.015)
	var sky_bottom := Color(0.02, 0.01, 0.03)
	for i in range(25):
		var t := float(i) / 24.0
		draw_rect(Rect2(0, 50.0 + float(i) * 19.0, 1280, 20.0), sky_top.lerp(sky_bottom, t))
	draw_rect(Rect2(0, 520, 1280, 120), Color(0.015, 0.01, 0.03))
	# Central dark vortex
	for vr in range(8):
		var vr_r := 30.0 + float(vr) * 20.0
		var vr_angle := _time * (0.5 - float(vr) * 0.05)
		draw_arc(Vector2(640, 350), vr_r, vr_angle, vr_angle + TAU * 0.7, 32, Color(0.06, 0.02, 0.10, 0.12 - float(vr) * 0.012), 2.0)
	# Ink explosion particles
	for ip in range(20):
		var ia := float(ip) * TAU / 20.0 + _time * 0.3
		var ir := 80.0 + sin(_time * 0.8 + float(ip) * 0.5) * 40.0
		var ix := 640.0 + cos(ia) * ir
		var iy := 350.0 + sin(ia) * ir * 0.5
		draw_circle(Vector2(ix, iy), 2.0 + sin(_time + float(ip)) * 1.0, Color(0.08, 0.03, 0.15, 0.3))
	# Massive dripping ink
	for dr in range(25):
		var dx := fmod(float(dr) * 53.0, 1280.0)
		var drip_speed := 30.0 + float(dr) * 3.0
		var dy := fmod(_time * drip_speed + float(dr) * 35.0, 520.0) + 50.0
		var drip_w := 2.0 + sin(float(dr) * 1.3) * 1.0
		draw_rect(Rect2(dx - drip_w / 2, dy, drip_w, 18 + sin(float(dr)) * 6.0), Color(0.05, 0.02, 0.08, 0.4))
	# Floating open books (larger)
	for bk in range(5):
		var bx := 100.0 + float(bk) * 240.0
		var by := 200.0 + sin(_time * 0.4 + float(bk) * 1.3) * 30.0
		draw_colored_polygon(PackedVector2Array([Vector2(bx - 20, by), Vector2(bx - 2, by - 8), Vector2(bx, by), Vector2(bx - 15, by + 10)]), Color(0.10, 0.06, 0.03, 0.35))
		draw_colored_polygon(PackedVector2Array([Vector2(bx, by), Vector2(bx + 2, by - 8), Vector2(bx + 20, by), Vector2(bx + 15, by + 10)]), Color(0.09, 0.05, 0.03, 0.35))
		# Glowing text
		var tg := 0.1 + 0.05 * sin(_time * 1.8 + float(bk))
		draw_rect(Rect2(bx - 14, by + 2, 12, 1.5), Color(0.4, 0.3, 0.6, tg))
		draw_rect(Rect2(bx + 2, by + 2, 12, 1.5), Color(0.4, 0.3, 0.6, tg))
	# Quills orbiting center
	for q in range(4):
		var qa := float(q) * TAU / 4.0 + _time * 0.4
		var qr := 150.0 + sin(_time * 0.5 + float(q)) * 20.0
		var qx := 640.0 + cos(qa) * qr
		var qy := 350.0 + sin(qa) * qr * 0.4
		draw_line(Vector2(qx - 8, qy + 5), Vector2(qx + 8, qy - 5), Color(0.3, 0.2, 0.12, 0.35), 1.5)
		draw_colored_polygon(PackedVector2Array([Vector2(qx + 6, qy - 4), Vector2(qx + 14, qy - 10), Vector2(qx + 12, qy)]), Color(0.25, 0.15, 0.08, 0.3))
	# Shadow tendrils from edges
	for st in range(8):
		var from_left := st < 4
		var sx := 0.0 if from_left else 1280.0
		var sy := 200.0 + float(st % 4) * 80.0
		var reach := 80.0 + sin(_time * 0.7 + float(st)) * 30.0
		var dir := 1.0 if from_left else -1.0
		for seg in range(6):
			var seg_x := sx + dir * float(seg) * (reach / 6.0)
			var seg_y := sy + sin(float(seg) * 0.5 + _time * 0.5) * 10.0
			draw_rect(Rect2(seg_x - 2, seg_y - 2, 4 + reach / 6.0, 4), Color(0.03, 0.01, 0.05, 0.3 - float(seg) * 0.04))

func _draw_robin_ch1(sky_color: Color, ground_color: Color) -> void:
	# --- SKY GRADIENT ---
	var sky_top := Color(0.02, 0.06, 0.10)
	var sky_mid := Color(0.04, 0.12, 0.08)
	var sky_horizon := Color(0.12, 0.18, 0.06)
	var amber_haze := Color(0.25, 0.15, 0.04, 0.35)
	for i in range(60):
		var t: float = float(i) / 59.0
		var col: Color
		if t < 0.5:
			col = sky_top.lerp(sky_mid, t * 2.0)
		else:
			col = sky_mid.lerp(sky_horizon, (t - 0.5) * 2.0)
		var haze_strength: float = clampf(t - 0.5, 0.0, 0.5) * 2.0
		col = col.lerp(amber_haze, haze_strength * 0.4)
		var y0: float = 50.0 + float(i) * 9.6
		draw_rect(Rect2(0, y0, 1280, 10.6), col)

	# --- STARS ---
	var star_seeds: Array = [37, 71, 113, 157, 199, 241, 283, 311, 347, 389, 421, 463, 509, 557, 601, 643, 691, 733, 787, 823]
	for s in range(star_seeds.size()):
		var sd: int = star_seeds[s]
		var sx: float = fmod(float(sd) * 7.3, 1280.0)
		var sy: float = 55.0 + fmod(float(sd) * 3.7, 200.0)
		var twinkle: float = 0.4 + 0.6 * absf(sin(_time * 1.5 + float(sd)))
		draw_circle(Vector2(sx, sy), 1.0 + twinkle * 0.5, Color(0.8, 0.85, 0.95, twinkle * 0.7))

	# --- FULL MOON ---
	var moon_center := Vector2(900, 120)
	for g in range(5):
		draw_circle(moon_center, 42.0 + float(g) * 12.0, Color(0.7, 0.75, 0.9, 0.06 - float(g) * 0.01))
	draw_circle(moon_center, 42.0, Color(0.82, 0.85, 0.92))
	draw_circle(moon_center + Vector2(-8, -5), 40.0, Color(0.78, 0.80, 0.88))
	draw_circle(moon_center + Vector2(-10, 5), 6.0, Color(0.72, 0.74, 0.82, 0.4))
	draw_circle(moon_center + Vector2(12, -8), 4.0, Color(0.72, 0.74, 0.82, 0.3))
	draw_circle(moon_center + Vector2(5, 14), 3.5, Color(0.72, 0.74, 0.82, 0.35))

	# --- MOONBEAMS ---
	for mb in range(5):
		var beam_x: float = 850.0 + float(mb) * 30.0
		var sway: float = sin(_time * 0.4 + float(mb) * 1.2) * 15.0
		var beam_alpha: float = 0.03 + 0.015 * sin(_time * 0.6 + float(mb))
		draw_colored_polygon(PackedVector2Array([Vector2(beam_x - 5 + sway * 0.3, 160), Vector2(beam_x + 5 + sway * 0.3, 160), Vector2(beam_x + 40 + sway, 620), Vector2(beam_x - 40 + sway, 620)]), Color(0.7, 0.75, 0.9, beam_alpha))

	# --- NOTTINGHAM CASTLE SILHOUETTE ---
	var castle_col := Color(0.03, 0.04, 0.06)
	draw_colored_polygon(PackedVector2Array([Vector2(950, 280), Vector2(1000, 200), Vector2(1050, 180), Vector2(1120, 170), Vector2(1200, 185), Vector2(1280, 220), Vector2(1280, 280)]), castle_col)
	draw_rect(Rect2(1060, 100, 80, 80), castle_col)
	for bt in range(5):
		draw_rect(Rect2(1060 + bt * 18, 92, 10, 12), castle_col)
	draw_rect(Rect2(1020, 110, 30, 70), castle_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1015, 110), Vector2(1035, 75), Vector2(1055, 110)]), castle_col)
	draw_rect(Rect2(1150, 105, 35, 75), castle_col)
	draw_colored_polygon(PackedVector2Array([Vector2(1145, 105), Vector2(1167, 68), Vector2(1190, 105)]), castle_col)
	draw_circle(Vector2(1100, 180), 15.0, Color(0.02, 0.02, 0.04))
	draw_rect(Rect2(1085, 180, 30, 20), Color(0.02, 0.02, 0.04))
	draw_rect(Rect2(1000, 170, 60, 10), castle_col)
	draw_rect(Rect2(1140, 165, 70, 10), castle_col)
	var tf1: float = 0.5 + 0.5 * sin(_time * 6.0 + 1.0)
	var tf2: float = 0.5 + 0.5 * sin(_time * 7.3 + 3.0)
	draw_circle(Vector2(1035, 130), 2.5, Color(0.9, 0.5, 0.1, 0.5 + tf1 * 0.5))
	draw_circle(Vector2(1035, 130), 5.0, Color(0.9, 0.4, 0.1, 0.15 + tf1 * 0.1))
	draw_circle(Vector2(1167, 125), 2.5, Color(0.9, 0.5, 0.1, 0.5 + tf2 * 0.5))
	draw_circle(Vector2(1167, 125), 5.0, Color(0.9, 0.4, 0.1, 0.15 + tf2 * 0.1))

	# --- DISTANT BACKGROUND TREES ---
	for dt in range(18):
		var dtx: float = float(dt) * 75.0 + 20.0
		var dty: float = 260.0 + sin(float(dt) * 2.3) * 30.0
		var dts: float = 50.0 + sin(float(dt) * 1.7) * 15.0
		draw_rect(Rect2(dtx - 3, dty, 6, 60), Color(0.02, 0.05, 0.08, 0.85))
		draw_circle(Vector2(dtx, dty - 10), dts * 0.5, Color(0.02, 0.05, 0.08, 0.85))
		draw_circle(Vector2(dtx - dts * 0.25, dty), dts * 0.4, Color(0.02, 0.05, 0.08, 0.85))

	# --- BROOK / STREAM ---
	var brook_pts: PackedVector2Array = PackedVector2Array()
	var brook_bottom: PackedVector2Array = PackedVector2Array()
	var bpx_arr: Array = [500, 530, 570, 620, 660, 680, 690, 700, 720, 750]
	var bpy_arr: Array = [380, 395, 415, 430, 445, 465, 485, 510, 540, 570]
	for bp in range(bpx_arr.size()):
		brook_pts.append(Vector2(float(bpx_arr[bp]) - 12, float(bpy_arr[bp])))
		brook_bottom.insert(0, Vector2(float(bpx_arr[bp]) + 12, float(bpy_arr[bp])))
	brook_pts.append_array(brook_bottom)
	draw_colored_polygon(brook_pts, Color(0.05, 0.1, 0.25, 0.8))
	for sh in range(8):
		var shx: float = float(bpx_arr[sh]) + sin(_time * 2.5 + float(sh)) * 4.0
		var shy: float = float(bpy_arr[sh]) + cos(_time * 1.8 + float(sh)) * 2.0
		draw_line(Vector2(shx - 5, shy), Vector2(shx + 5, shy), Color(0.2, 0.3, 0.6, 0.15 + 0.1 * sin(_time * 2.0)), 1.5)

	# --- LITTLE JOHN'S BRIDGE ---
	var bridge_x: float = 660.0
	var bridge_y: float = 440.0
	for pl in range(6):
		draw_rect(Rect2(bridge_x - 15 + float(pl) * 7, bridge_y - 3, 6, 28), Color(0.25, 0.15, 0.06))
	draw_line(Vector2(bridge_x - 18, bridge_y - 6), Vector2(bridge_x + 30, bridge_y - 6), Color(0.15, 0.08, 0.03), 2.5)
	draw_line(Vector2(bridge_x - 18, bridge_y + 28), Vector2(bridge_x + 30, bridge_y + 28), Color(0.15, 0.08, 0.03), 2.5)
	draw_rect(Rect2(bridge_x - 20, bridge_y - 10, 5, 42), Color(0.15, 0.08, 0.03))
	draw_rect(Rect2(bridge_x + 28, bridge_y - 10, 5, 42), Color(0.15, 0.08, 0.03))

	# --- GROUND LAYERS ---
	draw_rect(Rect2(0, 480, 1280, 240), Color(0.04, 0.12, 0.03))
	draw_rect(Rect2(0, 490, 1280, 130), Color(0.06, 0.14, 0.04))
	draw_rect(Rect2(0, 580, 1280, 48), Color(0.05, 0.10, 0.03))
	# moss rocks
	var rock_seeds: Array = [120, 340, 580, 800, 1050, 250, 700, 950]
	for r in range(rock_seeds.size()):
		var rx: float = float(rock_seeds[r])
		var ry: float = 530.0 + fmod(float(rock_seeds[r]) * 0.37, 60.0)
		var rs: float = 6.0 + fmod(float(rock_seeds[r]) * 0.13, 8.0)
		draw_circle(Vector2(rx, ry), rs, Color(0.15, 0.15, 0.12))
		draw_arc(Vector2(rx, ry - rs * 0.3), rs * 0.8, 2.8, 6.0, 8, Color(0.1, 0.3, 0.08, 0.7), 2.0)
	# ferns
	for f in range(15):
		var fx: float = fmod(float(f) * 97.0, 1280.0)
		var fy: float = 510.0 + fmod(float(f) * 43.0, 70.0)
		for frond in range(5):
			var angle: float = -0.8 + float(frond) * 0.4
			draw_line(Vector2(fx, fy), Vector2(fx + cos(angle) * 14.0, fy - sin(absf(angle) + 0.5) * 10.0), Color(0.06, 0.22, 0.05, 0.8), 1.5)
	# fallen leaves
	for lf in range(40):
		var lfx: float = fmod(float(lf) * 31.7, 1280.0)
		var lfy: float = 500.0 + fmod(float(lf) * 17.3, 100.0)
		var leaf_colors: Array = [Color(0.6, 0.35, 0.05, 0.6), Color(0.7, 0.2, 0.05, 0.5), Color(0.65, 0.5, 0.1, 0.55)]
		draw_circle(Vector2(lfx, lfy), 1.5 + fmod(float(lf) * 0.3, 1.5), leaf_colors[lf % 3])

	# --- PATH ---
	if enemy_path and enemy_path.curve:
		var pp: PackedVector2Array = enemy_path.curve.get_baked_points()
		if pp.size() > 1:
			for i in range(pp.size() - 1):
				draw_line(pp[i], pp[i + 1], Color(0.06, 0.18, 0.04, 0.5), 32.0)
			for i in range(pp.size() - 1):
				draw_line(pp[i], pp[i + 1], Color(0.08, 0.05, 0.02), 28.0)
			for i in range(pp.size() - 1):
				draw_line(pp[i], pp[i + 1], Color(0.18, 0.12, 0.05), 22.0)
			for i in range(pp.size() - 1):
				var p0: Vector2 = pp[i]
				var p1: Vector2 = pp[i + 1]
				var dir: Vector2 = (p1 - p0).normalized()
				var perp := Vector2(-dir.y, dir.x)
				draw_line(p0 + perp * 4.0, p1 + perp * 4.0, Color(0.22, 0.16, 0.08, 0.5), 1.5)
				draw_line(p0 - perp * 4.0, p1 - perp * 4.0, Color(0.22, 0.16, 0.08, 0.5), 1.5)
			for pb in range(20):
				var idx: int = (pb * 7) % pp.size()
				draw_circle(pp[idx] + Vector2(sin(float(pb) * 3.1) * 8.0, cos(float(pb) * 2.7) * 3.0), 1.5, Color(0.25, 0.2, 0.15, 0.6))

	# --- MIDGROUND TREES ---
	var mtx_arr: Array = [320, 480, 750, 920, 1100, 60, 1220]
	var mty_arr: Array = [340, 370, 320, 360, 340, 380, 350]
	for mt in range(mtx_arr.size()):
		var mtx: float = float(mtx_arr[mt])
		var mty: float = float(mty_arr[mt])
		draw_rect(Rect2(mtx - 5, mty, 10, 120), Color(0.12, 0.07, 0.03))
		draw_line(Vector2(mtx - 5, mty + 115), Vector2(mtx - 18, mty + 125), Color(0.12, 0.07, 0.03), 3.0)
		draw_line(Vector2(mtx + 5, mty + 115), Vector2(mtx + 16, mty + 125), Color(0.12, 0.07, 0.03), 3.0)
		draw_circle(Vector2(mtx, mty - 20), 35.0, Color(0.04, 0.14, 0.03, 0.9))
		draw_circle(Vector2(mtx - 25, mty - 5), 28.0, Color(0.04, 0.14, 0.03, 0.9))
		draw_circle(Vector2(mtx + 22, mty - 8), 30.0, Color(0.04, 0.14, 0.03, 0.9))

	# --- THE MAJOR OAK ---
	var oak_x: float = 150.0
	var oak_y: float = 300.0
	# massive trunk
	draw_colored_polygon(PackedVector2Array([Vector2(oak_x - 30, oak_y + 200), Vector2(oak_x - 35, oak_y + 150), Vector2(oak_x - 28, oak_y + 80), Vector2(oak_x - 22, oak_y + 20), Vector2(oak_x - 15, oak_y - 20), Vector2(oak_x + 15, oak_y - 20), Vector2(oak_x + 25, oak_y + 20), Vector2(oak_x + 30, oak_y + 80), Vector2(oak_x + 38, oak_y + 150), Vector2(oak_x + 32, oak_y + 200)]), Color(0.14, 0.08, 0.03))
	# bark texture
	for bl in range(8):
		var by: float = oak_y + 10.0 + float(bl) * 22.0
		draw_line(Vector2(oak_x - 18 + sin(float(bl) * 1.5) * 5.0, by), Vector2(oak_x - 12 + sin(float(bl) * 1.5) * 5.0, by + 18), Color(0.08, 0.04, 0.02), 1.5)
		draw_line(Vector2(oak_x + 8 - sin(float(bl) * 1.5) * 5.0, by + 5), Vector2(oak_x + 14 - sin(float(bl) * 1.5) * 5.0, by + 20), Color(0.08, 0.04, 0.02), 1.5)
	# massive branches
	draw_line(Vector2(oak_x - 15, oak_y), Vector2(oak_x - 80, oak_y - 60), Color(0.14, 0.08, 0.03), 10.0)
	draw_line(Vector2(oak_x + 15, oak_y), Vector2(oak_x + 90, oak_y - 50), Color(0.14, 0.08, 0.03), 9.0)
	draw_line(Vector2(oak_x - 10, oak_y - 10), Vector2(oak_x - 50, oak_y - 90), Color(0.14, 0.08, 0.03), 7.0)
	draw_line(Vector2(oak_x + 10, oak_y - 10), Vector2(oak_x + 40, oak_y - 80), Color(0.14, 0.08, 0.03), 7.0)
	draw_line(Vector2(oak_x, oak_y - 15), Vector2(oak_x + 10, oak_y - 100), Color(0.14, 0.08, 0.03), 6.0)
	draw_line(Vector2(oak_x - 80, oak_y - 60), Vector2(oak_x - 110, oak_y - 85), Color(0.08, 0.04, 0.02), 4.0)
	draw_line(Vector2(oak_x + 90, oak_y - 50), Vector2(oak_x + 130, oak_y - 70), Color(0.08, 0.04, 0.02), 4.0)
	# enormous canopy
	for cp_data in [[0, -80, 70], [-60, -50, 55], [65, -45, 55], [-30, -100, 45], [30, -95, 48], [-85, -70, 35], [95, -60, 38]]:
		draw_circle(Vector2(oak_x + cp_data[0], oak_y + cp_data[1]), float(cp_data[2]), Color(0.03, 0.12, 0.02, 0.95))
	draw_circle(Vector2(oak_x + 20, oak_y - 110), 20.0, Color(0.05, 0.18, 0.04, 0.85))
	# treehouse platform
	draw_rect(Rect2(oak_x - 25, oak_y - 30, 55, 5), Color(0.2, 0.12, 0.04))
	draw_rect(Rect2(oak_x - 25, oak_y - 48, 3, 18), Color(0.18, 0.1, 0.04))
	draw_rect(Rect2(oak_x + 27, oak_y - 48, 3, 18), Color(0.18, 0.1, 0.04))
	draw_line(Vector2(oak_x - 25, oak_y - 48), Vector2(oak_x + 30, oak_y - 48), Color(0.18, 0.1, 0.04), 2.0)
	# rope ladder
	draw_line(Vector2(oak_x + 5, oak_y - 25), Vector2(oak_x + 5, oak_y + 55), Color(0.35, 0.25, 0.1), 1.5)
	draw_line(Vector2(oak_x + 15, oak_y - 25), Vector2(oak_x + 15, oak_y + 55), Color(0.35, 0.25, 0.1), 1.5)
	for rung in range(6):
		draw_line(Vector2(oak_x + 5, oak_y - 15 + float(rung) * 11.0), Vector2(oak_x + 15, oak_y - 15 + float(rung) * 11.0), Color(0.35, 0.25, 0.1), 1.5)
	# hanging game
	draw_line(Vector2(oak_x + 90, oak_y - 50), Vector2(oak_x + 90, oak_y - 30), Color(0.35, 0.25, 0.1), 1.5)
	draw_circle(Vector2(oak_x + 90, oak_y - 24), 4.0, Color(0.2, 0.12, 0.06))
	draw_line(Vector2(oak_x + 90, oak_y - 20), Vector2(oak_x + 87, oak_y - 12), Color(0.18, 0.1, 0.05), 1.5)

	# --- ROBIN HOOD'S CAMP ---
	var camp_x: float = 160.0
	var camp_y: float = 510.0
	draw_colored_polygon(PackedVector2Array([Vector2(camp_x - 50, camp_y + 30), Vector2(camp_x - 25, camp_y - 10), Vector2(camp_x, camp_y + 30)]), Color(0.12, 0.2, 0.06))
	draw_colored_polygon(PackedVector2Array([Vector2(camp_x - 32, camp_y + 30), Vector2(camp_x - 25, camp_y + 8), Vector2(camp_x - 18, camp_y + 30)]), Color(0.04, 0.04, 0.03))
	draw_colored_polygon(PackedVector2Array([Vector2(camp_x + 30, camp_y + 25), Vector2(camp_x + 50, camp_y - 5), Vector2(camp_x + 70, camp_y + 25)]), Color(0.2, 0.14, 0.06))
	draw_colored_polygon(PackedVector2Array([Vector2(camp_x + 5, camp_y + 10), Vector2(camp_x + 18, camp_y - 12), Vector2(camp_x + 32, camp_y + 10)]), Color(0.08, 0.14, 0.04))
	draw_rect(Rect2(camp_x - 15, camp_y + 35, 30, 5), Color(0.2, 0.12, 0.04))
	draw_rect(Rect2(camp_x + 20, camp_y + 40, 25, 5), Color(0.2, 0.12, 0.04))
	# weapon rack
	draw_line(Vector2(camp_x + 85, camp_y + 5), Vector2(camp_x + 85, camp_y + 45), Color(0.2, 0.12, 0.05), 2.5)
	draw_line(Vector2(camp_x + 100, camp_y + 5), Vector2(camp_x + 100, camp_y + 45), Color(0.2, 0.12, 0.05), 2.5)
	draw_arc(Vector2(camp_x + 89, camp_y + 20), 8.0, 1.2, 5.1, 10, Color(0.3, 0.18, 0.06), 1.5)
	draw_arc(Vector2(camp_x + 95, camp_y + 25), 7.0, 1.2, 5.1, 10, Color(0.3, 0.18, 0.06), 1.5)
	# WANTED poster
	draw_rect(Rect2(oak_x + 35, oak_y + 60, 22, 28), Color(0.7, 0.6, 0.4, 0.8))
	draw_rect(Rect2(oak_x + 36, oak_y + 61, 20, 5), Color(0.3, 0.1, 0.05, 0.7))
	for tl in range(4):
		draw_line(Vector2(oak_x + 38, oak_y + 70 + float(tl) * 4.5), Vector2(oak_x + 54, oak_y + 70 + float(tl) * 4.5), Color(0.3, 0.2, 0.1, 0.5), 1.0)
	draw_circle(Vector2(oak_x + 46, oak_y + 59), 1.5, Color(0.3, 0.3, 0.3))

	# --- DECORATIONS ---
	for dec in _decorations:
		var dtype: String = dec["type"]
		var dpos: Vector2 = dec["pos"]
		var dsize: float = dec["size"]
		var dextra: float = dec["extra"]
		if dtype == "oak_tree":
			draw_rect(Rect2(dpos.x - dsize * 0.15, dpos.y - dsize * 0.2, dsize * 0.3, dsize * 0.8), Color(0.1, 0.06, 0.02))
			draw_circle(dpos + Vector2(0, -dsize * 0.4), dsize * 0.5, Color(0.03, 0.15, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, -dsize * 0.2), dsize * 0.35, Color(0.03, 0.15, 0.03, 0.9))
		elif dtype == "target":
			draw_circle(dpos, 7.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 5.0, Color(0.7, 0.15, 0.1))
			draw_circle(dpos, 3.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 1.5, Color(0.7, 0.15, 0.1))
			draw_line(dpos + Vector2(-8, -4), dpos, Color(0.3, 0.2, 0.05), 1.5)
			draw_line(Vector2(dpos.x, dpos.y + 7), Vector2(dpos.x, dpos.y + 16), Color(0.2, 0.12, 0.04), 2.5)
		elif dtype == "bush":
			draw_circle(dpos, dsize * 0.5, Color(0.04, 0.16 + dextra * 0.05, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, dsize * 0.1), dsize * 0.35, Color(0.04, 0.16, 0.03, 0.9))
			draw_circle(dpos + Vector2(dsize * 0.25, dsize * 0.08), dsize * 0.38, Color(0.04, 0.16, 0.03, 0.9))
			if dextra > 0.5:
				for b in range(3):
					draw_circle(dpos + Vector2(cos(float(b) * 2.1) * dsize * 0.25, sin(float(b) * 2.1) * dsize * 0.15 - dsize * 0.1), 2.0, Color(0.5, 0.05, 0.1))
		elif dtype == "deer":
			var deer_col := Color(0.15, 0.1, 0.05)
			var facing: float = -1.0 if dextra > 0.5 else 1.0
			var body_pts: PackedVector2Array = PackedVector2Array()
			for da in range(16):
				body_pts.append(dpos + Vector2(cos(float(da) * TAU / 16.0) * dsize * 0.4 * facing, sin(float(da) * TAU / 16.0) * dsize * 0.2))
			draw_colored_polygon(body_pts, deer_col)
			var head_pos: Vector2 = dpos + Vector2(dsize * 0.5 * facing, -dsize * 0.35)
			draw_line(dpos + Vector2(dsize * 0.3 * facing, -dsize * 0.1), head_pos, deer_col, dsize * 0.1)
			draw_circle(head_pos, dsize * 0.1, deer_col)
			var ab: Vector2 = head_pos + Vector2(0, -dsize * 0.1)
			draw_line(ab, ab + Vector2(-dsize * 0.12 * facing, -dsize * 0.2), deer_col, 1.5)
			draw_line(ab, ab + Vector2(dsize * 0.08 * facing, -dsize * 0.22), deer_col, 1.5)
			draw_line(ab + Vector2(-dsize * 0.12 * facing, -dsize * 0.2), ab + Vector2(-dsize * 0.2 * facing, -dsize * 0.25), deer_col, 1.0)
			for li in range(4):
				var loff: Array = [-0.2, -0.08, 0.08, 0.2]
				draw_line(Vector2(dpos.x + loff[li] * dsize * facing, dpos.y + dsize * 0.15), Vector2(dpos.x + loff[li] * dsize * facing + facing * 2.0, dpos.y + dsize * 0.45), deer_col, 2.0)
			draw_circle(head_pos + Vector2(dsize * 0.05 * facing, -dsize * 0.02), 1.0, Color(0.4, 0.3, 0.1))
		elif dtype == "campfire":
			var fi: float = 0.7 + 0.3 * sin(_time * 5.0 + dextra * 10.0)
			draw_circle(dpos, dsize * 3.0, Color(0.4, 0.15, 0.02, 0.08 * fi))
			draw_circle(dpos, dsize * 2.0, Color(0.5, 0.2, 0.03, 0.12 * fi))
			for fs in range(8):
				draw_circle(dpos + Vector2(cos(float(fs) * TAU / 8.0) * dsize * 0.7, sin(float(fs) * TAU / 8.0) * dsize * 0.35), 3.0, Color(0.2, 0.18, 0.15))
			draw_line(dpos + Vector2(-dsize * 0.5, dsize * 0.15), dpos + Vector2(dsize * 0.5, dsize * 0.15), Color(0.2, 0.1, 0.02), 4.0)
			for fl in range(6):
				var flame_x: float = dpos.x + sin(float(fl) * 1.7 + _time * 4.0) * dsize * 0.3
				var flame_h: float = dsize * (0.6 + 0.4 * sin(_time * 6.0 + float(fl) * 2.0)) * fi
				var fc: Color = Color(0.95, 0.85, 0.2, 0.9) if fl < 2 else (Color(0.95, 0.5, 0.05, 0.85) if fl < 4 else Color(0.8, 0.2, 0.02, 0.7))
				draw_line(Vector2(flame_x, dpos.y + dsize * 0.1), Vector2(flame_x + sin(_time * 3.0 + float(fl)) * 3.0, dpos.y - flame_h), fc, 3.5 - float(fl) * 0.3)
			draw_circle(dpos + Vector2(0, -dsize * 0.1), dsize * 0.2, Color(1.0, 0.9, 0.4, 0.4 * fi))
			# cooking spit and pot
			draw_line(Vector2(dpos.x - dsize * 1.2, dpos.y + dsize * 0.2), Vector2(dpos.x - dsize * 1.2, dpos.y - dsize * 0.6), Color(0.2, 0.12, 0.04), 2.5)
			draw_line(Vector2(dpos.x + dsize * 1.2, dpos.y + dsize * 0.2), Vector2(dpos.x + dsize * 1.2, dpos.y - dsize * 0.6), Color(0.2, 0.12, 0.04), 2.5)
			draw_line(Vector2(dpos.x - dsize * 1.2, dpos.y - dsize * 0.6), Vector2(dpos.x + dsize * 1.2, dpos.y - dsize * 0.6), Color(0.2, 0.12, 0.04), 2.0)
			draw_arc(Vector2(dpos.x, dpos.y - dsize * 0.3), dsize * 0.2, 0, PI, 10, Color(0.12, 0.12, 0.12), 3.0)
			# smoke
			for sm in range(4):
				var smoke_t: float = fmod(_time * 0.8 + float(sm) * 0.7, 3.0)
				draw_circle(Vector2(dpos.x + sin(smoke_t * 2.0 + float(sm)) * 10.0, dpos.y - dsize * 0.8 - smoke_t * 30.0), 4.0 + smoke_t * 5.0, Color(0.4, 0.4, 0.45, clampf(0.25 - smoke_t * 0.08, 0.0, 0.25)))
			# sparks
			for sp in range(6):
				var spark_t: float = fmod(_time * 1.5 + float(sp) * 0.5, 2.0)
				draw_circle(Vector2(dpos.x + sin(spark_t * 3.0 + float(sp) * 2.0) * 15.0, dpos.y - dsize * 0.3 - spark_t * 40.0), 1.0, Color(1.0, 0.7, 0.1, clampf(0.8 - spark_t * 0.4, 0.0, 0.8)))

	# --- FOREGROUND TREE FRAMING ---
	draw_rect(Rect2(-10, 200, 35, 500), Color(0.06, 0.03, 0.01))
	draw_circle(Vector2(12, 180), 60.0, Color(0.02, 0.08, 0.02, 0.95))
	draw_circle(Vector2(-15, 210), 45.0, Color(0.02, 0.08, 0.02, 0.95))
	draw_line(Vector2(25, 250), Vector2(120, 200), Color(0.06, 0.03, 0.01), 5.0)
	draw_rect(Rect2(1258, 280, 30, 440), Color(0.06, 0.03, 0.01))
	draw_circle(Vector2(1270, 260), 50.0, Color(0.02, 0.08, 0.02, 0.95))

	# --- FIREFLIES ---
	for ff in range(18):
		var ff_phase: float = _time * 0.6 + float(ff) * 1.1
		var ff_x: float = 100.0 + fmod(float(ff) * 73.0, 1080.0) + sin(ff_phase) * 20.0
		var ff_y: float = 300.0 + fmod(float(ff) * 47.0, 250.0) + cos(ff_phase * 0.7) * 15.0
		var ff_alpha: float = clampf(0.5 + 0.5 * sin(ff_phase * 2.5), 0.0, 1.0)
		draw_circle(Vector2(ff_x, ff_y), 4.0, Color(0.9, 0.8, 0.2, ff_alpha * 0.3))
		draw_circle(Vector2(ff_x, ff_y), 1.5, Color(1.0, 0.95, 0.4, ff_alpha))

	# --- FALLING LEAVES ---
	for fl in range(8):
		var leaf_phase: float = fmod(_time * 0.3 + float(fl) * 2.5, 6.0)
		var leaf_x: float = 100.0 + fmod(float(fl) * 157.0, 1080.0) + sin(leaf_phase * 1.5) * 30.0 + leaf_phase * 8.0
		var leaf_y: float = 100.0 + leaf_phase * 85.0
		if leaf_y < 620.0:
			var leaf_cols: Array = [Color(0.7, 0.4, 0.05, 0.6), Color(0.6, 0.15, 0.05, 0.6), Color(0.65, 0.5, 0.1, 0.6)]
			draw_circle(Vector2(leaf_x + cos(leaf_phase * 3.0) * 3.0, leaf_y + sin(leaf_phase * 3.0) * 1.5), 2.5, leaf_cols[fl % 3])

	# --- WARM GLOW OVERLAY ---
	for dec3 in _decorations:
		if dec3["type"] == "campfire":
			var gp: Vector2 = dec3["pos"]
			var gpulse: float = 0.8 + 0.2 * sin(_time * 3.0)
			for gr in range(4):
				draw_circle(gp, 60.0 + float(gr) * 40.0, Color(0.9, 0.5, 0.1, (0.04 - float(gr) * 0.008) * gpulse))

	# --- BRANCHES OVER MOON ---
	draw_line(Vector2(870, 100), Vector2(940, 130), Color(0.02, 0.06, 0.02), 3.5)
	draw_line(Vector2(920, 90), Vector2(960, 140), Color(0.02, 0.06, 0.02), 2.5)
	draw_circle(Vector2(935, 125), 10.0, Color(0.02, 0.07, 0.02, 0.85))
	draw_circle(Vector2(955, 120), 8.0, Color(0.02, 0.07, 0.02, 0.8))

func _draw_alice_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Oversized moon
	var moon_pos = Vector2(1000, 100)
	draw_circle(moon_pos, 55, Color(0.85, 0.7, 0.9, 0.3))
	draw_circle(moon_pos, 45, Color(0.9, 0.75, 0.95, 0.45))
	draw_circle(moon_pos, 35, Color(0.95, 0.82, 0.98, 0.55))
	draw_arc(moon_pos, 50.0 + sin(_time * 0.5) * 3.0, 0, TAU, 48, Color(0.9, 0.75, 0.95, 0.1), 2.0)
	# Cheshire Cat grin
	var grin_alpha = (sin(_time * 0.7) + 1.0) * 0.5
	if grin_alpha > 0.15:
		var gc = Vector2(950, 350) + Vector2(sin(_time * 0.3) * 5.0, cos(_time * 0.4) * 3.0)
		draw_arc(gc, 20.0, 0.1, PI - 0.1, 16, Color(0.9, 0.3, 0.8, grin_alpha * 0.6), 2.5)
		for i in range(7):
			var tooth_a = 0.2 + float(i) * 0.37
			draw_line(gc + Vector2.from_angle(tooth_a) * 18.0, gc + Vector2.from_angle(tooth_a) * 22.0, Color(0.95, 0.95, 0.9, grin_alpha * 0.5), 1.5)
		draw_circle(gc + Vector2(-12, -18), 5.0, Color(0.8, 0.9, 0.1, grin_alpha * 0.7))
		draw_circle(gc + Vector2(12, -18), 5.0, Color(0.8, 0.9, 0.1, grin_alpha * 0.7))
		draw_circle(gc + Vector2(-12, -18), 2.0, Color(0.1, 0.05, 0.2, grin_alpha * 0.7))
		draw_circle(gc + Vector2(12, -18), 2.0, Color(0.1, 0.05, 0.2, grin_alpha * 0.7))
	# Checkerboard patches
	for i in range(12):
		var cx = float(i) * 110.0 + 20.0
		for j in range(6):
			var cy = 380.0 + float(j) * 40.0
			var is_white = (i + j) % 2 == 0
			var tc = Color(0.85, 0.82, 0.78, 0.08) if is_white else Color(0.05, 0.04, 0.06, 0.1)
			draw_rect(Rect2(cx, cy, 40, 40), tc)
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"giant_mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var glow_pulse = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 0.8, mp.y - ms * 4.0, ms * 1.6, ms * 4.0), Color(0.85, 0.8, 0.7, 0.5))
				var cap_center = mp + Vector2(0, -ms * 4.5)
				draw_circle(cap_center, ms * 3.0 + 4.0, Color(0.7, 0.2, 0.8, 0.1 + glow_pulse * 0.08))
				draw_circle(cap_center, ms * 3.0, Color(0.8, 0.25, 0.4, 0.5))
				draw_circle(cap_center + Vector2(-ms, -ms * 0.5), ms * 0.5, Color(1, 0.95, 0.85, 0.4))
			"floating_card":
				var cp = dec["pos"]
				var drift_y = sin(_time * 0.8 + dec["extra"]) * 15.0
				var drift_x = cos(_time * 0.5 + dec["extra"]) * 8.0
				var card_pos = cp + Vector2(drift_x, drift_y)
				draw_rect(Rect2(card_pos.x - 4, card_pos.y - 6, 8, 12), Color(1.0, 0.98, 0.9, 0.25))
				var suit_col = Color(0.8, 0.15, 0.15, 0.35) if dec["extra"] > 3.0 else Color(0.1, 0.1, 0.1, 0.35)
				draw_circle(card_pos, 2.0, suit_col)
			"rose":
				var rp = dec["pos"]
				var sway = sin(_time * 1.2 + dec["extra"]) * 2.0
				draw_line(rp, rp + Vector2(sway, -12), Color(0.15, 0.4, 0.1, 0.45), 1.5)
				var bloom = rp + Vector2(sway, -12)
				var rc = Color(0.85, 0.1, 0.15, 0.5) if dec["extra"] < 0.5 else Color(0.95, 0.9, 0.85, 0.5)
				draw_circle(bloom, dec["size"], rc)
			"teacup":
				var tp = dec["pos"]
				draw_rect(Rect2(tp.x - 4, tp.y - 5, 8, 6), Color(0.8, 0.75, 0.6, 0.4))
				draw_arc(Vector2(tp.x + 5, tp.y - 2), 3, -PI * 0.5, PI * 0.5, 6, Color(0.8, 0.75, 0.6, 0.35), 1.0)
	# Path (mosaic tile road)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.15, 0.08, 0.18), 52.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.55, 0.4, 0.6), 44.0)
		for i in range(0, points.size() - 1, 8):
			var tile_alt = (i / 8) % 2 == 0
			var tc = Color(0.7, 0.5, 0.75, 0.35) if tile_alt else Color(0.45, 0.3, 0.55, 0.35)
			draw_rect(Rect2(points[i].x - 4, points[i].y - 4, 8, 8), tc)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.7, 0.55, 0.75, 0.2), 12.0)
	# Foreground haze
	for i in range(6):
		draw_circle(Vector2(float(i) * 220.0 + sin(_time * 0.3 + float(i)) * 30.0, 580.0), 60.0, Color(0.6, 0.3, 0.7, 0.03))

func _draw_oz_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Tornado funnel in distance
	var tornado_x = 1100.0 + sin(_time * 0.3) * 15.0
	for i in range(20):
		var t = float(i) / 19.0
		var y_pos = lerp(400.0, 60.0, t)
		var width = lerp(50.0, 8.0, t)
		var sway = sin(_time * 2.0 + t * 4.0) * (10.0 * (1.0 - t))
		draw_line(Vector2(tornado_x + sway - width, y_pos), Vector2(tornado_x + sway + width, y_pos), Color(0.25, 0.28, 0.2, 0.08 + t * 0.06), 3.0)
	# Emerald City silhouette
	var city_x = 300.0
	var city_base_y = 180.0
	draw_rect(Rect2(city_x - 70, city_base_y, 140, 20), Color(0.1, 0.3, 0.12, 0.35))
	var towers_data = [{"x": -50.0, "h": 80.0, "w": 14.0}, {"x": -25.0, "h": 110.0, "w": 16.0}, {"x": 0.0, "h": 140.0, "w": 20.0}, {"x": 25.0, "h": 100.0, "w": 15.0}, {"x": 50.0, "h": 70.0, "w": 12.0}]
	for td in towers_data:
		var tx = city_x + td["x"]
		var tw = td["w"]
		var th = td["h"]
		draw_rect(Rect2(tx - tw * 0.5, city_base_y - th, tw, th), Color(0.12, 0.35, 0.15, 0.4))
		draw_colored_polygon(PackedVector2Array([Vector2(tx - tw * 0.5, city_base_y - th), Vector2(tx + tw * 0.5, city_base_y - th), Vector2(tx, city_base_y - th - 20)]), Color(0.1, 0.4, 0.15, 0.45))
	for i in range(8):
		var sparkle = (sin(_time * 3.0 + float(i) * 1.7) + 1.0) * 0.5
		if sparkle > 0.6:
			draw_circle(Vector2(city_x - 55.0 + float(i) * 15.0, city_base_y - 30.0 - float(i % 3) * 35.0), 1.5, Color(0.4, 1.0, 0.5, sparkle * 0.5))
	draw_circle(Vector2(city_x, city_base_y - 50), 80.0, Color(0.15, 0.5, 0.2, 0.04 + sin(_time) * 0.015))
	# Ground terrain
	draw_rect(Rect2(0, 440, 1280, 190), Color(0.12, 0.22, 0.06, 0.3))
	draw_rect(Rect2(0, 520, 1280, 110), Color(0.1, 0.18, 0.04, 0.25))
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"poppy":
				var pp = dec["pos"]
				var ps = dec["size"]
				var sway = sin(_time * 1.3 + dec["extra"]) * 2.0
				draw_line(pp, pp + Vector2(sway, -ps * 6.0), Color(0.15, 0.35, 0.1, 0.5), 1.0)
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 2.5, Color(0.85, 0.12, 0.1, 0.55))
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 0.7, Color(0.15, 0.1, 0.05, 0.5))
			"emerald_crystal":
				var ep = dec["pos"]
				var es = dec["size"]
				var sparkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				draw_colored_polygon(PackedVector2Array([ep + Vector2(0, -es * 2), ep + Vector2(es, 0), ep + Vector2(0, es), ep + Vector2(-es, 0)]), Color(0.2, 0.8, 0.3, 0.4 + sparkle * 0.15))
			"scarecrow":
				var sp = dec["pos"]
				var ss = dec["size"]
				draw_line(sp, sp + Vector2(0, -ss * 2), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_line(sp + Vector2(-ss, -ss * 1.5), sp + Vector2(ss, -ss * 1.5), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_circle(sp + Vector2(0, -ss * 2.2), ss * 0.5, Color(0.6, 0.5, 0.2, 0.45))
	# Path (yellow brick road)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.2, 0.15, 0.05), 52.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.75, 0.6, 0.15), 44.0)
		for i in range(0, points.size() - 1, 10):
			var bright = Color(0.85, 0.72, 0.2, 0.4)
			var dark = Color(0.65, 0.5, 0.1, 0.35)
			if (i / 10) % 2 == 0:
				draw_rect(Rect2(points[i].x - 8, points[i].y - 10, 16, 9), bright)
				draw_rect(Rect2(points[i].x - 8, points[i].y + 1, 16, 9), dark)
			else:
				draw_rect(Rect2(points[i].x - 8, points[i].y - 10, 16, 9), dark)
				draw_rect(Rect2(points[i].x - 8, points[i].y + 1, 16, 9), bright)
		for i in range(0, points.size() - 1, 30):
			var shimmer = (sin(_time * 2.0 + float(i) * 0.5) + 1.0) * 0.5
			if shimmer > 0.7:
				draw_circle(points[i], 3.0, Color(1.0, 0.95, 0.5, shimmer * 0.2))

func _draw_peter_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Stars
	for dec in _decorations:
		if dec["type"] == "star":
			var twinkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
			var alpha = dec["size"] * (0.4 + twinkle * 0.6)
			draw_circle(dec["pos"], 1.0 + twinkle * 0.8, Color(1.0, 0.97, 0.8, alpha))
	# Second star to the right
	var second_star = Vector2(980, 72)
	var ss_twinkle = (sin(_time * 1.5) + 1.0) * 0.5
	draw_circle(second_star, 3.0 + ss_twinkle, Color(1.0, 0.95, 0.6, 0.9))
	draw_circle(second_star, 6.0 + ss_twinkle * 2.0, Color(1.0, 0.95, 0.6, 0.15))
	for a in [0, PI / 2.0, PI / 4.0, -PI / 4.0]:
		var ray = Vector2.from_angle(a) * (5.0 + ss_twinkle * 3.0)
		draw_line(second_star - ray, second_star + ray, Color(1.0, 0.95, 0.7, 0.25), 1.0)
	# Moon
	draw_circle(Vector2(180, 90), 28, Color(0.9, 0.88, 0.7, 0.7))
	draw_circle(Vector2(190, 84), 24, Color(0.04, 0.06, 0.14))
	# Mermaid Lagoon
	var lagoon_center = Vector2(1050, 500)
	draw_circle(lagoon_center, 70, Color(0.1, 0.35, 0.45, 0.5))
	draw_circle(lagoon_center, 60, Color(0.15, 0.45, 0.55, 0.4))
	draw_circle(lagoon_center, 45, Color(0.2, 0.55, 0.65, 0.35))
	for i in range(3):
		draw_arc(lagoon_center, 30.0 + float(i) * 15.0 + sin(_time * 0.8 + float(i)) * 3.0, 0, TAU, 24, Color(0.4, 0.7, 0.8, 0.12), 1.0)
	# Skull Rock
	var skull_pos = Vector2(100, 480)
	draw_circle(skull_pos, 22, Color(0.3, 0.28, 0.25))
	draw_circle(skull_pos, 18, Color(0.38, 0.35, 0.3))
	draw_circle(skull_pos + Vector2(-5, -4), 4, Color(0.12, 0.1, 0.08))
	draw_circle(skull_pos + Vector2(5, -4), 4, Color(0.12, 0.1, 0.08))
	for i in range(5):
		draw_line(Vector2(skull_pos.x - 5.0 + float(i) * 2.5, skull_pos.y + 7), Vector2(skull_pos.x - 5.0 + float(i) * 2.5, skull_pos.y + 11), Color(0.35, 0.32, 0.28), 1.5)
	# Jolly Roger
	var ship_x = 850.0
	var ship_y = 110.0
	draw_colored_polygon(PackedVector2Array([Vector2(ship_x - 40, ship_y), Vector2(ship_x + 40, ship_y), Vector2(ship_x + 30, ship_y + 12), Vector2(ship_x - 30, ship_y + 12)]), Color(0.12, 0.08, 0.06, 0.5))
	draw_line(Vector2(ship_x, ship_y), Vector2(ship_x, ship_y - 35), Color(0.15, 0.1, 0.08, 0.5), 2.0)
	draw_colored_polygon(PackedVector2Array([Vector2(ship_x, ship_y - 30), Vector2(ship_x + 20, ship_y - 20), Vector2(ship_x, ship_y - 8)]), Color(0.2, 0.15, 0.12, 0.35))
	# Ground cover
	draw_rect(Rect2(0, 400, 1280, 230), Color(0.08, 0.2, 0.06, 0.3))
	draw_rect(Rect2(0, 500, 1280, 130), Color(0.06, 0.16, 0.04, 0.2))
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var mh = dec["extra"]
				draw_line(mp, mp + Vector2(0, -ms * 1.5), Color(0.85, 0.82, 0.7), ms * 0.4)
				var cap_col = Color(0.8, 0.2, 0.15, 0.7) if mh < 0.33 else (Color(0.7, 0.5, 0.15, 0.7) if mh < 0.66 else Color(0.6, 0.2, 0.6, 0.7))
				draw_circle(mp + Vector2(0, -ms * 1.5), ms, cap_col)
				draw_circle(mp + Vector2(-ms * 0.3, -ms * 1.7), ms * 0.2, Color(1, 1, 1, 0.5))
			"jungle_tree":
				var tp = dec["pos"]
				var cr = dec["size"]
				var sh = dec["extra"]
				var th = cr * 0.8
				draw_line(tp, tp + Vector2(0, -th), Color(0.3 + sh, 0.2 + sh, 0.08), 3.0 + cr * 0.1)
				draw_circle(tp + Vector2(0, -th), cr, Color(0.1 + sh, 0.35 + sh, 0.08 + sh * 0.5, 0.55))
				draw_circle(tp + Vector2(-cr * 0.4, -th + cr * 0.2), cr * 0.6, Color(0.12 + sh, 0.37 + sh, 0.1, 0.5))
				if cr > 20:
					draw_line(tp + Vector2(-cr * 0.3, -th + cr * 0.5), tp + Vector2(-cr * 0.4, -th + cr + 8), Color(0.15, 0.4, 0.1, 0.3), 1.0)
			"fairy":
				var fp = dec["pos"]
				var fo = dec["extra"]
				var drift = Vector2(sin(_time * 1.2 + fo) * 8.0, cos(_time * 0.9 + fo) * 5.0)
				var pulse = (sin(_time * 3.0 + fo) + 1.0) * 0.5
				draw_circle(fp + drift, 1.5 + pulse, Color(1.0, 0.92, 0.3, 0.5 + pulse * 0.3))
				draw_circle(fp + drift, 4.0 + pulse * 2.0, Color(1.0, 0.9, 0.3, 0.08 + pulse * 0.06))
	# Underground Home
	var tree_home = Vector2(1180, 350)
	draw_rect(Rect2(tree_home.x - 16, tree_home.y - 60, 32, 80), Color(0.3, 0.18, 0.08))
	draw_rect(Rect2(tree_home.x - 12, tree_home.y - 55, 24, 70), Color(0.38, 0.24, 0.1))
	draw_circle(tree_home + Vector2(0, 5), 7, Color(0.12, 0.08, 0.04))
	draw_circle(tree_home + Vector2(0, -65), 35, Color(0.12, 0.35, 0.08, 0.7))
	draw_circle(tree_home + Vector2(-18, -55), 22, Color(0.14, 0.38, 0.1, 0.6))
	draw_circle(tree_home + Vector2(18, -55), 22, Color(0.1, 0.32, 0.07, 0.6))
	# Path (jungle trail)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.15, 0.1, 0.05), 52.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.35, 0.22, 0.1), 44.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.45, 0.32, 0.16, 0.5), 24.0)

func _draw_phantom_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Organ pipes silhouette
	var organ_x = 640.0
	var pipe_widths = [6, 8, 10, 12, 14, 14, 12, 10, 8, 6]
	var pipe_heights = [80, 100, 120, 145, 160, 155, 140, 115, 95, 75]
	var pipe_x = organ_x - 55.0
	for i in range(pipe_widths.size()):
		draw_rect(Rect2(pipe_x, 100.0 - pipe_heights[i], pipe_widths[i], pipe_heights[i]), Color(0.12, 0.06, 0.08, 0.5))
		draw_rect(Rect2(pipe_x - 1, 100.0 - pipe_heights[i] - 3, pipe_widths[i] + 2, 4), Color(0.25, 0.15, 0.1, 0.45))
		pipe_x += float(pipe_widths[i]) + 3.0
	# Red velvet curtains
	for i in range(8):
		var cx = 10.0 + float(i) * 8.0
		var fold = sin(float(i) * 1.2) * 4.0
		draw_line(Vector2(cx + fold, 50), Vector2(cx + fold * 0.5, 620), Color(0.35, 0.04, 0.06, 0.55 - float(i) * 0.05), 8.0)
	for i in range(8):
		var cx = 1270.0 - float(i) * 8.0
		var fold = sin(float(i) * 1.2) * 4.0
		draw_line(Vector2(cx - fold, 50), Vector2(cx - fold * 0.5, 620), Color(0.35, 0.04, 0.06, 0.55 - float(i) * 0.05), 8.0)
	draw_circle(Vector2(85, 200), 6, Color(0.85, 0.65, 0.1, 0.5))
	draw_circle(Vector2(1195, 200), 6, Color(0.85, 0.65, 0.1, 0.5))
	# Grand chandelier
	var chandelier_sway = sin(_time * 0.6) * 8.0
	var ch_center = Vector2(640 + chandelier_sway, 80)
	draw_line(Vector2(640, 50), ch_center, Color(0.7, 0.55, 0.15, 0.5), 2.0)
	draw_arc(ch_center, 35, 0, TAU, 24, Color(0.8, 0.65, 0.15, 0.5), 2.5)
	for i in range(8):
		var angle = float(i) * TAU / 8.0 + _time * 0.1
		var arm_end = ch_center + Vector2.from_angle(angle) * 35.0
		draw_line(ch_center + Vector2.from_angle(angle) * 28.0, arm_end, Color(0.8, 0.65, 0.15, 0.45), 1.5)
		var flicker = sin(_time * 5.0 + float(i) * 2.0) * 0.15
		draw_circle(arm_end + Vector2(0, -3), 2.5 + flicker, Color(1.0, 0.8, 0.2, 0.6 + flicker))
	for i in range(12):
		var angle = float(i) * TAU / 12.0
		var crystal_pos = ch_center + Vector2.from_angle(angle) * 22.0 + Vector2(0, 8)
		var sparkle = (sin(_time * 4.0 + float(i) * 1.5) + 1.0) * 0.5
		draw_line(crystal_pos, crystal_pos + Vector2(0, 6 + sparkle * 3), Color(0.9, 0.85, 1.0, 0.2 + sparkle * 0.2), 1.0)
	# Underground lake
	draw_rect(Rect2(0, 560, 1280, 68), Color(0.03, 0.02, 0.06, 0.7))
	for i in range(32):
		var wave_y = 560.0 + sin(_time * 1.2 + float(i) * 0.8) * 2.0
		draw_line(Vector2(float(i) * 42.0, wave_y), Vector2(float(i) * 42.0 + 42, wave_y + sin(_time * 1.2 + float(i + 1) * 0.8) * 2.0), Color(0.15, 0.1, 0.25, 0.3), 1.5)
	draw_circle(Vector2(640 + chandelier_sway, 585), 30, Color(0.3, 0.2, 0.05, 0.06))
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"candelabra":
				var cp = dec["pos"]
				var cs = dec["size"]
				draw_line(cp, cp + Vector2(0, -cs * 12.0), Color(0.6, 0.45, 0.1, 0.5), 2.5)
				draw_line(cp + Vector2(-cs * 3, 0), cp + Vector2(cs * 3, 0), Color(0.6, 0.45, 0.1, 0.45), 2.0)
				var arm_top = cp + Vector2(0, -cs * 12.0)
				draw_line(arm_top, arm_top + Vector2(-cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				draw_line(arm_top, arm_top + Vector2(cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				var flames = [arm_top + Vector2(0, -cs * 2), arm_top + Vector2(-cs * 5, -cs * 5), arm_top + Vector2(cs * 5, -cs * 5)]
				for fi in range(flames.size()):
					var flicker = sin(_time * 5.5 + dec["extra"] + float(fi) * 1.7) * 0.2
					draw_circle(flames[fi], 2.5 + flicker, Color(1.0, 0.75, 0.15, 0.6 + flicker))
					draw_circle(flames[fi], 18.0, Color(1.0, 0.6, 0.1, 0.02))
			"mirror":
				var mp = dec["pos"]
				var ms = dec["size"]
				draw_rect(Rect2(mp.x - ms * 8 - 3, mp.y - ms * 12 - 3, ms * 16 + 6, ms * 24 + 6), Color(0.8, 0.6, 0.1, 0.45))
				draw_rect(Rect2(mp.x - ms * 8, mp.y - ms * 12, ms * 16, ms * 24), Color(0.08, 0.05, 0.12, 0.7))
				var shimmer = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 5, mp.y - ms * 8, ms * 3, ms * 16), Color(0.4, 0.35, 0.5, shimmer * 0.1))
			"rose":
				var rp = dec["pos"]
				draw_circle(rp, dec["size"], Color(0.85, 0.1, 0.1, 0.5))
				draw_circle(rp, dec["size"] * 0.5, Color(0.95, 0.2, 0.15, 0.4))
			"sheet_music":
				var smp = dec["pos"]
				var sms = dec["size"]
				var drift = sin(_time * 0.6 + dec["extra"]) * 5.0
				draw_rect(Rect2(smp.x - sms + drift, smp.y - sms * 1.5, sms * 2, sms * 3), Color(0.85, 0.82, 0.7, 0.2))
				for line_idx in range(5):
					draw_line(Vector2(smp.x - sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Vector2(smp.x + sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Color(0.2, 0.15, 0.1, 0.15), 0.5)
	# Path (stone floor with red carpet)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.15, 0.1, 0.08), 54.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.25, 0.2, 0.18), 46.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.5, 0.06, 0.08, 0.55), 24.0)
		for i in range(points.size() - 1):
			if i + 1 < points.size():
				var dir = (points[i + 1] - points[i]).normalized()
				var perp = Vector2(-dir.y, dir.x)
				draw_line(points[i] + perp * 12, points[i + 1] + perp * 12, Color(0.8, 0.6, 0.1, 0.18), 1.5)
				draw_line(points[i] - perp * 12, points[i + 1] - perp * 12, Color(0.8, 0.6, 0.1, 0.18), 1.5)
		for i in range(0, points.size() - 1, 24):
			draw_colored_polygon(PackedVector2Array([points[i] + Vector2(0, -5), points[i] + Vector2(4, 0), points[i] + Vector2(0, 5), points[i] + Vector2(-4, 0)]), Color(0.85, 0.65, 0.1, 0.2))

func _draw_scrooge_ch1(sky_color: Color, ground_color: Color) -> void:
	draw_rect(Rect2(0, 0, 1280, 720), sky_color)
	for y in range(50, 620, 4):
		var t = float(y - 50) / 570.0
		var sky_col = sky_color.lerp(ground_color, t * t)
		draw_line(Vector2(0, y), Vector2(1280, y), Color(sky_col.r, sky_col.g, sky_col.b, 0.6), 4.0)
	# Fog layers
	for i in range(6):
		var fog_y = 200.0 + float(i) * 70.0
		draw_rect(Rect2(-20 + sin(_time * 0.15 + float(i) * 1.5) * 40.0, fog_y, 1320, 30), Color(0.4, 0.42, 0.5, 0.04))
	# Victorian building silhouettes
	var bldg_data = [{"x": 50.0, "w": 100.0, "h": 150.0}, {"x": 155.0, "w": 80.0, "h": 130.0}, {"x": 240.0, "w": 110.0, "h": 170.0}, {"x": 360.0, "w": 90.0, "h": 140.0}, {"x": 460.0, "w": 70.0, "h": 120.0}, {"x": 750.0, "w": 100.0, "h": 155.0}, {"x": 860.0, "w": 85.0, "h": 135.0}, {"x": 950.0, "w": 110.0, "h": 165.0}, {"x": 1070.0, "w": 95.0, "h": 145.0}, {"x": 1170.0, "w": 80.0, "h": 125.0}]
	var bldg_base_y = 340.0
	for bd in bldg_data:
		var bx = bd["x"]
		var bw = bd["w"]
		var bh = bd["h"]
		draw_rect(Rect2(bx, bldg_base_y - bh, bw, bh), Color(0.06, 0.06, 0.08, 0.6))
		draw_colored_polygon(PackedVector2Array([Vector2(bx - 3, bldg_base_y - bh), Vector2(bx + bw + 3, bldg_base_y - bh), Vector2(bx + bw * 0.5, bldg_base_y - bh - 15)]), Color(0.07, 0.06, 0.09, 0.55))
		for wy in range(3):
			for wx_off in range(3):
				var win_x = bx + 10.0 + float(wx_off) * (bw - 20.0) / 2.0
				var win_y = bldg_base_y - bh + 20.0 + float(wy) * 35.0
				if win_y < bldg_base_y - 10:
					var lit = sin(float(int(bx) + wx_off * 7 + wy * 13) * 0.5) > 0
					draw_rect(Rect2(win_x, win_y, 8, 10), Color(0.7, 0.55, 0.2, 0.2) if lit else Color(0.04, 0.04, 0.06, 0.4))
		var ch_x = bx + bw * 0.3
		draw_rect(Rect2(ch_x, bldg_base_y - bh - 25, 8, 20), Color(0.08, 0.07, 0.09, 0.55))
		for sc in range(3):
			draw_circle(Vector2(ch_x + 4.0 + sin(_time * 0.5 + bd["x"] * 0.01 + float(sc)) * 5.0, bldg_base_y - bh - 28.0 - float(sc) * 12.0), 5.0 + float(sc) * 3.0, Color(0.4, 0.4, 0.45, 0.08 - float(sc) * 0.02))
	# Church steeple
	var church_x = 620.0
	draw_rect(Rect2(church_x - 18, bldg_base_y - 200, 36, 200), Color(0.07, 0.06, 0.09, 0.65))
	draw_colored_polygon(PackedVector2Array([Vector2(church_x - 20, bldg_base_y - 200), Vector2(church_x + 20, bldg_base_y - 200), Vector2(church_x, bldg_base_y - 260)]), Color(0.06, 0.05, 0.08, 0.6))
	draw_line(Vector2(church_x, bldg_base_y - 260), Vector2(church_x, bldg_base_y - 275), Color(0.3, 0.28, 0.25, 0.45), 2.0)
	draw_line(Vector2(church_x - 6, bldg_base_y - 268), Vector2(church_x + 6, bldg_base_y - 268), Color(0.3, 0.28, 0.25, 0.45), 2.0)
	# Clock face
	var clock_center = Vector2(church_x, bldg_base_y - 170)
	draw_circle(clock_center, 12, Color(0.75, 0.7, 0.6, 0.4))
	draw_circle(clock_center, 10, Color(0.15, 0.12, 0.1, 0.5))
	draw_line(clock_center, clock_center + Vector2(0, -8), Color(0.85, 0.8, 0.6, 0.5), 1.5)
	draw_line(clock_center, clock_center + Vector2(0, -9.5), Color(0.85, 0.8, 0.6, 0.4), 1.0)
	# Thames river
	var river_y = 555.0
	draw_rect(Rect2(0, river_y, 1280, 73), Color(0.04, 0.05, 0.08, 0.65))
	for i in range(24):
		var ry = river_y + 10.0 + sin(_time * 0.8 + float(i) * 0.6) * 2.0
		draw_line(Vector2(float(i) * 56.0, ry), Vector2(float(i) * 56.0 + 56, ry + sin(_time * 0.8 + float(i + 1) * 0.6) * 2.0), Color(0.15, 0.18, 0.25, 0.2), 1.0)
	# Ground
	draw_rect(Rect2(0, bldg_base_y, 1280, river_y - bldg_base_y), Color(ground_color.r, ground_color.g, ground_color.b, 0.35))
	for i in range(40):
		draw_circle(Vector2(float(i) * 33.0 + sin(float(i) * 2.3) * 10.0, bldg_base_y + 5.0), 12.0, Color(0.8, 0.82, 0.88, 0.06))
	# Snowflakes
	for i in range(30):
		var sx = fmod(float(i) * 43.7 + sin(_time * 0.6 + float(i)) * 20.0, 1280.0)
		var sy = fmod(_time * 15.0 * (0.5 + fmod(float(i) * 0.3, 1.0)) + float(i) * 50.0, 620.0) + 50.0
		draw_circle(Vector2(sx, sy), 1.5 + fmod(float(i) * 0.7, 1.0), Color(0.9, 0.92, 0.95, 0.3))
	# Decorations
	for dec in _decorations:
		match dec["type"]:
			"lamp_post":
				var lp = dec["pos"]
				var ls = dec["size"]
				draw_line(lp, lp + Vector2(0, -ls * 1.4), Color(0.15, 0.12, 0.1, 0.6), 3.0)
				var lamp_top = lp + Vector2(0, -ls * 1.4)
				draw_rect(Rect2(lamp_top.x - ls * 0.2, lamp_top.y - ls * 0.4, ls * 0.4, ls * 0.4), Color(0.18, 0.14, 0.1, 0.5))
				var flicker = sin(_time * 6.0 + dec["extra"]) * 0.15
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.15 + flicker, Color(1.0, 0.75, 0.2, 0.55 + flicker))
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.8, Color(1.0, 0.7, 0.2, 0.04))
			"bare_tree":
				var tp = dec["pos"]
				var ts = dec["size"]
				var sh = dec["extra"]
				draw_line(tp, tp + Vector2(0, -ts * 1.4), Color(0.12, 0.1, 0.08, 0.5), 3.0)
				var branch_base = tp + Vector2(0, -ts * 1.4)
				for b in range(4):
					var b_angle = -PI * 0.6 + float(b) * 0.4 + sin(float(int(sh * 100) + b)) * 0.2
					var b_len = ts * (0.6 + float(b) * 0.2)
					draw_line(branch_base + Vector2(0, float(b) * ts * 0.2), branch_base + Vector2(0, float(b) * ts * 0.2) + Vector2.from_angle(b_angle) * b_len, Color(0.12, 0.1, 0.08, 0.4), 1.5)
			"snow_pile":
				draw_circle(dec["pos"], dec["size"], Color(0.85, 0.87, 0.9, 0.15))
				draw_circle(dec["pos"] + Vector2(dec["size"] * 0.3, -dec["size"] * 0.2), dec["size"] * 0.7, Color(0.88, 0.9, 0.92, 0.12))
			"chimney":
				var cp = dec["pos"]
				var cs = dec["size"]
				draw_rect(Rect2(cp.x - cs * 0.4, cp.y - cs * 2, cs * 0.8, cs * 2), Color(0.15, 0.12, 0.1, 0.4))
				var cf = sin(_time * 0.5 + dec["extra"]) * 4.0
				draw_circle(Vector2(cp.x + cf, cp.y - cs * 2.2), 4.0, Color(0.4, 0.4, 0.45, 0.06))
	# Path (cobblestone)
	var curve = enemy_path.curve
	if curve and curve.point_count > 1:
		var points = curve.get_baked_points()
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.08, 0.08, 0.1), 54.0)
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.22, 0.2, 0.22), 46.0)
		for i in range(0, points.size() - 1, 8):
			if i + 1 < points.size():
				var dir = (points[i + 1] - points[i]).normalized()
				var perp = Vector2(-dir.y, dir.x)
				for j in range(-2, 3):
					var stone_x = points[i] + perp * float(j) * 9.0 + dir * float((i / 8) % 2) * 4.0
					var stone_shade = 0.18 + sin(float(i + j * 37) * 0.7) * 0.04
					draw_rect(Rect2(stone_x.x - 3.5, stone_x.y - 3.5, 7, 7), Color(stone_shade, stone_shade, stone_shade + 0.02, 0.4))
		for i in range(0, points.size() - 1, 20):
			draw_circle(points[i] + Vector2(6, -3), 4.0, Color(0.85, 0.87, 0.9, 0.12))
		for i in range(points.size() - 1):
			draw_line(points[i], points[i + 1], Color(0.28, 0.26, 0.28, 0.18), 16.0)


func _draw_robin_ch2(sky_color: Color, ground_color: Color) -> void:
	# --- Sky gradient: dark blue-green night sky ---
	for sy in range(0, 50):
		var t: float = float(sy) / 50.0
		var band_color := Color(
			sky_color.r * 0.3 + 0.02 * t,
			sky_color.g * 0.35 + 0.04 * t,
			sky_color.b * 0.5 + 0.06 * t
		)
		draw_line(Vector2(0, float(sy)), Vector2(1280, float(sy)), band_color, 1.5)

	# --- Stars twinkling in night sky ---
	for si in range(45):
		var sx: float = fmod(float(si) * 173.7 + 51.3, 1280.0)
		var star_y: float = fmod(float(si) * 97.1 + 13.7, 45.0) + 5.0
		var twinkle: float = 0.4 + 0.6 * clampf(sin(_time * (1.5 + float(si) * 0.2) + float(si) * 3.7), 0.0, 1.0)
		var star_size: float = 1.0 + fmod(float(si) * 0.7, 1.5)
		draw_circle(Vector2(sx, star_y), star_size, Color(0.85, 0.9, 1.0, twinkle * 0.8))

	# --- Crescent moon ---
	var moon_x: float = 1050.0 + sin(_time * 0.05) * 5.0
	draw_circle(Vector2(moon_x, 25.0), 18.0, Color(0.9, 0.92, 0.8, 0.85))
	draw_circle(Vector2(moon_x + 7.0, 22.0), 15.0, Color(sky_color.r * 0.3, sky_color.g * 0.35, sky_color.b * 0.5))

	# --- Deep sky to forest canopy transition ---
	for sy2 in range(50, 160):
		var t2: float = float(sy2 - 50) / 110.0
		var canopy_col := Color(
			lerp(sky_color.r * 0.3, 0.01, t2),
			lerp(sky_color.g * 0.35, 0.06, t2),
			lerp(sky_color.b * 0.5, 0.03, t2)
		)
		draw_line(Vector2(0, float(sy2)), Vector2(1280, float(sy2)), canopy_col, 1.5)

	# --- Dense forest canopy silhouettes (background layer) ---
	for ct in range(30):
		var cx: float = fmod(float(ct) * 97.3 + 22.0, 1400.0) - 60.0
		var cy: float = 100.0 + fmod(float(ct) * 31.7, 70.0)
		var crad: float = 40.0 + fmod(float(ct) * 17.3, 35.0)
		var sway: float = sin(_time * 0.4 + float(ct) * 0.8) * 3.0
		var canopy_dark := Color(0.01, 0.04 + fmod(float(ct) * 0.003, 0.02), 0.01, 0.92)
		draw_circle(Vector2(cx + sway, cy), crad, canopy_dark)
		draw_circle(Vector2(cx + sway - crad * 0.5, cy + 10.0), crad * 0.7, canopy_dark)

	# --- Sheriff's torches visible through distant trees ---
	for ti in range(5):
		var torch_x: float = 180.0 + float(ti) * 220.0 + sin(_time * 0.3 + float(ti)) * 15.0
		var torch_y: float = 140.0 + fmod(float(ti) * 23.0, 40.0)
		var torch_flicker: float = 0.6 + 0.4 * sin(_time * 7.0 + float(ti) * 4.3)
		# Distant glow halo
		draw_circle(Vector2(torch_x, torch_y), 25.0, Color(0.6, 0.25, 0.02, 0.06 * torch_flicker))
		draw_circle(Vector2(torch_x, torch_y), 14.0, Color(0.7, 0.35, 0.05, 0.1 * torch_flicker))
		# Torch flame
		draw_circle(Vector2(torch_x, torch_y), 4.5, Color(0.95, 0.7, 0.1, 0.7 * torch_flicker))
		draw_circle(Vector2(torch_x, torch_y - 3.0), 2.5, Color(1.0, 0.9, 0.4, 0.8 * torch_flicker))

	# --- Owl silhouettes perched on branches ---
	for oi in range(3):
		var owl_x: float = 200.0 + float(oi) * 400.0 + sin(_time * 0.15 + float(oi) * 2.0) * 8.0
		var owl_y: float = 115.0 + float(oi) * 18.0
		var owl_col := Color(0.02, 0.02, 0.02, 0.9)
		# Body
		draw_circle(Vector2(owl_x, owl_y), 8.0, owl_col)
		# Head
		draw_circle(Vector2(owl_x, owl_y - 9.0), 5.5, owl_col)
		# Ear tufts
		draw_line(Vector2(owl_x - 4.0, owl_y - 13.0), Vector2(owl_x - 6.0, owl_y - 18.0), owl_col, 2.0)
		draw_line(Vector2(owl_x + 4.0, owl_y - 13.0), Vector2(owl_x + 6.0, owl_y - 18.0), owl_col, 2.0)
		# Eyes glow
		var blink: float = 1.0 if fmod(_time + float(oi) * 3.0, 5.0) > 0.3 else 0.0
		draw_circle(Vector2(owl_x - 2.5, owl_y - 9.5), 1.8, Color(0.9, 0.7, 0.1, 0.7 * blink))
		draw_circle(Vector2(owl_x + 2.5, owl_y - 9.5), 1.8, Color(0.9, 0.7, 0.1, 0.7 * blink))
		# Branch underneath
		draw_line(Vector2(owl_x - 30.0, owl_y + 8.0), Vector2(owl_x + 30.0, owl_y + 6.0), Color(0.06, 0.03, 0.01), 3.0)

	# --- Ground layers: forest floor with leaves ---
	for gy in range(280, 628):
		var gt: float = float(gy - 280) / 348.0
		var gx_wave: float = sin(float(gy) * 0.03 + _time * 0.15) * 0.02
		var floor_col := Color(
			lerp(0.04, ground_color.r * 0.6, gt) + gx_wave,
			lerp(0.08, ground_color.g * 0.5, gt),
			lerp(0.02, ground_color.b * 0.3, gt)
		)
		draw_line(Vector2(0, float(gy)), Vector2(1280, float(gy)), floor_col, 1.5)

	# --- Rushing river with rapids (horizontal, mid-ground) ---
	var river_y: float = 400.0
	for ry in range(30):
		var ry_f: float = float(ry)
		var river_t: float = ry_f / 30.0
		var river_wave: float = sin(ry_f * 0.5 + _time * 2.5) * 3.0
		var depth_col := Color(
			0.05 + 0.08 * river_t,
			0.12 + 0.15 * river_t + 0.03 * sin(_time * 1.5 + ry_f * 0.3),
			0.25 + 0.2 * river_t,
			0.85
		)
		draw_line(Vector2(0, river_y + ry_f + river_wave), Vector2(1280, river_y + ry_f + river_wave), depth_col, 1.5)
	# Rapids / white water foam
	for ri in range(20):
		var rapid_x: float = fmod(float(ri) * 127.3 + _time * 60.0, 1400.0) - 60.0
		var rapid_y: float = river_y + 5.0 + fmod(float(ri) * 11.3, 22.0)
		var foam_alpha: float = 0.3 + 0.4 * sin(_time * 4.0 + float(ri) * 2.7)
		draw_circle(Vector2(rapid_x, rapid_y), 3.0 + sin(_time * 3.0 + float(ri)) * 1.5, Color(0.85, 0.9, 0.95, clampf(foam_alpha, 0.0, 1.0)))

	# --- Little John's stone bridge (centerpiece) ---
	var bridge_cx: float = 640.0
	var bridge_top: float = river_y - 10.0
	# Stone arch
	var arch_pts: PackedVector2Array = PackedVector2Array()
	for ai in range(21):
		var angle: float = PI * float(ai) / 20.0
		arch_pts.append(Vector2(bridge_cx + cos(angle) * 80.0, bridge_top + 30.0 - sin(angle) * 35.0))
	for ai2 in range(20, -1, -1):
		var angle2: float = PI * float(ai2) / 20.0
		arch_pts.append(Vector2(bridge_cx + cos(angle2) * 70.0, bridge_top + 30.0 - sin(angle2) * 28.0))
	draw_colored_polygon(arch_pts, Color(0.25, 0.22, 0.18))
	# Bridge deck
	draw_rect(Rect2(bridge_cx - 85.0, bridge_top - 8.0, 170.0, 14.0), Color(0.3, 0.27, 0.2))
	# Stone texture lines on bridge
	for sl in range(8):
		var slx: float = bridge_cx - 75.0 + float(sl) * 20.0
		draw_line(Vector2(slx, bridge_top - 8.0), Vector2(slx, bridge_top + 5.0), Color(0.2, 0.17, 0.12, 0.5), 1.0)
	# Railings
	for rail in range(9):
		var rx: float = bridge_cx - 80.0 + float(rail) * 20.0
		draw_line(Vector2(rx, bridge_top - 8.0), Vector2(rx, bridge_top - 22.0), Color(0.2, 0.17, 0.12), 2.5)
	draw_line(Vector2(bridge_cx - 80.0, bridge_top - 22.0), Vector2(bridge_cx + 80.0, bridge_top - 22.0), Color(0.22, 0.19, 0.14), 3.0)

	# --- Wanted posters on trees ---
	for wp in range(4):
		var poster_x: float = 90.0 + float(wp) * 310.0
		var poster_y: float = 260.0 + fmod(float(wp) * 37.0, 40.0)
		# Parchment
		draw_rect(Rect2(poster_x - 12.0, poster_y - 16.0, 24.0, 30.0), Color(0.85, 0.78, 0.6, 0.85))
		draw_rect(Rect2(poster_x - 11.0, poster_y - 15.0, 22.0, 28.0), Color(0.0, 0.0, 0.0, 1.0), false, 1.0)
		# "WANTED" text line
		draw_line(Vector2(poster_x - 7.0, poster_y - 10.0), Vector2(poster_x + 7.0, poster_y - 10.0), Color(0.15, 0.05, 0.02), 1.5)
		# Face circle
		draw_circle(Vector2(poster_x, poster_y + 2.0), 5.0, Color(0.7, 0.6, 0.45, 0.6))
		# Nail
		draw_circle(Vector2(poster_x, poster_y - 16.0), 1.5, Color(0.4, 0.4, 0.4))

	# --- Decorations loop ---
	for dec in _decorations:
		var dtype: String = dec["type"]
		var dpos: Vector2 = dec["pos"]
		var dsize: float = dec["size"]
		var dextra: float = dec["extra"]
		if dtype == "oak_tree":
			draw_rect(Rect2(dpos.x - dsize * 0.15, dpos.y - dsize * 0.2, dsize * 0.3, dsize * 0.8), Color(0.1, 0.06, 0.02))
			draw_circle(dpos + Vector2(0, -dsize * 0.4), dsize * 0.5, Color(0.03, 0.15, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, -dsize * 0.2), dsize * 0.35, Color(0.03, 0.15, 0.03, 0.9))
		elif dtype == "target":
			draw_circle(dpos, 7.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 5.0, Color(0.7, 0.15, 0.1))
			draw_circle(dpos, 3.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 1.5, Color(0.7, 0.15, 0.1))
			draw_line(dpos + Vector2(-8, -4), dpos, Color(0.3, 0.2, 0.05), 1.5)
			draw_line(Vector2(dpos.x, dpos.y + 7), Vector2(dpos.x, dpos.y + 16), Color(0.2, 0.12, 0.04), 2.5)
		elif dtype == "bush":
			draw_circle(dpos, dsize * 0.5, Color(0.04, 0.16 + dextra * 0.05, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, dsize * 0.1), dsize * 0.35, Color(0.04, 0.16, 0.03, 0.9))
			draw_circle(dpos + Vector2(dsize * 0.25, dsize * 0.08), dsize * 0.38, Color(0.04, 0.16, 0.03, 0.9))
		elif dtype == "deer":
			var deer_col := Color(0.15, 0.1, 0.05)
			var facing: float = -1.0 if dextra > 0.5 else 1.0
			var body_pts: PackedVector2Array = PackedVector2Array()
			for da in range(16):
				body_pts.append(dpos + Vector2(cos(float(da) * TAU / 16.0) * dsize * 0.4 * facing, sin(float(da) * TAU / 16.0) * dsize * 0.2))
			draw_colored_polygon(body_pts, deer_col)
			var head_pos: Vector2 = dpos + Vector2(dsize * 0.5 * facing, -dsize * 0.35)
			draw_line(dpos + Vector2(dsize * 0.3 * facing, -dsize * 0.1), head_pos, deer_col, dsize * 0.1)
			draw_circle(head_pos, dsize * 0.1, deer_col)
		elif dtype == "campfire":
			var fi: float = 0.7 + 0.3 * sin(_time * 5.0 + dextra * 10.0)
			draw_circle(dpos, dsize * 3.0, Color(0.4, 0.15, 0.02, 0.08 * fi))
			draw_circle(dpos, dsize * 2.0, Color(0.5, 0.2, 0.03, 0.12 * fi))
			for fs in range(8):
				draw_circle(dpos + Vector2(cos(float(fs) * TAU / 8.0) * dsize * 0.7, sin(float(fs) * TAU / 8.0) * dsize * 0.35), 3.0, Color(0.2, 0.18, 0.15))
			for fl2 in range(6):
				var flame_x: float = dpos.x + sin(float(fl2) * 1.7 + _time * 4.0) * dsize * 0.3
				var flame_h: float = dsize * (0.6 + 0.4 * sin(_time * 6.0 + float(fl2) * 2.0)) * fi
				var fc: Color = Color(0.95, 0.85, 0.2, 0.9) if fl2 < 2 else (Color(0.95, 0.5, 0.05, 0.85) if fl2 < 4 else Color(0.8, 0.2, 0.02, 0.7))
				draw_line(Vector2(flame_x, dpos.y + dsize * 0.1), Vector2(flame_x + sin(_time * 3.0 + float(fl2)) * 3.0, dpos.y - flame_h), fc, 3.5 - float(fl2) * 0.3)

	# --- Path rendering: dark forest dirt trail ---
	if enemy_path and enemy_path.curve:
		var curve: Curve2D = enemy_path.curve
		var path_len: float = curve.get_baked_length()
		var prev_pt: Vector2 = curve.sample_baked(0.0)
		for pi in range(1, 101):
			var pt: Vector2 = curve.sample_baked(float(pi) / 100.0 * path_len)
			# Main trail
			draw_line(prev_pt, pt, Color(0.12, 0.08, 0.04), 26.0)
			# Darker edges
			var perp: Vector2 = (pt - prev_pt).normalized().rotated(PI * 0.5)
			draw_line(prev_pt + perp * 12.0, pt + perp * 12.0, Color(0.06, 0.04, 0.02, 0.6), 4.0)
			draw_line(prev_pt - perp * 12.0, pt - perp * 12.0, Color(0.06, 0.04, 0.02, 0.6), 4.0)
			prev_pt = pt
		# Footprints / muddy patches
		for mi in range(15):
			var mud_offset: float = (float(mi) + 0.5) / 15.0
			var mud_pt: Vector2 = curve.sample_baked(mud_offset * path_len)
			var mud_side: float = -5.0 if mi % 2 == 0 else 5.0
			draw_circle(mud_pt + Vector2(mud_side, 0), 2.5, Color(0.08, 0.05, 0.02, 0.5))

	# --- Rolling fog (foreground effect) ---
	for fi2 in range(12):
		var fog_x: float = fmod(float(fi2) * 160.0 - _time * 18.0, 1500.0) - 100.0
		var fog_y: float = 350.0 + fmod(float(fi2) * 47.0, 200.0)
		var fog_pulse: float = 0.03 + 0.025 * sin(_time * 0.6 + float(fi2) * 1.3)
		var fog_rad: float = 60.0 + 20.0 * sin(_time * 0.4 + float(fi2) * 0.9)
		draw_circle(Vector2(fog_x, fog_y), fog_rad, Color(0.5, 0.55, 0.6, fog_pulse))
		draw_circle(Vector2(fog_x + 40.0, fog_y + 10.0), fog_rad * 0.7, Color(0.5, 0.55, 0.6, fog_pulse * 0.7))

	# --- Fireflies (animated foreground sparkles) ---
	for ff in range(18):
		var ff_x: float = fmod(float(ff) * 151.0 + sin(_time * 0.8 + float(ff) * 2.1) * 40.0, 1280.0)
		var ff_y: float = 200.0 + fmod(float(ff) * 67.0, 350.0) + sin(_time * 1.2 + float(ff) * 1.7) * 15.0
		var ff_alpha: float = clampf(0.5 + 0.5 * sin(_time * 3.0 + float(ff) * 4.1), 0.0, 1.0)
		draw_circle(Vector2(ff_x, ff_y), 2.0, Color(0.7, 0.9, 0.3, ff_alpha * 0.7))
		draw_circle(Vector2(ff_x, ff_y), 5.0, Color(0.7, 0.9, 0.3, ff_alpha * 0.15))


## Robin Hood Chapter 3: "Siege of Nottingham"
## Nottingham Castle walls, siege ladders, moat with drawbridge, castle towers with
## archer windows, burning arrows arcing across sky, dawn breaking golden, Robin's flag.

func _draw_robin_ch3(sky_color: Color, ground_color: Color) -> void:
	# --- Sky gradient: warm dawn breaking ---
	for sy in range(0, 50):
		var t: float = float(sy) / 50.0
		var dawn_col := Color(
			lerp(sky_color.r * 0.4, sky_color.r * 0.9, t),
			lerp(sky_color.g * 0.2, sky_color.g * 0.6, t),
			lerp(sky_color.b * 0.3, sky_color.b * 0.5, t)
		)
		draw_line(Vector2(0, float(sy)), Vector2(1280, float(sy)), dawn_col, 1.5)

	# --- Golden horizon glow ---
	for hg in range(20):
		var hg_t: float = float(hg) / 20.0
		var glow_alpha: float = 0.12 * (1.0 - hg_t) * (0.8 + 0.2 * sin(_time * 0.5))
		draw_line(Vector2(0, 50.0 - float(hg)), Vector2(1280, 50.0 - float(hg)), Color(1.0, 0.75, 0.2, glow_alpha), 1.5)

	# --- Fading stars at dawn ---
	for si in range(20):
		var sx: float = fmod(float(si) * 173.7 + 51.3, 1280.0)
		var star_y: float = fmod(float(si) * 97.1 + 5.0, 40.0) + 3.0
		var fade: float = clampf(0.3 + 0.2 * sin(_time * 1.0 + float(si) * 2.3), 0.0, 1.0)
		draw_circle(Vector2(sx, star_y), 1.0, Color(0.9, 0.85, 0.7, fade * 0.4))

	# --- Burning arrows arcing across sky (animated) ---
	for ba in range(6):
		var arrow_phase: float = fmod(_time * 0.7 + float(ba) * 1.8, 4.0)
		var arrow_t: float = arrow_phase / 4.0
		var arrow_start_x: float = -40.0 + float(ba) * 50.0
		var arrow_end_x: float = 400.0 + float(ba) * 150.0
		var arrow_x: float = lerp(arrow_start_x, arrow_end_x, arrow_t)
		var arrow_arc: float = -120.0 * sin(arrow_t * PI)
		var arrow_y: float = 45.0 + arrow_arc + float(ba) * 3.0
		if arrow_t > 0.02 and arrow_t < 0.98 and arrow_x > 0.0 and arrow_x < 1280.0:
			# Arrow body
			var arrow_dir: float = atan2(arrow_arc * 0.1, 5.0)
			var ax2: float = arrow_x - cos(arrow_dir) * 12.0
			var ay2: float = arrow_y - sin(arrow_dir) * 12.0
			draw_line(Vector2(ax2, ay2), Vector2(arrow_x, arrow_y), Color(0.3, 0.2, 0.05), 1.5)
			# Flame on tip
			var flame_fl: float = 0.7 + 0.3 * sin(_time * 8.0 + float(ba) * 3.0)
			draw_circle(Vector2(arrow_x, arrow_y), 4.0, Color(0.95, 0.6, 0.05, 0.6 * flame_fl))
			draw_circle(Vector2(arrow_x, arrow_y), 2.5, Color(1.0, 0.9, 0.3, 0.8 * flame_fl))
			# Smoke trail
			for st in range(4):
				var trail_x: float = ax2 - float(st) * 6.0
				var trail_y: float = ay2 + float(st) * 2.0
				draw_circle(Vector2(trail_x, trail_y), 2.0 + float(st) * 0.5, Color(0.3, 0.3, 0.3, 0.15 - float(st) * 0.03))

	# --- Sky to ground transition ---
	for sy2 in range(50, 180):
		var t2: float = float(sy2 - 50) / 130.0
		var mid_col := Color(
			lerp(sky_color.r * 0.9, 0.35, t2),
			lerp(sky_color.g * 0.6, 0.3, t2),
			lerp(sky_color.b * 0.5, 0.25, t2)
		)
		draw_line(Vector2(0, float(sy2)), Vector2(1280, float(sy2)), mid_col, 1.5)

	# --- Nottingham Castle (dominating background) ---
	var castle_base_y: float = 180.0
	# Main wall
	draw_rect(Rect2(200.0, castle_base_y, 880.0, 200.0), Color(0.3, 0.28, 0.24))
	# Battlements (crenellations)
	for cr in range(22):
		var cr_x: float = 200.0 + float(cr) * 40.0
		if cr % 2 == 0:
			draw_rect(Rect2(cr_x, castle_base_y - 20.0, 30.0, 20.0), Color(0.32, 0.3, 0.26))

	# Left tower
	draw_rect(Rect2(140.0, castle_base_y - 100.0, 80.0, 300.0), Color(0.28, 0.26, 0.22))
	# Left tower roof (conical shape)
	var ltower_pts: PackedVector2Array = PackedVector2Array([
		Vector2(180.0, castle_base_y - 140.0),
		Vector2(135.0, castle_base_y - 100.0),
		Vector2(225.0, castle_base_y - 100.0)
	])
	draw_colored_polygon(ltower_pts, Color(0.2, 0.08, 0.08))
	# Left tower archer windows
	for aw in range(3):
		var aw_y: float = castle_base_y - 70.0 + float(aw) * 55.0
		draw_rect(Rect2(172.0, aw_y, 6.0, 16.0), Color(0.05, 0.05, 0.08))
		draw_rect(Rect2(169.0, aw_y + 5.0, 12.0, 4.0), Color(0.05, 0.05, 0.08))
		# Arrow slit glow (interior light)
		var glow_f: float = 0.3 + 0.2 * sin(_time * 2.0 + float(aw) * 1.5)
		draw_circle(Vector2(175.0, aw_y + 8.0), 4.0, Color(0.8, 0.5, 0.1, glow_f * 0.3))

	# Right tower
	draw_rect(Rect2(1060.0, castle_base_y - 80.0, 80.0, 280.0), Color(0.28, 0.26, 0.22))
	var rtower_pts: PackedVector2Array = PackedVector2Array([
		Vector2(1100.0, castle_base_y - 120.0),
		Vector2(1055.0, castle_base_y - 80.0),
		Vector2(1145.0, castle_base_y - 80.0)
	])
	draw_colored_polygon(rtower_pts, Color(0.2, 0.08, 0.08))
	for aw2 in range(3):
		var aw2_y: float = castle_base_y - 50.0 + float(aw2) * 50.0
		draw_rect(Rect2(1092.0, aw2_y, 6.0, 16.0), Color(0.05, 0.05, 0.08))
		draw_rect(Rect2(1089.0, aw2_y + 5.0, 12.0, 4.0), Color(0.05, 0.05, 0.08))

	# Central keep (taller)
	draw_rect(Rect2(540.0, castle_base_y - 70.0, 200.0, 270.0), Color(0.33, 0.3, 0.27))
	# Keep battlements
	for kb in range(5):
		var kb_x: float = 540.0 + float(kb) * 40.0
		if kb % 2 == 0:
			draw_rect(Rect2(kb_x, castle_base_y - 88.0, 28.0, 18.0), Color(0.35, 0.32, 0.28))
	# Keep gate (large arched entrance)
	var gate_pts: PackedVector2Array = PackedVector2Array()
	for gi in range(21):
		var g_angle: float = PI * float(gi) / 20.0
		gate_pts.append(Vector2(640.0 + cos(g_angle) * 28.0, castle_base_y + 100.0 - sin(g_angle) * 35.0))
	gate_pts.append(Vector2(668.0, castle_base_y + 200.0))
	gate_pts.append(Vector2(612.0, castle_base_y + 200.0))
	draw_colored_polygon(gate_pts, Color(0.06, 0.04, 0.04))
	# Portcullis lines
	for pc in range(5):
		var pcx: float = 618.0 + float(pc) * 11.0
		draw_line(Vector2(pcx, castle_base_y + 68.0), Vector2(pcx, castle_base_y + 200.0), Color(0.2, 0.18, 0.15), 2.0)
	for pcr in range(6):
		var pcry: float = castle_base_y + 80.0 + float(pcr) * 20.0
		draw_line(Vector2(614.0, pcry), Vector2(666.0, pcry), Color(0.2, 0.18, 0.15), 1.5)

	# --- Robin's flag on left tower ---
	var flag_x: float = 180.0
	var flag_y: float = castle_base_y - 140.0
	# Pole
	draw_line(Vector2(flag_x, flag_y), Vector2(flag_x, flag_y - 40.0), Color(0.4, 0.35, 0.2), 2.0)
	# Flag waving
	var flag_wave: float = sin(_time * 3.0) * 5.0
	var flag_pts: PackedVector2Array = PackedVector2Array([
		Vector2(flag_x, flag_y - 40.0),
		Vector2(flag_x + 28.0, flag_y - 37.0 + flag_wave),
		Vector2(flag_x + 25.0, flag_y - 25.0 + flag_wave * 0.6),
		Vector2(flag_x, flag_y - 22.0)
	])
	draw_colored_polygon(flag_pts, Color(0.15, 0.5, 0.15))
	# Arrow emblem on flag
	draw_line(Vector2(flag_x + 8.0, flag_y - 33.0 + flag_wave * 0.4), Vector2(flag_x + 20.0, flag_y - 30.0 + flag_wave * 0.7), Color(0.9, 0.85, 0.3), 1.5)

	# --- Moat (water around castle base) ---
	var moat_y: float = castle_base_y + 200.0
	for my in range(25):
		var my_f: float = float(my)
		var moat_wave: float = sin(my_f * 0.6 + _time * 1.5) * 2.0
		var moat_col := Color(
			0.06 + 0.04 * sin(_time * 0.8 + my_f * 0.2),
			0.15 + 0.08 * (my_f / 25.0),
			0.3 + 0.1 * (my_f / 25.0),
			0.9
		)
		draw_line(Vector2(0, moat_y + my_f + moat_wave), Vector2(1280, moat_y + my_f + moat_wave), moat_col, 1.5)
	# Water reflections
	for wr in range(10):
		var wr_x: float = fmod(float(wr) * 137.0 + _time * 12.0, 1280.0)
		var wr_y: float = moat_y + 5.0 + fmod(float(wr) * 7.3, 18.0)
		var wr_alpha: float = 0.15 + 0.1 * sin(_time * 2.0 + float(wr) * 1.9)
		draw_line(Vector2(wr_x - 8.0, wr_y), Vector2(wr_x + 8.0, wr_y), Color(0.6, 0.7, 0.8, wr_alpha), 1.0)

	# --- Drawbridge ---
	var db_x: float = 640.0
	var db_angle: float = 0.1 * sin(_time * 0.3)
	draw_rect(Rect2(db_x - 30.0, moat_y - 4.0, 60.0, 8.0), Color(0.25, 0.15, 0.06))
	# Planks
	for pl in range(6):
		var plx: float = db_x - 28.0 + float(pl) * 10.0
		draw_line(Vector2(plx, moat_y - 4.0), Vector2(plx, moat_y + 4.0), Color(0.18, 0.1, 0.04, 0.6), 1.0)
	# Chains
	draw_line(Vector2(db_x - 25.0, moat_y - 4.0), Vector2(db_x - 20.0, castle_base_y + 195.0), Color(0.35, 0.33, 0.3), 2.0)
	draw_line(Vector2(db_x + 25.0, moat_y - 4.0), Vector2(db_x + 20.0, castle_base_y + 195.0), Color(0.35, 0.33, 0.3), 2.0)

	# --- Siege ladders leaning against walls ---
	for li in range(3):
		var ladder_x: float = 280.0 + float(li) * 260.0
		var ladder_bot: float = moat_y - 2.0
		var ladder_top: float = castle_base_y + 10.0
		var ladder_lean: float = 20.0 + sin(_time * 0.4 + float(li) * 2.0) * 3.0
		# Side rails
		draw_line(Vector2(ladder_x - 6.0, ladder_bot), Vector2(ladder_x - 6.0 + ladder_lean, ladder_top), Color(0.3, 0.2, 0.08), 3.0)
		draw_line(Vector2(ladder_x + 6.0, ladder_bot), Vector2(ladder_x + 6.0 + ladder_lean, ladder_top), Color(0.3, 0.2, 0.08), 3.0)
		# Rungs
		var rungs: int = 8
		for ru in range(rungs):
			var rung_t: float = float(ru + 1) / float(rungs + 1)
			var rx1: float = lerp(ladder_x - 6.0, ladder_x - 6.0 + ladder_lean, rung_t)
			var rx2: float = lerp(ladder_x + 6.0, ladder_x + 6.0 + ladder_lean, rung_t)
			var rung_y: float = lerp(ladder_bot, ladder_top, rung_t)
			draw_line(Vector2(rx1, rung_y), Vector2(rx2, rung_y), Color(0.28, 0.18, 0.06), 2.0)

	# --- Ground layers: battlefield/earth ---
	for gy in range(int(moat_y) + 25, 628):
		var gt: float = float(gy - int(moat_y) - 25) / float(628 - int(moat_y) - 25)
		var ground_col := Color(
			lerp(0.2, ground_color.r * 0.7, gt),
			lerp(0.18, ground_color.g * 0.6, gt),
			lerp(0.12, ground_color.b * 0.4, gt)
		)
		draw_line(Vector2(0, float(gy)), Vector2(1280, float(gy)), ground_col, 1.5)

	# --- Stone wall texture on castle ---
	for sr in range(12):
		for sc in range(24):
			var stone_x: float = 200.0 + float(sc) * 37.0 + fmod(float(sr) * 17.0, 18.0)
			var stone_y: float = castle_base_y + float(sr) * 16.5
			if stone_x < 1080.0 and stone_y < castle_base_y + 195.0:
				draw_rect(Rect2(stone_x, stone_y, 34.0, 14.0), Color(0.25, 0.23, 0.19, 0.25), false, 0.5)

	# --- Decorations loop ---
	for dec in _decorations:
		var dtype: String = dec["type"]
		var dpos: Vector2 = dec["pos"]
		var dsize: float = dec["size"]
		var dextra: float = dec["extra"]
		if dtype == "oak_tree":
			draw_rect(Rect2(dpos.x - dsize * 0.15, dpos.y - dsize * 0.2, dsize * 0.3, dsize * 0.8), Color(0.1, 0.06, 0.02))
			draw_circle(dpos + Vector2(0, -dsize * 0.4), dsize * 0.5, Color(0.03, 0.15, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, -dsize * 0.2), dsize * 0.35, Color(0.03, 0.15, 0.03, 0.9))
		elif dtype == "target":
			draw_circle(dpos, 7.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 5.0, Color(0.7, 0.15, 0.1))
			draw_circle(dpos, 3.0, Color(0.8, 0.8, 0.7))
			draw_circle(dpos, 1.5, Color(0.7, 0.15, 0.1))
			draw_line(dpos + Vector2(-8, -4), dpos, Color(0.3, 0.2, 0.05), 1.5)
			draw_line(Vector2(dpos.x, dpos.y + 7), Vector2(dpos.x, dpos.y + 16), Color(0.2, 0.12, 0.04), 2.5)
		elif dtype == "bush":
			draw_circle(dpos, dsize * 0.5, Color(0.04, 0.16 + dextra * 0.05, 0.03, 0.9))
			draw_circle(dpos + Vector2(-dsize * 0.3, dsize * 0.1), dsize * 0.35, Color(0.04, 0.16, 0.03, 0.9))
			draw_circle(dpos + Vector2(dsize * 0.25, dsize * 0.08), dsize * 0.38, Color(0.04, 0.16, 0.03, 0.9))
		elif dtype == "deer":
			var deer_col := Color(0.15, 0.1, 0.05)
			var facing: float = -1.0 if dextra > 0.5 else 1.0
			var body_pts: PackedVector2Array = PackedVector2Array()
			for da in range(16):
				body_pts.append(dpos + Vector2(cos(float(da) * TAU / 16.0) * dsize * 0.4 * facing, sin(float(da) * TAU / 16.0) * dsize * 0.2))
			draw_colored_polygon(body_pts, deer_col)
			var head_pos: Vector2 = dpos + Vector2(dsize * 0.5 * facing, -dsize * 0.35)
			draw_line(dpos + Vector2(dsize * 0.3 * facing, -dsize * 0.1), head_pos, deer_col, dsize * 0.1)
			draw_circle(head_pos, dsize * 0.1, deer_col)
		elif dtype == "campfire":
			var fi: float = 0.7 + 0.3 * sin(_time * 5.0 + dextra * 10.0)
			draw_circle(dpos, dsize * 3.0, Color(0.4, 0.15, 0.02, 0.08 * fi))
			draw_circle(dpos, dsize * 2.0, Color(0.5, 0.2, 0.03, 0.12 * fi))
			for fs in range(8):
				draw_circle(dpos + Vector2(cos(float(fs) * TAU / 8.0) * dsize * 0.7, sin(float(fs) * TAU / 8.0) * dsize * 0.35), 3.0, Color(0.2, 0.18, 0.15))
			for fl2 in range(6):
				var flame_x: float = dpos.x + sin(float(fl2) * 1.7 + _time * 4.0) * dsize * 0.3
				var flame_h: float = dsize * (0.6 + 0.4 * sin(_time * 6.0 + float(fl2) * 2.0)) * fi
				var fc: Color = Color(0.95, 0.85, 0.2, 0.9) if fl2 < 2 else (Color(0.95, 0.5, 0.05, 0.85) if fl2 < 4 else Color(0.8, 0.2, 0.02, 0.7))
				draw_line(Vector2(flame_x, dpos.y + dsize * 0.1), Vector2(flame_x + sin(_time * 3.0 + float(fl2)) * 3.0, dpos.y - flame_h), fc, 3.5 - float(fl2) * 0.3)

	# --- Path rendering: castle cobblestone (gray) ---
	if enemy_path and enemy_path.curve:
		var curve: Curve2D = enemy_path.curve
		var path_len: float = curve.get_baked_length()
		var prev_pt: Vector2 = curve.sample_baked(0.0)
		for pi in range(1, 101):
			var pt: Vector2 = curve.sample_baked(float(pi) / 100.0 * path_len)
			# Main cobblestone path
			draw_line(prev_pt, pt, Color(0.35, 0.33, 0.3), 28.0)
			# Lighter center
			draw_line(prev_pt, pt, Color(0.42, 0.4, 0.36), 18.0)
			# Edge stones
			var perp: Vector2 = (pt - prev_pt).normalized().rotated(PI * 0.5)
			draw_line(prev_pt + perp * 13.0, pt + perp * 13.0, Color(0.28, 0.26, 0.22, 0.7), 3.0)
			draw_line(prev_pt - perp * 13.0, pt - perp * 13.0, Color(0.28, 0.26, 0.22, 0.7), 3.0)
			prev_pt = pt
		# Cobblestone texture marks
		for ci in range(25):
			var cb_offset: float = (float(ci) + 0.3) / 25.0
			var cb_pt: Vector2 = curve.sample_baked(cb_offset * path_len)
			for cj in range(3):
				var cx_off: float = -7.0 + float(cj) * 7.0
				var cy_off: float = sin(float(ci) * 2.3 + float(cj) * 1.1) * 3.0
				draw_rect(Rect2(cb_pt.x + cx_off - 3.0, cb_pt.y + cy_off - 2.0, 6.0, 4.0), Color(0.3, 0.28, 0.25, 0.35), false, 0.8)

	# --- Smoke rising from castle (foreground effect) ---
	for sm in range(8):
		var smoke_base_x: float = 500.0 + float(sm) * 40.0
		var smoke_phase: float = fmod(_time * 0.5 + float(sm) * 1.2, 6.0)
		var smoke_y: float = castle_base_y - 20.0 - smoke_phase * 25.0
		var smoke_alpha: float = clampf(0.15 * (1.0 - smoke_phase / 6.0), 0.0, 0.15)
		var smoke_rad: float = 8.0 + smoke_phase * 6.0
		var smoke_drift: float = sin(_time * 0.8 + float(sm) * 0.7) * smoke_phase * 4.0
		draw_circle(Vector2(smoke_base_x + smoke_drift, smoke_y), smoke_rad, Color(0.3, 0.3, 0.3, smoke_alpha))

	# --- Dawn light rays (foreground atmospheric) ---
	for dr in range(5):
		var ray_x: float = 100.0 + float(dr) * 280.0
		var ray_alpha: float = 0.03 + 0.02 * sin(_time * 0.4 + float(dr) * 1.5)
		var ray_pts: PackedVector2Array = PackedVector2Array([
			Vector2(ray_x, 0.0),
			Vector2(ray_x - 40.0, 628.0),
			Vector2(ray_x + 60.0, 628.0),
			Vector2(ray_x + 15.0, 0.0)
		])
		draw_colored_polygon(ray_pts, Color(1.0, 0.85, 0.4, ray_alpha))

	# --- Embers / sparks floating up (animated) ---
	for em in range(15):
		var ember_phase: float = fmod(_time * 1.2 + float(em) * 0.9, 3.5)
		var ember_x: float = fmod(float(em) * 107.0 + sin(_time * 0.5 + float(em) * 1.3) * 30.0, 1280.0)
		var ember_y: float = 500.0 - ember_phase * 120.0 + sin(_time * 2.0 + float(em) * 2.7) * 10.0
		var ember_alpha: float = clampf(0.8 * (1.0 - ember_phase / 3.5), 0.0, 0.8)
		if ember_y > 50.0:
			draw_circle(Vector2(ember_x, ember_y), 1.5, Color(1.0, 0.6, 0.1, ember_alpha))
			draw_circle(Vector2(ember_x, ember_y), 3.5, Color(1.0, 0.5, 0.05, ember_alpha * 0.2))

func _draw_alice_ch2(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — deep purple twilight ===
	var sky_steps := 24
	for i in range(sky_steps):
		var t := float(i) / float(sky_steps)
		var y_start := 50.0 + t * 290.0
		var band_h := 290.0 / float(sky_steps) + 1.0
		var band_col := sky_color.lerp(Color(0.15, 0.08, 0.25), t)
		# Subtle purple haze pulsing
		var haze := clampf(sin(_time * 0.3 + t * 2.0), 0.0, 1.0) * 0.06
		band_col = band_col.lerp(Color(0.5, 0.2, 0.6), haze)
		draw_rect(Rect2(0, y_start, 1280, band_h), band_col)

	# === ATMOSPHERE — swirling tea steam and madness particles ===
	for i in range(18):
		var sx := fmod(float(i) * 173.7 + _time * 8.0, 1280.0)
		var sy := 80.0 + sin(_time * 0.6 + float(i) * 0.9) * 60.0 + float(i) * 14.0
		var steam_alpha := clampf(sin(_time * 0.7 + float(i) * 1.3), 0.0, 1.0) * 0.12
		draw_circle(Vector2(sx, sy), 6.0 + sin(_time + float(i)) * 3.0, Color(0.8, 0.7, 0.9, steam_alpha))

	# Floating question marks / madness sparkles
	for i in range(10):
		var qx := fmod(float(i) * 127.3, 1280.0)
		var qy := 100.0 + sin(_time * 0.4 + float(i) * 2.1) * 40.0 + float(i) * 20.0
		var q_alpha := clampf(sin(_time * 1.1 + float(i) * 0.7), 0.0, 1.0) * 0.15
		draw_circle(Vector2(qx, qy), 2.0, Color(1.0, 0.9, 0.3, q_alpha))

	# === CHESHIRE CAT GRIN — fading in and out ===
	var cat_x := 200.0 + sin(_time * 0.15) * 30.0
	var cat_y := 140.0 + cos(_time * 0.2) * 15.0
	var grin_alpha := clampf(sin(_time * 0.5), 0.0, 1.0) * 0.7
	if grin_alpha > 0.05:
		# Wide crescent grin
		var grin_w := 60.0
		var grin_pts := 16
		for i in range(grin_pts - 1):
			var t1 := float(i) / float(grin_pts - 1)
			var t2 := float(i + 1) / float(grin_pts - 1)
			var x1 := cat_x - grin_w * 0.5 + t1 * grin_w
			var x2 := cat_x - grin_w * 0.5 + t2 * grin_w
			var curve1 := sin(t1 * PI) * 12.0
			var curve2 := sin(t2 * PI) * 12.0
			draw_line(Vector2(x1, cat_y + curve1), Vector2(x2, cat_y + curve2), Color(0.9, 0.5, 0.9, grin_alpha), 2.5)
		# Teeth lines
		for i in range(6):
			var tx := cat_x - 20.0 + float(i) * 8.0
			var tt := (tx - (cat_x - grin_w * 0.5)) / grin_w
			var ty := cat_y + sin(tt * PI) * 12.0
			draw_line(Vector2(tx, ty - 2.0), Vector2(tx, ty + 3.0), Color(1.0, 1.0, 1.0, grin_alpha * 0.6), 1.0)
		# Eyes above grin (floating, glowing)
		var eye_alpha := grin_alpha * 0.8
		draw_circle(Vector2(cat_x - 18.0, cat_y - 20.0), 5.0, Color(0.6, 0.9, 0.2, eye_alpha))
		draw_circle(Vector2(cat_x + 18.0, cat_y - 20.0), 5.0, Color(0.6, 0.9, 0.2, eye_alpha))
		draw_circle(Vector2(cat_x - 18.0, cat_y - 20.0), 2.0, Color(0.1, 0.05, 0.2, eye_alpha))
		draw_circle(Vector2(cat_x + 18.0, cat_y - 20.0), 2.0, Color(0.1, 0.05, 0.2, eye_alpha))

	# === LANDMARKS ===
	# --- Massive tea table (center) ---
	var table_y := 360.0
	var table_x := 640.0
	# Table legs
	draw_rect(Rect2(table_x - 200.0, table_y, 16.0, 80.0), Color(0.35, 0.2, 0.1, 0.7))
	draw_rect(Rect2(table_x + 184.0, table_y, 16.0, 80.0), Color(0.35, 0.2, 0.1, 0.7))
	# Table top
	draw_rect(Rect2(table_x - 220.0, table_y - 8.0, 440.0, 16.0), Color(0.45, 0.28, 0.15, 0.75))
	# Table cloth drape
	for i in range(10):
		var drape_x := table_x - 210.0 + float(i) * 46.0
		var drape_sag := sin(float(i) * 0.8 + 1.0) * 8.0
		draw_line(Vector2(drape_x, table_y - 6.0), Vector2(drape_x + 23.0, table_y + drape_sag), Color(0.85, 0.8, 0.95, 0.35), 1.5)

	# --- Oversized teapot (on table, center) ---
	var pot_x := table_x
	var pot_y := table_y - 50.0
	# Body
	draw_circle(Vector2(pot_x, pot_y), 30.0, Color(0.6, 0.45, 0.7, 0.55))
	draw_circle(Vector2(pot_x, pot_y), 26.0, Color(0.7, 0.55, 0.8, 0.45))
	# Lid
	draw_rect(Rect2(pot_x - 18.0, pot_y - 34.0, 36.0, 6.0), Color(0.6, 0.45, 0.7, 0.6))
	draw_circle(Vector2(pot_x, pot_y - 38.0), 5.0, Color(0.65, 0.5, 0.75, 0.6))
	# Spout
	draw_line(Vector2(pot_x + 28.0, pot_y - 10.0), Vector2(pot_x + 55.0, pot_y - 30.0), Color(0.6, 0.45, 0.7, 0.5), 4.0)
	# Steam from spout
	for i in range(5):
		var st_y := pot_y - 35.0 - float(i) * 10.0
		var st_x := pot_x + 55.0 + sin(_time * 1.2 + float(i) * 0.8) * 8.0
		var st_a := 0.2 - float(i) * 0.035
		draw_circle(Vector2(st_x, st_y), 4.0 + float(i) * 1.5, Color(0.9, 0.85, 1.0, clampf(st_a, 0.0, 1.0)))
	# Handle
	draw_arc(Vector2(pot_x - 30.0, pot_y - 5.0), 14.0, PI * 0.5, PI * 1.5, 10, Color(0.6, 0.45, 0.7, 0.5), 3.0)

	# --- Oversized teacups on table ---
	for i in range(4):
		var cx := table_x - 150.0 + float(i) * 100.0
		if absf(cx - pot_x) < 40.0:
			cx += 60.0
		var cy := table_y - 20.0
		var cup_col := Color(0.75, 0.6 + float(i) * 0.05, 0.85, 0.5)
		draw_rect(Rect2(cx - 12.0, cy - 16.0, 24.0, 18.0), cup_col)
		draw_arc(Vector2(cx + 14.0, cy - 8.0), 7.0, -PI * 0.5, PI * 0.5, 8, cup_col, 2.0)
		# Liquid inside
		draw_rect(Rect2(cx - 10.0, cy - 12.0, 20.0, 4.0), Color(0.6, 0.4, 0.15, 0.35))

	# --- Broken pocket watches ---
	for i in range(5):
		var wx := 80.0 + float(i) * 260.0
		var wy := 300.0 + sin(float(i) * 1.7) * 40.0
		var watch_r := 14.0
		# Watch face
		draw_circle(Vector2(wx, wy), watch_r, Color(0.85, 0.78, 0.55, 0.35))
		draw_arc(Vector2(wx, wy), watch_r, 0.0, TAU, 12, Color(0.6, 0.5, 0.3, 0.4), 1.5)
		# Hands (spinning erratically)
		var hand_angle := _time * (1.5 + float(i) * 0.7)
		var hx := cos(hand_angle) * watch_r * 0.7
		var hy := sin(hand_angle) * watch_r * 0.7
		draw_line(Vector2(wx, wy), Vector2(wx + hx, wy + hy), Color(0.2, 0.15, 0.1, 0.5), 1.5)
		# Crack line
		draw_line(Vector2(wx - 4.0, wy - 6.0), Vector2(wx + 6.0, wy + 8.0), Color(0.3, 0.25, 0.2, 0.3), 1.0)

	# --- Croquet mallets (flamingo-shaped) ---
	for i in range(3):
		var mx := 950.0 + float(i) * 100.0
		var my := 380.0 + float(i) * 30.0
		var lean := sin(_time * 0.6 + float(i)) * 0.15
		# Shaft
		var shaft_top := Vector2(mx + sin(lean) * 50.0, my - 50.0)
		draw_line(Vector2(mx, my), shaft_top, Color(0.95, 0.55, 0.65, 0.4), 3.0)
		# Flamingo head
		draw_circle(shaft_top, 6.0, Color(0.95, 0.6, 0.7, 0.45))
		draw_circle(shaft_top + Vector2(4.0, -2.0), 2.0, Color(0.2, 0.15, 0.1, 0.4))
		# Beak
		draw_line(shaft_top + Vector2(5.0, 0.0), shaft_top + Vector2(11.0, 1.0), Color(0.9, 0.7, 0.2, 0.4), 1.5)

	# === GROUND — chess board tiles ===
	var ground_y := 440.0
	draw_rect(Rect2(0, ground_y, 1280, 628.0 - ground_y), ground_color)
	var tile_size := 40.0
	var cols := int(1280.0 / tile_size) + 1
	var rows := int((628.0 - ground_y) / tile_size) + 1
	for row in range(rows):
		for col in range(cols):
			var is_dark := (row + col) % 2 == 0
			var tile_col: Color
			if is_dark:
				tile_col = Color(0.2, 0.12, 0.25, 0.25)
			else:
				tile_col = Color(0.85, 0.78, 0.9, 0.15)
			draw_rect(Rect2(float(col) * tile_size, ground_y + float(row) * tile_size, tile_size, tile_size), tile_col)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"giant_mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var glow_pulse = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 0.8, mp.y - ms * 4.0, ms * 1.6, ms * 4.0), Color(0.85, 0.8, 0.7, 0.5))
				var cap_center = mp + Vector2(0, -ms * 4.5)
				draw_circle(cap_center, ms * 3.0 + 4.0, Color(0.7, 0.2, 0.8, 0.1 + glow_pulse * 0.08))
				draw_circle(cap_center, ms * 3.0, Color(0.8, 0.25, 0.4, 0.5))
				draw_circle(cap_center + Vector2(-ms, -ms * 0.5), ms * 0.5, Color(1, 0.95, 0.85, 0.4))
			"floating_card":
				var cp = dec["pos"]
				var drift_y = sin(_time * 0.8 + dec["extra"]) * 15.0
				var drift_x = cos(_time * 0.5 + dec["extra"]) * 8.0
				var card_pos = cp + Vector2(drift_x, drift_y)
				draw_rect(Rect2(card_pos.x - 4, card_pos.y - 6, 8, 12), Color(1.0, 0.98, 0.9, 0.25))
				var suit_col = Color(0.8, 0.15, 0.15, 0.35) if dec["extra"] > 3.0 else Color(0.1, 0.1, 0.1, 0.35)
				draw_circle(card_pos, 2.0, suit_col)
			"rose":
				var rp = dec["pos"]
				var sway = sin(_time * 1.2 + dec["extra"]) * 2.0
				draw_line(rp, rp + Vector2(sway, -12), Color(0.15, 0.4, 0.1, 0.45), 1.5)
				var bloom = rp + Vector2(sway, -12)
				var rc = Color(0.85, 0.1, 0.15, 0.5) if dec["extra"] < 0.5 else Color(0.95, 0.9, 0.85, 0.5)
				draw_circle(bloom, dec["size"], rc)
			"teacup":
				var tp2 = dec["pos"]
				draw_rect(Rect2(tp2.x - 4, tp2.y - 5, 8, 6), Color(0.8, 0.75, 0.6, 0.4))
				draw_arc(Vector2(tp2.x + 5, tp2.y - 2), 3, -PI * 0.5, PI * 0.5, 6, Color(0.8, 0.75, 0.6, 0.35), 1.0)

	# === FOREGROUND ===
	# Floating teaspoons drifting across bottom
	for i in range(6):
		var sp_x := fmod(float(i) * 213.0 + _time * 12.0, 1400.0) - 60.0
		var sp_y := 560.0 + sin(_time * 0.5 + float(i) * 1.1) * 20.0
		var sp_alpha := 0.2 + sin(_time * 0.8 + float(i)) * 0.08
		# Spoon handle
		draw_line(Vector2(sp_x, sp_y), Vector2(sp_x + 18.0, sp_y - 2.0), Color(0.75, 0.7, 0.5, clampf(sp_alpha, 0.0, 1.0)), 1.5)
		# Spoon bowl
		draw_circle(Vector2(sp_x - 4.0, sp_y + 1.0), 4.0, Color(0.75, 0.7, 0.5, clampf(sp_alpha, 0.0, 1.0)))

	# Sugar cubes tumbling
	for i in range(4):
		var sc_x := 100.0 + float(i) * 300.0
		var sc_y := 590.0 + sin(_time * 0.9 + float(i) * 2.0) * 8.0
		var rot := _time * 0.4 + float(i) * 1.5
		var sz := 6.0
		draw_rect(Rect2(sc_x - sz * 0.5, sc_y - sz * 0.5, sz, sz), Color(0.95, 0.93, 0.88, 0.2 + sin(rot) * 0.05))

	# Bottom haze — purple mist
	for i in range(8):
		var hz_t := float(i) / 8.0
		var hz_y := 600.0 + hz_t * 28.0
		draw_rect(Rect2(0, hz_y, 1280, 4.0), Color(0.25, 0.12, 0.35, 0.08 + hz_t * 0.06))


func _draw_alice_ch3(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — dark crimson royal sky ===
	var sky_steps := 24
	for i in range(sky_steps):
		var t := float(i) / float(sky_steps)
		var y_start := 50.0 + t * 290.0
		var band_h := 290.0 / float(sky_steps) + 1.0
		var band_col := sky_color.lerp(Color(0.3, 0.05, 0.08), t)
		# Pulsing red atmosphere
		var throb := clampf(sin(_time * 0.4 + t * 1.5), 0.0, 1.0) * 0.05
		band_col = band_col.lerp(Color(0.6, 0.05, 0.1), throb)
		draw_rect(Rect2(0, y_start, 1280, band_h), band_col)

	# === ATMOSPHERE — drifting red particles, paint droplets ===
	for i in range(14):
		var px := fmod(float(i) * 197.3 + _time * 5.0, 1280.0)
		var py := 80.0 + sin(_time * 0.5 + float(i) * 1.4) * 50.0 + float(i) * 15.0
		var p_alpha := clampf(sin(_time * 0.9 + float(i) * 0.8), 0.0, 1.0) * 0.12
		draw_circle(Vector2(px, py), 3.0 + sin(_time * 0.6 + float(i)) * 1.5, Color(0.8, 0.1, 0.15, p_alpha))

	# Falling paint droplets (red paint dripping from sky)
	for i in range(8):
		var dx := fmod(float(i) * 163.7, 1280.0)
		var fall_cycle := fmod(_time * 0.3 + float(i) * 1.2, 4.0)
		var dy := 60.0 + fall_cycle * 100.0
		var drop_alpha := clampf(0.25 - fall_cycle * 0.05, 0.0, 0.25)
		draw_circle(Vector2(dx, dy), 2.5, Color(0.85, 0.08, 0.12, drop_alpha))
		# Paint trail
		if fall_cycle > 0.5:
			draw_line(Vector2(dx, dy - 15.0), Vector2(dx, dy), Color(0.85, 0.08, 0.12, drop_alpha * 0.5), 1.0)

	# === LANDMARKS ===
	# --- Red palace walls (background, spanning width) ---
	var palace_y := 160.0
	var palace_h := 220.0
	# Main wall
	draw_rect(Rect2(80.0, palace_y, 1120.0, palace_h), Color(0.5, 0.08, 0.1, 0.3))
	# Crenellations along top
	for i in range(28):
		var cx := 80.0 + float(i) * 40.0
		if cx > 1200.0:
			break
		draw_rect(Rect2(cx, palace_y - 18.0, 28.0, 18.0), Color(0.5, 0.08, 0.1, 0.3))

	# Heart-shaped windows
	for i in range(6):
		var wx := 180.0 + float(i) * 170.0
		var wy := palace_y + 60.0 + sin(float(i) * 1.3) * 20.0
		# Heart shape from two circles + triangle
		var hr := 10.0
		draw_circle(Vector2(wx - hr * 0.55, wy - hr * 0.3), hr, Color(0.15, 0.02, 0.04, 0.5))
		draw_circle(Vector2(wx + hr * 0.55, wy - hr * 0.3), hr, Color(0.15, 0.02, 0.04, 0.5))
		# Bottom of heart (triangle approx with rect)
		draw_rect(Rect2(wx - hr, wy - hr * 0.3, hr * 2.0, hr * 1.2), Color(0.15, 0.02, 0.04, 0.5))
		# Inner glow
		var win_glow := clampf(sin(_time * 0.7 + float(i) * 1.1), 0.0, 1.0) * 0.15
		draw_circle(Vector2(wx, wy), hr * 0.6, Color(1.0, 0.8, 0.3, win_glow))

	# --- Palace towers at edges ---
	for side in range(2):
		var tx := 60.0 if side == 0 else 1180.0
		draw_rect(Rect2(tx, palace_y - 60.0, 50.0, palace_h + 60.0), Color(0.55, 0.1, 0.12, 0.35))
		# Tower top (pointed)
		draw_line(Vector2(tx, palace_y - 60.0), Vector2(tx + 25.0, palace_y - 100.0), Color(0.55, 0.1, 0.12, 0.35), 3.0)
		draw_line(Vector2(tx + 50.0, palace_y - 60.0), Vector2(tx + 25.0, palace_y - 100.0), Color(0.55, 0.1, 0.12, 0.35), 3.0)
		# Heart flag
		draw_line(Vector2(tx + 25.0, palace_y - 100.0), Vector2(tx + 25.0, palace_y - 125.0), Color(0.3, 0.05, 0.08, 0.4), 1.5)
		var flag_sway := sin(_time * 1.5 + float(side) * PI) * 4.0
		draw_circle(Vector2(tx + 25.0 + flag_sway, palace_y - 130.0), 6.0, Color(0.85, 0.1, 0.15, 0.4))

	# --- Queen's throne silhouette (center background) ---
	var throne_x := 640.0
	var throne_y := 200.0
	# Throne back (tall arch)
	draw_rect(Rect2(throne_x - 25.0, throne_y - 80.0, 50.0, 100.0), Color(0.2, 0.02, 0.05, 0.35))
	# Throne ornate top (crown-like)
	for i in range(5):
		var spike_x := throne_x - 20.0 + float(i) * 10.0
		var spike_h := 15.0 if (i % 2 == 0) else 10.0
		draw_rect(Rect2(spike_x - 2.0, throne_y - 80.0 - spike_h, 4.0, spike_h), Color(0.2, 0.02, 0.05, 0.35))
	# Heart on throne
	draw_circle(Vector2(throne_x, throne_y - 50.0), 8.0, Color(0.7, 0.05, 0.1, 0.3))
	# Seat
	draw_rect(Rect2(throne_x - 30.0, throne_y + 15.0, 60.0, 12.0), Color(0.2, 0.02, 0.05, 0.35))
	# Armrests
	draw_rect(Rect2(throne_x - 35.0, throne_y - 10.0, 8.0, 30.0), Color(0.2, 0.02, 0.05, 0.3))
	draw_rect(Rect2(throne_x + 27.0, throne_y - 10.0, 8.0, 30.0), Color(0.2, 0.02, 0.05, 0.3))

	# --- "OFF WITH THEIR HEADS" banner ---
	var banner_y := 130.0
	var banner_sway := sin(_time * 0.6) * 5.0
	draw_rect(Rect2(440.0, banner_y + banner_sway, 400.0, 28.0), Color(0.8, 0.08, 0.12, 0.35))
	# Banner end notches
	draw_line(Vector2(440.0, banner_y + banner_sway), Vector2(430.0, banner_y + banner_sway + 14.0), Color(0.8, 0.08, 0.12, 0.35), 3.0)
	draw_line(Vector2(840.0, banner_y + banner_sway), Vector2(850.0, banner_y + banner_sway + 14.0), Color(0.8, 0.08, 0.12, 0.35), 3.0)
	# Text approximation with small rectangles (block letters)
	var text_blocks := [0.0, 20.0, 40.0, 60.0, 100.0, 120.0, 140.0, 160.0, 200.0, 220.0, 240.0, 260.0, 280.0, 320.0, 340.0, 360.0, 380.0]
	for bx in text_blocks:
		draw_rect(Rect2(450.0 + bx, banner_y + 6.0 + banner_sway, 14.0, 4.0), Color(0.15, 0.02, 0.04, 0.5))
		draw_rect(Rect2(450.0 + bx, banner_y + 14.0 + banner_sway, 14.0, 4.0), Color(0.15, 0.02, 0.04, 0.5))

	# --- Card soldier formations (flanking path) ---
	for i in range(8):
		var sx := 100.0 + float(i) * 150.0
		var sy := 400.0 + sin(float(i) * 0.9) * 20.0
		var bob := sin(_time * 1.0 + float(i) * 0.7) * 2.0
		# Card body
		var is_heart := (i % 2 == 0)
		var card_col := Color(0.85, 0.1, 0.15, 0.35) if is_heart else Color(0.15, 0.15, 0.15, 0.3)
		draw_rect(Rect2(sx - 8.0, sy - 22.0 + bob, 16.0, 28.0), card_col)
		# Suit symbol
		var sym_col := Color(0.95, 0.2, 0.25, 0.45) if is_heart else Color(0.3, 0.3, 0.3, 0.4)
		draw_circle(Vector2(sx, sy - 12.0 + bob), 3.0, sym_col)
		# Spear
		draw_line(Vector2(sx + 10.0, sy - 20.0 + bob), Vector2(sx + 10.0, sy - 45.0 + bob), Color(0.5, 0.45, 0.3, 0.3), 1.5)
		# Spear tip
		draw_line(Vector2(sx + 10.0, sy - 45.0 + bob), Vector2(sx + 7.0, sy - 40.0 + bob), Color(0.6, 0.55, 0.5, 0.35), 1.5)
		draw_line(Vector2(sx + 10.0, sy - 45.0 + bob), Vector2(sx + 13.0, sy - 40.0 + bob), Color(0.6, 0.55, 0.5, 0.35), 1.5)

	# --- Rose garden — white roses being painted red ---
	for i in range(10):
		var rx := 60.0 + float(i) * 125.0
		var ry := 430.0 + sin(float(i) * 2.1) * 15.0
		# Stem
		var stem_sway := sin(_time * 0.9 + float(i) * 0.6) * 1.5
		draw_line(Vector2(rx + stem_sway, ry), Vector2(rx, ry + 25.0), Color(0.15, 0.35, 0.1, 0.4), 1.5)
		# Rose bloom — transition from white to red based on paint progress
		var paint_progress := clampf(sin(_time * 0.2 + float(i) * 0.8) * 0.5 + 0.5, 0.0, 1.0)
		var rose_white := Color(0.95, 0.92, 0.88, 0.5)
		var rose_red := Color(0.85, 0.1, 0.15, 0.55)
		var rose_col := rose_white.lerp(rose_red, paint_progress)
		draw_circle(Vector2(rx + stem_sway, ry), 6.0, rose_col)
		# Paint drip below partially-painted roses
		if paint_progress > 0.3:
			var drip_len := paint_progress * 12.0
			draw_line(Vector2(rx + stem_sway, ry + 5.0), Vector2(rx + stem_sway, ry + 5.0 + drip_len), Color(0.85, 0.08, 0.1, 0.3), 1.5)
			# Drip drop at bottom
			draw_circle(Vector2(rx + stem_sway, ry + 6.0 + drip_len), 1.5, Color(0.85, 0.08, 0.1, 0.25))

	# --- Heart motifs scattered ---
	for i in range(12):
		var hx := fmod(float(i) * 107.3, 1280.0)
		var hy := 100.0 + float(i) * 40.0 + sin(_time * 0.3 + float(i)) * 10.0
		var h_alpha := 0.08 + clampf(sin(_time * 0.6 + float(i) * 1.3), 0.0, 1.0) * 0.07
		var h_size := 4.0 + sin(float(i) * 1.5) * 2.0
		draw_circle(Vector2(hx - h_size * 0.4, hy), h_size, Color(0.8, 0.1, 0.15, h_alpha))
		draw_circle(Vector2(hx + h_size * 0.4, hy), h_size, Color(0.8, 0.1, 0.15, h_alpha))
		draw_rect(Rect2(hx - h_size, hy, h_size * 2.0, h_size * 1.0), Color(0.8, 0.1, 0.15, h_alpha))

	# === GROUND — red/black checkerboard courtyard ===
	var ground_y := 450.0
	draw_rect(Rect2(0, ground_y, 1280, 628.0 - ground_y), ground_color)
	var tile_size := 36.0
	var cols := int(1280.0 / tile_size) + 1
	var rows := int((628.0 - ground_y) / tile_size) + 1
	for row in range(rows):
		for col in range(cols):
			var is_red := (row + col) % 2 == 0
			var tile_col: Color
			if is_red:
				tile_col = Color(0.55, 0.08, 0.1, 0.3)
			else:
				tile_col = Color(0.08, 0.05, 0.05, 0.25)
			draw_rect(Rect2(float(col) * tile_size, ground_y + float(row) * tile_size, tile_size, tile_size), tile_col)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"giant_mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var glow_pulse = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 0.8, mp.y - ms * 4.0, ms * 1.6, ms * 4.0), Color(0.85, 0.8, 0.7, 0.5))
				var cap_center = mp + Vector2(0, -ms * 4.5)
				draw_circle(cap_center, ms * 3.0 + 4.0, Color(0.7, 0.2, 0.8, 0.1 + glow_pulse * 0.08))
				draw_circle(cap_center, ms * 3.0, Color(0.8, 0.25, 0.4, 0.5))
				draw_circle(cap_center + Vector2(-ms, -ms * 0.5), ms * 0.5, Color(1, 0.95, 0.85, 0.4))
			"floating_card":
				var cp = dec["pos"]
				var drift_y = sin(_time * 0.8 + dec["extra"]) * 15.0
				var drift_x = cos(_time * 0.5 + dec["extra"]) * 8.0
				var card_pos = cp + Vector2(drift_x, drift_y)
				draw_rect(Rect2(card_pos.x - 4, card_pos.y - 6, 8, 12), Color(1.0, 0.98, 0.9, 0.25))
				var suit_col = Color(0.8, 0.15, 0.15, 0.35) if dec["extra"] > 3.0 else Color(0.1, 0.1, 0.1, 0.35)
				draw_circle(card_pos, 2.0, suit_col)
			"rose":
				var rp = dec["pos"]
				var sway = sin(_time * 1.2 + dec["extra"]) * 2.0
				draw_line(rp, rp + Vector2(sway, -12), Color(0.15, 0.4, 0.1, 0.45), 1.5)
				var bloom = rp + Vector2(sway, -12)
				var rc = Color(0.85, 0.1, 0.15, 0.5) if dec["extra"] < 0.5 else Color(0.95, 0.9, 0.85, 0.5)
				draw_circle(bloom, dec["size"], rc)
			"teacup":
				var tp2 = dec["pos"]
				draw_rect(Rect2(tp2.x - 4, tp2.y - 5, 8, 6), Color(0.8, 0.75, 0.6, 0.4))
				draw_arc(Vector2(tp2.x + 5, tp2.y - 2), 3, -PI * 0.5, PI * 0.5, 6, Color(0.8, 0.75, 0.6, 0.35), 1.0)

	# === FOREGROUND ===
	# Scattered playing cards at bottom
	for i in range(7):
		var fc_x := fmod(float(i) * 187.0 + _time * 6.0, 1400.0) - 60.0
		var fc_y := 570.0 + sin(_time * 0.4 + float(i) * 0.9) * 12.0
		var fc_alpha := 0.15 + clampf(sin(_time * 0.5 + float(i)), 0.0, 1.0) * 0.08
		# Card rectangle
		draw_rect(Rect2(fc_x - 6.0, fc_y - 9.0, 12.0, 18.0), Color(0.95, 0.92, 0.85, fc_alpha))
		# Red or black suit
		var is_red_card := (i % 2 == 0)
		var suit_c := Color(0.8, 0.1, 0.15, fc_alpha * 1.2) if is_red_card else Color(0.1, 0.1, 0.1, fc_alpha * 1.2)
		draw_circle(Vector2(fc_x, fc_y - 2.0), 2.0, suit_c)

	# Red paint splatters on ground
	for i in range(5):
		var splat_x := 150.0 + float(i) * 240.0
		var splat_y := 600.0 + sin(float(i) * 2.7) * 10.0
		var splat_r := 8.0 + sin(float(i) * 1.3) * 4.0
		draw_circle(Vector2(splat_x, splat_y), splat_r, Color(0.75, 0.06, 0.1, 0.12))
		# Smaller satellite splatters
		for j in range(3):
			var angle := float(j) * TAU / 3.0 + float(i)
			var dist := splat_r + 5.0
			var sub_x := splat_x + cos(angle) * dist
			var sub_y := splat_y + sin(angle) * dist
			draw_circle(Vector2(sub_x, sub_y), 2.5, Color(0.75, 0.06, 0.1, 0.08))

	# Bottom crimson fog
	for i in range(8):
		var fog_t := float(i) / 8.0
		var fog_y := 600.0 + fog_t * 28.0
		draw_rect(Rect2(0, fog_y, 1280, 4.0), Color(0.35, 0.05, 0.08, 0.08 + fog_t * 0.06))

func _draw_oz_ch2(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — dark green-black storm sky ===
	for i in range(40):
		var t = float(i) / 39.0
		var col = sky_color.lerp(Color(0.03, 0.08, 0.02, 1.0), t * 0.6)
		# Lightning flicker in storm clouds
		var lightning = clampf(sin(_time * 8.7 + t * 12.0) * sin(_time * 3.1), 0.0, 1.0)
		if lightning > 0.92:
			col = col.lerp(Color(0.6, 0.7, 0.5, 1.0), (lightning - 0.92) * 8.0)
		draw_rect(Rect2(0, 50 + t * 280, 1280, 8.5), col)

	# === STORM CLOUDS — roiling green-black masses ===
	for i in range(18):
		var cx = float(i) * 75.0 + sin(_time * 0.3 + float(i) * 0.9) * 30.0
		var cy = 70.0 + sin(float(i) * 1.7 + _time * 0.25) * 25.0
		var cr = 55.0 + sin(float(i) * 2.3) * 20.0
		var cloud_col = Color(0.04, 0.1, 0.03, 0.6 + sin(_time * 0.4 + float(i)) * 0.1)
		draw_circle(Vector2(cx, cy), cr, cloud_col)
		# Green-tinged underbelly
		draw_circle(Vector2(cx + 10.0, cy + 15.0), cr * 0.7, Color(0.08, 0.18, 0.05, 0.35))

	# === SICKLY GREEN MOON behind clouds ===
	var moon_x = 980.0
	var moon_y = 100.0
	draw_circle(Vector2(moon_x, moon_y), 42.0, Color(0.25, 0.45, 0.15, 0.35))
	draw_circle(Vector2(moon_x, moon_y), 34.0, Color(0.35, 0.55, 0.2, 0.5))
	draw_circle(Vector2(moon_x, moon_y), 26.0, Color(0.5, 0.7, 0.3, 0.6))
	# Moon craters
	draw_circle(Vector2(moon_x - 8.0, moon_y - 5.0), 6.0, Color(0.3, 0.5, 0.15, 0.3))
	draw_circle(Vector2(moon_x + 10.0, moon_y + 4.0), 4.0, Color(0.3, 0.5, 0.15, 0.25))

	# === BROOMSTICK SILHOUETTE crossing the moon (animated) ===
	var broom_phase = fmod(_time * 0.4, 2.0) - 1.0
	var broom_cx = moon_x + broom_phase * 80.0
	var broom_cy = moon_y + sin(broom_phase * 3.0) * 12.0
	if absf(broom_phase) < 0.8:
		# Rider silhouette
		var broom_pts = PackedVector2Array([
			Vector2(broom_cx - 18.0, broom_cy - 6.0),
			Vector2(broom_cx + 12.0, broom_cy - 2.0),
			Vector2(broom_cx + 22.0, broom_cy + 2.0),
			Vector2(broom_cx + 30.0, broom_cy + 6.0),
			Vector2(broom_cx + 30.0, broom_cy + 10.0),
			Vector2(broom_cx + 12.0, broom_cy + 4.0),
			Vector2(broom_cx - 8.0, broom_cy + 4.0),
			Vector2(broom_cx - 18.0, broom_cy)])
		draw_colored_polygon(broom_pts, Color(0.02, 0.02, 0.02, 0.85))
		# Pointy hat
		draw_colored_polygon(PackedVector2Array([
			Vector2(broom_cx - 12.0, broom_cy - 6.0),
			Vector2(broom_cx - 6.0, broom_cy - 22.0),
			Vector2(broom_cx - 2.0, broom_cy - 6.0)]), Color(0.02, 0.02, 0.02, 0.85))
		# Broom bristles
		for b in range(5):
			var boff = float(b) * 2.5 - 5.0
			draw_line(Vector2(broom_cx + 28.0, broom_cy + 6.0), Vector2(broom_cx + 40.0, broom_cy + 4.0 + boff), Color(0.02, 0.02, 0.02, 0.7), 1.0)

	# === DISTANT MOUNTAINS — dark jagged peaks ===
	for layer in range(3):
		var pts = PackedVector2Array()
		pts.append(Vector2(0, 330 - layer * 30))
		var lf = float(layer)
		for j in range(26):
			var mx = float(j) * 52.0
			var my = 210.0 - lf * 30.0 + sin(float(j) * 1.3 + lf * 2.0) * 45.0 + sin(float(j) * 0.4) * 30.0
			pts.append(Vector2(mx, my))
		pts.append(Vector2(1280, 330 - layer * 30))
		var dark = 0.03 + lf * 0.02
		draw_colored_polygon(pts, Color(dark, dark + 0.02, dark, 0.85 - lf * 0.1))

	# === WITCH'S CASTLE SILHOUETTE on tallest peak ===
	var castle_x = 350.0
	var castle_base = 165.0
	# Main tower
	draw_colored_polygon(PackedVector2Array([
		Vector2(castle_x - 25.0, castle_base), Vector2(castle_x - 20.0, castle_base - 80.0),
		Vector2(castle_x - 8.0, castle_base - 95.0), Vector2(castle_x, castle_base - 110.0),
		Vector2(castle_x + 8.0, castle_base - 95.0), Vector2(castle_x + 20.0, castle_base - 80.0),
		Vector2(castle_x + 25.0, castle_base)]), Color(0.02, 0.02, 0.02, 0.95))
	# Side towers
	for side in [-1.0, 1.0]:
		var sx = castle_x + side * 45.0
		draw_colored_polygon(PackedVector2Array([
			Vector2(sx - 12.0, castle_base), Vector2(sx - 10.0, castle_base - 50.0),
			Vector2(sx, castle_base - 65.0), Vector2(sx + 10.0, castle_base - 50.0),
			Vector2(sx + 12.0, castle_base)]), Color(0.02, 0.02, 0.02, 0.95))
	# Castle windows — eerie green glow
	var win_glow = 0.5 + sin(_time * 1.5) * 0.2
	draw_circle(Vector2(castle_x, castle_base - 70.0), 4.0, Color(0.2, 0.6 * win_glow, 0.1, 0.7))
	draw_circle(Vector2(castle_x - 45.0, castle_base - 35.0), 3.0, Color(0.2, 0.5 * win_glow, 0.1, 0.6))
	draw_circle(Vector2(castle_x + 45.0, castle_base - 35.0), 3.0, Color(0.2, 0.5 * win_glow, 0.1, 0.6))

	# === HOURGLASS MOTIF — ghostly outline in the sky ===
	var hg_x = 160.0
	var hg_y = 130.0
	var hg_alpha = 0.12 + sin(_time * 0.8) * 0.05
	draw_colored_polygon(PackedVector2Array([
		Vector2(hg_x - 14.0, hg_y - 28.0), Vector2(hg_x + 14.0, hg_y - 28.0),
		Vector2(hg_x + 3.0, hg_y), Vector2(hg_x + 14.0, hg_y + 28.0),
		Vector2(hg_x - 14.0, hg_y + 28.0), Vector2(hg_x - 3.0, hg_y)]),
		Color(0.3, 0.6, 0.2, hg_alpha))
	# Sand falling
	var sand_y = hg_y - 10.0 + fmod(_time * 12.0, 20.0)
	if sand_y < hg_y + 20.0:
		draw_circle(Vector2(hg_x, sand_y), 1.5, Color(0.5, 0.7, 0.2, hg_alpha * 2.0))

	# === GREEN SMOKE RISING from castle ===
	for s in range(8):
		var sf = float(s)
		var smoke_t = fmod(_time * 0.6 + sf * 0.4, 3.5)
		var smoke_x = castle_x + sin(smoke_t * 2.0 + sf) * 15.0
		var smoke_y = castle_base - 110.0 - smoke_t * 30.0
		var smoke_r = 6.0 + smoke_t * 8.0
		var smoke_a = clampf(0.3 - smoke_t * 0.08, 0.0, 0.3)
		draw_circle(Vector2(smoke_x, smoke_y), smoke_r, Color(0.15, 0.5, 0.1, smoke_a))

	# === WINKIE GUARD TOWERS — flanking the scene ===
	for gx in [80.0, 1200.0]:
		var gy = 300.0
		# Tower body
		draw_rect(Rect2(gx - 14.0, gy - 55.0, 28.0, 55.0), Color(0.12, 0.1, 0.05, 0.75))
		# Crenellations
		for c in range(4):
			draw_rect(Rect2(gx - 14.0 + float(c) * 9.0, gy - 62.0, 5.0, 7.0), Color(0.12, 0.1, 0.05, 0.75))
		# Torch glow
		var torch_flicker = 0.6 + sin(_time * 5.0 + gx) * 0.15
		draw_circle(Vector2(gx, gy - 40.0), 5.0, Color(0.6, 0.3, 0.05, torch_flicker * 0.5))
		draw_circle(Vector2(gx, gy - 40.0), 3.0, Color(0.8, 0.5, 0.1, torch_flicker * 0.7))

	# === FLYING MONKEYS — animated swooping ===
	for m in range(4):
		var mf = float(m)
		var monkey_t = fmod(_time * 0.7 + mf * 1.8, 6.0)
		var monkey_x = monkey_t * 220.0 - 40.0
		var monkey_y = 140.0 + sin(monkey_t * 3.0 + mf * 2.0) * 35.0 + mf * 25.0
		if monkey_x > -20.0 and monkey_x < 1300.0:
			# Body
			draw_circle(Vector2(monkey_x, monkey_y), 5.0, Color(0.08, 0.06, 0.04, 0.7))
			# Wings flapping
			var wing_angle = sin(_time * 8.0 + mf * 3.0) * 0.6
			var wing_up = -12.0 + wing_angle * 10.0
			draw_line(Vector2(monkey_x - 4.0, monkey_y), Vector2(monkey_x - 16.0, monkey_y + wing_up), Color(0.1, 0.08, 0.05, 0.6), 2.0)
			draw_line(Vector2(monkey_x + 4.0, monkey_y), Vector2(monkey_x + 16.0, monkey_y + wing_up), Color(0.1, 0.08, 0.05, 0.6), 2.0)

	# === DEAD GNARLED TREES ===
	for tx in [50.0, 220.0, 600.0, 850.0, 1100.0, 1230.0]:
		var tree_base = 340.0 + sin(tx * 0.7) * 15.0
		var tree_h = 50.0 + sin(tx * 1.3) * 15.0
		var tree_col = Color(0.08, 0.06, 0.03, 0.7)
		# Trunk
		draw_line(Vector2(tx, tree_base), Vector2(tx + sin(tx) * 5.0, tree_base - tree_h), tree_col, 3.0)
		# Twisted branches
		for br in range(4):
			var bf = float(br)
			var by = tree_base - tree_h * (0.4 + bf * 0.15)
			var bx_off = (15.0 + bf * 8.0) * (1.0 if fmod(bf, 2.0) < 1.0 else -1.0)
			var sway = sin(_time * 0.7 + tx + bf) * 3.0
			draw_line(Vector2(tx, by), Vector2(tx + bx_off + sway, by - 12.0 - bf * 3.0), tree_col, 1.5)
			# Sub-branches
			draw_line(Vector2(tx + bx_off * 0.7 + sway, by - 8.0), Vector2(tx + bx_off * 1.1 + sway, by - 20.0), tree_col, 1.0)

	# === GROUND — barren dark earth ===
	var ground_pts = PackedVector2Array()
	ground_pts.append(Vector2(0, 628))
	for g in range(65):
		var gx = float(g) * 20.0
		var gy = 340.0 + sin(gx * 0.03 + 1.5) * 12.0 + sin(gx * 0.07) * 5.0
		ground_pts.append(Vector2(gx, gy))
	ground_pts.append(Vector2(1280, 628))
	draw_colored_polygon(ground_pts, ground_color)

	# Ground texture — cracked dry earth
	for i in range(30):
		var cx = float(i) * 43.0 + sin(float(i) * 3.7) * 20.0
		var cy = 380.0 + sin(float(i) * 1.9) * 60.0 + float(i) * 5.0
		if cy < 620.0:
			var crack_len = 15.0 + sin(float(i) * 2.3) * 8.0
			var crack_angle = sin(float(i) * 4.1) * 0.8
			draw_line(Vector2(cx, cy), Vector2(cx + cos(crack_angle) * crack_len, cy + sin(crack_angle) * crack_len), Color(0.05, 0.04, 0.02, 0.3), 1.0)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"poppy":
				var pp = dec["pos"]
				var ps = dec["size"]
				var sway = sin(_time * 1.3 + dec["extra"]) * 2.0
				draw_line(pp, pp + Vector2(sway, -ps * 6.0), Color(0.15, 0.35, 0.1, 0.5), 1.0)
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 2.5, Color(0.85, 0.12, 0.1, 0.55))
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 0.7, Color(0.15, 0.1, 0.05, 0.5))
			"emerald_crystal":
				var ep = dec["pos"]
				var es = dec["size"]
				var sparkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				draw_colored_polygon(PackedVector2Array([ep + Vector2(0, -es * 2), ep + Vector2(es, 0), ep + Vector2(0, es), ep + Vector2(-es, 0)]), Color(0.2, 0.8, 0.3, 0.4 + sparkle * 0.15))
			"scarecrow":
				var sp = dec["pos"]
				var ss = dec["size"]
				draw_line(sp, sp + Vector2(0, -ss * 2), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_line(sp + Vector2(-ss, -ss * 1.5), sp + Vector2(ss, -ss * 1.5), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_circle(sp + Vector2(0, -ss * 2.2), ss * 0.5, Color(0.6, 0.5, 0.2, 0.45))

	# === FOREGROUND — dark mist and atmosphere ===
	for i in range(6):
		var fi = float(i)
		var fog_x = fmod(fi * 250.0 + _time * 15.0, 1400.0) - 60.0
		var fog_y = 560.0 + sin(fi * 2.0) * 30.0
		draw_circle(Vector2(fog_x, fog_y), 50.0 + fi * 8.0, Color(0.05, 0.12, 0.03, 0.08))

	# Vignette — dark edges
	for v in range(8):
		var vf = float(v)
		var va = 0.04 * (8.0 - vf)
		draw_rect(Rect2(0, 50, vf * 2.0, 578), Color(0.0, 0.0, 0.0, va))
		draw_rect(Rect2(1280.0 - vf * 2.0, 50, vf * 2.0, 578), Color(0.0, 0.0, 0.0, va))


func _draw_oz_ch3(sky_color: Color, ground_color: Color) -> void:
	# === SKY / CEILING — emerald green crystalline glow ===
	for i in range(40):
		var t = float(i) / 39.0
		var col = sky_color.lerp(Color(0.05, 0.25, 0.08, 1.0), t * 0.7)
		# Pulsing emerald radiance
		var pulse = sin(_time * 0.6 + t * 4.0) * 0.04
		col = Color(col.r + pulse * 0.3, col.g + pulse, col.b + pulse * 0.3, 1.0)
		draw_rect(Rect2(0, 50 + t * 280, 1280, 8.5), col)

	# === JEWELED CEILING — faceted crystal pattern ===
	for i in range(22):
		var fi = float(i)
		var cx = fi * 62.0 + sin(fi * 1.7) * 15.0
		var cy = 65.0 + sin(fi * 2.3) * 12.0
		var jewel_size = 8.0 + sin(fi * 3.1) * 3.0
		var shimmer = (sin(_time * 1.8 + fi * 1.4) + 1.0) * 0.5
		# Emerald facet
		draw_colored_polygon(PackedVector2Array([
			Vector2(cx, cy - jewel_size), Vector2(cx + jewel_size * 0.7, cy),
			Vector2(cx, cy + jewel_size * 0.5), Vector2(cx - jewel_size * 0.7, cy)]),
			Color(0.15, 0.6 + shimmer * 0.2, 0.2, 0.35 + shimmer * 0.15))
		# Light refraction lines
		if shimmer > 0.7:
			draw_line(Vector2(cx, cy), Vector2(cx + sin(fi) * 30.0, cy + 40.0 + fi * 3.0),
				Color(0.3, 0.8, 0.4, 0.06), 1.0)

	# === GREEN CRYSTAL WALLS — left and right ===
	for side in [0.0, 1.0]:
		var wall_x = side * 1200.0 + 20.0
		# Crystal column structures
		for j in range(6):
			var jf = float(j)
			var col_x = wall_x + sin(jf * 2.0) * 10.0
			var col_top = 70.0 + jf * 8.0
			var col_bot = 600.0 - jf * 10.0
			var glow = 0.3 + sin(_time * 1.2 + jf + side * 3.0) * 0.1
			# Crystal column body
			draw_rect(Rect2(col_x, col_top, 10.0 + jf * 2.0, col_bot - col_top),
				Color(0.1, 0.35 + glow, 0.12, 0.2 - jf * 0.02))
			# Facet highlights
			draw_line(Vector2(col_x + 2.0, col_top), Vector2(col_x + 2.0, col_bot),
				Color(0.3, 0.7, 0.35, 0.1), 1.0)

	# === EMERALD GLOW — ambient light from walls ===
	for i in range(5):
		var fi = float(i)
		var glow_x = fi * 320.0 + 80.0
		var glow_y = 300.0 + sin(fi * 2.0) * 50.0
		var glow_pulse = 0.06 + sin(_time * 0.9 + fi * 1.5) * 0.02
		draw_circle(Vector2(glow_x, glow_y), 120.0, Color(0.1, 0.4, 0.12, glow_pulse))
		draw_circle(Vector2(glow_x, glow_y), 60.0, Color(0.15, 0.5, 0.18, glow_pulse * 1.5))

	# === THRONE at far end — tall emerald chair ===
	var throne_x = 640.0
	var throne_y = 150.0
	# Throne back — tall pointed emerald
	draw_colored_polygon(PackedVector2Array([
		Vector2(throne_x - 30.0, throne_y + 60.0), Vector2(throne_x - 20.0, throne_y - 40.0),
		Vector2(throne_x - 8.0, throne_y - 70.0), Vector2(throne_x, throne_y - 80.0),
		Vector2(throne_x + 8.0, throne_y - 70.0), Vector2(throne_x + 20.0, throne_y - 40.0),
		Vector2(throne_x + 30.0, throne_y + 60.0)]),
		Color(0.08, 0.35, 0.1, 0.6))
	# Throne glow
	var throne_glow = 0.3 + sin(_time * 0.7) * 0.1
	draw_circle(Vector2(throne_x, throne_y - 20.0), 18.0, Color(0.2, 0.6, 0.25, throne_glow * 0.4))
	# Emerald jewel on throne top
	draw_circle(Vector2(throne_x, throne_y - 72.0), 6.0, Color(0.3, 0.85, 0.35, 0.7))
	draw_circle(Vector2(throne_x, throne_y - 72.0), 3.0, Color(0.6, 1.0, 0.65, 0.5))
	# Throne seat
	draw_rect(Rect2(throne_x - 24.0, throne_y + 40.0, 48.0, 12.0), Color(0.06, 0.28, 0.08, 0.55))
	# Armrests
	draw_rect(Rect2(throne_x - 32.0, throne_y + 20.0, 8.0, 32.0), Color(0.07, 0.3, 0.09, 0.5))
	draw_rect(Rect2(throne_x + 24.0, throne_y + 20.0, 8.0, 32.0), Color(0.07, 0.3, 0.09, 0.5))

	# === RUBY SLIPPERS MOTIF — glowing on throne steps ===
	var slipper_x = 640.0
	var slipper_y = 240.0
	var ruby_sparkle = (sin(_time * 2.5) + 1.0) * 0.5
	# Left slipper
	draw_colored_polygon(PackedVector2Array([
		Vector2(slipper_x - 15.0, slipper_y), Vector2(slipper_x - 5.0, slipper_y - 5.0),
		Vector2(slipper_x - 2.0, slipper_y - 3.0), Vector2(slipper_x - 3.0, slipper_y + 2.0),
		Vector2(slipper_x - 10.0, slipper_y + 4.0)]),
		Color(0.8, 0.1, 0.1, 0.5 + ruby_sparkle * 0.2))
	# Right slipper
	draw_colored_polygon(PackedVector2Array([
		Vector2(slipper_x + 5.0, slipper_y), Vector2(slipper_x + 15.0, slipper_y - 4.0),
		Vector2(slipper_x + 18.0, slipper_y - 1.0), Vector2(slipper_x + 16.0, slipper_y + 3.0),
		Vector2(slipper_x + 8.0, slipper_y + 4.0)]),
		Color(0.8, 0.1, 0.1, 0.5 + ruby_sparkle * 0.2))
	# Ruby glow
	draw_circle(Vector2(slipper_x + 2.0, slipper_y), 12.0, Color(0.7, 0.1, 0.1, 0.08 + ruby_sparkle * 0.06))

	# === NOME KING'S ROCKS — emerging through floor ===
	for i in range(7):
		var fi = float(i)
		var rock_x = 100.0 + fi * 170.0 + sin(fi * 3.3) * 40.0
		var rock_base_y = 420.0 + sin(fi * 2.1) * 30.0
		var emerge_phase = sin(_time * 0.5 + fi * 1.2)
		var rock_height = 20.0 + clampf(emerge_phase, 0.0, 1.0) * 25.0
		var rock_w = 18.0 + sin(fi * 1.7) * 6.0
		# Jagged rock shape
		draw_colored_polygon(PackedVector2Array([
			Vector2(rock_x - rock_w, rock_base_y),
			Vector2(rock_x - rock_w * 0.6, rock_base_y - rock_height * 0.7),
			Vector2(rock_x - rock_w * 0.2, rock_base_y - rock_height),
			Vector2(rock_x + rock_w * 0.3, rock_base_y - rock_height * 0.85),
			Vector2(rock_x + rock_w * 0.7, rock_base_y - rock_height * 0.5),
			Vector2(rock_x + rock_w, rock_base_y)]),
			Color(0.25, 0.18, 0.1, 0.5 + clampf(emerge_phase, 0.0, 1.0) * 0.2))
		# Cracks in rock
		draw_line(Vector2(rock_x, rock_base_y - rock_height * 0.3),
			Vector2(rock_x + rock_w * 0.3, rock_base_y - rock_height * 0.8),
			Color(0.15, 0.1, 0.05, 0.3), 1.0)
		# Dust particles when emerging
		if emerge_phase > 0.3:
			for d in range(3):
				var df = float(d)
				var dust_x = rock_x + sin(_time * 3.0 + df * 2.0 + fi) * 12.0
				var dust_y = rock_base_y - sin(_time * 2.0 + df + fi) * 10.0
				draw_circle(Vector2(dust_x, dust_y), 2.0, Color(0.3, 0.22, 0.12, 0.15))

	# === CRACKING FLOOR — tile pattern with fractures ===
	for row in range(8):
		var rf = float(row)
		var ty = 380.0 + rf * 32.0
		for col in range(20):
			var cf = float(col)
			var tx = cf * 68.0 + fmod(rf, 2.0) * 34.0
			# Tile outline
			draw_rect(Rect2(tx, ty, 64.0, 28.0), Color(0.1, 0.32, 0.12, 0.15), false, 1.0)
			# Cracks across some tiles
			if sin(rf * 3.1 + cf * 2.7) > 0.2:
				var crack_start = Vector2(tx + 10.0, ty + 14.0)
				var crack_end = Vector2(tx + 50.0 + sin(cf * 4.0) * 10.0, ty + 8.0 + cos(rf * 2.0) * 8.0)
				draw_line(crack_start, crack_end, Color(0.15, 0.08, 0.04, 0.3), 1.0)
				# Branch crack
				var mid = (crack_start + crack_end) * 0.5
				draw_line(mid, mid + Vector2(sin(cf) * 12.0, 10.0), Color(0.15, 0.08, 0.04, 0.2), 1.0)

	# === SHATTERED GREEN GLASS — debris scattered ===
	for i in range(12):
		var fi = float(i)
		var gx = 80.0 + fi * 105.0 + sin(fi * 2.7) * 30.0
		var gy = 400.0 + sin(fi * 1.9) * 50.0
		var gs = 4.0 + sin(fi * 3.2) * 2.0
		var glass_alpha = 0.2 + sin(_time * 1.5 + fi * 0.8) * 0.08
		# Triangular glass shard
		draw_colored_polygon(PackedVector2Array([
			Vector2(gx, gy - gs * 2.0),
			Vector2(gx + gs * 1.5, gy + gs),
			Vector2(gx - gs, gy + gs * 0.5)]),
			Color(0.25, 0.75, 0.3, glass_alpha))
		# Glint
		draw_line(Vector2(gx - 1.0, gy - gs), Vector2(gx + 2.0, gy + gs * 0.5),
			Color(0.5, 0.9, 0.55, glass_alpha * 0.7), 1.0)

	# === GROUND — emerald tile floor ===
	var ground_pts = PackedVector2Array()
	ground_pts.append(Vector2(0, 628))
	for g in range(65):
		var gx = float(g) * 20.0
		var gy = 370.0 + sin(gx * 0.02 + 0.5) * 8.0
		ground_pts.append(Vector2(gx, gy))
	ground_pts.append(Vector2(1280, 628))
	draw_colored_polygon(ground_pts, ground_color)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"poppy":
				var pp = dec["pos"]
				var ps = dec["size"]
				var sway = sin(_time * 1.3 + dec["extra"]) * 2.0
				draw_line(pp, pp + Vector2(sway, -ps * 6.0), Color(0.15, 0.35, 0.1, 0.5), 1.0)
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 2.5, Color(0.85, 0.12, 0.1, 0.55))
				draw_circle(pp + Vector2(sway, -ps * 6.0), ps * 0.7, Color(0.15, 0.1, 0.05, 0.5))
			"emerald_crystal":
				var ep = dec["pos"]
				var es = dec["size"]
				var sparkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				draw_colored_polygon(PackedVector2Array([ep + Vector2(0, -es * 2), ep + Vector2(es, 0), ep + Vector2(0, es), ep + Vector2(-es, 0)]), Color(0.2, 0.8, 0.3, 0.4 + sparkle * 0.15))
			"scarecrow":
				var sp = dec["pos"]
				var ss = dec["size"]
				draw_line(sp, sp + Vector2(0, -ss * 2), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_line(sp + Vector2(-ss, -ss * 1.5), sp + Vector2(ss, -ss * 1.5), Color(0.4, 0.3, 0.15, 0.5), 2.0)
				draw_circle(sp + Vector2(0, -ss * 2.2), ss * 0.5, Color(0.6, 0.5, 0.2, 0.45))

	# === FOREGROUND — emerald sparkle particles ===
	for i in range(10):
		var fi = float(i)
		var spark_t = fmod(_time * 0.8 + fi * 0.7, 4.0)
		var spark_x = fi * 130.0 + sin(spark_t * 2.0 + fi) * 40.0
		var spark_y = 500.0 + sin(spark_t * 1.5 + fi * 3.0) * 60.0 - spark_t * 20.0
		var spark_alpha = clampf(0.25 - absf(spark_t - 2.0) * 0.12, 0.0, 0.25)
		draw_circle(Vector2(spark_x, spark_y), 2.0, Color(0.3, 0.9, 0.4, spark_alpha))
		draw_circle(Vector2(spark_x, spark_y), 1.0, Color(0.6, 1.0, 0.65, spark_alpha * 1.5))

	# === Green ambient fog at base ===
	for i in range(8):
		var fi = float(i)
		var fog_x = fmod(fi * 180.0 + _time * 10.0, 1400.0) - 60.0
		var fog_y = 580.0 + sin(fi * 1.7) * 20.0
		draw_circle(Vector2(fog_x, fog_y), 55.0 + fi * 6.0, Color(0.1, 0.35, 0.12, 0.06))

	# === Ceiling light beams ===
	for i in range(4):
		var fi = float(i)
		var bx = 200.0 + fi * 280.0
		var bs = sin(_time * 0.3 + fi * 1.5) * 15.0
		var ba = 0.03 + sin(_time * 0.7 + fi * 2.0) * 0.01
		draw_colored_polygon(PackedVector2Array([
			Vector2(bx - 8.0 + bs * 0.3, 55.0), Vector2(bx + 8.0 + bs * 0.3, 55.0),
			Vector2(bx + 40.0 + bs, 620.0), Vector2(bx - 40.0 + bs, 620.0)]),
			Color(0.2, 0.7, 0.25, ba))

func _draw_peter_ch2(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — Dark jungle night ===
	for i in range(32):
		var t = float(i) / 31.0
		var col = sky_color.lerp(Color(0.02, 0.06, 0.12), t)
		# Add faint green jungle haze in lower sky
		col = col.lerp(Color(0.03, 0.1, 0.06), t * t * 0.4)
		var y0 = int(t * 578.0) + 50
		var y1 = int((t + 1.0 / 31.0) * 578.0) + 50
		draw_rect(Rect2(0, y0, 1280, y1 - y0 + 1), col)

	# === STARS / ATMOSPHERE — Faint stars through canopy gaps ===
	var star_positions = [
		Vector2(120, 62), Vector2(340, 75), Vector2(580, 58), Vector2(790, 80),
		Vector2(950, 65), Vector2(1100, 72), Vector2(200, 90), Vector2(680, 68),
		Vector2(1020, 85), Vector2(440, 60), Vector2(860, 70), Vector2(1200, 78)
	]
	for sp in star_positions:
		var flicker = (sin(_time * 1.8 + sp.x * 0.03) + 1.0) * 0.5
		var blocked = sin(sp.x * 0.02 + sp.y * 0.05)
		if blocked > 0.1:
			draw_circle(sp, 0.8 + flicker * 0.5, Color(1.0, 0.97, 0.85, 0.15 + flicker * 0.2))

	# Moon glow behind canopy
	var moon_pos = Vector2(980, 90)
	draw_circle(moon_pos, 50.0, Color(0.6, 0.65, 0.8, 0.04))
	draw_circle(moon_pos, 30.0, Color(0.7, 0.75, 0.9, 0.07))
	draw_circle(moon_pos, 14.0, Color(0.85, 0.88, 0.95, 0.2))

	# Jungle mist layers
	for m in range(5):
		var my = 200.0 + float(m) * 70.0
		var mx_off = sin(_time * 0.15 + float(m) * 1.3) * 40.0
		var mist_alpha = 0.03 + float(m) * 0.008
		draw_rect(Rect2(mx_off - 50, my, 1380, 25), Color(0.15, 0.25, 0.18, mist_alpha))

	# === LANDMARKS ===

	# --- Skull Rock in distance (far right background) ---
	var skull_base = Vector2(1150, 200)
	var skull_pts: PackedVector2Array = PackedVector2Array([
		skull_base + Vector2(-60, 0), skull_base + Vector2(-55, -40),
		skull_base + Vector2(-40, -65), skull_base + Vector2(-15, -78),
		skull_base + Vector2(15, -78), skull_base + Vector2(40, -65),
		skull_base + Vector2(55, -40), skull_base + Vector2(60, 0)
	])
	draw_colored_polygon(skull_pts, Color(0.12, 0.1, 0.13, 0.6))
	# Skull eye sockets — faint red glow
	draw_circle(skull_base + Vector2(-18, -50), 9.0, Color(0.05, 0.03, 0.05, 0.7))
	draw_circle(skull_base + Vector2(18, -50), 9.0, Color(0.05, 0.03, 0.05, 0.7))
	var eye_pulse = (sin(_time * 1.5) + 1.0) * 0.5
	draw_circle(skull_base + Vector2(-18, -50), 4.0, Color(0.8, 0.1, 0.05, 0.2 + eye_pulse * 0.15))
	draw_circle(skull_base + Vector2(18, -50), 4.0, Color(0.8, 0.1, 0.05, 0.2 + eye_pulse * 0.15))
	# Nose cavity
	draw_circle(skull_base + Vector2(0, -38), 5.0, Color(0.04, 0.02, 0.04, 0.6))
	# Teeth
	for ti in range(5):
		var tx = skull_base.x - 12.0 + float(ti) * 6.0
		draw_line(Vector2(tx, skull_base.y - 25), Vector2(tx, skull_base.y - 19), Color(0.1, 0.08, 0.1, 0.5), 2.0)

	# --- Dense background canopy trees ---
	var bg_trees = [
		Vector2(50, 310), Vector2(180, 290), Vector2(350, 300), Vector2(500, 280),
		Vector2(650, 305), Vector2(800, 275), Vector2(960, 295), Vector2(1100, 285),
		Vector2(120, 320), Vector2(420, 315), Vector2(730, 310), Vector2(1030, 300)
	]
	for bt in bg_trees:
		var trunk_h = 120.0 + sin(bt.x * 0.01) * 30.0
		var canopy_r = 55.0 + cos(bt.x * 0.02) * 15.0
		# Trunk
		draw_line(bt, bt + Vector2(0, -trunk_h), Color(0.15, 0.1, 0.05, 0.7), 5.0)
		# Canopy mass
		var ct = bt + Vector2(0, -trunk_h)
		draw_circle(ct, canopy_r, Color(0.04, 0.18, 0.06, 0.6))
		draw_circle(ct + Vector2(-canopy_r * 0.4, canopy_r * 0.15), canopy_r * 0.7, Color(0.03, 0.15, 0.05, 0.55))
		draw_circle(ct + Vector2(canopy_r * 0.35, canopy_r * 0.1), canopy_r * 0.65, Color(0.05, 0.2, 0.07, 0.5))

	# --- Lost Boys' Treehouse Complex (center-left) ---
	# Main treehouse tree
	var th_base = Vector2(400, 480)
	var th_trunk_top = th_base + Vector2(0, -280)
	draw_line(th_base, th_trunk_top, Color(0.25, 0.16, 0.06), 14.0)
	# Branches
	var branches = [
		[th_base + Vector2(0, -180), Vector2(70, -40)],
		[th_base + Vector2(0, -220), Vector2(-80, -30)],
		[th_base + Vector2(0, -140), Vector2(-60, -50)],
		[th_base + Vector2(0, -250), Vector2(55, -25)]
	]
	for br in branches:
		draw_line(br[0], br[0] + br[1], Color(0.22, 0.14, 0.05), 5.0)

	# Treehouse platform
	var platform_y = th_base.y - 200.0
	draw_rect(Rect2(340, platform_y, 120, 8), Color(0.35, 0.22, 0.08))
	# Treehouse walls
	draw_rect(Rect2(350, platform_y - 55, 100, 55), Color(0.3, 0.2, 0.07, 0.85))
	# Roof (triangle)
	var roof_pts: PackedVector2Array = PackedVector2Array([
		Vector2(345, platform_y - 55), Vector2(400, platform_y - 90), Vector2(455, platform_y - 55)
	])
	draw_colored_polygon(roof_pts, Color(0.2, 0.35, 0.1, 0.9))
	# Window with warm light
	draw_rect(Rect2(375, platform_y - 45, 18, 16), Color(0.9, 0.7, 0.2, 0.6))
	draw_rect(Rect2(410, platform_y - 45, 18, 16), Color(0.9, 0.7, 0.2, 0.5))
	# Hidden door in trunk
	draw_rect(Rect2(391, th_base.y - 130, 18, 30), Color(0.18, 0.12, 0.04))
	var knob_pulse = (sin(_time * 2.2) + 1.0) * 0.5
	draw_circle(Vector2(405, th_base.y - 115), 2.5, Color(0.7, 0.6, 0.2, 0.5 + knob_pulse * 0.3))

	# Ladder from ground to platform
	var ladder_x = 355.0
	for li in range(8):
		var ly = th_base.y - 40.0 - float(li) * 20.0
		draw_line(Vector2(ladder_x, ly), Vector2(ladder_x + 16, ly), Color(0.4, 0.28, 0.1), 2.0)
	draw_line(Vector2(ladder_x, th_base.y - 40), Vector2(ladder_x, platform_y), Color(0.4, 0.28, 0.1), 2.0)
	draw_line(Vector2(ladder_x + 16, th_base.y - 40), Vector2(ladder_x + 16, platform_y), Color(0.4, 0.28, 0.1), 2.0)

	# Second treehouse (right side, smaller)
	var th2_base = Vector2(750, 460)
	draw_line(th2_base, th2_base + Vector2(0, -200), Color(0.22, 0.14, 0.05), 10.0)
	var plat2_y = th2_base.y - 160.0
	draw_rect(Rect2(710, plat2_y, 80, 6), Color(0.32, 0.2, 0.07))
	draw_rect(Rect2(718, plat2_y - 40, 64, 40), Color(0.28, 0.18, 0.06, 0.8))
	draw_rect(Rect2(738, plat2_y - 32, 14, 12), Color(0.85, 0.65, 0.15, 0.5))
	# Hidden door
	draw_rect(Rect2(742, th2_base.y - 100, 16, 26), Color(0.16, 0.1, 0.03))

	# --- Rope bridges between treehouses ---
	var rope_sag = sin(_time * 0.5) * 3.0
	for ri in range(20):
		var rt = float(ri) / 19.0
		var sag = sin(rt * PI) * (18.0 + rope_sag)
		var rp = Vector2(460, platform_y + 4).lerp(Vector2(710, plat2_y + 3), rt) + Vector2(0, sag)
		var rp_next_t = float(ri + 1) / 19.0
		var sag_next = sin(rp_next_t * PI) * (18.0 + rope_sag)
		var rp_next = Vector2(460, platform_y + 4).lerp(Vector2(710, plat2_y + 3), rp_next_t) + Vector2(0, sag_next)
		if ri < 19:
			draw_line(rp, rp_next, Color(0.45, 0.3, 0.1, 0.8), 2.0)
	# Rope rails
	for ri in range(20):
		var rt = float(ri) / 19.0
		var sag_top = sin(rt * PI) * (10.0 + rope_sag * 0.5)
		var rp_top = Vector2(460, platform_y - 15).lerp(Vector2(710, plat2_y - 15), rt) + Vector2(0, sag_top)
		var rp_top_next_t = float(ri + 1) / 19.0
		var sag_top_next = sin(rp_top_next_t * PI) * (10.0 + rope_sag * 0.5)
		var rp_top_next = Vector2(460, platform_y - 15).lerp(Vector2(710, plat2_y - 15), rp_top_next_t) + Vector2(0, sag_top_next)
		if ri < 19:
			draw_line(rp_top, rp_top_next, Color(0.45, 0.3, 0.1, 0.5), 1.5)

	# --- Fairy lanterns strung between trees ---
	var lantern_anchors = [
		[Vector2(180, 250), Vector2(350, 230)],
		[Vector2(500, 210), Vector2(650, 240)],
		[Vector2(800, 225), Vector2(960, 250)],
	]
	for la in lantern_anchors:
		for li in range(6):
			var lt = (float(li) + 0.5) / 6.0
			var lsag = sin(lt * PI) * 15.0
			var lp = la[0].lerp(la[1], lt) + Vector2(0, lsag)
			var lbob = sin(_time * 1.5 + float(li) * 0.8) * 2.0
			lp.y += lbob
			var lpulse = (sin(_time * 2.5 + float(li) * 1.1) + 1.0) * 0.5
			# Lantern body
			draw_circle(lp, 3.0, Color(1.0, 0.85, 0.2, 0.4 + lpulse * 0.3))
			# Glow
			draw_circle(lp, 10.0 + lpulse * 4.0, Color(1.0, 0.9, 0.3, 0.04 + lpulse * 0.03))

	# --- Pirate torchlight visible through trees (background right) ---
	var torch_positions = [Vector2(1050, 350), Vector2(1120, 380), Vector2(1000, 400)]
	for tp in torch_positions:
		var tflicker = (sin(_time * 4.0 + tp.x * 0.05) + 1.0) * 0.5
		draw_circle(tp, 5.0 + tflicker * 2.0, Color(1.0, 0.55, 0.1, 0.3 + tflicker * 0.2))
		draw_circle(tp, 18.0 + tflicker * 6.0, Color(1.0, 0.4, 0.05, 0.04 + tflicker * 0.03))
		# Torch stick
		draw_line(tp, tp + Vector2(0, 20), Color(0.3, 0.18, 0.05), 2.5)

	# --- Captain Hook's shadow looming (far left) ---
	var hook_shadow_base = Vector2(80, 380)
	var shadow_sway = sin(_time * 0.4) * 5.0
	# Tall menacing silhouette
	var hook_body: PackedVector2Array = PackedVector2Array([
		hook_shadow_base + Vector2(-15 + shadow_sway, 0),
		hook_shadow_base + Vector2(-20 + shadow_sway * 1.2, -60),
		hook_shadow_base + Vector2(-12 + shadow_sway * 1.4, -100),
		hook_shadow_base + Vector2(0 + shadow_sway * 1.5, -130),
		hook_shadow_base + Vector2(12 + shadow_sway * 1.4, -100),
		hook_shadow_base + Vector2(20 + shadow_sway * 1.2, -60),
		hook_shadow_base + Vector2(15 + shadow_sway, 0)
	])
	draw_colored_polygon(hook_body, Color(0.02, 0.02, 0.03, 0.6))
	# Hat silhouette
	var hat_center = hook_shadow_base + Vector2(shadow_sway * 1.5, -130)
	var hat_pts: PackedVector2Array = PackedVector2Array([
		hat_center + Vector2(-25, 0), hat_center + Vector2(-8, -25),
		hat_center + Vector2(8, -25), hat_center + Vector2(25, 0)
	])
	draw_colored_polygon(hat_pts, Color(0.02, 0.02, 0.03, 0.6))
	# Hook arm extending
	var hook_arm_end = hook_shadow_base + Vector2(35 + shadow_sway * 1.3, -80)
	draw_line(hook_shadow_base + Vector2(18 + shadow_sway * 1.3, -70), hook_arm_end, Color(0.02, 0.02, 0.03, 0.5), 3.0)
	# The hook curve
	var hook_tip = hook_arm_end + Vector2(8, 10)
	draw_line(hook_arm_end, hook_arm_end + Vector2(5, -8), Color(0.3, 0.3, 0.35, 0.5), 2.0)
	draw_line(hook_arm_end + Vector2(5, -8), hook_tip, Color(0.3, 0.3, 0.35, 0.5), 2.0)

	# === GROUND — Dense jungle floor ===
	var ground_y = 500.0
	# Ground gradient layers
	for gi in range(8):
		var gy = ground_y + float(gi) * 16.0
		var gt = float(gi) / 7.0
		var gc = ground_color.lerp(Color(0.05, 0.12, 0.04), gt * 0.5)
		draw_rect(Rect2(0, gy, 1280, 18), gc)

	# Leaf litter / undergrowth
	for ui in range(30):
		var ux = float(ui) * 44.0 + sin(float(ui) * 2.3) * 15.0
		var uy = ground_y - 5.0 + sin(float(ui) * 1.7) * 8.0
		var u_sway = sin(_time * 0.6 + float(ui) * 0.5) * 3.0
		var uh = 12.0 + sin(float(ui) * 3.1) * 6.0
		# Fern fronds
		draw_line(Vector2(ux + u_sway, uy), Vector2(ux - 6 + u_sway, uy - uh), Color(0.08, 0.25, 0.06, 0.6), 1.5)
		draw_line(Vector2(ux + u_sway, uy), Vector2(ux + 6 + u_sway, uy - uh * 0.8), Color(0.06, 0.22, 0.05, 0.5), 1.5)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var mh = dec["extra"]
				draw_line(mp, mp + Vector2(0, -ms * 1.5), Color(0.85, 0.82, 0.7), ms * 0.4)
				var cap_col = Color(0.8, 0.2, 0.15, 0.7) if mh < 0.33 else (Color(0.7, 0.5, 0.15, 0.7) if mh < 0.66 else Color(0.6, 0.2, 0.6, 0.7))
				draw_circle(mp + Vector2(0, -ms * 1.5), ms, cap_col)
				draw_circle(mp + Vector2(-ms * 0.3, -ms * 1.7), ms * 0.2, Color(1, 1, 1, 0.5))
			"jungle_tree":
				var tp = dec["pos"]
				var cr = dec["size"]
				var sh = dec["extra"]
				var th = cr * 0.8
				draw_line(tp, tp + Vector2(0, -th), Color(0.3 + sh, 0.2 + sh, 0.08), 3.0 + cr * 0.1)
				draw_circle(tp + Vector2(0, -th), cr, Color(0.1 + sh, 0.35 + sh, 0.08 + sh * 0.5, 0.55))
				draw_circle(tp + Vector2(-cr * 0.4, -th + cr * 0.2), cr * 0.6, Color(0.12 + sh, 0.37 + sh, 0.1, 0.5))
			"fairy":
				var fp = dec["pos"]
				var fo = dec["extra"]
				var drift = Vector2(sin(_time * 1.2 + fo) * 8.0, cos(_time * 0.9 + fo) * 5.0)
				var pulse = (sin(_time * 3.0 + fo) + 1.0) * 0.5
				draw_circle(fp + drift, 1.5 + pulse, Color(1.0, 0.92, 0.3, 0.5 + pulse * 0.3))
				draw_circle(fp + drift, 4.0 + pulse * 2.0, Color(1.0, 0.9, 0.3, 0.08 + pulse * 0.06))
			"star":
				var twinkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				var alpha = dec["size"] * (0.4 + twinkle * 0.6)
				draw_circle(dec["pos"], 1.0 + twinkle * 0.8, Color(1.0, 0.97, 0.8, alpha))

	# === FOREGROUND — Dense canopy overlay at top ===
	# Foreground canopy leaves draping down
	for fi in range(14):
		var fx = float(fi) * 95.0 + sin(float(fi) * 1.9) * 20.0
		var fy = 50.0 + sin(float(fi) * 2.7) * 15.0
		var f_sway = sin(_time * 0.35 + float(fi) * 0.7) * 4.0
		var leaf_len = 40.0 + sin(float(fi) * 1.3) * 15.0
		# Hanging vine
		draw_line(Vector2(fx + f_sway, fy), Vector2(fx + f_sway * 1.5, fy + leaf_len), Color(0.05, 0.2, 0.04, 0.5), 2.0)
		# Leaf cluster
		draw_circle(Vector2(fx + f_sway * 1.2, fy + leaf_len * 0.5), 18.0, Color(0.03, 0.14, 0.03, 0.4))
		draw_circle(Vector2(fx + f_sway * 0.8, fy + leaf_len * 0.3), 14.0, Color(0.04, 0.17, 0.05, 0.35))

	# Bottom foreground — thick underbrush
	for bi in range(20):
		var bx = float(bi) * 66.0 + sin(float(bi) * 3.3) * 10.0
		var by = 600.0 + sin(float(bi) * 1.5) * 15.0
		var b_sway = sin(_time * 0.4 + float(bi) * 0.6) * 3.0
		draw_circle(Vector2(bx + b_sway, by), 20.0 + sin(float(bi) * 2.1) * 8.0, Color(0.03, 0.12, 0.03, 0.5))

	# Foreground vines from top corners
	for vi in range(8):
		var vt = float(vi) / 7.0
		var vine_sway = sin(_time * 0.3 + vt * 2.0) * 6.0
		var v_left = Vector2(vine_sway, 50.0 + vt * 80.0)
		var v_right = Vector2(1280.0 + vine_sway, 50.0 + vt * 70.0)
		draw_circle(v_left, 10.0, Color(0.03, 0.15, 0.04, 0.25 - vt * 0.02))
		draw_circle(v_right, 10.0, Color(0.03, 0.15, 0.04, 0.25 - vt * 0.02))

	# Firefly particles in foreground
	for ffi in range(10):
		var ff_phase = float(ffi) * 1.7 + _time * 0.8
		var ffx = fmod(absf(sin(ff_phase * 0.3)) * 1280.0, 1280.0)
		var ffy = 400.0 + sin(ff_phase * 0.5) * 150.0
		var ff_drift = Vector2(sin(_time * 0.7 + float(ffi)) * 12.0, cos(_time * 0.5 + float(ffi)) * 8.0)
		var ff_bright = clampf((sin(_time * 3.5 + float(ffi) * 2.1) + 1.0) * 0.5, 0.0, 1.0)
		draw_circle(Vector2(ffx, ffy) + ff_drift, 1.5, Color(0.5, 1.0, 0.3, ff_bright * 0.5))
		draw_circle(Vector2(ffx, ffy) + ff_drift, 5.0, Color(0.4, 0.9, 0.2, ff_bright * 0.06))


func _draw_peter_ch3(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — Sunset battle colors (orange/red/purple) ===
	for i in range(32):
		var t = float(i) / 31.0
		var col: Color
		if t < 0.3:
			col = sky_color.lerp(Color(0.85, 0.35, 0.08), t / 0.3)
		elif t < 0.6:
			var t2 = (t - 0.3) / 0.3
			col = Color(0.85, 0.35, 0.08).lerp(Color(0.65, 0.12, 0.15), t2)
		else:
			var t3 = (t - 0.6) / 0.4
			col = Color(0.65, 0.12, 0.15).lerp(Color(0.2, 0.05, 0.25), t3)
		var y0 = int(t * 578.0) + 50
		var y1 = int((t + 1.0 / 31.0) * 578.0) + 50
		draw_rect(Rect2(0, y0, 1280, y1 - y0 + 1), col)

	# === STARS / ATMOSPHERE — Battle-torn sunset sky ===
	# Dramatic cloud streaks
	for ci in range(8):
		var cx = float(ci) * 170.0 + sin(float(ci) * 2.1) * 40.0
		var cy = 70.0 + sin(float(ci) * 1.5) * 25.0
		var cw = 120.0 + sin(float(ci) * 3.2) * 40.0
		var cloud_drift = sin(_time * 0.1 + float(ci) * 0.8) * 10.0
		draw_rect(Rect2(cx + cloud_drift, cy, cw, 8), Color(0.95, 0.5, 0.15, 0.12))
		draw_rect(Rect2(cx + cloud_drift + 10, cy + 10, cw * 0.7, 5), Color(0.9, 0.3, 0.1, 0.08))

	# Sun on horizon (low, half-sunk)
	var sun_pos = Vector2(200, 170)
	draw_circle(sun_pos, 55.0, Color(1.0, 0.6, 0.1, 0.08))
	draw_circle(sun_pos, 35.0, Color(1.0, 0.5, 0.05, 0.15))
	draw_circle(sun_pos, 18.0, Color(1.0, 0.75, 0.2, 0.3))

	# Smoke / cannon haze
	for si in range(6):
		var sx = 300.0 + float(si) * 160.0
		var sy = 120.0 + sin(float(si) * 2.5) * 40.0
		var s_drift = sin(_time * 0.2 + float(si)) * 20.0
		var s_rise = -_time * 3.0 + float(si) * 50.0
		var sfy = sy + fmod(s_rise, 100.0) - 50.0
		draw_circle(Vector2(sx + s_drift, sfy), 25.0 + sin(float(si) * 1.8) * 10.0, Color(0.3, 0.25, 0.2, 0.06))

	# === LANDMARKS ===

	# --- Dark water below ship ---
	var water_y = 480.0
	for wi in range(10):
		var wy = water_y + float(wi) * 15.0
		var wt = float(wi) / 9.0
		var wc = Color(0.02, 0.05, 0.15).lerp(Color(0.01, 0.02, 0.08), wt)
		draw_rect(Rect2(0, wy, 1280, 17), wc)
	# Wave details
	for wvi in range(25):
		var wx = float(wvi) * 52.0
		var wy_off = sin(_time * 0.8 + float(wvi) * 0.6) * 3.0
		var wave_x2 = wx + 30.0 + sin(float(wvi) * 1.2) * 10.0
		draw_line(Vector2(wx, water_y + 5.0 + wy_off), Vector2(wave_x2, water_y + 5.0 + wy_off + sin(_time * 0.9 + float(wvi)) * 2.0), Color(0.15, 0.2, 0.35, 0.15), 1.5)

	# --- Ship hull ---
	var hull_pts: PackedVector2Array = PackedVector2Array([
		Vector2(100, water_y), Vector2(50, water_y - 40),
		Vector2(80, water_y - 80), Vector2(200, water_y - 110),
		Vector2(1080, water_y - 110), Vector2(1200, water_y - 80),
		Vector2(1230, water_y - 40), Vector2(1180, water_y)
	])
	draw_colored_polygon(hull_pts, Color(0.22, 0.12, 0.04))
	# Hull wood planking
	for hi in range(6):
		var hy = water_y - 20.0 - float(hi) * 15.0
		draw_line(Vector2(90, hy), Vector2(1190, hy), Color(0.18, 0.1, 0.03, 0.4), 1.0)

	# --- Cannon ports ---
	var cannon_ys = [water_y - 45.0, water_y - 70.0]
	for cy in cannon_ys:
		for ci in range(7):
			var cx = 180.0 + float(ci) * 130.0
			# Port hole
			draw_rect(Rect2(cx - 10, cy - 8, 20, 16), Color(0.08, 0.04, 0.02))
			# Cannon barrel poking out
			draw_rect(Rect2(cx - 4, cy - 3, 18, 6), Color(0.15, 0.15, 0.15, 0.8))
			# Flash on one random cannon
			if ci == 3 and cy == cannon_ys[0]:
				var flash = clampf(sin(_time * 5.0), 0.0, 1.0)
				if flash > 0.8:
					draw_circle(Vector2(cx + 16, cy), 8.0, Color(1.0, 0.8, 0.2, 0.4))

	# --- Ship deck (main play area) ---
	var deck_y = water_y - 110.0
	draw_rect(Rect2(140, deck_y, 1000, 12), Color(0.3, 0.18, 0.06))
	# Deck planks
	for di in range(22):
		var dx = 150.0 + float(di) * 48.0
		draw_line(Vector2(dx, deck_y), Vector2(dx, deck_y + 12), Color(0.2, 0.12, 0.04, 0.5), 1.0)

	# Deck railing
	draw_line(Vector2(140, deck_y - 35), Vector2(1140, deck_y - 35), Color(0.25, 0.15, 0.05), 3.0)
	for ri in range(18):
		var rx = 155.0 + float(ri) * 56.0
		draw_line(Vector2(rx, deck_y), Vector2(rx, deck_y - 35), Color(0.25, 0.15, 0.05), 2.0)

	# --- Masts and rigging ---
	# Main mast (center)
	var mast1_x = 640.0
	draw_line(Vector2(mast1_x, deck_y), Vector2(mast1_x, 60), Color(0.28, 0.16, 0.05), 8.0)
	# Crow's nest
	draw_rect(Rect2(mast1_x - 18, 75, 36, 10), Color(0.25, 0.14, 0.04))
	draw_line(Vector2(mast1_x - 18, 75), Vector2(mast1_x - 12, 85), Color(0.25, 0.14, 0.04), 2.0)
	draw_line(Vector2(mast1_x + 18, 75), Vector2(mast1_x + 12, 85), Color(0.25, 0.14, 0.04), 2.0)
	# Cross beam
	draw_line(Vector2(mast1_x - 80, 120), Vector2(mast1_x + 80, 120), Color(0.28, 0.16, 0.05), 5.0)
	draw_line(Vector2(mast1_x - 60, 190), Vector2(mast1_x + 60, 190), Color(0.28, 0.16, 0.05), 4.0)
	# Sail (partially furled)
	var sail1_pts: PackedVector2Array = PackedVector2Array([
		Vector2(mast1_x - 75, 122), Vector2(mast1_x + 75, 122),
		Vector2(mast1_x + 55, 185), Vector2(mast1_x - 55, 185)
	])
	var sail_billow = sin(_time * 0.4) * 5.0
	draw_colored_polygon(sail1_pts, Color(0.85, 0.8, 0.7, 0.6))
	# Sail tear/battle damage
	draw_line(Vector2(mast1_x - 20, 140), Vector2(mast1_x + 5, 170), Color(0.4, 0.2, 0.1, 0.3), 2.0)

	# Fore mast
	var mast2_x = 340.0
	draw_line(Vector2(mast2_x, deck_y), Vector2(mast2_x, 100), Color(0.28, 0.16, 0.05), 6.0)
	draw_line(Vector2(mast2_x - 55, 140), Vector2(mast2_x + 55, 140), Color(0.28, 0.16, 0.05), 4.0)
	var sail2_pts: PackedVector2Array = PackedVector2Array([
		Vector2(mast2_x - 50, 142), Vector2(mast2_x + 50, 142),
		Vector2(mast2_x + 40, 210), Vector2(mast2_x - 40, 210)
	])
	draw_colored_polygon(sail2_pts, Color(0.82, 0.77, 0.68, 0.55))

	# Rear mast
	var mast3_x = 940.0
	draw_line(Vector2(mast3_x, deck_y), Vector2(mast3_x, 120), Color(0.28, 0.16, 0.05), 6.0)
	draw_line(Vector2(mast3_x - 50, 160), Vector2(mast3_x + 50, 160), Color(0.28, 0.16, 0.05), 4.0)

	# --- Rigging ropes (mast to mast, mast to hull) ---
	var rigging_lines = [
		[Vector2(mast1_x, 70), Vector2(mast2_x, 105)],
		[Vector2(mast1_x, 70), Vector2(mast3_x, 125)],
		[Vector2(mast2_x, 105), Vector2(140, deck_y - 30)],
		[Vector2(mast3_x, 125), Vector2(1140, deck_y - 30)],
		[Vector2(mast1_x, 120), Vector2(140, deck_y - 20)],
		[Vector2(mast1_x, 120), Vector2(1140, deck_y - 20)],
	]
	for rl in rigging_lines:
		draw_line(rl[0], rl[1], Color(0.2, 0.15, 0.08, 0.4), 1.0)

	# Rope nets on sides
	for ni in range(6):
		for nj in range(4):
			var nx = 160.0 + float(ni) * 15.0
			var ny = deck_y - 30.0 + float(nj) * 12.0
			draw_line(Vector2(nx, ny), Vector2(nx + 15, ny), Color(0.3, 0.2, 0.1, 0.25), 1.0)
			draw_line(Vector2(nx, ny), Vector2(nx, ny + 12), Color(0.3, 0.2, 0.1, 0.25), 1.0)

	# --- Skull-and-crossbones flag (on main mast, flapping) ---
	var flag_base = Vector2(mast1_x, 62)
	var flag_w = 45.0
	var flag_h = 30.0
	var flag_pts: PackedVector2Array = PackedVector2Array()
	for fi in range(10):
		var fx = flag_base.x + float(fi) / 9.0 * flag_w
		var fy_top = flag_base.y + sin(_time * 3.0 + float(fi) * 0.5) * 3.0
		flag_pts.append(Vector2(fx, fy_top))
	for fi in range(9, -1, -1):
		var fx = flag_base.x + float(fi) / 9.0 * flag_w
		var fy_bot = flag_base.y + flag_h + sin(_time * 3.0 + float(fi) * 0.5 + 0.5) * 3.0
		flag_pts.append(Vector2(fx, fy_bot))
	draw_colored_polygon(flag_pts, Color(0.05, 0.05, 0.05, 0.9))
	# Skull on flag
	var flag_center = flag_base + Vector2(flag_w * 0.5, flag_h * 0.45)
	var fc_wave = sin(_time * 3.0 + 2.0) * 2.0
	draw_circle(flag_center + Vector2(fc_wave, 0), 7.0, Color(0.9, 0.85, 0.8, 0.7))
	draw_circle(flag_center + Vector2(-3 + fc_wave, -1), 1.5, Color(0.05, 0.05, 0.05, 0.7))
	draw_circle(flag_center + Vector2(3 + fc_wave, -1), 1.5, Color(0.05, 0.05, 0.05, 0.7))
	# Crossbones
	draw_line(flag_center + Vector2(-8 + fc_wave, 5), flag_center + Vector2(8 + fc_wave, 11), Color(0.9, 0.85, 0.8, 0.6), 1.5)
	draw_line(flag_center + Vector2(8 + fc_wave, 5), flag_center + Vector2(-8 + fc_wave, 11), Color(0.9, 0.85, 0.8, 0.6), 1.5)

	# --- Plank extending over water (right side) ---
	var plank_start = Vector2(1100, deck_y + 5)
	var plank_end = Vector2(1250, deck_y + 15)
	var plank_bob = sin(_time * 1.2) * 2.0
	draw_line(plank_start, plank_end + Vector2(0, plank_bob), Color(0.35, 0.22, 0.08), 8.0)
	# Plank wood grain
	draw_line(plank_start + Vector2(0, -2), plank_end + Vector2(0, -2 + plank_bob), Color(0.28, 0.18, 0.06, 0.5), 1.0)
	draw_line(plank_start + Vector2(0, 2), plank_end + Vector2(0, 2 + plank_bob), Color(0.28, 0.18, 0.06, 0.5), 1.0)

	# --- Ticking crocodile below (in water under plank) ---
	var croc_base = Vector2(1200, water_y + 20)
	var croc_bob = sin(_time * 0.7) * 4.0
	var croc_y = croc_base.y + croc_bob
	# Body
	var croc_body: PackedVector2Array = PackedVector2Array([
		Vector2(croc_base.x - 40, croc_y - 5),
		Vector2(croc_base.x - 30, croc_y - 12),
		Vector2(croc_base.x, croc_y - 14),
		Vector2(croc_base.x + 25, croc_y - 10),
		Vector2(croc_base.x + 40, croc_y - 5),
		Vector2(croc_base.x + 35, croc_y + 3),
		Vector2(croc_base.x, croc_y + 6),
		Vector2(croc_base.x - 35, croc_y + 3)
	])
	draw_colored_polygon(croc_body, Color(0.15, 0.3, 0.1, 0.7))
	# Snout
	draw_line(Vector2(croc_base.x + 35, croc_y - 3), Vector2(croc_base.x + 55, croc_y - 1), Color(0.15, 0.3, 0.1, 0.7), 6.0)
	# Eye
	draw_circle(Vector2(croc_base.x + 20, croc_y - 11), 3.0, Color(0.9, 0.8, 0.1, 0.7))
	draw_circle(Vector2(croc_base.x + 20, croc_y - 11), 1.2, Color(0.1, 0.1, 0.05, 0.8))
	# Teeth
	for ti in range(4):
		var tx = croc_base.x + 38.0 + float(ti) * 5.0
		draw_line(Vector2(tx, croc_y - 3), Vector2(tx, croc_y + 1), Color(0.9, 0.9, 0.8, 0.5), 1.0)
	# Clock visible in water (the ticking clock!)
	var clock_pos = Vector2(croc_base.x - 10, croc_y + 25)
	var clock_pulse = (sin(_time * 6.28) + 1.0) * 0.5  # Ticking once per second
	draw_circle(clock_pos, 12.0, Color(0.7, 0.6, 0.3, 0.15 + clock_pulse * 0.1))
	draw_circle(clock_pos, 10.0, Color(0.85, 0.8, 0.6, 0.2 + clock_pulse * 0.1))
	# Clock hands
	var minute_angle = _time * 0.5
	var hour_angle = _time * 0.04
	draw_line(clock_pos, clock_pos + Vector2(sin(minute_angle) * 7.0, -cos(minute_angle) * 7.0), Color(0.2, 0.15, 0.05, 0.3), 1.0)
	draw_line(clock_pos, clock_pos + Vector2(sin(hour_angle) * 5.0, -cos(hour_angle) * 5.0), Color(0.2, 0.15, 0.05, 0.3), 1.5)
	# Tick-tock ripple
	draw_arc(clock_pos, 14.0 + clock_pulse * 3.0, 0, TAU, 24, Color(0.5, 0.5, 0.4, 0.06 + clock_pulse * 0.04), 1.0)

	# --- Treasure chests on deck ---
	var chest_positions = [Vector2(250, deck_y - 5), Vector2(850, deck_y - 5), Vector2(550, deck_y - 5)]
	for chi in range(chest_positions.size()):
		var cp = chest_positions[chi]
		# Chest body
		draw_rect(Rect2(cp.x - 12, cp.y - 14, 24, 14), Color(0.35, 0.2, 0.05))
		# Chest lid (slightly open on middle one)
		var lid_open = 0.0
		if chi == 2:
			lid_open = 3.0
			# Gold glow
			var g_pulse = (sin(_time * 2.0 + 1.0) + 1.0) * 0.5
			draw_circle(cp + Vector2(0, -16), 8.0, Color(1.0, 0.85, 0.2, 0.08 + g_pulse * 0.06))
		draw_rect(Rect2(cp.x - 13, cp.y - 18 - lid_open, 26, 6), Color(0.4, 0.25, 0.08))
		# Lock / clasp
		draw_circle(cp + Vector2(0, -12), 2.0, Color(0.7, 0.6, 0.15, 0.6))
		# Metal bands
		draw_line(Vector2(cp.x - 12, cp.y - 7), Vector2(cp.x + 12, cp.y - 7), Color(0.5, 0.4, 0.1, 0.4), 1.0)

	# === GROUND — Wooden ship deck (lower portion) ===
	for gi in range(6):
		var gy = water_y + float(gi) * 25.0
		var gt = float(gi) / 5.0
		var gc = Color(0.02, 0.04, 0.12).lerp(Color(0.01, 0.02, 0.06), gt)
		draw_rect(Rect2(0, gy, 1280, 27), gc)

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"mushroom":
				var mp = dec["pos"]
				var ms = dec["size"]
				var mh = dec["extra"]
				draw_line(mp, mp + Vector2(0, -ms * 1.5), Color(0.85, 0.82, 0.7), ms * 0.4)
				var cap_col = Color(0.8, 0.2, 0.15, 0.7) if mh < 0.33 else (Color(0.7, 0.5, 0.15, 0.7) if mh < 0.66 else Color(0.6, 0.2, 0.6, 0.7))
				draw_circle(mp + Vector2(0, -ms * 1.5), ms, cap_col)
				draw_circle(mp + Vector2(-ms * 0.3, -ms * 1.7), ms * 0.2, Color(1, 1, 1, 0.5))
			"jungle_tree":
				var tp = dec["pos"]
				var cr = dec["size"]
				var sh = dec["extra"]
				var th = cr * 0.8
				draw_line(tp, tp + Vector2(0, -th), Color(0.3 + sh, 0.2 + sh, 0.08), 3.0 + cr * 0.1)
				draw_circle(tp + Vector2(0, -th), cr, Color(0.1 + sh, 0.35 + sh, 0.08 + sh * 0.5, 0.55))
				draw_circle(tp + Vector2(-cr * 0.4, -th + cr * 0.2), cr * 0.6, Color(0.12 + sh, 0.37 + sh, 0.1, 0.5))
			"fairy":
				var fp = dec["pos"]
				var fo = dec["extra"]
				var drift = Vector2(sin(_time * 1.2 + fo) * 8.0, cos(_time * 0.9 + fo) * 5.0)
				var pulse = (sin(_time * 3.0 + fo) + 1.0) * 0.5
				draw_circle(fp + drift, 1.5 + pulse, Color(1.0, 0.92, 0.3, 0.5 + pulse * 0.3))
				draw_circle(fp + drift, 4.0 + pulse * 2.0, Color(1.0, 0.9, 0.3, 0.08 + pulse * 0.06))
			"star":
				var twinkle = (sin(_time * 2.0 + dec["extra"]) + 1.0) * 0.5
				var alpha = dec["size"] * (0.4 + twinkle * 0.6)
				draw_circle(dec["pos"], 1.0 + twinkle * 0.8, Color(1.0, 0.97, 0.8, alpha))

	# === FOREGROUND ===
	# Rope and rigging in foreground (parallax feel)
	for fi in range(5):
		var rope_x = 50.0 + float(fi) * 300.0
		var rope_sway = sin(_time * 0.5 + float(fi) * 1.2) * 8.0
		draw_line(Vector2(rope_x + rope_sway, 50), Vector2(rope_x + rope_sway * 0.3, deck_y), Color(0.2, 0.14, 0.06, 0.15), 2.0)

	# Cannon smoke puffs drifting across foreground
	for si in range(4):
		var smoke_phase = _time * 0.3 + float(si) * 1.5
		var smoke_x = fmod(absf(smoke_phase) * 80.0, 1400.0) - 60.0
		var smoke_y = 200.0 + float(si) * 80.0 + sin(smoke_phase) * 20.0
		var smoke_alpha = 0.04 + sin(smoke_phase * 0.5) * 0.02
		smoke_alpha = clampf(smoke_alpha, 0.0, 0.1)
		draw_circle(Vector2(smoke_x, smoke_y), 35.0 + sin(float(si) * 2.1) * 10.0, Color(0.4, 0.35, 0.3, smoke_alpha))
		draw_circle(Vector2(smoke_x + 20, smoke_y - 10), 25.0, Color(0.45, 0.4, 0.35, smoke_alpha * 0.7))

	# Water splashes at hull line
	for wi in range(12):
		var wx = 100.0 + float(wi) * 95.0
		var splash_t = sin(_time * 1.5 + float(wi) * 0.9)
		if splash_t > 0.5:
			var splash_h = (splash_t - 0.5) * 8.0
			draw_circle(Vector2(wx, water_y - splash_h), 2.5, Color(0.4, 0.5, 0.7, 0.2))

	# Dark vignette at edges for dramatic battle atmosphere
	for vi in range(10):
		var v_alpha = 0.03 * float(10 - vi)
		# Left edge
		draw_rect(Rect2(0, 50, float(vi) * 8, 578), Color(0.02, 0.01, 0.03, v_alpha))
		# Right edge
		draw_rect(Rect2(1280.0 - float(vi) * 8.0, 50, float(vi) * 8, 578), Color(0.02, 0.01, 0.03, v_alpha))

	# Sparks from battle (foreground particles)
	for spi in range(6):
		var sp_phase = _time * 2.0 + float(spi) * 1.1
		var sp_x = 300.0 + float(spi) * 130.0 + sin(sp_phase * 0.7) * 50.0
		var sp_y = 150.0 + fmod(absf(sp_phase * 40.0), 300.0)
		var sp_bright = clampf(1.0 - fmod(absf(sp_phase * 40.0), 300.0) / 300.0, 0.0, 1.0)
		draw_circle(Vector2(sp_x, sp_y), 1.0, Color(1.0, 0.7, 0.2, sp_bright * 0.4))

func _draw_phantom_ch2(sky_color: Color, ground_color: Color) -> void:
	# === CEILING / SKY — Dark underground brick tunnel ceiling ===
	for y_strip in range(0, 300, 4):
		var t = float(y_strip) / 300.0
		var ceiling_col = sky_color.lerp(Color(0.06, 0.04, 0.08, 1.0), t)
		# Subtle moisture shimmer on ceiling
		var moisture = sin(_time * 0.8 + float(y_strip) * 0.05) * 0.015
		ceiling_col = ceiling_col.lerp(Color(0.15, 0.18, 0.25), clampf(moisture, 0.0, 1.0))
		draw_rect(Rect2(0, 50 + y_strip, 1280, 4), ceiling_col)

	# === CEILING BRICKWORK — visible arched tunnel ceiling ===
	for bx in range(0, 1280, 48):
		for by in range(0, 5):
			var offset_x = 24.0 if by % 2 == 1 else 0.0
			var brick_y = 52.0 + float(by) * 18.0
			var brick_alpha = 0.12 - float(by) * 0.02
			draw_rect(Rect2(float(bx) + offset_x, brick_y, 46, 16), Color(0.25, 0.15, 0.1, brick_alpha))
			draw_line(Vector2(float(bx) + offset_x, brick_y), Vector2(float(bx) + offset_x + 46.0, brick_y), Color(0.1, 0.06, 0.04, brick_alpha * 0.7), 0.5)

	# === WATER DRIPPING FROM CEILING — animated droplets ===
	for i in range(18):
		var drip_x = 70.0 + float(i) * 68.0
		var drip_phase = fmod(_time * 0.7 + float(i) * 2.3, 3.0)
		var drip_start_y = 55.0 + sin(float(i) * 1.1) * 15.0
		if drip_phase < 2.0:
			# Droplet falling
			var drip_y = drip_start_y + drip_phase * 120.0
			var drop_alpha = 0.4 - drip_phase * 0.15
			draw_circle(Vector2(drip_x, drip_y), 1.5, Color(0.3, 0.4, 0.6, clampf(drop_alpha, 0.0, 1.0)))
			# Tiny trail
			draw_line(Vector2(drip_x, drip_y - 4.0), Vector2(drip_x, drip_y), Color(0.3, 0.4, 0.6, clampf(drop_alpha * 0.5, 0.0, 1.0)), 0.8)
		else:
			# Splash ripple at bottom
			var splash_t = (drip_phase - 2.0) * 3.0
			var splash_y = drip_start_y + 240.0
			var ripple_r = splash_t * 8.0
			draw_arc(Vector2(drip_x, splash_y), ripple_r, 0.0, TAU, 12, Color(0.3, 0.4, 0.6, clampf(0.3 - splash_t * 0.3, 0.0, 1.0)), 0.5)
		# Gathering droplet on ceiling
		var gather = sin(_time * 1.2 + float(i) * 3.0) * 0.3 + 0.5
		draw_circle(Vector2(drip_x, drip_start_y), 1.0 + gather, Color(0.3, 0.45, 0.65, 0.2))

	# === ATMOSPHERE — Underground haze and candlelight glow ===
	for i in range(8):
		var haze_x = 160.0 * float(i) + sin(_time * 0.15 + float(i)) * 30.0
		var haze_y = 250.0 + cos(_time * 0.2 + float(i) * 0.7) * 40.0
		draw_circle(Vector2(haze_x, haze_y), 90.0, Color(0.2, 0.15, 0.1, 0.025))
		draw_circle(Vector2(haze_x, haze_y), 55.0, Color(1.0, 0.7, 0.2, 0.015))

	# Candlelight pools on walls — flickering warm light
	for i in range(10):
		var cx = 60.0 + float(i) * 128.0
		var cy = 180.0 + sin(float(i) * 2.5) * 30.0
		var flicker = sin(_time * 4.5 + float(i) * 1.9) * 0.1 + 0.5
		draw_circle(Vector2(cx, cy), 45.0, Color(1.0, 0.65, 0.15, 0.02 * flicker))
		# Candle on wall sconce
		draw_line(Vector2(cx, cy + 10.0), Vector2(cx, cy - 8.0), Color(0.8, 0.75, 0.6, 0.35), 2.5)
		draw_circle(Vector2(cx, cy - 10.0), 2.5 + flicker * 2.0, Color(1.0, 0.8, 0.2, 0.5 + flicker * 0.3))
		draw_circle(Vector2(cx, cy - 10.0), 8.0, Color(1.0, 0.6, 0.1, 0.06))

	# === LANDMARKS ===
	# --- Descending stone stairs (left side) ---
	for step in range(8):
		var sx = 30.0 + float(step) * 22.0
		var sy = 350.0 + float(step) * 20.0
		var step_w = 24.0
		var step_h = 18.0
		draw_rect(Rect2(sx, sy, step_w, step_h), Color(0.22, 0.18, 0.16, 0.55))
		draw_line(Vector2(sx, sy), Vector2(sx + step_w, sy), Color(0.35, 0.3, 0.25, 0.4), 1.0)
		# Step shadow
		draw_rect(Rect2(sx, sy + step_h - 3.0, step_w, 3.0), Color(0.05, 0.03, 0.02, 0.3))

	# --- Iron gates (two locations) ---
	for gi in range(2):
		var gate_x = 320.0 + float(gi) * 600.0
		var gate_top = 140.0
		var gate_bot = 380.0
		# Gate frame
		draw_rect(Rect2(gate_x - 2, gate_top, 4, gate_bot - gate_top), Color(0.2, 0.18, 0.15, 0.5))
		draw_rect(Rect2(gate_x + 40, gate_top, 4, gate_bot - gate_top), Color(0.2, 0.18, 0.15, 0.5))
		draw_line(Vector2(gate_x, gate_top), Vector2(gate_x + 44, gate_top), Color(0.25, 0.2, 0.18, 0.5), 3.0)
		# Vertical bars
		for bar in range(5):
			var bar_x = gate_x + 6.0 + float(bar) * 8.0
			draw_line(Vector2(bar_x, gate_top + 4.0), Vector2(bar_x, gate_bot), Color(0.3, 0.25, 0.2, 0.4), 1.5)
		# Horizontal crossbar
		var mid_y = (gate_top + gate_bot) * 0.5
		draw_line(Vector2(gate_x + 2, mid_y), Vector2(gate_x + 42, mid_y), Color(0.3, 0.25, 0.2, 0.35), 1.5)

	# --- Mirror hall with reflections (center-right) ---
	for mi in range(4):
		var mx = 650.0 + float(mi) * 80.0
		var my = 160.0 + float(mi) * 15.0
		var mw = 30.0
		var mh = 50.0
		# Mirror frame (ornate gold)
		draw_rect(Rect2(mx - 3, my - 3, mw + 6, mh + 6), Color(0.7, 0.55, 0.1, 0.35))
		# Mirror surface — dark reflective
		draw_rect(Rect2(mx, my, mw, mh), Color(0.06, 0.04, 0.1, 0.65))
		# Reflection shimmer
		var shimmer_off = sin(_time * 1.8 + float(mi) * 1.2) * 0.08
		draw_rect(Rect2(mx + 4.0, my + 5.0, 6.0, mh - 10.0), Color(0.4, 0.35, 0.5, 0.08 + shimmer_off))

	# --- Phantom's white mask in center mirror ---
	var mask_x = 730.0
	var mask_y = 185.0
	var mask_pulse = sin(_time * 1.2) * 0.05 + 0.3
	# Half-mask shape (right side of face)
	draw_circle(Vector2(mask_x, mask_y), 10.0, Color(0.95, 0.92, 0.88, mask_pulse))
	draw_rect(Rect2(mask_x - 5, mask_y - 8, 10, 5), Color(0.95, 0.92, 0.88, mask_pulse))
	# Eye hole
	draw_circle(Vector2(mask_x + 2, mask_y - 3), 2.0, Color(0.02, 0.01, 0.05, mask_pulse + 0.1))
	# Eerie glow behind mask
	draw_circle(Vector2(mask_x, mask_y), 25.0, Color(0.5, 0.4, 0.6, 0.03))

	# --- Visual sound waves (echoing through tunnels) ---
	for sw in range(5):
		var wave_cx = 500.0 + float(sw) * 10.0
		var wave_cy = 280.0
		var wave_r = 20.0 + float(sw) * 18.0 + sin(_time * 2.5 + float(sw)) * 5.0
		var wave_alpha = 0.08 - float(sw) * 0.015
		draw_arc(Vector2(wave_cx, wave_cy), wave_r, -0.5, 0.5, 16, Color(0.6, 0.5, 0.8, clampf(wave_alpha, 0.0, 1.0)), 0.8)

	# --- Rats scurrying along the floor ---
	for ri in range(6):
		var rat_base_x = 100.0 + float(ri) * 190.0
		var rat_y = 510.0 + sin(float(ri) * 3.0) * 15.0
		var rat_run = fmod(_time * 1.5 + float(ri) * 4.0, 8.0)
		var rat_x = rat_base_x + rat_run * 20.0
		var rat_dir = 1.0 if ri % 2 == 0 else -1.0
		# Body
		draw_circle(Vector2(rat_x, rat_y), 3.0, Color(0.25, 0.2, 0.15, 0.4))
		# Head
		draw_circle(Vector2(rat_x + rat_dir * 4.0, rat_y - 1.0), 1.8, Color(0.28, 0.22, 0.16, 0.4))
		# Tail
		var tail_wave = sin(_time * 8.0 + float(ri) * 2.0) * 2.0
		draw_line(Vector2(rat_x - rat_dir * 3.0, rat_y), Vector2(rat_x - rat_dir * 9.0, rat_y - 2.0 + tail_wave), Color(0.3, 0.22, 0.15, 0.3), 0.7)

	# === TUNNEL WALLS — brick texture on sides ===
	for side in range(2):
		var wall_x = 0.0 if side == 0 else 1240.0
		var wall_w = 40.0
		for wy in range(0, 20):
			var brick_y2 = 140.0 + float(wy) * 25.0
			var off = 15.0 if wy % 2 == 1 else 0.0
			draw_rect(Rect2(wall_x + off, brick_y2, wall_w - 2, 23), Color(0.28, 0.16, 0.1, 0.25))
			draw_line(Vector2(wall_x, brick_y2), Vector2(wall_x + wall_w, brick_y2), Color(0.15, 0.08, 0.05, 0.15), 0.5)

	# === FLOOR — Wet stone tunnel floor with water reflections ===
	for y_strip in range(0, 148, 3):
		var t = float(y_strip) / 148.0
		var floor_col = ground_color.lerp(Color(0.12, 0.1, 0.13), t)
		# Water reflection ripples
		var water_ref = sin(_time * 1.5 + float(y_strip) * 0.15) * 0.02
		floor_col = floor_col.lerp(Color(0.2, 0.25, 0.35), clampf(absf(water_ref), 0.0, 1.0))
		draw_rect(Rect2(0, 480 + y_strip, 1280, 3), floor_col)

	# Wet stone floor — tile lines
	for fx in range(0, 1280, 64):
		for fy in range(0, 3):
			var tile_y = 485.0 + float(fy) * 48.0
			draw_line(Vector2(float(fx), tile_y), Vector2(float(fx) + 62.0, tile_y), Color(0.18, 0.14, 0.12, 0.12), 0.5)
		draw_line(Vector2(float(fx), 480.0), Vector2(float(fx), 628.0), Color(0.18, 0.14, 0.12, 0.08), 0.5)

	# Water puddle reflections on floor
	for pi in range(7):
		var px = 90.0 + float(pi) * 170.0
		var py = 530.0 + sin(float(pi) * 1.7) * 25.0
		var puddle_w = 30.0 + sin(float(pi) * 2.3) * 10.0
		var puddle_ripple = sin(_time * 2.0 + float(pi) * 1.5) * 0.03
		draw_rect(Rect2(px - puddle_w * 0.5, py - 3.0, puddle_w, 6.0), Color(0.15, 0.2, 0.3, 0.12 + puddle_ripple))

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"candelabra":
				var cp = dec["pos"]
				var cs = dec["size"]
				draw_line(cp, cp + Vector2(0, -cs * 12.0), Color(0.6, 0.45, 0.1, 0.5), 2.5)
				draw_line(cp + Vector2(-cs * 3, 0), cp + Vector2(cs * 3, 0), Color(0.6, 0.45, 0.1, 0.45), 2.0)
				var arm_top = cp + Vector2(0, -cs * 12.0)
				draw_line(arm_top, arm_top + Vector2(-cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				draw_line(arm_top, arm_top + Vector2(cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				var flames = [arm_top + Vector2(0, -cs * 2), arm_top + Vector2(-cs * 5, -cs * 5), arm_top + Vector2(cs * 5, -cs * 5)]
				for fi in range(flames.size()):
					var flicker = sin(_time * 5.5 + dec["extra"] + float(fi) * 1.7) * 0.2
					draw_circle(flames[fi], 2.5 + flicker, Color(1.0, 0.75, 0.15, 0.6 + flicker))
					draw_circle(flames[fi], 18.0, Color(1.0, 0.6, 0.1, 0.02))
			"mirror":
				var mp = dec["pos"]
				var ms = dec["size"]
				draw_rect(Rect2(mp.x - ms * 8 - 3, mp.y - ms * 12 - 3, ms * 16 + 6, ms * 24 + 6), Color(0.8, 0.6, 0.1, 0.45))
				draw_rect(Rect2(mp.x - ms * 8, mp.y - ms * 12, ms * 16, ms * 24), Color(0.08, 0.05, 0.12, 0.7))
				var shimmer = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 5, mp.y - ms * 8, ms * 3, ms * 16), Color(0.4, 0.35, 0.5, shimmer * 0.1))
			"rose":
				var rp = dec["pos"]
				draw_circle(rp, dec["size"], Color(0.85, 0.1, 0.1, 0.5))
				draw_circle(rp, dec["size"] * 0.5, Color(0.95, 0.2, 0.15, 0.4))
			"sheet_music":
				var smp = dec["pos"]
				var sms = dec["size"]
				var drift = sin(_time * 0.6 + dec["extra"]) * 5.0
				draw_rect(Rect2(smp.x - sms + drift, smp.y - sms * 1.5, sms * 2, sms * 3), Color(0.85, 0.82, 0.7, 0.2))
				for line_idx in range(5):
					draw_line(Vector2(smp.x - sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Vector2(smp.x + sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Color(0.2, 0.15, 0.1, 0.15), 0.5)

	# === FOREGROUND — Dripping stalactites, dust motes, cobwebs ===
	# Stalactites hanging from top
	for i in range(12):
		var st_x = 50.0 + float(i) * 105.0
		var st_len = 20.0 + sin(float(i) * 2.7) * 12.0
		var st_top = 50.0
		draw_line(Vector2(st_x, st_top), Vector2(st_x, st_top + st_len), Color(0.2, 0.15, 0.12, 0.25), 3.0)
		draw_line(Vector2(st_x, st_top), Vector2(st_x, st_top + st_len), Color(0.25, 0.2, 0.15, 0.15), 1.0)
		# Drip at tip
		var drip_pulse = sin(_time * 2.0 + float(i) * 1.3)
		if drip_pulse > 0.7:
			draw_circle(Vector2(st_x, st_top + st_len + 2.0), 1.2, Color(0.3, 0.4, 0.55, 0.3))

	# Floating dust motes
	for i in range(20):
		var dx = fmod(float(i) * 137.5 + _time * 8.0 + sin(_time * 0.3 + float(i)) * 30.0, 1280.0)
		var dy = 100.0 + float(i) * 25.0 + sin(_time * 0.5 + float(i) * 0.8) * 15.0
		var mote_alpha = sin(_time * 1.5 + float(i) * 0.7) * 0.06 + 0.06
		draw_circle(Vector2(dx, dy), 1.0, Color(0.9, 0.8, 0.5, clampf(mote_alpha, 0.0, 1.0)))

	# Cobwebs in corners
	for corner in range(2):
		var web_x = 5.0 if corner == 0 else 1275.0
		var web_dir = 1.0 if corner == 0 else -1.0
		for strand in range(5):
			var angle = float(strand) * 0.3
			var end_x = web_x + web_dir * cos(angle) * 50.0
			var end_y = 50.0 + sin(angle) * 50.0
			draw_line(Vector2(web_x, 50.0), Vector2(end_x, end_y), Color(0.6, 0.6, 0.55, 0.08), 0.5)

	# Vignette darkness at edges
	for v in range(40):
		var v_alpha = (1.0 - float(v) / 40.0) * 0.15
		draw_rect(Rect2(0, 50 + v, float(v) * 0.5, 1), Color(0.0, 0.0, 0.0, v_alpha))
		draw_rect(Rect2(1280.0 - float(v) * 0.5, 50 + v, float(v) * 0.5, 1), Color(0.0, 0.0, 0.0, v_alpha))


func _draw_phantom_ch3(sky_color: Color, ground_color: Color) -> void:
	# === CEILING / SKY — Deep purple-black cavern roof ===
	for y_strip in range(0, 200, 3):
		var t = float(y_strip) / 200.0
		var ceiling_col = sky_color.lerp(Color(0.05, 0.02, 0.08, 1.0), t)
		# Faint golden candlelight reflecting on ceiling
		var candle_glow = sin(_time * 0.6 + float(y_strip) * 0.04) * 0.01
		ceiling_col = ceiling_col.lerp(Color(0.4, 0.25, 0.05), clampf(candle_glow, 0.0, 1.0))
		draw_rect(Rect2(0, 50 + y_strip, 1280, 3), ceiling_col)

	# Cavern rock texture on ceiling
	for i in range(25):
		var rock_x = float(i) * 52.0 + sin(float(i) * 1.7) * 15.0
		var rock_y = 55.0 + sin(float(i) * 2.3) * 10.0
		var rock_r = 8.0 + sin(float(i) * 3.1) * 4.0
		draw_circle(Vector2(rock_x, rock_y), rock_r, Color(0.08, 0.04, 0.06, 0.2))

	# === ATMOSPHERE — Golden candlelight and purple haze ===
	# Large ambient glow zones
	for i in range(6):
		var glow_x = 100.0 + float(i) * 200.0 + sin(_time * 0.2 + float(i) * 1.5) * 20.0
		var glow_y = 300.0 + cos(_time * 0.15 + float(i)) * 30.0
		draw_circle(Vector2(glow_x, glow_y), 120.0, Color(1.0, 0.7, 0.15, 0.012))
		draw_circle(Vector2(glow_x, glow_y), 60.0, Color(1.0, 0.6, 0.1, 0.02))

	# Purple mist rising from water
	for i in range(14):
		var mist_x = float(i) * 95.0 + sin(_time * 0.25 + float(i) * 0.8) * 25.0
		var mist_y = 420.0 + sin(_time * 0.3 + float(i) * 1.2) * 20.0
		draw_circle(Vector2(mist_x, mist_y), 50.0, Color(0.2, 0.08, 0.25, 0.025))

	# === LANDMARKS ===
	# --- Massive organ pipes towering overhead (center-left) ---
	var organ_base_x = 200.0
	for pipe in range(14):
		var pipe_x = organ_base_x + float(pipe) * 18.0
		var pipe_h = 180.0 + sin(float(pipe) * 0.8) * 80.0 + cos(float(pipe) * 0.5) * 30.0
		var pipe_w = 10.0 + sin(float(pipe) * 1.3) * 3.0
		var pipe_top = 60.0
		# Pipe body — dark bronze/gold
		draw_rect(Rect2(pipe_x - pipe_w * 0.5, pipe_top, pipe_w, pipe_h), Color(0.35, 0.28, 0.12, 0.35))
		# Pipe highlight
		draw_rect(Rect2(pipe_x - pipe_w * 0.25, pipe_top, pipe_w * 0.3, pipe_h), Color(0.5, 0.4, 0.15, 0.12))
		# Pipe top cap
		draw_rect(Rect2(pipe_x - pipe_w * 0.6, pipe_top, pipe_w * 1.2, 4.0), Color(0.4, 0.32, 0.1, 0.4))
		# Sound vibration from pipes
		if pipe % 3 == 0:
			var vib = sin(_time * 3.0 + float(pipe) * 1.5) * 2.0
			draw_arc(Vector2(pipe_x, pipe_top - 5.0), 6.0 + absf(vib), -1.0, -2.1, 8, Color(0.5, 0.4, 0.7, 0.06), 0.5)

	# --- Underground lake — black water reflecting candles ---
	var lake_top = 430.0
	for y_strip in range(0, 198, 3):
		var t = float(y_strip) / 198.0
		var water_col = Color(0.03, 0.02, 0.06, 0.85).lerp(Color(0.02, 0.01, 0.04, 0.9), t)
		# Candle reflections rippling in water
		var ripple1 = sin(_time * 1.2 + float(y_strip) * 0.08) * 0.015
		var ripple2 = sin(_time * 0.9 + float(y_strip) * 0.12 + 2.0) * 0.01
		water_col = water_col.lerp(Color(1.0, 0.7, 0.15), clampf(ripple1 + ripple2, 0.0, 1.0))
		draw_rect(Rect2(0, lake_top + float(y_strip), 1280, 3), water_col)

	# Water surface ripples
	for i in range(10):
		var rip_x = 60.0 + float(i) * 125.0
		var rip_y = lake_top + 5.0 + sin(_time * 0.7 + float(i) * 1.3) * 3.0
		var rip_w = 30.0 + sin(float(i) * 2.1) * 10.0
		draw_line(Vector2(rip_x - rip_w, rip_y), Vector2(rip_x + rip_w, rip_y), Color(0.2, 0.15, 0.25, 0.12), 0.7)

	# Candle reflections in water — inverted/distorted golden streaks
	for i in range(8):
		var ref_x = 80.0 + float(i) * 155.0
		var ref_base = lake_top + 15.0
		var ref_len = 40.0 + sin(float(i) * 1.7) * 15.0
		var ref_wave = sin(_time * 1.5 + float(i) * 2.0) * 3.0
		draw_line(Vector2(ref_x + ref_wave, ref_base), Vector2(ref_x - ref_wave, ref_base + ref_len), Color(1.0, 0.7, 0.15, 0.06), 3.0)

	# --- Phantom's mask and cape center-stage ---
	var phantom_x = 640.0
	var phantom_y = 300.0
	var phantom_sway = sin(_time * 0.8) * 3.0

	# Cape — sweeping black fabric
	var cape_pts = PackedVector2Array()
	cape_pts.append(Vector2(phantom_x - 5.0 + phantom_sway, phantom_y - 30.0))
	cape_pts.append(Vector2(phantom_x - 40.0 + phantom_sway * 0.5, phantom_y + 60.0))
	cape_pts.append(Vector2(phantom_x - 25.0, phantom_y + 80.0))
	cape_pts.append(Vector2(phantom_x + 25.0, phantom_y + 80.0))
	cape_pts.append(Vector2(phantom_x + 40.0 + phantom_sway * 0.5, phantom_y + 60.0))
	cape_pts.append(Vector2(phantom_x + 5.0 + phantom_sway, phantom_y - 30.0))
	var cape_cols = PackedColorArray()
	for _ci in range(cape_pts.size()):
		cape_cols.append(Color(0.02, 0.01, 0.04, 0.5))
	draw_polygon(cape_pts, cape_cols)
	# Cape inner lining — dark red
	draw_line(Vector2(phantom_x - 35.0 + phantom_sway, phantom_y + 50.0), Vector2(phantom_x - 15.0, phantom_y + 75.0), Color(0.4, 0.05, 0.05, 0.25), 3.0)

	# Mask — white half-mask, iconic
	var mask_glow = sin(_time * 1.0) * 0.06 + 0.45
	draw_circle(Vector2(phantom_x + phantom_sway, phantom_y - 15.0), 14.0, Color(0.96, 0.93, 0.88, mask_glow))
	# Mask shaping — right half only
	draw_rect(Rect2(phantom_x + phantom_sway - 8, phantom_y - 28, 16, 8), Color(0.96, 0.93, 0.88, mask_glow))
	# Eye socket
	draw_circle(Vector2(phantom_x + phantom_sway + 3.0, phantom_y - 18.0), 3.0, Color(0.02, 0.01, 0.05, mask_glow + 0.15))
	# Eerie glow around phantom
	draw_circle(Vector2(phantom_x + phantom_sway, phantom_y), 50.0, Color(0.3, 0.15, 0.4, 0.025))

	# --- Monkey music box (right of phantom) ---
	var monkey_x = 850.0
	var monkey_y = 380.0
	# Box base
	draw_rect(Rect2(monkey_x - 15, monkey_y, 30, 20), Color(0.4, 0.25, 0.08, 0.4))
	draw_rect(Rect2(monkey_x - 13, monkey_y + 2, 26, 16), Color(0.5, 0.32, 0.1, 0.3))
	# Monkey figure
	draw_circle(Vector2(monkey_x, monkey_y - 6.0), 6.0, Color(0.35, 0.22, 0.1, 0.4))
	draw_circle(Vector2(monkey_x, monkey_y - 14.0), 4.5, Color(0.38, 0.25, 0.12, 0.4))
	# Cymbals — animated clapping
	var cymbal_angle = sin(_time * 4.0) * 0.4
	draw_circle(Vector2(monkey_x - 7.0 - cymbal_angle * 3.0, monkey_y - 10.0), 3.0, Color(0.7, 0.55, 0.1, 0.35))
	draw_circle(Vector2(monkey_x + 7.0 + cymbal_angle * 3.0, monkey_y - 10.0), 3.0, Color(0.7, 0.55, 0.1, 0.35))

	# --- Christine's wedding veil (left of phantom) ---
	var veil_x = 430.0
	var veil_y = 310.0
	var veil_drift = sin(_time * 0.5) * 4.0
	# Veil fabric — translucent white flowing
	for vi in range(6):
		var v_off_x = sin(_time * 0.7 + float(vi) * 0.9) * 5.0 + veil_drift
		var v_off_y = float(vi) * 12.0
		var v_width = 15.0 + float(vi) * 4.0
		var v_alpha = 0.15 - float(vi) * 0.02
		draw_line(Vector2(veil_x - v_width + v_off_x, veil_y + v_off_y), Vector2(veil_x + v_width + v_off_x, veil_y + v_off_y), Color(0.95, 0.93, 0.9, clampf(v_alpha, 0.0, 1.0)), 2.0)
	# Veil top crown/tiara
	draw_circle(Vector2(veil_x + veil_drift, veil_y - 5.0), 4.0, Color(0.85, 0.8, 0.75, 0.2))
	for ti in range(3):
		var tiara_x = veil_x + veil_drift + float(ti - 1) * 5.0
		draw_line(Vector2(tiara_x, veil_y - 5.0), Vector2(tiara_x, veil_y - 10.0 - float(1 - absi(ti - 1)) * 3.0), Color(0.8, 0.7, 0.4, 0.25), 1.0)

	# --- Roses scattered throughout ---
	for ri in range(12):
		var rose_x = 50.0 + float(ri) * 105.0 + sin(float(ri) * 3.7) * 30.0
		var rose_y = 400.0 + sin(float(ri) * 2.1) * 25.0
		var rose_size = 3.5 + sin(float(ri) * 1.9) * 1.5
		draw_circle(Vector2(rose_x, rose_y), rose_size, Color(0.85, 0.08, 0.08, 0.45))
		draw_circle(Vector2(rose_x, rose_y), rose_size * 0.5, Color(0.95, 0.15, 0.12, 0.35))
		# Stem
		draw_line(Vector2(rose_x, rose_y + rose_size), Vector2(rose_x + 3.0, rose_y + rose_size + 10.0), Color(0.15, 0.35, 0.1, 0.25), 0.8)

	# === FLOOR — Stone walkway over water ===
	# The walkway is a narrow stone bridge across the lake
	for y_strip in range(0, 30, 3):
		var t = float(y_strip) / 30.0
		var walkway_col = ground_color.lerp(Color(0.18, 0.14, 0.12), t)
		draw_rect(Rect2(200, 485 + y_strip, 880, 3), walkway_col)

	# Walkway stone texture
	for sx in range(0, 880, 44):
		var stone_x = 200.0 + float(sx)
		draw_line(Vector2(stone_x, 485.0), Vector2(stone_x, 515.0), Color(0.25, 0.2, 0.18, 0.12), 0.5)
	for sy in range(0, 2):
		draw_line(Vector2(200.0, 495.0 + float(sy) * 12.0), Vector2(1080.0, 495.0 + float(sy) * 12.0), Color(0.25, 0.2, 0.18, 0.1), 0.5)

	# Walkway edges — stone railing
	draw_line(Vector2(200.0, 485.0), Vector2(1080.0, 485.0), Color(0.3, 0.25, 0.2, 0.3), 2.0)
	draw_line(Vector2(200.0, 515.0), Vector2(1080.0, 515.0), Color(0.3, 0.25, 0.2, 0.3), 2.0)

	# Water visible on sides of walkway
	for side in range(2):
		var water_x = 0.0 if side == 0 else 1080.0
		var water_w = 200.0 if side == 0 else 200.0
		for wy in range(0, 50, 4):
			var ripple = sin(_time * 1.0 + float(wy) * 0.15 + float(side) * 2.0) * 0.01
			draw_rect(Rect2(water_x, 485.0 + float(wy), water_w, 4), Color(0.03, 0.02, 0.06, 0.5 + ripple))

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"candelabra":
				var cp = dec["pos"]
				var cs = dec["size"]
				draw_line(cp, cp + Vector2(0, -cs * 12.0), Color(0.6, 0.45, 0.1, 0.5), 2.5)
				draw_line(cp + Vector2(-cs * 3, 0), cp + Vector2(cs * 3, 0), Color(0.6, 0.45, 0.1, 0.45), 2.0)
				var arm_top = cp + Vector2(0, -cs * 12.0)
				draw_line(arm_top, arm_top + Vector2(-cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				draw_line(arm_top, arm_top + Vector2(cs * 5, -cs * 3), Color(0.6, 0.45, 0.1, 0.45), 1.5)
				var flames = [arm_top + Vector2(0, -cs * 2), arm_top + Vector2(-cs * 5, -cs * 5), arm_top + Vector2(cs * 5, -cs * 5)]
				for fi in range(flames.size()):
					var flicker = sin(_time * 5.5 + dec["extra"] + float(fi) * 1.7) * 0.2
					draw_circle(flames[fi], 2.5 + flicker, Color(1.0, 0.75, 0.15, 0.6 + flicker))
					draw_circle(flames[fi], 18.0, Color(1.0, 0.6, 0.1, 0.02))
			"mirror":
				var mp = dec["pos"]
				var ms = dec["size"]
				draw_rect(Rect2(mp.x - ms * 8 - 3, mp.y - ms * 12 - 3, ms * 16 + 6, ms * 24 + 6), Color(0.8, 0.6, 0.1, 0.45))
				draw_rect(Rect2(mp.x - ms * 8, mp.y - ms * 12, ms * 16, ms * 24), Color(0.08, 0.05, 0.12, 0.7))
				var shimmer = (sin(_time * 1.5 + dec["extra"]) + 1.0) * 0.5
				draw_rect(Rect2(mp.x - ms * 5, mp.y - ms * 8, ms * 3, ms * 16), Color(0.4, 0.35, 0.5, shimmer * 0.1))
			"rose":
				var rp = dec["pos"]
				draw_circle(rp, dec["size"], Color(0.85, 0.1, 0.1, 0.5))
				draw_circle(rp, dec["size"] * 0.5, Color(0.95, 0.2, 0.15, 0.4))
			"sheet_music":
				var smp = dec["pos"]
				var sms = dec["size"]
				var drift = sin(_time * 0.6 + dec["extra"]) * 5.0
				draw_rect(Rect2(smp.x - sms + drift, smp.y - sms * 1.5, sms * 2, sms * 3), Color(0.85, 0.82, 0.7, 0.2))
				for line_idx in range(5):
					draw_line(Vector2(smp.x - sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Vector2(smp.x + sms + drift, smp.y - sms + float(line_idx) * sms * 0.4), Color(0.2, 0.15, 0.1, 0.15), 0.5)

	# === FOREGROUND — Floating candles, mist, rose petals falling ===
	# Floating candles on lake surface (foreground layer)
	for i in range(9):
		var fc_x = 70.0 + float(i) * 140.0 + sin(_time * 0.4 + float(i) * 1.7) * 15.0
		var fc_y = 540.0 + sin(_time * 0.6 + float(i) * 2.1) * 5.0
		# Candle body
		draw_rect(Rect2(fc_x - 2, fc_y - 10, 4, 10), Color(0.85, 0.8, 0.7, 0.35))
		# Flame
		var fc_flicker = sin(_time * 6.0 + float(i) * 2.3) * 1.5
		draw_circle(Vector2(fc_x, fc_y - 12.0 + fc_flicker), 2.5, Color(1.0, 0.8, 0.2, 0.55))
		draw_circle(Vector2(fc_x, fc_y - 12.0 + fc_flicker), 10.0, Color(1.0, 0.6, 0.1, 0.03))
		# Reflection in water below
		draw_line(Vector2(fc_x, fc_y + 2.0), Vector2(fc_x + sin(_time * 1.0 + float(i)) * 2.0, fc_y + 18.0), Color(1.0, 0.7, 0.15, 0.04), 2.0)

	# Falling rose petals
	for i in range(15):
		var petal_x = fmod(float(i) * 89.0 + _time * 12.0 + sin(_time * 0.4 + float(i) * 1.5) * 40.0, 1280.0)
		var petal_y = fmod(float(i) * 43.0 + _time * 18.0, 578.0) + 50.0
		var petal_rot = _time * 2.0 + float(i) * 1.3
		var petal_size = 2.0 + sin(float(i) * 2.5) * 0.8
		var px_off = cos(petal_rot) * petal_size
		var py_off = sin(petal_rot) * petal_size * 0.5
		draw_circle(Vector2(petal_x + px_off, petal_y + py_off), petal_size, Color(0.8, 0.1, 0.1, 0.18))

	# Low mist / fog across foreground
	for i in range(10):
		var fog_x = float(i) * 130.0 + sin(_time * 0.15 + float(i) * 0.6) * 40.0
		var fog_y = 580.0 + sin(_time * 0.3 + float(i) * 1.1) * 10.0
		draw_circle(Vector2(fog_x, fog_y), 70.0, Color(0.12, 0.06, 0.15, 0.03))
		draw_circle(Vector2(fog_x + 30.0, fog_y - 5.0), 45.0, Color(0.15, 0.08, 0.18, 0.025))

	# Musical notes floating up from the organ
	for i in range(7):
		var note_x = 220.0 + float(i) * 30.0 + sin(_time * 1.2 + float(i) * 1.8) * 15.0
		var note_y = 200.0 - fmod(_time * 15.0 + float(i) * 40.0, 180.0)
		var note_alpha = 0.12 - fmod(_time * 0.05 + float(i) * 0.15, 0.12)
		if note_y > 55.0:
			draw_circle(Vector2(note_x, note_y), 2.5, Color(0.7, 0.55, 0.9, clampf(note_alpha, 0.0, 1.0)))
			draw_line(Vector2(note_x + 2.5, note_y), Vector2(note_x + 2.5, note_y - 8.0), Color(0.7, 0.55, 0.9, clampf(note_alpha * 0.8, 0.0, 1.0)), 0.7)

	# Vignette — deep darkness at edges for dramatic framing
	for v in range(60):
		var v_alpha = (1.0 - float(v) / 60.0) * 0.2
		draw_rect(Rect2(0, 50 + v, float(v) * 0.8, 1), Color(0.0, 0.0, 0.0, v_alpha))
		draw_rect(Rect2(1280.0 - float(v) * 0.8, 50 + v, float(v) * 0.8, 1), Color(0.0, 0.0, 0.0, v_alpha))
		# Bottom vignette
		var bv_y = 628 - v
		draw_rect(Rect2(0, bv_y, 1280, 1), Color(0.0, 0.0, 0.0, v_alpha * 0.5))

func _draw_scrooge_ch2(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — Midnight spectral blue ===
	var midnight_base := Color(0.03, 0.04, 0.08)
	var spectral_blue := Color(0.05, 0.12, 0.2)
	for i in range(30):
		var t := float(i) / 29.0
		var band_color := midnight_base.lerp(spectral_blue, t * t)
		# Pulsing spectral glow across the whole sky
		var spectral_pulse := sin(_time * 0.4 + t * 3.0) * 0.02
		band_color.g += spectral_pulse
		band_color.b += spectral_pulse * 1.5
		var y_start := t * 300.0
		var y_height := 300.0 / 29.0 + 2.0
		draw_rect(Rect2(0, y_start, 1280, y_height), band_color)

	# === ATMOSPHERE — Spectral green/blue mist ===
	for i in range(12):
		var mx := float(i) * 110.0 + sin(_time * 0.3 + float(i)) * 30.0
		var my := 250.0 + sin(_time * 0.2 + float(i) * 0.7) * 40.0
		var mrad := 80.0 + sin(_time * 0.5 + float(i) * 1.3) * 20.0
		var green_tint := 0.15 + sin(_time * 0.6 + float(i)) * 0.05
		draw_circle(Vector2(mx, my), mrad, Color(0.1, green_tint, 0.2, 0.03))

	# Spectral aurora ribbons in upper sky
	for i in range(5):
		var ribbon_y := 60.0 + float(i) * 35.0
		var pts := PackedVector2Array()
		for s in range(20):
			var sx := float(s) * 68.0
			var sy := ribbon_y + sin(_time * 0.3 + float(s) * 0.5 + float(i)) * 15.0
			pts.append(Vector2(sx, sy))
		for s in range(pts.size() - 1):
			var ribbon_alpha := 0.04 + sin(_time * 0.4 + float(s) * 0.3) * 0.02
			draw_line(pts[s], pts[s + 1], Color(0.15, 0.4, 0.3, ribbon_alpha), 2.0)

	# === MOON — Pale ghostly moon ===
	var moon_pos := Vector2(950, 80)
	draw_circle(moon_pos, 35.0, Color(0.6, 0.65, 0.75, 0.15))
	draw_circle(moon_pos, 22.0, Color(0.7, 0.75, 0.85, 0.25))
	draw_circle(moon_pos, 12.0, Color(0.85, 0.88, 0.95, 0.4))

	# === CHURCH STEEPLE AT MIDNIGHT — far background ===
	var church_x := 180.0
	var church_base_y := 320.0
	# Main church body
	draw_rect(Rect2(church_x - 40, church_base_y - 100, 80, 100), Color(0.06, 0.06, 0.1, 0.7))
	# Steeple
	var steeple_pts := PackedVector2Array([
		Vector2(church_x - 20, church_base_y - 100),
		Vector2(church_x, church_base_y - 180),
		Vector2(church_x + 20, church_base_y - 100)
	])
	draw_colored_polygon(steeple_pts, Color(0.05, 0.05, 0.09, 0.8))
	# Cross on top
	draw_line(Vector2(church_x, church_base_y - 180), Vector2(church_x, church_base_y - 200), Color(0.3, 0.3, 0.35, 0.6), 2.0)
	draw_line(Vector2(church_x - 8, church_base_y - 192), Vector2(church_x + 8, church_base_y - 192), Color(0.3, 0.3, 0.35, 0.6), 2.0)
	# Clock face — midnight
	draw_circle(Vector2(church_x, church_base_y - 70), 12.0, Color(0.15, 0.15, 0.2, 0.5))
	draw_circle(Vector2(church_x, church_base_y - 70), 10.0, Color(0.6, 0.6, 0.55, 0.3))
	draw_line(Vector2(church_x, church_base_y - 70), Vector2(church_x, church_base_y - 80), Color(0.1, 0.1, 0.1, 0.5), 1.5)
	# Arched window glow
	draw_circle(Vector2(church_x, church_base_y - 45), 8.0, Color(0.2, 0.5, 0.4, 0.15))

	# === GHOST OF CHRISTMAS PAST — Golden sphere, upper left ===
	var past_x := 300.0 + sin(_time * 0.7) * 20.0
	var past_y := 140.0 + sin(_time * 0.5) * 15.0
	var past_glow := 0.3 + sin(_time * 2.0) * 0.1
	draw_circle(Vector2(past_x, past_y), 30.0, Color(1.0, 0.85, 0.3, 0.05))
	draw_circle(Vector2(past_x, past_y), 18.0, Color(1.0, 0.8, 0.2, 0.1))
	draw_circle(Vector2(past_x, past_y), 10.0, Color(1.0, 0.9, 0.5, past_glow))
	# Rays emanating
	for r in range(8):
		var ray_angle := float(r) * PI * 0.25 + _time * 0.3
		var ray_end := Vector2(past_x, past_y) + Vector2.from_angle(ray_angle) * (25.0 + sin(_time * 3.0 + float(r)) * 5.0)
		draw_line(Vector2(past_x, past_y), ray_end, Color(1.0, 0.85, 0.3, 0.08), 1.0)

	# === GHOST OF CHRISTMAS PRESENT — Jolly silhouette with holly crown ===
	var present_x := 700.0 + sin(_time * 0.4) * 10.0
	var present_y := 200.0
	# Large robed body
	var robe_pts := PackedVector2Array([
		Vector2(present_x - 25, present_y + 60),
		Vector2(present_x - 30, present_y),
		Vector2(present_x - 15, present_y - 40),
		Vector2(present_x, present_y - 50),
		Vector2(present_x + 15, present_y - 40),
		Vector2(present_x + 30, present_y),
		Vector2(present_x + 25, present_y + 60)
	])
	draw_colored_polygon(robe_pts, Color(0.1, 0.35, 0.15, 0.2))
	# Holly crown
	for h in range(5):
		var holly_angle := -PI * 0.3 + float(h) * 0.3
		var hx := present_x + cos(holly_angle) * 18.0
		var hy := present_y - 50.0 + sin(holly_angle) * 5.0 - 5.0
		draw_circle(Vector2(hx, hy), 3.0, Color(0.15, 0.5, 0.1, 0.3))
	# Holly berries
	draw_circle(Vector2(present_x - 5, present_y - 56), 2.0, Color(0.7, 0.1, 0.1, 0.3))
	draw_circle(Vector2(present_x + 5, present_y - 56), 2.0, Color(0.7, 0.1, 0.1, 0.3))

	# === TOMBSTONES — Graveyard ===
	var tombstones := [
		{"x": 400.0, "h": 50.0, "w": 28.0}, {"x": 520.0, "h": 42.0, "w": 24.0},
		{"x": 640.0, "h": 55.0, "w": 30.0}, {"x": 780.0, "h": 38.0, "w": 22.0},
		{"x": 880.0, "h": 48.0, "w": 26.0}, {"x": 1020.0, "h": 44.0, "w": 25.0},
		{"x": 1140.0, "h": 40.0, "w": 23.0}, {"x": 340.0, "h": 36.0, "w": 20.0}
	]
	var grave_y := 420.0
	for ts_data in tombstones:
		var tx: float = ts_data["x"]
		var th: float = ts_data["h"]
		var tw: float = ts_data["w"]
		# Tombstone body
		draw_rect(Rect2(tx - tw * 0.5, grave_y - th, tw, th), Color(0.18, 0.17, 0.2, 0.5))
		# Rounded top
		draw_circle(Vector2(tx, grave_y - th), tw * 0.5, Color(0.18, 0.17, 0.2, 0.5))
		# Spectral glow behind each stone
		var ts_glow := sin(_time * 0.8 + tx * 0.01) * 0.03
		draw_circle(Vector2(tx, grave_y - th * 0.5), tw * 1.2, Color(0.15, 0.4, 0.3, 0.04 + ts_glow))

	# === "EBENEZER SCROOGE" TOMBSTONE — prominent center ===
	var eb_x := 640.0
	var eb_y := 380.0
	var eb_w := 50.0
	var eb_h := 75.0
	draw_rect(Rect2(eb_x - eb_w * 0.5, eb_y - eb_h, eb_w, eb_h), Color(0.2, 0.19, 0.22, 0.65))
	draw_circle(Vector2(eb_x, eb_y - eb_h), eb_w * 0.5, Color(0.2, 0.19, 0.22, 0.65))
	# Engraved text lines (small horizontal marks suggesting letters)
	for line_i in range(3):
		var line_y2 := eb_y - eb_h + 20.0 + float(line_i) * 12.0
		var line_w2 := eb_w * (0.7 - float(line_i) * 0.1)
		draw_line(Vector2(eb_x - line_w2 * 0.5, line_y2), Vector2(eb_x + line_w2 * 0.5, line_y2), Color(0.35, 0.33, 0.38, 0.4), 1.5)
	# Eerie glow around Scrooge's tombstone
	var eb_glow := 0.06 + sin(_time * 1.2) * 0.03
	draw_circle(Vector2(eb_x, eb_y - eb_h * 0.5), 60.0, Color(0.2, 0.6, 0.4, eb_glow))

	# === GHOSTLY FIGURES RISING FROM GRAVES ===
	for gi in range(4):
		var ghost_x := 420.0 + float(gi) * 200.0
		var rise_offset := sin(_time * 0.6 + float(gi) * 1.5) * 12.0
		var ghost_base_y := 400.0 + rise_offset
		var ghost_alpha := 0.08 + sin(_time * 0.9 + float(gi) * 2.0) * 0.04
		# Wispy body shape
		var ghost_pts := PackedVector2Array([
			Vector2(ghost_x - 10, ghost_base_y),
			Vector2(ghost_x - 14, ghost_base_y - 25),
			Vector2(ghost_x - 8, ghost_base_y - 45),
			Vector2(ghost_x, ghost_base_y - 55 + rise_offset * 0.3),
			Vector2(ghost_x + 8, ghost_base_y - 45),
			Vector2(ghost_x + 14, ghost_base_y - 25),
			Vector2(ghost_x + 10, ghost_base_y)
		])
		draw_colored_polygon(ghost_pts, Color(0.5, 0.7, 0.6, ghost_alpha))
		# Eyes
		draw_circle(Vector2(ghost_x - 3, ghost_base_y - 45), 1.5, Color(0.7, 0.9, 0.8, ghost_alpha * 2.0))
		draw_circle(Vector2(ghost_x + 3, ghost_base_y - 45), 1.5, Color(0.7, 0.9, 0.8, ghost_alpha * 2.0))

	# === FLOATING CHAINS (animated) ===
	for ci in range(6):
		var chain_start_x := 150.0 + float(ci) * 190.0
		var chain_y_base := 280.0 + sin(_time * 0.7 + float(ci) * 1.1) * 25.0
		var chain_sway := sin(_time * 1.2 + float(ci) * 0.8) * 15.0
		for link in range(6):
			var lx := chain_start_x + chain_sway * (float(link) / 5.0) + sin(_time + float(link)) * 3.0
			var ly := chain_y_base + float(link) * 14.0
			# Oval chain link
			draw_arc(Vector2(lx, ly), 5.0, 0, TAU, 12, Color(0.35, 0.3, 0.28, 0.15 + sin(_time * 0.5 + float(ci)) * 0.05), 1.5)

	# === GROUND — Frozen graveyard earth with snow ===
	var ground_top := 440.0
	for gi2 in range(20):
		var gt := float(gi2) / 19.0
		var gy := ground_top + gt * (628.0 - ground_top)
		var gc := Color(0.08, 0.1, 0.12).lerp(Color(0.06, 0.07, 0.1), gt)
		# Snow tint near surface
		if gt < 0.3:
			gc = gc.lerp(Color(0.4, 0.42, 0.5), (1.0 - gt / 0.3) * 0.15)
		draw_rect(Rect2(0, gy, 1280, (628.0 - ground_top) / 19.0 + 2.0), gc)

	# Snow drifts along ground
	for sd in range(10):
		var sdx := float(sd) * 135.0 + 30.0
		var sdy := ground_top + 5.0 + sin(float(sd) * 2.3) * 8.0
		draw_circle(Vector2(sdx, sdy), 25.0 + sin(float(sd) * 1.7) * 10.0, Color(0.6, 0.62, 0.7, 0.08))

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"lamp_post":
				var lp = dec["pos"]
				var ls = dec["size"]
				draw_line(lp, lp + Vector2(0, -ls * 1.4), Color(0.15, 0.12, 0.1, 0.6), 3.0)
				var lamp_top = lp + Vector2(0, -ls * 1.4)
				draw_rect(Rect2(lamp_top.x - ls * 0.2, lamp_top.y - ls * 0.4, ls * 0.4, ls * 0.4), Color(0.18, 0.14, 0.1, 0.5))
				var flicker = sin(_time * 6.0 + dec["extra"]) * 0.15
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.15 + flicker, Color(1.0, 0.75, 0.2, 0.55 + flicker))
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.8, Color(1.0, 0.7, 0.2, 0.04))
			"bare_tree":
				var tp = dec["pos"]
				var ts = dec["size"]
				var sh = dec["extra"]
				draw_line(tp, tp + Vector2(0, -ts * 1.4), Color(0.12, 0.1, 0.08, 0.5), 3.0)
				var branch_base = tp + Vector2(0, -ts * 1.4)
				for b in range(4):
					var b_angle = -PI * 0.6 + float(b) * 0.4 + sin(float(int(sh * 100) + b)) * 0.2
					var b_len = ts * (0.6 + float(b) * 0.2)
					draw_line(branch_base + Vector2(0, float(b) * ts * 0.2), branch_base + Vector2(0, float(b) * ts * 0.2) + Vector2.from_angle(b_angle) * b_len, Color(0.12, 0.1, 0.08, 0.4), 1.5)
			"snow_pile":
				draw_circle(dec["pos"], dec["size"], Color(0.85, 0.87, 0.9, 0.15))
				draw_circle(dec["pos"] + Vector2(dec["size"] * 0.3, -dec["size"] * 0.2), dec["size"] * 0.7, Color(0.88, 0.9, 0.92, 0.12))
			"chimney":
				var cp2 = dec["pos"]
				var cs2 = dec["size"]
				draw_rect(Rect2(cp2.x - cs2 * 0.4, cp2.y - cs2 * 2, cs2 * 0.8, cs2 * 2), Color(0.15, 0.12, 0.1, 0.4))
				var cf = sin(_time * 0.5 + dec["extra"]) * 4.0
				draw_circle(Vector2(cp2.x + cf, cp2.y - cs2 * 2.2), 4.0, Color(0.4, 0.4, 0.45, 0.06))

	# === FOREGROUND — Low mist and frost particles ===
	for fi in range(8):
		var fx := float(fi) * 170.0 + sin(_time * 0.3 + float(fi) * 0.9) * 40.0
		var fy := 550.0 + sin(_time * 0.4 + float(fi) * 1.2) * 20.0
		draw_circle(Vector2(fx, fy), 50.0 + sin(_time * 0.5 + float(fi)) * 15.0, Color(0.15, 0.25, 0.2, 0.04))

	# Frost sparkle particles drifting down
	for sp in range(15):
		var sp_x := fmod(float(sp) * 97.0 + _time * 8.0 + sin(float(sp) * 3.7) * 200.0, 1280.0)
		var sp_y := fmod(float(sp) * 53.0 + _time * 12.0, 578.0) + 50.0
		var sp_alpha := 0.1 + sin(_time * 3.0 + float(sp) * 2.1) * 0.06
		draw_circle(Vector2(sp_x, sp_y), 1.5, Color(0.7, 0.85, 0.95, sp_alpha))

	# Foreground iron fence silhouettes
	for fence_i in range(20):
		var fence_x := float(fence_i) * 68.0 + 10.0
		var fence_base_y := 590.0
		draw_line(Vector2(fence_x, fence_base_y), Vector2(fence_x, fence_base_y - 35.0), Color(0.08, 0.08, 0.1, 0.3), 2.0)
		# Pointed top
		draw_line(Vector2(fence_x - 3, fence_base_y - 35.0), Vector2(fence_x, fence_base_y - 42.0), Color(0.08, 0.08, 0.1, 0.3), 1.5)
		draw_line(Vector2(fence_x + 3, fence_base_y - 35.0), Vector2(fence_x, fence_base_y - 42.0), Color(0.08, 0.08, 0.1, 0.3), 1.5)
	# Horizontal fence bars
	draw_line(Vector2(10, 570.0), Vector2(1270, 570.0), Color(0.08, 0.08, 0.1, 0.2), 1.5)
	draw_line(Vector2(10, 580.0), Vector2(1270, 580.0), Color(0.08, 0.08, 0.1, 0.2), 1.5)


func _draw_scrooge_ch3(sky_color: Color, ground_color: Color) -> void:
	# === SKY GRADIENT — Split dawn: warm gold left, cold gray right ===
	var warm_dawn := Color(0.45, 0.25, 0.08)
	var cold_gray := Color(0.12, 0.13, 0.18)
	var golden_top := Color(0.3, 0.18, 0.06)
	var pale_sky := Color(0.35, 0.3, 0.25)
	for i in range(30):
		var t := float(i) / 29.0
		var y_start := t * 300.0
		var y_height := 300.0 / 29.0 + 2.0
		# Draw sky in vertical strips blending left-warm to right-cold
		for sx in range(16):
			var xt := float(sx) / 15.0
			var left_color := golden_top.lerp(warm_dawn, t)
			var right_color := cold_gray.lerp(Color(0.15, 0.15, 0.2), t * 0.5)
			var band_color := left_color.lerp(right_color, xt)
			# Add golden sunrise glow near horizon on the left
			if t > 0.6 and xt < 0.4:
				var glow_strength := (t - 0.6) * 2.5 * (1.0 - xt / 0.4) * 0.3
				band_color = band_color.lerp(Color(0.8, 0.5, 0.15), glow_strength)
			draw_rect(Rect2(float(sx) * 80.0, y_start, 82.0, y_height), band_color)

	# === ATMOSPHERE — Golden light rays from left ===
	for ray in range(8):
		var ray_angle := -0.3 + float(ray) * 0.08
		var ray_length := 500.0 + sin(_time * 0.4 + float(ray)) * 50.0
		var ray_start := Vector2(0, 200.0 + float(ray) * 20.0)
		var ray_end := ray_start + Vector2.from_angle(ray_angle) * ray_length
		var ray_alpha := 0.03 + sin(_time * 0.5 + float(ray) * 0.7) * 0.015
		draw_line(ray_start, ray_end, Color(1.0, 0.8, 0.3, ray_alpha), 3.0 + float(ray) * 0.5)

	# Warm golden haze on left side
	for hz in range(6):
		var hx := 80.0 + float(hz) * 60.0 + sin(_time * 0.3 + float(hz)) * 15.0
		var hy := 200.0 + float(hz) * 30.0
		draw_circle(Vector2(hx, hy), 70.0 + sin(_time * 0.4 + float(hz) * 1.3) * 15.0, Color(0.9, 0.65, 0.2, 0.03))

	# Cold mist on right side
	for cm in range(5):
		var cx := 850.0 + float(cm) * 90.0 + sin(_time * 0.25 + float(cm)) * 20.0
		var cy := 180.0 + float(cm) * 40.0
		draw_circle(Vector2(cx, cy), 60.0, Color(0.2, 0.2, 0.25, 0.04))

	# === GHOST OF CHRISTMAS YET TO COME — Tall hooded shadow, right side ===
	var ghost_x := 1100.0 + sin(_time * 0.3) * 5.0
	var ghost_y := 180.0
	# Tall hooded cloak
	var cloak_pts := PackedVector2Array([
		Vector2(ghost_x - 20, ghost_y + 120),
		Vector2(ghost_x - 28, ghost_y + 40),
		Vector2(ghost_x - 22, ghost_y - 20),
		Vector2(ghost_x - 12, ghost_y - 60),
		Vector2(ghost_x, ghost_y - 75),
		Vector2(ghost_x + 12, ghost_y - 60),
		Vector2(ghost_x + 22, ghost_y - 20),
		Vector2(ghost_x + 28, ghost_y + 40),
		Vector2(ghost_x + 20, ghost_y + 120)
	])
	var cloak_alpha := 0.3 + sin(_time * 0.8) * 0.05
	draw_colored_polygon(cloak_pts, Color(0.02, 0.02, 0.04, cloak_alpha))
	# Hood darkness
	draw_circle(Vector2(ghost_x, ghost_y - 55), 14.0, Color(0.0, 0.0, 0.0, cloak_alpha * 0.8))
	# Pointing arm extending left
	var arm_sway := sin(_time * 0.6) * 3.0
	draw_line(Vector2(ghost_x - 20, ghost_y), Vector2(ghost_x - 55 + arm_sway, ghost_y - 10), Color(0.02, 0.02, 0.04, cloak_alpha * 0.7), 3.0)
	# Dark aura
	draw_circle(Vector2(ghost_x, ghost_y + 20), 50.0, Color(0.02, 0.02, 0.06, 0.06))

	# === LONDON ROOFTOPS — Snow-covered with chimneys ===
	var rooftop_data := [
		{"x": 100.0, "w": 120.0, "h": 80.0, "roof_h": 40.0},
		{"x": 250.0, "w": 100.0, "h": 95.0, "roof_h": 35.0},
		{"x": 380.0, "w": 140.0, "h": 70.0, "roof_h": 45.0},
		{"x": 560.0, "w": 110.0, "h": 85.0, "roof_h": 38.0},
		{"x": 700.0, "w": 130.0, "h": 75.0, "roof_h": 42.0},
		{"x": 860.0, "w": 105.0, "h": 90.0, "roof_h": 36.0},
		{"x": 1000.0, "w": 115.0, "h": 72.0, "roof_h": 40.0}
	]
	var rooftop_base_y := 360.0
	for rd in rooftop_data:
		var rx: float = rd["x"]
		var rw: float = rd["w"]
		var rh: float = rd["h"]
		var rrh: float = rd["roof_h"]
		var building_top := rooftop_base_y - rh
		# Building wall
		draw_rect(Rect2(rx, building_top, rw, rh), Color(0.12, 0.1, 0.1, 0.55))
		# Pitched roof
		var roof_pts := PackedVector2Array([
			Vector2(rx - 5, building_top),
			Vector2(rx + rw * 0.5, building_top - rrh),
			Vector2(rx + rw + 5, building_top)
		])
		draw_colored_polygon(roof_pts, Color(0.1, 0.08, 0.08, 0.6))
		# Snow on roof ridge
		draw_line(Vector2(rx - 2, building_top), Vector2(rx + rw * 0.5, building_top - rrh), Color(0.8, 0.82, 0.88, 0.2), 3.0)
		draw_line(Vector2(rx + rw * 0.5, building_top - rrh), Vector2(rx + rw + 2, building_top), Color(0.8, 0.82, 0.88, 0.2), 3.0)
		# Warm lit windows
		for wi in range(2):
			for wj in range(2):
				var win_x := rx + 15.0 + float(wi) * (rw - 30.0)
				var win_y := building_top + 15.0 + float(wj) * 25.0
				if win_y < rooftop_base_y - 10.0:
					draw_rect(Rect2(win_x - 5, win_y - 7, 10, 14), Color(0.9, 0.65, 0.2, 0.25))
					# Warm glow
					draw_circle(Vector2(win_x, win_y), 8.0, Color(0.95, 0.7, 0.25, 0.06))

	# === WREATHS AND HOLLY on buildings ===
	for wr_i in range(5):
		var wr_x := 160.0 + float(wr_i) * 220.0
		var wr_y := rooftop_base_y - 50.0
		# Wreath circle
		draw_arc(Vector2(wr_x, wr_y), 8.0, 0, TAU, 16, Color(0.1, 0.4, 0.12, 0.3), 2.5)
		# Red bow at bottom
		draw_circle(Vector2(wr_x, wr_y + 8.0), 2.5, Color(0.7, 0.1, 0.08, 0.3))
		# Holly leaves nearby
		draw_circle(Vector2(wr_x + 12.0, wr_y - 3.0), 3.0, Color(0.08, 0.35, 0.1, 0.2))
		draw_circle(Vector2(wr_x + 18.0, wr_y - 1.0), 2.5, Color(0.08, 0.35, 0.1, 0.2))
		draw_circle(Vector2(wr_x + 15.0, wr_y - 5.0), 1.5, Color(0.65, 0.08, 0.08, 0.25))

	# === CHURCH BELLS — Visual golden rings ===
	var bell_x := 200.0
	var bell_y := 160.0
	# Church tower in background
	draw_rect(Rect2(bell_x - 20, bell_y, 40, 100), Color(0.1, 0.09, 0.08, 0.5))
	var bell_steeple := PackedVector2Array([
		Vector2(bell_x - 15, bell_y),
		Vector2(bell_x, bell_y - 40),
		Vector2(bell_x + 15, bell_y)
	])
	draw_colored_polygon(bell_steeple, Color(0.1, 0.09, 0.08, 0.55))
	# Animated golden rings expanding outward
	for ring_i in range(4):
		var ring_radius := 15.0 + fmod(_time * 20.0 + float(ring_i) * 25.0, 100.0)
		var ring_alpha := clampf(0.12 - ring_radius * 0.001, 0.0, 0.12)
		draw_arc(Vector2(bell_x, bell_y - 20), ring_radius, 0, TAU, 24, Color(0.95, 0.8, 0.3, ring_alpha), 1.5)

	# === CHILDREN IN SNOW — Small figures on left side ===
	for chi in range(3):
		var child_x := 80.0 + float(chi) * 50.0
		var child_y := 430.0
		var bounce := absf(sin(_time * 2.0 + float(chi) * 1.5)) * 4.0
		# Simple body
		draw_circle(Vector2(child_x, child_y - 18.0 - bounce), 5.0, Color(0.5, 0.3, 0.15, 0.3))
		draw_rect(Rect2(child_x - 4, child_y - 13.0 - bounce, 8, 13), Color(0.4, 0.15, 0.1 + float(chi) * 0.08, 0.3))
		# Legs
		draw_line(Vector2(child_x - 2, child_y - bounce), Vector2(child_x - 3, child_y + 6.0), Color(0.25, 0.15, 0.1, 0.3), 1.5)
		draw_line(Vector2(child_x + 2, child_y - bounce), Vector2(child_x + 3, child_y + 6.0), Color(0.25, 0.15, 0.1, 0.3), 1.5)
		# Scarf
		var scarf_col := Color(0.7, 0.1, 0.1, 0.3) if chi != 1 else Color(0.1, 0.4, 0.1, 0.3)
		draw_line(Vector2(child_x - 3, child_y - 14.0 - bounce), Vector2(child_x - 8, child_y - 10.0 - bounce), scarf_col, 2.0)

	# === GROUND — Snow-covered cobblestone ===
	var ground_top := 440.0
	for gi in range(20):
		var gt := float(gi) / 19.0
		var gy := ground_top + gt * (628.0 - ground_top)
		# Transition: snow white on top, darker cobblestone beneath
		var gc := Color(0.55, 0.55, 0.6).lerp(Color(0.15, 0.13, 0.12), gt)
		# Warm golden reflection on left, cold on right
		if gt < 0.3:
			gc = gc.lerp(Color(0.7, 0.6, 0.45), (1.0 - gt / 0.3) * 0.1)
		draw_rect(Rect2(0, gy, 1280, (628.0 - ground_top) / 19.0 + 2.0), gc)

	# Snow accumulation patches
	for sp2 in range(14):
		var sx2 := float(sp2) * 95.0 + 20.0
		var sy2 := ground_top + 2.0 + sin(float(sp2) * 1.9) * 5.0
		draw_circle(Vector2(sx2, sy2), 20.0 + sin(float(sp2) * 2.7) * 8.0, Color(0.75, 0.77, 0.82, 0.1))

	# === DECORATIONS ===
	for dec in _decorations:
		match dec["type"]:
			"lamp_post":
				var lp = dec["pos"]
				var ls = dec["size"]
				draw_line(lp, lp + Vector2(0, -ls * 1.4), Color(0.15, 0.12, 0.1, 0.6), 3.0)
				var lamp_top = lp + Vector2(0, -ls * 1.4)
				draw_rect(Rect2(lamp_top.x - ls * 0.2, lamp_top.y - ls * 0.4, ls * 0.4, ls * 0.4), Color(0.18, 0.14, 0.1, 0.5))
				var flicker = sin(_time * 6.0 + dec["extra"]) * 0.15
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.15 + flicker, Color(1.0, 0.75, 0.2, 0.55 + flicker))
				draw_circle(lamp_top + Vector2(0, -ls * 0.2), ls * 0.8, Color(1.0, 0.7, 0.2, 0.04))
			"bare_tree":
				var tp = dec["pos"]
				var ts = dec["size"]
				var sh = dec["extra"]
				draw_line(tp, tp + Vector2(0, -ts * 1.4), Color(0.12, 0.1, 0.08, 0.5), 3.0)
				var branch_base = tp + Vector2(0, -ts * 1.4)
				for b in range(4):
					var b_angle = -PI * 0.6 + float(b) * 0.4 + sin(float(int(sh * 100) + b)) * 0.2
					var b_len = ts * (0.6 + float(b) * 0.2)
					draw_line(branch_base + Vector2(0, float(b) * ts * 0.2), branch_base + Vector2(0, float(b) * ts * 0.2) + Vector2.from_angle(b_angle) * b_len, Color(0.12, 0.1, 0.08, 0.4), 1.5)
			"snow_pile":
				draw_circle(dec["pos"], dec["size"], Color(0.85, 0.87, 0.9, 0.15))
				draw_circle(dec["pos"] + Vector2(dec["size"] * 0.3, -dec["size"] * 0.2), dec["size"] * 0.7, Color(0.88, 0.9, 0.92, 0.12))
			"chimney":
				var cp2 = dec["pos"]
				var cs2 = dec["size"]
				draw_rect(Rect2(cp2.x - cs2 * 0.4, cp2.y - cs2 * 2, cs2 * 0.8, cs2 * 2), Color(0.15, 0.12, 0.1, 0.4))
				var cf = sin(_time * 0.5 + dec["extra"]) * 4.0
				draw_circle(Vector2(cp2.x + cf, cp2.y - cs2 * 2.2), 4.0, Color(0.4, 0.4, 0.45, 0.06))

	# === FOREGROUND — Falling snow and warm/cold atmosphere ===
	# Falling snowflakes
	for sf in range(25):
		var sway := sin(_time * 1.5 + float(sf) * 2.3) * 15.0
		var sf_x := fmod(float(sf) * 57.0 + sway + sin(float(sf) * 4.1) * 100.0, 1280.0)
		var sf_y := fmod(float(sf) * 37.0 + _time * (15.0 + float(sf) * 0.5), 578.0) + 50.0
		var sf_size := 1.0 + sin(float(sf) * 1.3) * 0.5
		var sf_alpha := 0.12 + sin(_time * 2.0 + float(sf)) * 0.04
		draw_circle(Vector2(sf_x, sf_y), sf_size, Color(0.9, 0.92, 0.95, sf_alpha))

	# Warm foreground glow on far left (dawn light hitting ground)
	draw_circle(Vector2(0, 500), 150.0, Color(0.8, 0.55, 0.15, 0.03))
	draw_circle(Vector2(50, 550), 100.0, Color(0.85, 0.6, 0.2, 0.025))

	# Cold shadow on right foreground
	draw_rect(Rect2(900, 500, 380, 128), Color(0.04, 0.04, 0.08, 0.06))

	# Foreground lamp post silhouette (closer, larger)
	var fg_lamp_x := 1200.0
	draw_line(Vector2(fg_lamp_x, 628), Vector2(fg_lamp_x, 520), Color(0.06, 0.05, 0.04, 0.4), 4.0)
	draw_rect(Rect2(fg_lamp_x - 8, 510, 16, 16), Color(0.08, 0.06, 0.05, 0.35))
	var fg_flicker := sin(_time * 5.0) * 0.1
	draw_circle(Vector2(fg_lamp_x, 508), 5.0 + fg_flicker, Color(1.0, 0.8, 0.3, 0.4 + fg_flicker))
	draw_circle(Vector2(fg_lamp_x, 508), 25.0, Color(1.0, 0.75, 0.25, 0.04))

func _on_tower_pressed(tower_type: TowerType, desc: String) -> void:
	_play_sfx(_sfx_ui_click)
	_deselect_tower()
	if not _is_character_unlocked(tower_type):
		info_label.text = "%s is not yet unlocked!" % tower_info[tower_type]["name"]
		return
	if purchased_towers.has(tower_type):
		info_label.text = "%s is already placed!" % tower_info[tower_type]["name"]
		return
	var cost = _get_discounted_cost(tower_type)
	if gold < cost:
		info_label.text = "Need %dG for %s! (Have %dG)" % [cost, tower_info[tower_type]["name"], gold]
		_insufficient_gold_flash = 1.0
		return
	selected_tower = tower_type
	placing_tower = true
	cancel_button.visible = true
	# Add synergy hints to placement info
	var synergy_hints = ""
	for syn in synergy_definitions:
		if syn["tower_a"] == tower_type or syn["tower_b"] == tower_type:
			var partner = syn["tower_b"] if syn["tower_a"] == tower_type else syn["tower_a"]
			if purchased_towers.has(partner):
				synergy_hints += " ★ SYNERGY: %s" % syn["name"]
	info_label.text = desc + synergy_hints

func _on_cancel_placement() -> void:
	placing_tower = false
	cancel_button.visible = false
	info_label.text = "Placement cancelled."

func _find_tower_at(pos: Vector2) -> Node2D:
	var closest: Node2D = null
	var closest_dist: float = TOWER_SELECT_RADIUS
	for tower in get_tree().get_nodes_in_group("towers"):
		var dist = pos.distance_to(tower.global_position)
		if dist < closest_dist:
			closest = tower
			closest_dist = dist
	return closest

func _select_tower(tower: Node2D) -> void:
	_deselect_tower()
	selected_tower_node = tower
	tower.is_selected = true
	_update_upgrade_panel()

func _deselect_tower() -> void:
	if selected_tower_node and is_instance_valid(selected_tower_node):
		selected_tower_node.is_selected = false
	selected_tower_node = null
	_hide_upgrade_panel()

func _update_upgrade_panel() -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		_hide_upgrade_panel()
		return
	var tower = selected_tower_node
	var display_name = tower.get_tower_display_name() if tower.has_method("get_tower_display_name") else "Tower"
	upgrade_name_label.text = display_name

	# Update all 4 upgrade slots
	for i in range(4):
		var btn = upgrade_buttons[i]
		var cost_lbl = upgrade_cost_labels[i]
		var status_rect = upgrade_status_rects[i]

		var tier_name = tower.TIER_NAMES[i] if i < tower.TIER_NAMES.size() else "?"
		var tier_cost = tower.TIER_COSTS[i] if i < tower.TIER_COSTS.size() else 0
		var tier_desc = tower.ABILITY_DESCRIPTIONS[i] if i < tower.ABILITY_DESCRIPTIONS.size() else ""

		var desc_lbl = upgrade_desc_labels[i]
		desc_lbl.text = tier_desc

		if i < tower.upgrade_tier:
			# Already purchased — green
			btn.text = "%s  ✔" % tier_name
			btn.disabled = true
			cost_lbl.text = "OWNED"
			cost_lbl.add_theme_color_override("font_color", Color(0.4, 0.8, 0.3))
			desc_lbl.add_theme_color_override("font_color", Color(0.6, 0.8, 0.5, 0.7))
			status_rect.color = Color(0.08, 0.18, 0.06, 0.85)
			# Green border
			status_rect.get_child(0).color = Color(0.3, 0.7, 0.2, 0.5)
		elif i == tower.upgrade_tier:
			# Next available — check if affordable
			btn.text = tier_name
			var can_afford = gold >= tier_cost
			btn.disabled = not can_afford
			cost_lbl.text = "%dG" % tier_cost
			desc_lbl.add_theme_color_override("font_color", Color(0.85, 0.82, 0.75, 0.9))
			if can_afford:
				# Affordable — gold border
				cost_lbl.add_theme_color_override("font_color", Color(1.0, 0.84, 0.0))
				status_rect.color = Color(0.14, 0.10, 0.06, 0.85)
				status_rect.get_child(0).color = Color(0.85, 0.65, 0.1, 0.6)
			else:
				# Too expensive — dark
				cost_lbl.add_theme_color_override("font_color", Color(0.6, 0.4, 0.3))
				status_rect.color = Color(0.10, 0.07, 0.12, 0.85)
				status_rect.get_child(0).color = Color(0.4, 0.3, 0.5, 0.3)
		else:
			# Locked — gray
			btn.text = tier_name
			btn.disabled = true
			cost_lbl.text = "%dG" % tier_cost
			cost_lbl.add_theme_color_override("font_color", Color(0.4, 0.35, 0.3))
			desc_lbl.add_theme_color_override("font_color", Color(0.5, 0.48, 0.55, 0.5))
			status_rect.color = Color(0.08, 0.06, 0.10, 0.7)
			status_rect.get_child(0).color = Color(0.25, 0.2, 0.3, 0.3)

	# Update sell button
	if tower.has_method("get_sell_value"):
		var sv = tower.get_sell_value()
		sell_value_label.text = "Refund: %dG" % sv
	else:
		sell_value_label.text = ""

	upgrade_panel.visible = true

func _hide_upgrade_panel() -> void:
	upgrade_panel.visible = false

func _on_upgrade_tier_pressed(tier_index: int) -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	# Only allow purchasing the next tier in sequence
	if tier_index != selected_tower_node.upgrade_tier:
		return
	if selected_tower_node.has_method("purchase_upgrade"):
		# Check cost before attempting purchase for feedback
		var upgrade_cost = 0
		if selected_tower_node.has_method("get_next_upgrade_info"):
			var info = selected_tower_node.get_next_upgrade_info()
			upgrade_cost = info.get("cost", 0)
		if selected_tower_node.purchase_upgrade():
			_update_upgrade_panel()
			var tier_name = selected_tower_node.TIER_NAMES[selected_tower_node.upgrade_tier - 1]
			info_label.text = "Upgraded: %s!" % tier_name
			spawn_floating_text(selected_tower_node.global_position + Vector2(0, -30), tier_name + "!", Color(0.4, 1.0, 0.5), 15.0, 1.2)
			# Achievement: max power (tier 4)
			if selected_tower_node.upgrade_tier >= 4:
				_check_achievement("max_power", 1)
				_update_quest_progress("max_upgrades", 1)
		else:
			# Can't afford or already maxed — flash gold label
			if upgrade_cost > gold:
				info_label.text = "Need %dG! (Have %dG)" % [upgrade_cost, gold]
				_insufficient_gold_flash = 1.0

func _on_sell_pressed() -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	var tower = selected_tower_node
	var sell_value = 0
	if tower.has_method("get_sell_value"):
		sell_value = tower.get_sell_value()
	# Include branch upgrade costs in sell refund (60% like base)
	if tower.has_meta("branch_upgrades"):
		var branch_ups = tower.get_meta("branch_upgrades")
		for bu in branch_ups:
			sell_value += int(bu.get("cost", 0) * 0.6)
	var tower_name = tower.get_tower_display_name() if tower.has_method("get_tower_display_name") else "Tower"
	var tower_pos = tower.global_position

	# Refund gold (tracked for achievements/quests)
	add_gold(sell_value)
	spawn_floating_text(tower_pos + Vector2(0, -20), "+%dG" % sell_value, Color(1.0, 0.85, 0.2), 16.0, 1.2)

	# Remove tower position from placement tracking
	for i in range(placed_tower_positions.size() - 1, -1, -1):
		if placed_tower_positions[i].distance_to(tower_pos) < 5.0:
			placed_tower_positions.remove_at(i)
			break

	# Re-enable the tower button for this type (with discounted cost)
	for tower_type in tower_info.keys():
		if tower_info[tower_type]["name"] == tower_name:
			purchased_towers.erase(tower_type)
			if tower_buttons.has(tower_type):
				var display_cost = _get_discounted_cost(tower_type)
				var short_name = tower_name.split(" ")[0] if tower_name.length() > 8 else tower_name
				tower_buttons[tower_type].text = "%s [%dG]" % [short_name, display_cost]
				tower_buttons[tower_type].disabled = false
			break

	# Deselect and destroy
	_deselect_tower()
	tower.queue_free()
	info_label.text = "%s sold for %dG!" % [tower_name, sell_value]
	# Re-check synergies after tower is freed (2-frame delay to ensure queue_free completes)
	get_tree().create_timer(0.05).timeout.connect(_check_synergies)

func _on_speed_pressed() -> void:
	_play_sfx(_sfx_ui_click)
	# Cycle through speeds: 1x → 2x → 3x → 1x
	if not fast_forward:
		fast_forward = true
		_game_speed_level = 2.0
		if not game_paused:
			Engine.time_scale = 2.0
		speed_button.text = "  [2x]  "
	elif _game_speed_level < 2.5:
		_game_speed_level = 3.0
		if not game_paused:
			Engine.time_scale = 3.0
		speed_button.text = "  [3x]  "
	else:
		fast_forward = false
		_game_speed_level = 1.0
		if not game_paused:
			Engine.time_scale = 1.0
		speed_button.text = "  >>  "
		current_game_fast_forward_only = false

func _on_sfx_mute_pressed() -> void:
	sfx_muted = not sfx_muted
	sfx_mute_button.text = " [SFX] " if sfx_muted else " SFX "

func _on_voice_mute_pressed() -> void:
	voices_muted = not voices_muted
	voice_mute_button.text = " [VOX] " if voices_muted else " VOX "

func _on_auto_wave_toggled() -> void:
	_play_sfx(_sfx_ui_click)
	auto_wave_enabled = not auto_wave_enabled
	auto_wave_btn.text = " AUTO " if auto_wave_enabled else " [AUTO] "
	if not auto_wave_enabled:
		wave_auto_timer = -1.0
		if not is_wave_active and wave < total_waves:
			start_button.text = "  START WAVE  "
	_save_game()

func _on_start_wave_pressed() -> void:
	_play_sfx(_sfx_ui_click)
	if is_wave_active:
		if game_paused:
			# Resume
			game_paused = false
			Engine.time_scale = _game_speed_level if fast_forward else 1.0
			start_button.text = "  ⏸ Pause  "
			queue_redraw()
		else:
			# Pause
			game_paused = true
			Engine.time_scale = 0.0
			start_button.text = "  ▶ Resume  "
			queue_redraw()
		return
	wave_auto_timer = -1.0
	_start_next_wave()

func _on_restart_pressed() -> void:
	if game_state != GameState.PLAYING:
		return
	if not is_wave_active and wave == 0:
		return
	# Kill all active enemies
	for enemy in get_tree().get_nodes_in_group("enemies"):
		enemy.queue_free()
	# Reset wave state
	enemies_alive = 0
	enemies_to_spawn = 0
	spawn_timer = 0.0
	is_wave_active = false
	game_paused = false
	wave_auto_timer = -1.0
	# Restore gold/lives to wave-start snapshot
	gold = wave_start_gold
	lives = wave_start_lives
	# Decrement wave so _start_next_wave replays the same wave
	wave -= 1
	# Reset tower cooldowns and abilities for fresh wave retry
	for tower in get_tree().get_nodes_in_group("towers"):
		if "fire_cooldown" in tower:
			tower.fire_cooldown = 0.0
		if "_attack_anim" in tower:
			tower._attack_anim = 0.0
		if "target" in tower:
			tower.target = null
	# Reset time scale
	Engine.time_scale = 2.0 if fast_forward else 1.0
	# Re-enable start button
	start_button.disabled = false
	start_button.text = "  START WAVE  "
	update_hud()
	info_label.text = "Wave %d restarted. Ready to go!" % (wave + 1)
	queue_redraw()

func _start_next_wave() -> void:
	if not fast_forward:
		current_game_fast_forward_only = false
	if is_wave_active or wave >= total_waves:
		return
	wave += 1
	is_wave_active = true
	game_paused = false
	_play_sfx(_sfx_wave_start)
	music_beat_index = 0
	_music_beat_accum = 0.0
	enemies_to_spawn = _get_wave_enemy_count(wave)
	spawn_interval = _get_wave_spawn_interval(wave)
	spawn_timer = 0.0
	wave_start_gold = gold
	wave_start_lives = lives
	start_button.disabled = false
	start_button.text = "  ⏸ Pause  "
	var wave_name = _get_wave_name(wave)
	var enemy_word = "enemy" if enemies_to_spawn == 1 else "enemies"
	info_label.text = "Wave %d — %s (%d %s)" % [wave, wave_name, enemies_to_spawn, enemy_word]
	# Boss wave alert
	if wave in [20, 25, 30, 35] or wave == total_waves or (wave >= 39 and selected_difficulty == 2):
		_boss_alert_timer = 2.5
		if wave == total_waves:
			_boss_alert_text = "FINAL WAVE"
		elif wave >= 39 and selected_difficulty == 2:
			_boss_alert_text = "FINAL VILLAIN"
		else:
			_boss_alert_text = "BOSS WAVE"
		_screen_shake_timer = 0.4
		_screen_shake_intensity = 5.0
	# Award wave survival XP to all placed towers (small bonus each wave)
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.has_method("register_damage"):
			var wave_xp = 5.0 + wave * 2.0  # Growing XP per wave
			tower.register_damage(wave_xp)
	# Notify towers that a wave started
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.has_method("on_wave_start"):
			tower.on_wave_start(wave)
	update_hud()

func update_hud() -> void:
	if wave_label:
		if endless_mode:
			wave_label.text = "Wave: %d (Endless)" % wave
		elif shadow_arena_active:
			wave_label.text = "Arena Wave: %d" % wave
		else:
			var diff_indicator = ["", " [M]", " [H]"][selected_difficulty]
			wave_label.text = "Wave: %d/%d%s" % [wave, total_waves, diff_indicator]
		# Show enemy count during active waves
		if is_wave_active:
			var remaining = enemies_alive + enemies_to_spawn
			wave_label.text += "  (%d left)" % remaining
	if gold_label:
		gold_label.text = "Gold: %s" % _format_gold(gold)
		if _insufficient_gold_flash > 0.0:
			var flash_a = clampf(_insufficient_gold_flash, 0.0, 1.0)
			gold_label.add_theme_color_override("font_color", Color(1.0, 0.3, 0.2).lerp(Color(1.0, 0.84, 0.0), 1.0 - flash_a))
		else:
			gold_label.add_theme_color_override("font_color", Color(1.0, 0.84, 0.0))
	if lives_label:
		lives_label.text = "Lives: %d" % lives
		var max_lives = difficulty_fixed_lives[selected_difficulty] if selected_difficulty < difficulty_fixed_lives.size() else 100
		var life_pct = float(lives) / float(max(1, max_lives))
		if life_pct <= 0.2:
			lives_label.add_theme_color_override("font_color", Color(1.0, 0.15, 0.1))
		elif life_pct <= 0.5:
			lives_label.add_theme_color_override("font_color", Color(1.0, 0.6, 0.2))
		else:
			lives_label.add_theme_color_override("font_color", Color(1.0, 0.39, 0.28))
	if selected_tower_node and is_instance_valid(selected_tower_node):
		_update_upgrade_panel()

func get_path_points() -> PackedVector2Array:
	return path_points

func add_gold(amount: int) -> void:
	gold += amount
	total_gold_earned += amount
	_check_achievement("penny_pincher", amount)
	_update_quest_progress("earn_gold", amount)
	update_hud()

func spend_gold(amount: int) -> bool:
	if gold >= amount:
		gold -= amount
		total_gold_spent += amount
		_check_achievement("big_spender", amount)
		update_hud()
		return true
	return false

func lose_life() -> void:
	# Storybook Shield blocks life loss
	if storybook_shield_charges > 0:
		storybook_shield_charges -= 1
		spawn_floating_text(Vector2(640, 400), "Shield blocked!", Color(0.3, 0.8, 1.0), 14.0, 0.8)
		return
	lives -= 1
	if lives < 0:
		lives = 0
	current_game_lives_lost += 1
	# Red screen flash on life loss + warning sound
	_death_flash_timer = 0.15
	_play_sfx(_sfx_life_lost)
	spawn_floating_text(Vector2(420, 30), "-1 LIFE!", Color(1.0, 0.2, 0.15, 1.0), 18.0, 0.8)
	update_hud()
	if lives <= 0:
		if odyssey_active:
			_odyssey_defeat()
		game_over()

func _quest_track_kill(enemy_node = null) -> void:
	_update_quest_progress("kill", 1)
	if enemy_node and enemy_node.get("is_shadow_infested"):
		_update_quest_progress("kill_shadow", 1)

func enemy_died(enemy_node = null) -> void:
	enemies_alive -= 1
	total_enemies_killed += 1
	_check_achievement("first_blood", 1)
	_check_achievement("centurion", 1)
	_check_achievement("thousand_slayer", 1)
	_quest_track_kill(enemy_node)

# === FLOATING TEXTS ===
func spawn_floating_text(pos: Vector2, text: String, color: Color, size: float = 14.0, duration: float = 1.0) -> void:
	if _floating_texts.size() >= 100:
		_floating_texts.pop_front()
	_floating_texts.append({
		"pos": pos, "text": text, "color": color, "size": size,
		"duration": duration, "timer": duration, "vel_y": -60.0
	})

func spawn_damage_number(pos: Vector2, amount: float, is_boss: bool) -> void:
	var text = str(int(amount))
	var color = Color(1.0, 1.0, 1.0, 0.9)
	var size = 14.0
	if is_boss:
		color = Color(1.0, 0.3, 0.2, 1.0)
		size = 20.0
	elif amount > 500.0:
		color = Color(1.0, 0.85, 0.2, 1.0)
		text = str(int(amount)) + "!"
		size = 17.0
	spawn_floating_text(pos + Vector2(randf_range(-8, 8), randf_range(-12, -4)), text, color, size, 0.8)

func spawn_gold_text(pos: Vector2, amount: int) -> void:
	spawn_floating_text(pos + Vector2(0, -10), "+%dg" % amount, Color(1.0, 0.85, 0.2, 0.9), 13.0, 1.0)

# === DEATH EFFECTS ===
func report_enemy_death(pos: Vector2, is_boss: bool, scale: float) -> void:
	_play_sfx(_sfx_enemy_death)
	if is_boss:
		# Screen shake
		_screen_shake_timer = 0.5
		_screen_shake_intensity = 8.0 * scale
		# White flash
		_death_flash_timer = 0.1
		# Ink splatters
		for i in range(10 + int(scale * 5)):
			var angle = randf() * TAU
			var speed = randf_range(90.0, 240.0) * scale
			var boss_hue = randf_range(0.0, 0.2)
			_ink_splatters.append({
				"pos": pos, "vel": Vector2(cos(angle), sin(angle)) * speed,
				"radius": randf_range(4.0, 10.0) * scale, "timer": 1.5,
				"color": Color(0.12 + boss_hue, 0.04, 0.15 + boss_hue * 0.3, 0.85)
			})
	else:
		# Small ink puffs
		for i in range(4 + randi() % 3):
			var angle = randf() * TAU
			var speed = randf_range(40.0, 100.0)
			var ink_hue = randf_range(0.0, 0.15)
			_ink_splatters.append({
				"pos": pos, "vel": Vector2(cos(angle), sin(angle)) * speed,
				"radius": randf_range(3.0, 6.0), "timer": 0.5,
				"color": Color(0.1 + ink_hue, 0.06, 0.15 + ink_hue * 0.5, 0.7)
			})

# === ENEMY MODIFIERS ===
func _apply_enemy_modifiers(enemy, wave_num: int, is_boss: bool) -> void:
	if selected_difficulty == 0:
		return  # Easy: no modifiers
	var available = ["spectral", "ironbound", "hexed", "bound", "shadow_infested", "regrown", "fortified", "shielded", "cursed", "phantom"]
	# Shadow Arena may force specific modifiers
	if shadow_arena_active and shadow_arena_modifiers.size() > 0:
		if "shadow_infested" in shadow_arena_modifiers:
			enemy.is_shadow_infested = true
			enemy.max_health *= 1.3
			enemy.health = enemy.max_health
		if "regrow_only" in shadow_arena_modifiers:
			enemy.is_regrown = true
		if "fortified_all" in shadow_arena_modifiers:
			enemy.is_fortified = true
			enemy.max_health *= 1.5
			enemy.health = enemy.max_health
		if "double_hp" in shadow_arena_modifiers:
			enemy.max_health *= 2.0
			enemy.health = enemy.max_health
		if "fast_enemies" in shadow_arena_modifiers:
			enemy.speed *= 1.5
	var min_wave = 15 if selected_difficulty == 1 else 10
	var chance = 0.10 if selected_difficulty == 1 else 0.20
	var max_mods = 1 if selected_difficulty == 1 else 2
	# New modifiers unlock progressively
	if wave_num < 20:
		available = ["spectral", "ironbound", "hexed", "bound", "shadow_infested", "fortified"]
	if wave_num < min_wave and not is_boss:
		return
	if is_boss and selected_difficulty == 2:
		# Bosses always get 1 modifier on Hard
		var mod = available[randi() % available.size()]
		_apply_single_modifier(enemy, mod)
	elif randf() < chance:
		var count = 1 + (randi() % max_mods if max_mods > 1 and randf() < 0.3 else 0)
		available.shuffle()
		for i in range(min(count, available.size())):
			_apply_single_modifier(enemy, available[i])

func _apply_single_modifier(enemy, mod: String) -> void:
	match mod:
		"ironbound":
			enemy.modifiers.append(mod)
			enemy.max_health *= 2.0
			enemy.health = enemy.max_health
		"bound":
			enemy.modifiers.append(mod)
			enemy.bound_shield = 200.0
		"shadow_infested":
			enemy.is_shadow_infested = true
			enemy.max_health *= 1.3
			enemy.health = enemy.max_health
		"regrown":
			enemy.is_regrown = true
		"fortified":
			enemy.is_fortified = true
			enemy.max_health *= 1.5
			enemy.health = enemy.max_health
		"shielded":
			enemy.is_shielded = true
			enemy.shield_hp = enemy.max_health * 0.3
		"cursed":
			enemy.is_cursed = true
			enemy.speed *= 0.85  # Cursed enemies move slower but debuff towers
		"phantom":
			enemy.is_phantom = true
			enemy.phantom_visible = true
			enemy.phantom_phase_timer = 0.0
		"hexed":
			enemy.modifiers.append(mod)
			enemy.speed *= 1.2
			enemy.max_health *= 0.8
			enemy.health = enemy.max_health
		"spectral":
			enemy.modifiers.append(mod)
			enemy.is_spectral = true
			enemy.max_health *= 0.7
			enemy.health = enemy.max_health
		_:
			enemy.modifiers.append(mod)

# === MOAB VILLAIN SPAWN ===
func spawn_moab_children(parent_progress: float, theme: int, child_tier: int, count: int) -> void:
	for i in range(count):
		var child = enemy_scene.instantiate()
		child.add_to_group("enemies")
		child.enemy_theme = theme
		child.enemy_tier = 3  # Always top-tier art
		child.progress = parent_progress + float(i) * 20.0
		if child_tier > 0:
			child.is_moab = true
			child.moab_tier = child_tier
			child.boss_scale = MOAB_TIER_SCALES[child_tier]
			child.max_health = (600.0 + wave * 40.0) * MOAB_TIER_HP_MULT[child_tier] * 0.5
			child.speed = 55.0 + wave * 1.5
			child.gold_reward = 15 + child_tier * 10
			child.boss_name = MOAB_VILLAIN_NAMES.get(theme, "Dark Overlord")
			child.moab_children_count = MOAB_TIER_CHILDREN[child_tier]
		else:
			# Tier 0 MOAB children are just strong regular enemies
			child.max_health = 400.0 + wave * 30.0
			child.speed = 70.0 + wave * 2.0
			child.gold_reward = 8
			child.boss_scale = 1.5
		child.health = child.max_health
		enemy_path.add_child(child)
		enemies_alive += 1

func spawn_regrow_children(parent_progress: float, theme: int, tier: int, generation: int, child_hp: float) -> void:
	for i in range(2):
		var child = enemy_scene.instantiate()
		child.add_to_group("enemies")
		child.enemy_theme = theme
		child.enemy_tier = max(0, tier - 1)
		child.progress = parent_progress + float(i) * 15.0
		child.is_regrown = true
		child.regrow_generation = generation
		child.max_health = child_hp
		child.health = child_hp
		child.speed = 90.0 + wave * 2.5
		child.gold_reward = 3
		child.boss_scale = 0.7 / float(generation)
		enemy_path.add_child(child)
		enemies_alive += 1

func _spawn_moab_wave(theme: int, tier: int) -> void:
	# Spawn a MOAB villain enemy for special waves
	var moab = enemy_scene.instantiate()
	moab.add_to_group("enemies")
	moab.enemy_theme = theme
	moab.enemy_tier = 3
	moab.is_moab = true
	moab.moab_tier = tier
	moab.boss_scale = MOAB_TIER_SCALES[tier]
	moab.boss_name = MOAB_VILLAIN_NAMES.get(theme, "Dark Overlord")
	moab.moab_children_count = MOAB_TIER_CHILDREN[tier]
	var diff_mult = [0.85, 1.0, 1.2][selected_difficulty]
	moab.max_health = (600.0 + wave * 40.0) * MOAB_TIER_HP_MULT[tier] * diff_mult
	moab.speed = (50.0 + wave * 1.0) * (0.9 + selected_difficulty * 0.05)
	moab.gold_reward = 20 + tier * 15
	moab.health = moab.max_health
	enemy_path.add_child(moab)
	enemies_alive += 1

# === TOME BINDING BONUSES ===
func _get_binding_bonuses(tower_type) -> Dictionary:
	var bonuses: Dictionary = {}
	var bindings = equipped_bindings.get(tower_type, [])
	for bid in bindings:
		var binding = _find_binding(bid)
		if binding.is_empty():
			continue
		# Multi-effect relics use "effects" array
		if binding.has("effects"):
			for fx in binding["effects"]:
				_apply_binding_effect(bonuses, fx.get("effect", ""), fx.get("value", 0.0))
		else:
			# Single-effect relics use "effect"/"value"
			_apply_binding_effect(bonuses, binding.get("effect", ""), binding.get("value", 0.0))
	return bonuses

func _apply_binding_effect(bonuses: Dictionary, eff: String, val: float) -> void:
	match eff:
		"attack_speed", "damage", "range", "crit", "gold_bonus", "slow", "dodge", "splash_radius", "armor_pierce", "crit_damage", "cooldown_reduction", "first_blood", "execute", "wave_gold", "poison", "burn", "chain", "multi_shot", "aura_range", "debuff_amp", "xp_gain", "boss_damage", "lifesteal", "bloodstained", "kill_gold", "absorb_hit", "heal_nearby":
			bonuses[eff] = bonuses.get(eff, 0.0) + val
		"raven":
			bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
			bonuses["damage"] = bonuses.get("damage", 0.0) - 0.05
		"candelabra":
			bonuses["range"] = bonuses.get("range", 0.0) + val
			bonuses["damage"] = bonuses.get("damage", 0.0) + 0.05
		"excalibur":
			bonuses["damage"] = bonuses.get("damage", 0.0) + val
			bonuses["crit"] = bonuses.get("crit", 0.0) + 0.05
		"ruby":
			bonuses["attack_speed"] = bonuses.get("attack_speed", 0.0) + val
			bonuses["range"] = bonuses.get("range", 0.0) + 0.10
		"all":
			for k in ["damage", "range", "attack_speed", "crit"]:
				bonuses[k] = bonuses.get(k, 0.0) + val

func _pick_weighted_relic(rarity: String, level_character: int) -> Dictionary:
	var char_names = ["robin_hood", "alice", "wicked_witch", "peter_pan", "phantom",
		"scrooge", "sherlock", "tarzan", "dracula", "merlin", "frankenstein"]
	var char_name = char_names[level_character] if level_character >= 0 and level_character < char_names.size() else ""
	var candidates: Array = []
	var weights: Array = []
	for b in TOME_BINDINGS:
		if b["rarity"] != rarity:
			continue
		var w = 1.0
		# Character weighting: 60% chance to prefer current world's character
		if char_name != "" and b.get("character", "") == char_name:
			w = 3.0  # 3x weight for matching character (~60% when 4 char + 6 universal)
		# Duplicate protection: 50% weight reduction for items owned 3+
		var count = owned_bindings.get(b["id"], 0)
		if count >= 3:
			w *= 0.5
		candidates.append(b)
		weights.append(w)
	if candidates.size() == 0:
		return {}
	# Weighted random selection
	var total_w = 0.0
	for ww in weights:
		total_w += ww
	var roll = randf() * total_w
	var accum = 0.0
	for i in range(candidates.size()):
		accum += weights[i]
		if roll <= accum:
			return candidates[i]
	return candidates[candidates.size() - 1]

func _get_highest_completed_level() -> int:
	if completed_levels.size() == 0:
		return -1
	var highest = -1
	for lv in completed_levels:
		if lv > highest:
			highest = lv
	return highest

func _get_binding_slots(tower_type) -> int:
	var level = survivor_progress.get(tower_type, {}).get("level", 1)
	if level >= 15:
		return 3
	elif level >= 10:
		return 2
	elif level >= 5:
		return 1
	return 0

func _build_binding_lookup() -> void:
	_binding_lookup.clear()
	for b in TOME_BINDINGS:
		_binding_lookup[b["id"]] = b

func _find_binding(binding_id: String) -> Dictionary:
	return _binding_lookup.get(binding_id, {})

func _tower_type_to_name(tt) -> String:
	match tt:
		TowerType.ROBIN_HOOD: return "robin_hood"
		TowerType.ALICE: return "alice"
		TowerType.WICKED_WITCH: return "wicked_witch"
		TowerType.PETER_PAN: return "peter_pan"
		TowerType.PHANTOM: return "phantom"
		TowerType.SCROOGE: return "scrooge"
		TowerType.SHERLOCK: return "sherlock"
		TowerType.TARZAN: return "tarzan"
		TowerType.DRACULA: return "dracula"
		TowerType.MERLIN: return "merlin"
		TowerType.FRANKENSTEIN: return "frankenstein"
		TowerType.SHADOW_AUTHOR: return "shadow_author"
	return ""

func game_over() -> void:
	game_state = GameState.GAME_OVER_STATE
	Engine.time_scale = 1.0
	fast_forward = false
	game_paused = false
	_play_sfx(_sfx_defeat)
	_death_flash_timer = 0.3  # Dramatic red flash on game over
	speed_button.text = "  >>  "
	_collect_session_damage()
	if shadow_arena_active:
		_end_shadow_arena()
		game_over_label.text = "SHADOW ARENA - Wave %d\nBest: Wave %d\n+%d Arena Crystals" % [wave, shadow_arena_high_score, wave / 5]
		shadow_arena_active = false
	elif endless_mode:
		if wave > endless_high_wave:
			endless_high_wave = wave
		game_over_label.text = "Reached Wave %d\nBest: Wave %d" % [wave, endless_high_wave]
		endless_mode = false
		_save_game()
	else:
		game_over_label.text = "GAME OVER"
	game_over_label.add_theme_color_override("font_color", Color.RED)
	game_over_label.add_theme_constant_override("shadow_offset_x", 2)
	game_over_label.add_theme_constant_override("shadow_offset_y", 3)
	game_over_label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.7))
	game_over_label.visible = true
	return_button.visible = true
	retry_button.visible = true
	start_button.disabled = true
	# Save progress (currencies, achievements, etc.) even on defeat
	_save_game()

# === BOSS RESCUE ANIMATION ===
func start_boss_rescue(pos: Vector2, boss_node: Node2D) -> void:
	boss_rescue_active = true
	boss_rescue_pos = pos
	boss_rescue_boss_ref = boss_node
	boss_rescue_timer = 0.0
	boss_rescue_phase = 0
	is_wave_active = false  # Prevent wave complete check during animation
	# Generate smoke particles
	_rescue_smoke_particles.clear()
	for i in range(30):
		_rescue_smoke_particles.append({
			"angle": randf() * TAU,
			"dist": randf_range(40.0, 120.0),
			"speed": randf_range(1.5, 3.5),
			"size": randf_range(4.0, 12.0),
			"offset_y": randf_range(-30.0, 10.0),
		})
	# Play Shadow Author voice if available
	if shadow_author_fight_clips.size() > 0 and not catchphrase_player.playing:
		var clip = shadow_author_fight_clips[randi() % shadow_author_fight_clips.size()]
		catchphrase_player.stream = clip
		catchphrase_player.play()

func _process_boss_rescue(delta: float) -> void:
	if not boss_rescue_active:
		return
	boss_rescue_timer += delta
	# Phase transitions
	if boss_rescue_phase == 0 and boss_rescue_timer >= 1.2:
		boss_rescue_phase = 1
	elif boss_rescue_phase == 1 and boss_rescue_timer >= 2.5:
		boss_rescue_phase = 2
	elif boss_rescue_phase == 2 and boss_rescue_timer >= 3.5:
		boss_rescue_phase = 3
		# Screen shake on flash
		_screen_shake_timer = 0.6
		_screen_shake_intensity = 12.0
	elif boss_rescue_phase == 3 and boss_rescue_timer >= 4.2:
		boss_rescue_phase = 4
	elif boss_rescue_phase == 4 and boss_rescue_timer >= 5.0:
		# Cleanup — remove boss, trigger victory
		if is_instance_valid(boss_rescue_boss_ref):
			boss_rescue_boss_ref.queue_free()
		enemies_alive = max(0, enemies_alive - 1)
		boss_rescue_active = false
		boss_rescue_boss_ref = null
		_rescue_smoke_particles.clear()
		_victory()

func _draw_boss_rescue() -> void:
	if not boss_rescue_active:
		return
	var t = boss_rescue_timer
	var pos = boss_rescue_pos
	var font = game_font

	# Phase 0: Black smoke particles swirl and gather
	if boss_rescue_phase >= 0:
		var smoke_progress = clampf(t / 1.2, 0.0, 1.0)
		for p in _rescue_smoke_particles:
			var angle = p["angle"] + t * p["speed"]
			var target_dist = p["dist"] * (1.0 - smoke_progress * 0.7)
			var px = pos.x + cos(angle) * target_dist
			var py = pos.y + sin(angle) * target_dist * 0.5 + p["offset_y"]
			var smoke_alpha = 0.15 + smoke_progress * 0.4
			var smoke_size = p["size"] * (0.5 + smoke_progress * 0.5)
			if boss_rescue_phase >= 3:
				smoke_alpha *= clampf(1.0 - (t - 3.5) / 0.7, 0.0, 1.0)
			draw_circle(Vector2(px, py), smoke_size, Color(0.08, 0.02, 0.12, smoke_alpha))

	# Phase 1+: Shadow Author materializes
	if boss_rescue_phase >= 1:
		var appear_t = clampf((t - 1.2) / 1.3, 0.0, 1.0)
		var author_alpha = appear_t
		if boss_rescue_phase >= 3:
			author_alpha *= clampf(1.0 - (t - 3.5) / 0.7, 0.0, 1.0)
		var author_pos = Vector2(pos.x + 60.0, pos.y - 20.0)
		# Float upward as appearing
		author_pos.y -= appear_t * 15.0
		_draw_shadow_author_figure(author_pos, 1.8, author_alpha, t)
		# "I'll take it from here..." text
		if boss_rescue_phase == 1:
			var text_alpha = clampf((t - 1.8) / 0.5, 0.0, 1.0)
			_udraw(font, Vector2(pos.x, pos.y - 90), "I'll take it from here...", HORIZONTAL_ALIGNMENT_CENTER, 300, 12, Color(0.7, 0.3, 0.9, text_alpha * 0.9))

	# Phase 2: Grab — villain shrinks/fades toward Shadow Author
	if boss_rescue_phase == 2:
		var grab_t = clampf((t - 2.5) / 1.0, 0.0, 1.0)
		# Draw energy tendrils from author to villain
		for i in range(5):
			var offset = float(i) * 0.3
			var tendril_x = lerp(pos.x + 60.0, pos.x, grab_t) + sin(t * 8.0 + offset) * 8.0
			var tendril_y = lerp(pos.y - 35.0, pos.y, grab_t) + cos(t * 6.0 + offset) * 5.0
			draw_circle(Vector2(tendril_x, tendril_y), 3.0, Color(0.5, 0.2, 0.8, 0.5 * (1.0 - grab_t * 0.5)))

	# Phase 3: Bright white flash
	if boss_rescue_phase == 3:
		var flash_t = clampf((t - 3.5) / 0.7, 0.0, 1.0)
		var flash_radius = 40.0 + flash_t * 400.0
		var flash_alpha = (1.0 - flash_t) * 0.8
		draw_circle(pos, flash_radius, Color(1.0, 0.95, 0.85, flash_alpha))
		# Inner bright core
		var core_alpha = (1.0 - flash_t) * 0.95
		draw_circle(pos, 30.0 * (1.0 - flash_t * 0.5), Color(1.0, 1.0, 1.0, core_alpha))

	# Phase 4: Fade out — lingering wisps
	if boss_rescue_phase == 4:
		var fade_t = clampf((t - 4.2) / 0.8, 0.0, 1.0)
		for i in range(8):
			var angle = TAU * float(i) / 8.0 + t * 2.0
			var dist = 20.0 + fade_t * 60.0
			var wisp_x = pos.x + cos(angle) * dist
			var wisp_y = pos.y + sin(angle) * dist * 0.6 - fade_t * 30.0
			draw_circle(Vector2(wisp_x, wisp_y), 4.0 * (1.0 - fade_t), Color(0.3, 0.1, 0.4, 0.3 * (1.0 - fade_t)))

func _draw_shadow_author_figure(pos: Vector2, scale: float, alpha: float, time: float) -> void:
	if alpha <= 0.01:
		return
	var s = scale
	# Body — tall flowing robes tapering to wispy tendrils
	# Cloak body (main shape)
	var cloak_pts = PackedVector2Array()
	cloak_pts.append(pos + Vector2(-18 * s, -60 * s))  # Left shoulder
	cloak_pts.append(pos + Vector2(-22 * s, -20 * s))  # Left mid
	cloak_pts.append(pos + Vector2(-25 * s, 20 * s))   # Left lower
	cloak_pts.append(pos + Vector2(-20 * s, 50 * s + sin(time * 2.0) * 5.0))  # Left tendril
	cloak_pts.append(pos + Vector2(-8 * s, 55 * s + sin(time * 2.5 + 1.0) * 4.0))  # Inner left tendril
	cloak_pts.append(pos + Vector2(0, 52 * s + sin(time * 3.0) * 3.0))  # Center bottom
	cloak_pts.append(pos + Vector2(8 * s, 55 * s + sin(time * 2.5 + 2.0) * 4.0))  # Inner right tendril
	cloak_pts.append(pos + Vector2(20 * s, 50 * s + sin(time * 2.0 + 1.5) * 5.0))  # Right tendril
	cloak_pts.append(pos + Vector2(25 * s, 20 * s))   # Right lower
	cloak_pts.append(pos + Vector2(22 * s, -20 * s))  # Right mid
	cloak_pts.append(pos + Vector2(18 * s, -60 * s))  # Right shoulder
	var cloak_color = Color(0.06, 0.02, 0.1, alpha * 0.9)
	draw_colored_polygon(cloak_pts, cloak_color)
	# Cloak edge highlight
	for i in range(cloak_pts.size() - 1):
		draw_line(cloak_pts[i], cloak_pts[i + 1], Color(0.25, 0.1, 0.35, alpha * 0.5), 1.5)

	# Hood (pointed)
	var hood_pts = PackedVector2Array()
	hood_pts.append(pos + Vector2(-20 * s, -58 * s))
	hood_pts.append(pos + Vector2(0, -95 * s))  # Hood peak
	hood_pts.append(pos + Vector2(20 * s, -58 * s))
	hood_pts.append(pos + Vector2(12 * s, -50 * s))
	hood_pts.append(pos + Vector2(-12 * s, -50 * s))
	draw_colored_polygon(hood_pts, Color(0.04, 0.01, 0.08, alpha * 0.95))
	# Hood edge
	draw_line(hood_pts[0], hood_pts[1], Color(0.3, 0.12, 0.4, alpha * 0.6), 1.5)
	draw_line(hood_pts[1], hood_pts[2], Color(0.3, 0.12, 0.4, alpha * 0.6), 1.5)

	# Eyes — glowing purple-red deep in hood
	var eye_y = pos.y - 65 * s
	var eye_pulse = 0.7 + sin(time * 4.0) * 0.3
	var eye_glow = Color(0.8, 0.15, 0.4, alpha * eye_pulse)
	draw_circle(Vector2(pos.x - 5 * s, eye_y), 2.5 * s, eye_glow)
	draw_circle(Vector2(pos.x + 5 * s, eye_y), 2.5 * s, eye_glow)
	# Eye glow halo
	draw_circle(Vector2(pos.x - 5 * s, eye_y), 5.0 * s, Color(0.6, 0.1, 0.3, alpha * 0.15 * eye_pulse))
	draw_circle(Vector2(pos.x + 5 * s, eye_y), 5.0 * s, Color(0.6, 0.1, 0.3, alpha * 0.15 * eye_pulse))

	# Skeletal hands
	var hand_sway = sin(time * 1.8) * 4.0 * s
	# Left hand
	var lh = pos + Vector2(-20 * s + hand_sway, -15 * s)
	draw_circle(lh, 3.0 * s, Color(0.75, 0.7, 0.6, alpha * 0.8))
	for f in range(4):
		var fa = -0.4 + float(f) * 0.25
		draw_line(lh, lh + Vector2(cos(fa) * 8.0 * s, sin(fa) * 8.0 * s), Color(0.7, 0.65, 0.55, alpha * 0.7), 1.0)
	# Right hand
	var rh = pos + Vector2(20 * s - hand_sway, -15 * s)
	draw_circle(rh, 3.0 * s, Color(0.75, 0.7, 0.6, alpha * 0.8))
	for f in range(4):
		var fa = PI - 0.4 + float(f) * 0.25
		draw_line(rh, rh + Vector2(cos(fa) * 8.0 * s, sin(fa) * 8.0 * s), Color(0.7, 0.65, 0.55, alpha * 0.7), 1.0)

	# Shadow tendrils at base — wispy dissolving edges
	for i in range(6):
		var ta = TAU * float(i) / 6.0 + time * 1.2
		var td = 15.0 * s + sin(time * 3.0 + float(i)) * 5.0 * s
		var tx = pos.x + cos(ta) * td
		var ty = pos.y + 50 * s + sin(ta) * 8.0 * s
		draw_circle(Vector2(tx, ty), 3.0 * s, Color(0.1, 0.03, 0.15, alpha * 0.4))

	# Shimmer effect on cloak
	var shimmer_y = pos.y - 40 * s + fmod(time * 30.0, 100.0) * s
	if shimmer_y < pos.y + 40 * s:
		draw_line(Vector2(pos.x - 12 * s, shimmer_y), Vector2(pos.x + 12 * s, shimmer_y), Color(0.4, 0.2, 0.6, alpha * 0.08), 1.0)

func _victory() -> void:
	game_state = GameState.GAME_OVER_STATE
	Engine.time_scale = 1.0
	fast_forward = false
	game_paused = false
	_play_sfx(_sfx_victory)
	speed_button.text = "  >>  "
	_collect_session_damage()
	var level_name = levels[current_level]["name"] if current_level >= 0 else "Level"
	var max_lives = difficulty_fixed_lives[selected_difficulty]
	var stars = 1
	if lives >= max_lives:
		stars = 3
	elif lives >= int(max_lives * 0.5):
		stars = 2
	if current_level >= 0 and not current_level in completed_levels:
		completed_levels.append(current_level)
	var old_stars = level_stars.get(current_level, 0)
	level_stars[current_level] = max(old_stars, stars)
	# Award +1 Knowledge Ink for first 3-star completion of a level
	if stars >= 3 and old_stars < 3:
		knowledge_ink += 1
	var star_str = ""
	for i in range(stars):
		star_str += "â˜…"
	for i in range(3 - stars):
		star_str += "â˜†"
	var diff_name = ["Easy", "Medium", "Hard"][selected_difficulty]
	# Generate treasure chest loot (awarded when chest animation plays)
	_generate_chest_loot(stars)
	# Hide the old text label — chest overlay handles all victory display now
	game_over_label.visible = false
	start_button.disabled = true
	# Start victory chest opening overlay (tier = difficulty)
	_start_victory_chest(selected_difficulty, stars)
	# Quest tracking on victory
	_update_quest_progress("complete_levels", 1)
	_update_quest_progress("earn_stars", stars)
	# Shadow Arena handling
	if shadow_arena_active:
		_end_shadow_arena()
	# Achievement checks on victory
	_check_achievement("first_steps", 1)
	_check_achievement("halfway_there", 1)
	_check_achievement("campaign_complete", 1)
	_check_achievement("wave_master", total_waves)
	if stars >= 3:
		_check_achievement("flawless", 1)
	# Check perfect campaign (all 18 levels with 3 stars)
	var three_star_count = 0
	for ls_key in level_stars:
		if level_stars[ls_key] >= 3:
			three_star_count += 1
	_check_achievement("perfect_campaign", three_star_count)
	if current_game_lives_lost == 0:
		_check_achievement("untouchable", 1)
	if current_game_fast_forward_only:
		_check_achievement("speed_demon", 1)
	# Odyssey handling
	if odyssey_active:
		_odyssey_map_victory()
		return
	# Check for character unlocks
	_check_character_unlocks()
	# Post-victory dialog is queued after chest closing (in _on_chest_overlay_clicked)
	_save_game()

func _check_character_unlocks() -> void:
	for char_id in character_unlock_map:
		if char_id in unlocked_characters:
			continue
		var required_levels = character_unlock_map[char_id]
		var all_complete = true
		for lvl in required_levels:
			if not lvl in completed_levels:
				all_complete = false
				break
		if all_complete:
			unlocked_characters.append(char_id)
			_refresh_unlocked_survivors()
			# Queue unlock dialog
			var unlock_key = "unlock_" + char_id
			if story_dialogs.has(unlock_key) and not unlock_key in story_seen:
				story_state.queued_dialog = unlock_key
			# Check if all 5 are unlocked
			if unlocked_characters.size() >= 5:
				if not "all_unlocked" in story_seen:
					if story_state.queued_dialog != "":
						# Will need to chain — handled by queued dialog system
						pass
					else:
						story_state.queued_dialog = "all_unlocked"

func _queue_post_victory_dialog() -> void:
	var post_key = "post_level_" + str(current_level)
	if not story_dialogs.has(post_key):
		return
	if post_key in story_seen:
		return
	# Check for act transitions that should play after this post-level dialog
	var act_key = ""
	if current_level == 15:
		# Just completed all rescue arcs — check if levels 0-15 done
		var rescue_done = true
		for i in range(16):
			if not i in completed_levels:
				rescue_done = false
				break
		if rescue_done and not "act2_intro" in story_seen:
			act_key = "act2_intro"
	elif current_level == 33:
		# Just completed all original arcs — check if levels 0-33 done
		var all_arcs_done = true
		for i in range(34):
			if not i in completed_levels:
				all_arcs_done = false
				break
		if all_arcs_done and not "act3_intro" in story_seen:
			act_key = "act3_intro"
	# Chain dialogs: post_level -> act transition (if any), or post_level -> unlock (if any)
	# Act transitions take priority over unlock dialogs in the queue
	if act_key != "":
		story_state.queued_dialog = act_key
	# If no act_key, the existing queued_dialog (unlock from _check_character_unlocks) stays as-is
	_start_story_dialog(post_key)

func _generate_chest_loot(stars: int) -> void:
	chest_loot.clear()
	var chapter = levels[current_level]["chapter"] if current_level >= 0 and current_level < levels.size() else 0
	# Tier based on difficulty: Easy=1, Medium=2, Hard=3
	var tier = selected_difficulty + 1
	# Chapter progression multiplier (later chapters = better base loot)
	var chapter_mult = 1.0 + chapter * 0.5  # Ch1=1.0, Ch2=1.5, Ch3=2.0
	# Stars bonus (more stars = more loot)
	var star_mult = 0.7 + float(stars) * 0.2  # 1star=0.9, 2star=1.1, 3star=1.3
	# Knowledge tree currency earn bonus
	var currency_mult = 1.0 + _get_knowledge_bonus("currency_earn")

	# === GOLD COINS ===
	var gold_base = [8, 18, 30][selected_difficulty]
	var gold_amount = int(float(gold_base) * chapter_mult * star_mult * currency_mult)
	chest_loot.append({"type": "gold", "amount": gold_amount, "name": "Gold"})

	# === RELIC SHARDS (always drop, more on higher tiers) ===
	var shard_base = [2, 5, 10][selected_difficulty]
	var shard_amount = int(float(shard_base) * chapter_mult * star_mult * currency_mult)
	chest_loot.append({"type": "shards", "amount": shard_amount, "name": "Relic Shards"})

	# === QUILLS (chance increases with tier) ===
	var quill_chance = [0.3, 0.6, 0.9][selected_difficulty]
	if randf() < quill_chance * star_mult:
		var quill_amount = [1, 2, 4][selected_difficulty]
		quill_amount = int(float(quill_amount) * chapter_mult * currency_mult)
		chest_loot.append({"type": "quills", "amount": quill_amount, "name": "Quills"})

	# === STORYBOOK STARS (more generous — guaranteed on Medium+, boosted on Hard) ===
	var star_chance = [0.25, 0.6, 1.0][selected_difficulty]
	if randf() < star_chance * chapter_mult * 0.5:
		var sb_amount = max(1, int(float([1, 2, 3][selected_difficulty]) * currency_mult))
		chest_loot.append({"type": "stars", "amount": sb_amount, "name": "Storybook Stars"})

	# === TRINKET DROP — Difficulty-exclusive, progression-gated ===
	var prog_chapter = current_level / 3  # World index for drop rate scaling
	var level_char = levels[current_level]["character"] if current_level >= 0 and current_level < levels.size() else -1
	var highest_lv = _get_highest_completed_level()
	var trinket_rarity = ["common", "uncommon", "rare"][selected_difficulty]
	var tier_ok = true
	if selected_difficulty == 1 and highest_lv < 12:
		tier_ok = false  # Purple requires Act 1 complete
	elif selected_difficulty == 2 and highest_lv < 24:
		tier_ok = false  # Gold requires Act 2 complete
	var relic_chance = [0.08, 0.12, 0.18][selected_difficulty]
	relic_chance += [0.01, 0.015, 0.02][selected_difficulty] * prog_chapter
	if stars >= 3:
		relic_chance += 0.05
	if tier_ok and randf() < relic_chance:
		var chosen_b = _pick_weighted_relic(trinket_rarity, level_char)
		if not chosen_b.is_empty():
			owned_bindings[chosen_b["id"]] = owned_bindings.get(chosen_b["id"], 0) + 1
			chest_loot.append({"type": "relic", "amount": 1, "name": chosen_b["name"]})

func _award_chest_loot() -> void:
	# Credit the guaranteed base loot currencies to the player
	for item in chest_loot:
		match item["type"]:
			"gold": player_gold += item["amount"]
			"shards": player_relic_shards += item["amount"]
			"quills": player_quills += item["amount"]
			"stars": player_storybook_stars += item["amount"]
			# Relics already awarded directly in _generate_chest_loot

func _collect_session_damage() -> void:
	# Map script filenames to TowerType
	var script_to_type = {
		"robin_hood.gd": TowerType.ROBIN_HOOD,
		"alice.gd": TowerType.ALICE,
		"wicked_witch.gd": TowerType.WICKED_WITCH,
		"peter_pan.gd": TowerType.PETER_PAN,
		"phantom.gd": TowerType.PHANTOM,
		"scrooge.gd": TowerType.SCROOGE,
		"sherlock.gd": TowerType.SHERLOCK,
		"tarzan.gd": TowerType.TARZAN,
		"dracula.gd": TowerType.DRACULA,
		"merlin.gd": TowerType.MERLIN,
		"frankenstein.gd": TowerType.FRANKENSTEIN,
		"shadow_author.gd": TowerType.SHADOW_AUTHOR,
	}
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.get("damage_dealt") != null:
			var dmg = tower.damage_dealt
			var script_path = tower.get_script().resource_path if tower.get_script() else ""
			var fname = script_path.get_file()
			if script_to_type.has(fname):
				var tt = script_to_type[fname]
				session_damage[tt] = session_damage.get(tt, 0.0) + dmg
				# Apply to persistent progression
				if survivor_progress.has(tt):
					var xp_mult = 1.0 + _get_knowledge_bonus("xp_gain")
					survivor_progress[tt]["xp"] += dmg * xp_mult
					# Accumulate total_damage for progressive abilities
					survivor_progress[tt]["total_damage"] = survivor_progress[tt].get("total_damage", 0.0) + dmg
					_check_ability_unlocks(tt)
					# Check for level ups (cap at MAX_SURVIVOR_LEVEL)
					while survivor_progress[tt]["xp"] >= survivor_progress[tt]["xp_next"] and survivor_progress[tt]["level"] < MAX_SURVIVOR_LEVEL:
						survivor_progress[tt]["xp"] -= survivor_progress[tt]["xp_next"]
						survivor_progress[tt]["level"] += 1
						survivor_progress[tt]["xp_next"] = _get_xp_for_level(survivor_progress[tt]["level"])
						_on_survivor_level_up(tt, survivor_progress[tt]["level"])

func _on_survivor_level_up(tower_type, new_level: int) -> void:
	# Unlock gear at level 2, sidekicks at 3/5/8
	# Relics: 0,2,4 auto-earned at levels 2,6,10; relics 1,3,5 purchasable at levels 4,8,12
	if not survivor_progress.has(tower_type):
		return
	var p = survivor_progress[tower_type]
	if new_level >= 2:
		p["gear_unlocked"] = true
	var sk_levels = [3, 5, 8]
	for i in range(3):
		if new_level >= sk_levels[i]:
			p["sidekicks_unlocked"][i] = true
	# Level-earned relics (indices 0, 2, 4) auto-unlock
	var earned_levels = {0: 2, 2: 6, 4: 10}
	for relic_idx in earned_levels:
		if new_level >= earned_levels[relic_idx]:
			p["relics_unlocked"][relic_idx] = true
	# Purchasable relics (indices 1, 3, 5) become available but NOT auto-unlocked
	# They are unlocked via gold purchase in _on_relic_clicked()
	# Award Knowledge Ink on level-up (+1 base, +2 bonus on milestone levels)
	knowledge_ink += 1
	if new_level in [5, 10, 15, 20]:
		knowledge_ink += 2
	# Achievement checks for survivor levels
	if new_level >= 5:
		_check_achievement("veteran_survivor", 1)
	if new_level >= 10:
		_check_achievement("master_survivor", 1)
	# Refresh meta buffs on all placed towers of this type (level-up mid-game)
	for tower in get_tree().get_nodes_in_group("towers"):
		var tower_tt = tower.get_meta("tower_type_enum") if tower.has_meta("tower_type_enum") else -1
		if tower_tt == tower_type:
			_apply_meta_buffs(tower, tower_type)

# === PROGRESSIVE ABILITY SYSTEM ===

func register_tower_damage(tower_type: int, amount: float) -> void:
	if not survivor_progress.has(tower_type):
		return
	var p = survivor_progress[tower_type]
	p["total_damage"] = p.get("total_damage", 0.0) + amount
	_check_ability_unlocks(tower_type)

func _check_ability_unlocks(tower_type: int) -> void:
	if not survivor_progress.has(tower_type):
		return
	var p = survivor_progress[tower_type]
	var total = p.get("total_damage", 0.0)
	var unlocked = p.get("abilities_unlocked", [])
	if unlocked.size() < 9:
		unlocked.resize(9)
		for i in range(unlocked.size()):
			if unlocked[i] == null:
				unlocked[i] = false
		p["abilities_unlocked"] = unlocked
	for i in range(9):
		if not unlocked[i] and total >= PROGRESSIVE_ABILITY_THRESHOLDS[i]:
			unlocked[i] = true
			_show_ability_unlock_popup(tower_type, i)
			_notify_tower_ability_unlocked(tower_type, i)

func _show_ability_unlock_popup(tower_type: int, ability_index: int) -> void:
	_ability_popup_tower_type = tower_type
	_ability_popup_index = ability_index
	# Get ability name from tower scripts
	var script_to_type = {
		TowerType.ROBIN_HOOD: "robin_hood.gd",
		TowerType.ALICE: "alice.gd",
		TowerType.WICKED_WITCH: "wicked_witch.gd",
		TowerType.PETER_PAN: "peter_pan.gd",
		TowerType.PHANTOM: "phantom.gd",
		TowerType.SCROOGE: "scrooge.gd",
	}
	_ability_popup_name = "Ability %d" % (ability_index + 1)
	_ability_popup_desc = ""
	for tower in get_tree().get_nodes_in_group("towers"):
		var tower_tt = tower.get_meta("tower_type_enum") if tower.has_meta("tower_type_enum") else -1
		if tower_tt == tower_type:
			if tower.has_method("get_progressive_ability_name"):
				_ability_popup_name = tower.get_progressive_ability_name(ability_index)
			if tower.has_method("get_progressive_ability_desc"):
				_ability_popup_desc = tower.get_progressive_ability_desc(ability_index)
			break
	_ability_popup_timer = 5.0
	_ability_popup_freeze = 1.5
	queue_redraw()

func _notify_tower_ability_unlocked(tower_type: int, ability_index: int) -> void:
	for tower in get_tree().get_nodes_in_group("towers"):
		var tower_tt = tower.get_meta("tower_type_enum") if tower.has_meta("tower_type_enum") else -1
		if tower_tt == tower_type:
			if tower.has_method("activate_progressive_ability"):
				tower.activate_progressive_ability(ability_index)

func restore_life(amount: int = 1) -> void:
	lives = mini(lives + amount, 99)
	update_hud()

func _update_spawn_debuffs() -> void:
	# Reset spawn debuffs each frame based on active towers
	spawn_hp_reduction = 0.0
	spawn_permanent_slow = 1.0
	for tower in get_tree().get_nodes_in_group("towers"):
		if tower.has_method("get_spawn_debuffs"):
			var debuffs = tower.get_spawn_debuffs()
			spawn_hp_reduction = max(spawn_hp_reduction, debuffs.get("hp_reduction", 0.0))
			spawn_permanent_slow = min(spawn_permanent_slow, debuffs.get("permanent_slow", 1.0))

func show_ability_choice(tower: Node2D) -> void:
	_ability_tower = tower
	ability_title.text = "CHOOSE AN ABILITY"
	for i in range(4):
		if i < tower.TIER_NAMES.size():
			var desc = ""
			if tower.has("ABILITY_DESCRIPTIONS") and i < tower.ABILITY_DESCRIPTIONS.size():
				desc = " — " + tower.ABILITY_DESCRIPTIONS[i]
			ability_buttons[i].text = tower.TIER_NAMES[i] + desc
			ability_buttons[i].visible = true
		else:
			ability_buttons[i].visible = false
	ability_panel.visible = true
	info_label.text = "Choose a special ability for your tower!"

func _on_ability_chosen(index: int) -> void:
	if _ability_tower and _ability_tower.has_method("choose_ability"):
		_ability_tower.choose_ability(index)
	ability_panel.visible = false
	var name = ""
	if _ability_tower and index < _ability_tower.TIER_NAMES.size():
		name = _ability_tower.TIER_NAMES[index]
	info_label.text = "Ability unlocked: %s!" % name
	_ability_tower = null

# === BATTLE POWER HANDLERS ===
func _on_battle_power_pressed(index: int) -> void:
	if index >= selected_powers.size():
		return
	var power_id = selected_powers[index]
	_activate_power(power_id)

func _open_power_selection() -> void:
	power_selection_open = true
	selected_powers.clear()
	queue_redraw()

func _close_power_selection_and_start() -> void:
	power_selection_open = false
	_update_power_buttons()
	# Now actually start the level
	if odyssey_active:
		pass  # Already started
	queue_redraw()

func _toggle_power_selection(power_id: String) -> void:
	if power_id in selected_powers:
		selected_powers.erase(power_id)
	elif selected_powers.size() < 3 and owned_powers.get(power_id, 0) > 0:
		selected_powers.append(power_id)
	queue_redraw()

# === ACHIEVEMENT DRAWING ===
func _draw_achievements_tab() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), col)
	# Gold border
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	# Title
	_udraw(font, Vector2(panel_x + panel_w * 0.5 - 60, panel_y + 28), "ACHIEVEMENTS", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 0.9))
	draw_rect(Rect2(panel_x + panel_w * 0.5 - 80, panel_y + 34, 160, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.4))
	# Count unlocked
	var unlocked_count = 0
	for ach in achievement_definitions:
		if achievements_unlocked.get(ach["id"], false):
			unlocked_count += 1
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "%d / %d" % [unlocked_count, achievement_definitions.size()], HORIZONTAL_ALIGNMENT_RIGHT, -1, 13, menu_text_muted)
	# Draw achievement cards in a grid (5 columns, scrollable via categories)
	var categories = ["Combat", "Tower", "Economy", "Progression"]
	var cat_colors = [Color(0.8, 0.3, 0.2), Color(0.3, 0.7, 0.4), Color(0.85, 0.7, 0.2), Color(0.4, 0.5, 0.85)]
	var card_w = 260.0
	var card_h = 52.0
	var gap_x = 12.0
	var gap_y = 6.0
	var start_y = panel_y + 48.0
	var cols = 4
	for ci in range(categories.size()):
		var cat = categories[ci]
		var cat_col = cat_colors[ci]
		var cat_achievements: Array = []
		for ach in achievement_definitions:
			if ach["category"] == cat:
				cat_achievements.append(ach)
		# Category header
		var hdr_y = start_y
		draw_rect(Rect2(panel_x + 10, hdr_y, panel_w - 20, 18), Color(cat_col.r, cat_col.g, cat_col.b, 0.12))
		_udraw(font, Vector2(panel_x + 20, hdr_y + 13), cat, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(cat_col.r, cat_col.g, cat_col.b, 0.9))
		start_y += 22.0
		# Cards
		for ai in range(cat_achievements.size()):
			var ach = cat_achievements[ai]
			var col_i = ai % cols
			var row_i = ai / cols
			var cx = panel_x + 10 + float(col_i) * (card_w + gap_x)
			var cy = start_y + float(row_i) * (card_h + gap_y)
			var is_done = achievements_unlocked.get(ach["id"], false)
			var prog = achievement_progress.get(ach["id"], 0)
			# Card background
			var bg = Color(0.10, 0.08, 0.22, 0.8) if is_done else Color(0.05, 0.05, 0.14, 0.8)
			draw_rect(Rect2(cx, cy, card_w, card_h), bg)
			# Border
			var bc = Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.6) if is_done else Color(0.25, 0.25, 0.40, 0.3)
			draw_rect(Rect2(cx, cy, card_w, 1), bc)
			draw_rect(Rect2(cx, cy + card_h - 1, card_w, 1), bc)
			draw_rect(Rect2(cx, cy, 1, card_h), bc)
			draw_rect(Rect2(cx + card_w - 1, cy, 1, card_h), bc)
			# Check mark or progress
			if is_done:
				draw_circle(Vector2(cx + 16, cy + card_h * 0.5), 8, Color(0.3, 0.7, 0.2, 0.7))
				_udraw(font, Vector2(cx + 11, cy + card_h * 0.5 + 5), "V", HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color.WHITE)
			else:
				# Progress bar
				var pct = clampf(float(prog) / float(max(1, ach["target"])), 0.0, 1.0)
				draw_rect(Rect2(cx + 4, cy + card_h - 8, (card_w - 8) * pct, 4), Color(cat_col.r, cat_col.g, cat_col.b, 0.5))
				draw_rect(Rect2(cx + 4, cy + card_h - 8, card_w - 8, 4), Color(0.3, 0.3, 0.4, 0.2), false, 1.0)
			# Name and desc
			var nx = cx + 30.0
			var nc = Color(menu_gold_light.r, menu_gold_light.g, menu_gold_light.b, 1.0) if is_done else Color(0.55, 0.52, 0.60)
			_udraw(font, Vector2(nx, cy + 16), ach["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 36), 12, nc)
			_udraw(font, Vector2(nx, cy + 31), ach["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 36), 11, Color(0.5, 0.45, 0.4))
			if not is_done:
				_udraw(font, Vector2(nx, cy + 42), "%d / %d" % [prog, ach["target"]], HORIZONTAL_ALIGNMENT_LEFT, -1, 9, menu_text_muted)
		var rows_for_cat = (cat_achievements.size() + cols - 1) / cols
		start_y += float(rows_for_cat) * (card_h + gap_y) + 8.0

# === POWER SELECTION OVERLAY ===
func _draw_power_selection() -> void:
	var font = game_font
	# Dark overlay
	draw_rect(Rect2(0, 0, 1280, 720), Color(0, 0, 0, 0.75))
	# Panel
	var pw = 700.0
	var ph = 480.0
	var px = (1280 - pw) / 2
	var py = (720 - ph) / 2
	draw_rect(Rect2(px, py, pw, ph), Color(0.06, 0.04, 0.10, 0.95))
	draw_rect(Rect2(px, py, pw, ph), Color(0.85, 0.65, 0.1, 0.5), false, 2.0)
	_udraw(font, Vector2(px + pw * 0.5 - 80, py + 30), "SELECT BATTLE POWERS", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.85, 0.75, 0.4))
	_udraw(font, Vector2(px + pw * 0.5 - 100, py + 50), "Choose up to 3 powers for this battle", HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(0.6, 0.5, 0.4))
	# Draw each power
	for i in range(battle_power_definitions.size()):
		var bp = battle_power_definitions[i]
		var bx = px + 30
		var by = py + 70 + i * 55
		var owned = owned_powers.get(bp["id"], 0)
		var is_selected_p = bp["id"] in selected_powers
		# Background
		var bg_c = Color(0.15, 0.12, 0.06, 0.8) if is_selected_p else Color(0.08, 0.06, 0.10, 0.8)
		draw_rect(Rect2(bx, by, pw - 60, 48), bg_c)
		# Border
		var bdr = Color(0.85, 0.7, 0.2, 0.6) if is_selected_p else Color(0.3, 0.25, 0.2, 0.3)
		draw_rect(Rect2(bx, by, pw - 60, 48), bdr, false, 1.0)
		# Name & desc
		_udraw(font, Vector2(bx + 12, by + 18), bp["name"], HORIZONTAL_ALIGNMENT_LEFT, -1, 14, Color(0.85, 0.75, 0.5))
		_udraw(font, Vector2(bx + 12, by + 34), bp["desc"], HORIZONTAL_ALIGNMENT_LEFT, 350, 10, Color(0.55, 0.48, 0.38))
		# Count
		_udraw(font, Vector2(bx + pw - 120, by + 18), "Owned: %d" % owned, HORIZONTAL_ALIGNMENT_RIGHT, -1, 12, Color(0.7, 0.6, 0.4) if owned > 0 else Color(0.4, 0.35, 0.3))
		if is_selected_p:
			_udraw(font, Vector2(bx + pw - 120, by + 34), "SELECTED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 11, Color(0.3, 0.8, 0.3))
	# Start button — large and prominent
	var sb_w = 260.0
	var sb_h = 50.0
	var sbx = px + (pw - sb_w) * 0.5
	var sby = py + ph - sb_h - 16
	var sb_pulse = (sin(_time * 3.0) + 1.0) * 0.5
	# Glow behind button
	draw_rect(Rect2(sbx - 4, sby - 4, sb_w + 8, sb_h + 8), Color(0.2, 0.7, 0.2, 0.08 + sb_pulse * 0.06))
	# Button background
	draw_rect(Rect2(sbx, sby, sb_w, sb_h), Color(0.15, 0.55, 0.15, 0.9))
	# Top highlight
	draw_rect(Rect2(sbx, sby, sb_w, sb_h * 0.4), Color(0.3, 0.7, 0.3, 0.2))
	# Border
	draw_rect(Rect2(sbx, sby, sb_w, sb_h), Color(0.4, 0.9, 0.3, 0.7 + sb_pulse * 0.3), false, 2.5)
	# Text
	var sb_text = "START BATTLE"
	var sb_tw = font.get_string_size(sb_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 20).x
	_udraw(font, Vector2(sbx + (sb_w - sb_tw) * 0.5 + 1, sby + 33), sb_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 20, Color(0, 0, 0, 0.3))
	_udraw(font, Vector2(sbx + (sb_w - sb_tw) * 0.5, sby + 32), sb_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 20, Color.WHITE)

# === ODYSSEY DRAWING ===
func _draw_odyssey_panel() -> void:
	var font = game_font
	# Odyssey panel in bottom bar (left third)
	var ox = 38.0
	var oy = 520.0
	var pw = 385.0
	var ph = 82.0
	# Panel background
	draw_rect(Rect2(ox, oy, pw, ph), Color(0.10, 0.06, 0.14, 0.85))
	draw_rect(Rect2(ox, oy, pw, ph), Color(0.55, 0.28, 0.75, 0.35), false, 1.5)
	# Purple accent line at top
	draw_rect(Rect2(ox, oy, pw, 2), Color(0.6, 0.3, 0.8, 0.6))
	_udraw(font, Vector2(ox + 12, oy + 20), "ODYSSEY MODE", HORIZONTAL_ALIGNMENT_LEFT, pw - 100, 14, Color(0.82, 0.62, 0.92))
	if odyssey_completed_this_week:
		_udraw(font, Vector2(ox + 12, oy + 40), "Completed this week!", HORIZONTAL_ALIGNMENT_LEFT, pw - 20, 11, Color(0.5, 0.8, 0.3))
		_udraw(font, Vector2(ox + 12, oy + 56), "Resets Monday", HORIZONTAL_ALIGNMENT_LEFT, pw - 20, 9, Color(0.4, 0.6, 0.3))
	else:
		var map_names = ""
		for mi in range(odyssey_maps.size()):
			if mi > 0: map_names += " > "
			if odyssey_maps[mi] < levels.size():
				map_names += levels[odyssey_maps[mi]]["name"]
		_udraw(font, Vector2(ox + 12, oy + 40), map_names, HORIZONTAL_ALIGNMENT_LEFT, pw - 110, 9, Color(0.6, 0.5, 0.4))
		_udraw(font, Vector2(ox + 12, oy + 56), "Trophies: %d | Reward: 10-30" % trophy_currency, HORIZONTAL_ALIGNMENT_LEFT, pw - 110, 9, Color(0.85, 0.7, 0.2))
		# Start button
		draw_rect(Rect2(ox + pw - 88, oy + 18, 78, 46), Color(0.30, 0.15, 0.50, 0.75))
		draw_rect(Rect2(ox + pw - 88, oy + 18, 78, 2), Color(0.5, 0.3, 0.7, 0.5))
		_udraw(font, Vector2(ox + pw - 50, oy + 48), "START", HORIZONTAL_ALIGNMENT_CENTER, 66, 14, Color(0.88, 0.78, 0.98))

# === ENDLESS MODE PANEL ===
func _draw_endless_panel() -> void:
	var font = game_font
	# Endless panel in bottom bar (center third)
	var ox = 432.0
	var oy = 520.0
	var pw = 385.0
	var ph = 82.0
	# Panel background
	draw_rect(Rect2(ox, oy, pw, ph), Color(0.06, 0.08, 0.14, 0.85))
	draw_rect(Rect2(ox, oy, pw, ph), Color(0.28, 0.38, 0.75, 0.35), false, 1.5)
	# Blue accent line at top
	draw_rect(Rect2(ox, oy, pw, 2), Color(0.3, 0.4, 0.8, 0.6))
	_udraw(font, Vector2(ox + 12, oy + 20), "THE ETERNAL CHAPTER", HORIZONTAL_ALIGNMENT_LEFT, pw - 100, 14, Color(0.52, 0.62, 0.92))
	if endless_high_wave > 0:
		_udraw(font, Vector2(ox + 12, oy + 40), "Best: Wave %d" % endless_high_wave, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.7, 0.7, 0.85))
	else:
		_udraw(font, Vector2(ox + 12, oy + 40), "Infinite scaling waves. How far can you go?", HORIZONTAL_ALIGNMENT_LEFT, pw - 110, 10, Color(0.50, 0.52, 0.65))
	_udraw(font, Vector2(ox + 12, oy + 56), "Hard difficulty | Random themes", HORIZONTAL_ALIGNMENT_LEFT, pw - 110, 9, Color(0.40, 0.42, 0.52))
	# Start button
	draw_rect(Rect2(ox + pw - 88, oy + 18, 78, 46), Color(0.15, 0.20, 0.48, 0.75))
	draw_rect(Rect2(ox + pw - 88, oy + 18, 78, 2), Color(0.3, 0.4, 0.7, 0.5))
	_udraw(font, Vector2(ox + pw - 50, oy + 48), "START", HORIZONTAL_ALIGNMENT_CENTER, 66, 14, Color(0.72, 0.82, 0.98))

func _start_endless_mode() -> void:
	_remove_survivor_preview()
	# Pick a random level for the background
	endless_background_level = randi() % levels.size()
	current_level = endless_background_level
	_reset_game()
	endless_mode = true
	gold = 150
	lives = 20
	selected_difficulty = 2  # Hard
	total_waves = 999999
	_setup_path_for_level(current_level)
	_generate_decorations_for_level(current_level)
	_stop_music()
	menu_overlay.visible = false
	top_bar.visible = true
	bottom_panel.visible = true
	game_over_label.visible = false
	return_button.visible = false
	game_state = GameState.PLAYING
	start_button.text = "  START WAVE  "
	# Setup tower buttons (same as _do_level_start)
	tower_buttons[TowerType.ROBIN_HOOD].text = "Robin [%dG]" % _get_discounted_cost(TowerType.ROBIN_HOOD)
	tower_buttons[TowerType.ROBIN_HOOD].disabled = false
	tower_buttons[TowerType.ALICE].text = "Alice [%dG]" % _get_discounted_cost(TowerType.ALICE)
	tower_buttons[TowerType.ALICE].disabled = false
	tower_buttons[TowerType.WICKED_WITCH].text = "Witch [%dG]" % _get_discounted_cost(TowerType.WICKED_WITCH)
	tower_buttons[TowerType.WICKED_WITCH].disabled = false
	tower_buttons[TowerType.PETER_PAN].text = "Peter [%dG]" % _get_discounted_cost(TowerType.PETER_PAN)
	tower_buttons[TowerType.PETER_PAN].disabled = false
	tower_buttons[TowerType.PHANTOM].text = "Phantom [%dG]" % _get_discounted_cost(TowerType.PHANTOM)
	tower_buttons[TowerType.PHANTOM].disabled = false
	tower_buttons[TowerType.SCROOGE].text = "Scrooge [%dG]" % _get_discounted_cost(TowerType.SCROOGE)
	tower_buttons[TowerType.SCROOGE].disabled = false
	var new_char_order = [TowerType.SHERLOCK, TowerType.TARZAN, TowerType.DRACULA, TowerType.MERLIN, TowerType.FRANKENSTEIN]
	var new_char_labels = {
		TowerType.SHERLOCK: "Holmes [%dG]" % _get_discounted_cost(TowerType.SHERLOCK),
		TowerType.TARZAN: "Tarzan [%dG]" % _get_discounted_cost(TowerType.TARZAN),
		TowerType.DRACULA: "Dracula [%dG]" % _get_discounted_cost(TowerType.DRACULA),
		TowerType.MERLIN: "Merlin [%dG]" % _get_discounted_cost(TowerType.MERLIN),
		TowerType.FRANKENSTEIN: "Monster [%dG]" % _get_discounted_cost(TowerType.FRANKENSTEIN),
	}
	var new_visible_count := 0
	for tt in new_char_order:
		if tower_buttons.has(tt):
			if tt in survivor_types and _is_character_unlocked(tt):
				var bx = 8 + new_visible_count * 158
				tower_buttons[tt].position = Vector2(bx, 42)
				tower_buttons[tt].visible = true
				tower_buttons[tt].text = new_char_labels[tt]
				tower_buttons[tt].disabled = false
				new_visible_count += 1
			else:
				tower_buttons[tt].visible = false
	if new_visible_count > 0:
		bottom_panel.size.y = 80
		bottom_panel.position.y = 720 - 80
	else:
		bottom_panel.size.y = 42
		bottom_panel.position.y = 720 - 42
	start_button.visible = true
	start_button.disabled = false
	speed_button.visible = true
	update_hud()
	info_label.text = "The Eternal Chapter (Endless) — Place your towers!"
	wave_auto_timer = -1.0

# === TROPHY STORE DRAWING (as Emporium sub-category) ===
func _draw_trophy_store() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Background
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), col)
	# Gold border
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	# Title
	_udraw(font, Vector2(panel_x + panel_w * 0.5 - 60, panel_y + 28), "TROPHY STORE", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.85, 0.7, 0.2, 0.9))
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Trophies: %d" % trophy_currency, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.85, 0.7, 0.2))
	draw_rect(Rect2(panel_x + panel_w * 0.5 - 80, panel_y + 34, 160, 1), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.4))
	# Categories
	var store_cats = ["auras", "trails", "fanfares", "themes"]
	var store_cat_names = ["Tower Auras", "Projectile Trails", "Victory Fanfares", "Menu Themes"]
	var card_w = 260.0
	var card_h = 50.0
	var start_y = panel_y + 48.0
	for ci in range(store_cats.size()):
		var cat_key = store_cats[ci]
		var items = trophy_store_items.get(cat_key, [])
		# Category header
		draw_rect(Rect2(panel_x + 10, start_y, panel_w - 20, 18), Color(0.6, 0.3, 0.8, 0.10))
		_udraw(font, Vector2(panel_x + 20, start_y + 13), store_cat_names[ci], HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color(0.7, 0.5, 0.85))
		start_y += 22.0
		for ii in range(items.size()):
			var item = items[ii]
			var col_i = ii % 4
			var row_i = ii / 4
			var ix = panel_x + 10 + float(col_i) * (card_w + 10)
			var iy = start_y + float(row_i) * (card_h + 6)
			var is_owned = item["id"] in owned_cosmetics
			var is_equipped = equipped_cosmetics.get(cat_key, "") == item["id"]
			# Background
			var bg = Color(0.12, 0.08, 0.14, 0.8) if is_owned else Color(0.06, 0.05, 0.08, 0.8)
			if is_equipped:
				bg = Color(0.14, 0.12, 0.06, 0.8)
			draw_rect(Rect2(ix, iy, card_w, card_h), bg)
			var bdr = Color(0.85, 0.7, 0.2, 0.5) if is_owned else Color(0.3, 0.25, 0.3, 0.3)
			draw_rect(Rect2(ix, iy, card_w, card_h), bdr, false, 1.0)
			# Color swatch for auras/trails
			if item.has("color"):
				var swatch_col = item["color"]
				if cat_key == "auras" and item["id"] == "aura_prismatic":
					swatch_col = Color.from_hsv(fmod(_time * 0.3, 1.0), 0.7, 0.9, 0.5)
				draw_circle(Vector2(ix + 18, iy + card_h * 0.5), 10, swatch_col)
			# Name
			_udraw(font, Vector2(ix + 34, iy + 18), item["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 40), 12, Color(0.8, 0.7, 0.5))
			_udraw(font, Vector2(ix + 34, iy + 32), item["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 40), 9, Color(0.5, 0.45, 0.38))
			if is_equipped:
				_udraw(font, Vector2(ix + card_w - 65, iy + 18), "EQUIPPED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(0.3, 0.8, 0.3))
			elif is_owned:
				_udraw(font, Vector2(ix + card_w - 50, iy + 18), "OWNED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(0.5, 0.7, 0.9))
			else:
				_udraw(font, Vector2(ix + card_w - 60, iy + 18), "%d T" % item["cost"], HORIZONTAL_ALIGNMENT_RIGHT, -1, 11, Color(0.85, 0.7, 0.2))
		var rows_in_cat = (items.size() + 3) / 4
		start_y += float(rows_in_cat) * (card_h + 6) + 8.0
	# Back button
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.85, 0.7, 0.4))

# === CLICK HANDLERS FOR NEW FEATURES ===
func _on_chapters_odyssey_clicked(mouse_pos: Vector2) -> void:
	# Check if clicking the odyssey start button (bottom bar left)
	var opw = 385.0
	var ox = 38.0 + opw - 88.0
	var oy = 520.0 + 18.0
	if mouse_pos.x >= ox and mouse_pos.x <= ox + 78 and mouse_pos.y >= oy and mouse_pos.y <= oy + 46:
		if not odyssey_completed_this_week:
			_start_odyssey()
	# Check if clicking the endless mode start button (bottom bar center)
	var epw = 385.0
	var ex = 432.0 + epw - 88.0
	var ey = 520.0 + 18.0
	if mouse_pos.x >= ex and mouse_pos.x <= ex + 78 and mouse_pos.y >= ey and mouse_pos.y <= ey + 46:
		_start_endless_mode()

func _on_trophy_store_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button (bottom-left)
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		queue_redraw()
		return
	var store_cats = ["auras", "trails", "fanfares", "themes"]
	var card_w = 260.0
	var card_h = 50.0
	var start_y = panel_y + 48.0
	for ci in range(store_cats.size()):
		var cat_key = store_cats[ci]
		var items = trophy_store_items.get(cat_key, [])
		start_y += 22.0  # category header
		for ii in range(items.size()):
			var item = items[ii]
			var col_i = ii % 4
			var row_i = ii / 4
			var ix = panel_x + 10 + float(col_i) * (card_w + 10)
			var iy = start_y + float(row_i) * (card_h + 6)
			if mouse_pos.x >= ix and mouse_pos.x <= ix + card_w and mouse_pos.y >= iy and mouse_pos.y <= iy + card_h:
				var is_owned = item["id"] in owned_cosmetics
				if is_owned:
					# Toggle equip/unequip
					if equipped_cosmetics.get(cat_key, "") == item["id"]:
						equipped_cosmetics.erase(cat_key)
					else:
						equipped_cosmetics[cat_key] = item["id"]
					_save_game()
				elif trophy_currency >= item["cost"]:
					# Purchase
					trophy_currency -= item["cost"]
					owned_cosmetics.append(item["id"])
					equipped_cosmetics[cat_key] = item["id"]
					_save_game()
				queue_redraw()
				return
		var rows_in_cat = (items.size() + 3) / 4
		start_y += float(rows_in_cat) * (card_h + 6) + 8.0

# === TOME BINDINGS SHOP ===
func _draw_binding_shop() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var content_top = panel_y + 48.0
	var content_bottom = panel_y + panel_h - 50.0
	for i in range(56):
		var t = float(i) / 55.0
		var col = menu_bg_section.lerp(menu_bg_dark, t)
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), col)
	draw_rect(Rect2(panel_x, panel_y, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y + panel_h - 2, panel_w, 2), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	draw_rect(Rect2(panel_x + panel_w - 2, panel_y, 2, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4))
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "TOME BINDINGS", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, Color(0.85, 0.7, 0.2, 0.9))
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Shards: %d" % player_relic_shards, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, Color(0.85, 0.7, 0.2))
	var card_w = 260.0
	var card_h = 48.0
	var rarity_order = ["common", "uncommon", "rare"]
	var rarity_names = {"common": "Common", "uncommon": "Uncommon", "rare": "Rare"}
	var rarity_costs = {"common": 15, "uncommon": 35, "rare": 80}
	var rarity_colors = {"common": Color(0.6, 0.6, 0.6), "uncommon": Color(0.3, 0.7, 0.3), "rare": Color(0.7, 0.4, 0.9)}
	var start_y = content_top - binding_shop_scroll
	var total_content_h = 0.0
	for ri in range(rarity_order.size()):
		var rarity = rarity_order[ri]
		# Category header
		if start_y + 18 > content_top and start_y < content_bottom:
			draw_rect(Rect2(panel_x + 10, start_y, panel_w - 20, 18), Color(0.6, 0.3, 0.8, 0.10))
			_udraw(font, Vector2(panel_x + 20, start_y + 13), rarity_names[rarity] + " (%d shards)" % rarity_costs[rarity], HORIZONTAL_ALIGNMENT_LEFT, -1, 12, rarity_colors[rarity])
		start_y += 22.0
		total_content_h += 22.0
		var bindings_in_rarity: Array = []
		for b in TOME_BINDINGS:
			if b["rarity"] == rarity:
				bindings_in_rarity.append(b)
		for ii in range(bindings_in_rarity.size()):
			var b = bindings_in_rarity[ii]
			var col_i = ii % 4
			var row_i = ii / 4
			var ix = panel_x + 10 + float(col_i) * (card_w + 10)
			var iy = start_y + float(row_i) * (card_h + 6)
			if iy + card_h < content_top or iy > content_bottom:
				continue
			var count = owned_bindings.get(b["id"], 0)
			var bg = Color(0.12, 0.08, 0.14, 0.8) if count > 0 else Color(0.06, 0.05, 0.08, 0.8)
			draw_rect(Rect2(ix, iy, card_w, card_h), bg)
			draw_rect(Rect2(ix, iy, card_w, card_h), Color(rarity_colors[rarity].r, rarity_colors[rarity].g, rarity_colors[rarity].b, 0.3), false, 1.0)
			_udraw(font, Vector2(ix + 8, iy + 16), b["name"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 80), 11, Color(0.8, 0.7, 0.5))
			_udraw(font, Vector2(ix + 8, iy + 30), b["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 16), 9, Color(0.5, 0.45, 0.38))
			if count > 0:
				_udraw(font, Vector2(ix + card_w - 35, iy + 16), "x%d" % count, HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(0.3, 0.8, 0.3))
			_udraw(font, Vector2(ix + card_w - 55, iy + 30), "%d S" % rarity_costs[rarity], HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(0.85, 0.7, 0.2))
		var rows_in_rarity = (bindings_in_rarity.size() + 3) / 4
		var section_h = float(rows_in_rarity) * (card_h + 6) + 8.0
		start_y += section_h
		total_content_h += section_h
	# Clamp scroll
	var max_scroll = maxf(0.0, total_content_h - (content_bottom - content_top))
	binding_shop_scroll = clampf(binding_shop_scroll, 0.0, max_scroll)
	# Scroll indicator
	if max_scroll > 0:
		var bar_x = panel_x + panel_w - 10
		var bar_h = content_bottom - content_top
		var thumb_h = maxf(30.0, bar_h * bar_h / (bar_h + max_scroll))
		var thumb_y = content_top + (binding_shop_scroll / max_scroll) * (bar_h - thumb_h)
		draw_rect(Rect2(bar_x, content_top, 4, bar_h), Color(0.2, 0.2, 0.25, 0.3))
		draw_rect(Rect2(bar_x, thumb_y, 4, thumb_h), Color(0.85, 0.7, 0.2, 0.5))
	# Back button (always visible at bottom)
	draw_rect(Rect2(panel_x + 2, panel_y + panel_h - 50, panel_w - 4, 48), Color(0.03, 0.03, 0.06, 0.95))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.85, 0.7, 0.4))

func _on_binding_shop_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	var content_top = panel_y + 48.0
	var content_bottom = panel_y + panel_h - 50.0
	# Back button
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		binding_shop_scroll = 0.0
		queue_redraw()
		return
	# Don't process clicks outside content area
	if mouse_pos.y < content_top or mouse_pos.y > content_bottom:
		return
	var card_w = 260.0
	var card_h = 48.0
	var rarity_order = ["common", "uncommon", "rare"]
	var rarity_costs = {"common": 15, "uncommon": 35, "rare": 80}
	var start_y = content_top - binding_shop_scroll
	for ri in range(rarity_order.size()):
		var rarity = rarity_order[ri]
		start_y += 22.0
		var bindings_in_rarity: Array = []
		for b in TOME_BINDINGS:
			if b["rarity"] == rarity:
				bindings_in_rarity.append(b)
		for ii in range(bindings_in_rarity.size()):
			var b = bindings_in_rarity[ii]
			var col_i = ii % 4
			var row_i = ii / 4
			var ix = panel_x + 10 + float(col_i) * (card_w + 10)
			var iy = start_y + float(row_i) * (card_h + 6)
			if iy + card_h < content_top or iy > content_bottom:
				continue
			if mouse_pos.x >= ix and mouse_pos.x <= ix + card_w and mouse_pos.y >= iy and mouse_pos.y <= iy + card_h:
				var cost = rarity_costs[rarity]
				if player_relic_shards >= cost:
					player_relic_shards -= cost
					owned_bindings[b["id"]] = owned_bindings.get(b["id"], 0) + 1
					emporium_sub_message = "Purchased %s!" % b["name"]
					emporium_sub_message_timer = 2.0
					_save_game()
				else:
					emporium_sub_message = "Not enough Relic Shards!"
					emporium_sub_message_timer = 2.0
				queue_redraw()
				return
		var rows_in_rarity = (bindings_in_rarity.size() + 3) / 4
		start_y += float(rows_in_rarity) * (card_h + 6) + 8.0

func _on_power_selection_clicked(mouse_pos: Vector2) -> void:
	var pw = 700.0
	var ph = 440.0
	var px = (1280.0 - pw) / 2.0
	var py = (720.0 - ph) / 2.0
	# Check power item clicks
	for i in range(battle_power_definitions.size()):
		var bp = battle_power_definitions[i]
		var bx = px + 30
		var by = py + 70 + i * 55
		if mouse_pos.x >= bx and mouse_pos.x <= bx + pw - 60 and mouse_pos.y >= by and mouse_pos.y <= by + 48:
			_toggle_power_selection(bp["id"])
			return
	# Check start button
	var sbx = px + pw * 0.5 - 80
	var sby = py + ph - 50
	if mouse_pos.x >= sbx and mouse_pos.x <= sbx + 160 and mouse_pos.y >= sby and mouse_pos.y <= sby + 36:
		_close_power_selection_and_start()
		return

func _on_emporium_tile_clicked_extended(index: int) -> void:
	if index == 6:
		# Trophy Store — switch to trophy store view
		emporium_sub_category = 6
		queue_redraw()
	else:
		_on_emporium_tile_clicked(index)

# =====================================================================================
# === FEATURE 3: ITEM DISMANTLING / SALVAGING ==========================================
# =====================================================================================

func _salvage_binding(binding_id: String) -> void:
	var count = owned_bindings.get(binding_id, 0)
	if count <= 0:
		return
	var binding = _find_binding(binding_id)
	if binding.is_empty():
		return
	var rarity = binding.get("rarity", "common")
	var shards_gained = salvage_rates.get(rarity, 5)
	owned_bindings[binding_id] = count - 1
	if owned_bindings[binding_id] <= 0:
		owned_bindings.erase(binding_id)
	# Remove from equipped if was equipped
	for t in equipped_bindings:
		if binding_id in equipped_bindings[t]:
			equipped_bindings[t].erase(binding_id)
	player_relic_shards += shards_gained
	_check_achievement("salvage_master", 1)
	_save_game()

func _draw_salvage_panel() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Background
	for i in range(56):
		var t = float(i) / 55.0
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), menu_bg_section.lerp(menu_bg_dark, t))
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4), false, 1.5)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "SALVAGE WORKSHOP", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Shards: %d" % player_relic_shards, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 46), "Dismantle unwanted Tome Bindings into Relic Shards", HORIZONTAL_ALIGNMENT_CENTER, -1, 11, menu_text_muted)
	var card_w = 260.0
	var card_h = 52.0
	var col_count = 4
	var row = 0
	var col = 0
	var content_y = panel_y + 60.0
	for bid in owned_bindings:
		if owned_bindings[bid] <= 0:
			continue
		var binding = _find_binding(bid)
		if binding.is_empty():
			continue
		var rarity = binding.get("rarity", "common")
		var shards_val = salvage_rates.get(rarity, 5)
		var ix = panel_x + 10 + float(col) * (card_w + 10)
		var iy = content_y + float(row) * (card_h + 6)
		if iy + card_h > panel_y + panel_h - 50:
			break
		var rarity_col = {"common": Color(0.6, 0.6, 0.6), "uncommon": Color(0.3, 0.7, 0.3), "rare": Color(0.7, 0.4, 0.9)}.get(rarity, Color.WHITE)
		draw_rect(Rect2(ix, iy, card_w, card_h), Color(0.08, 0.06, 0.10, 0.85))
		draw_rect(Rect2(ix, iy, card_w, card_h), Color(rarity_col.r, rarity_col.g, rarity_col.b, 0.3), false, 1.0)
		_udraw(font, Vector2(ix + 8, iy + 16), binding.get("name", "?"), HORIZONTAL_ALIGNMENT_LEFT, int(card_w - 90), 11, Color(0.8, 0.7, 0.5))
		_udraw(font, Vector2(ix + 8, iy + 32), "x%d" % owned_bindings[bid], HORIZONTAL_ALIGNMENT_LEFT, -1, 10, Color(0.5, 0.8, 0.5))
		# Salvage button
		draw_rect(Rect2(ix + card_w - 75, iy + 8, 65, 34), Color(0.5, 0.15, 0.1, 0.7))
		draw_rect(Rect2(ix + card_w - 75, iy + 8, 65, 34), Color(0.8, 0.3, 0.2, 0.4), false, 1.0)
		_udraw(font, Vector2(ix + card_w - 42, iy + 22), "SALVAGE", HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(1.0, 0.8, 0.6))
		_udraw(font, Vector2(ix + card_w - 42, iy + 36), "+%d S" % shards_val, HORIZONTAL_ALIGNMENT_CENTER, -1, 9, menu_gold)
		col += 1
		if col >= col_count:
			col = 0
			row += 1
	# Back button
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.85, 0.7, 0.4))

func _on_salvage_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		queue_redraw()
		return
	var card_w = 260.0
	var card_h = 52.0
	var content_y = panel_y + 60.0
	var col = 0
	var row = 0
	for bid in owned_bindings:
		if owned_bindings[bid] <= 0:
			continue
		var ix = panel_x + 10 + float(col) * (card_w + 10)
		var iy = content_y + float(row) * (card_h + 6)
		# Salvage button hitbox
		if mouse_pos.x >= ix + card_w - 75 and mouse_pos.x <= ix + card_w - 10 and mouse_pos.y >= iy + 8 and mouse_pos.y <= iy + 42:
			_salvage_binding(bid)
			queue_redraw()
			return
		col += 1
		if col >= 4:
			col = 0
			row += 1

# =====================================================================================
# === FEATURE 4: GOLDEN TREASURE CHEST CRAFTING ========================================
# =====================================================================================

func _draw_chest_crafting() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	for i in range(56):
		var t = float(i) / 55.0
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), menu_bg_section.lerp(menu_bg_dark, t))
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4), false, 1.5)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "CHEST FORGE", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Shards: %d" % player_relic_shards, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 46), "Forge Golden Treasure Chests from Relic Shards", HORIZONTAL_ALIGNMENT_CENTER, -1, 11, menu_text_muted)
	var tier_colors = [Color(0.7, 0.5, 0.25), Color(0.7, 0.7, 0.75), Color(0.95, 0.8, 0.2)]
	var tier_names = ["Bronze", "Silver", "Golden"]
	var chest_keys = ["bronze", "silver", "gold"]
	for i in range(3):
		var craft = golden_chest_craft_costs[i]
		var cx = panel_x + 80 + float(i) * 360.0
		var cy = panel_y + 100.0
		var cw = 320.0
		var ch = 300.0
		draw_rect(Rect2(cx, cy, cw, ch), Color(0.06, 0.05, 0.08, 0.9))
		draw_rect(Rect2(cx, cy, cw, ch), Color(tier_colors[i].r, tier_colors[i].g, tier_colors[i].b, 0.4), false, 2.0)
		# Chest icon (simple rectangle chest)
		var icon_y = cy + 40
		draw_rect(Rect2(cx + cw * 0.5 - 30, icon_y, 60, 45), tier_colors[i])
		draw_rect(Rect2(cx + cw * 0.5 - 32, icon_y, 64, 5), Color(tier_colors[i].r * 0.7, tier_colors[i].g * 0.7, tier_colors[i].b * 0.7))
		draw_rect(Rect2(cx + cw * 0.5 - 5, icon_y + 15, 10, 15), Color(0.2, 0.15, 0.1))
		_udraw(font, Vector2(cx + cw * 0.5, icon_y + 70), tier_names[i] + " Treasure Chest", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, tier_colors[i])
		_udraw(font, Vector2(cx + cw * 0.5, icon_y + 92), "Owned: %d" % treasure_chests_owned.get(chest_keys[i], 0), HORIZONTAL_ALIGNMENT_CENTER, -1, 12, menu_text)
		_udraw(font, Vector2(cx + cw * 0.5, icon_y + 115), "Cost: %d Shards" % craft["shard_cost"], HORIZONTAL_ALIGNMENT_CENTER, -1, 13, menu_gold)
		# Craft button
		var can_afford = player_relic_shards >= craft["shard_cost"]
		var btn_col = Color(0.15, 0.35, 0.15, 0.8) if can_afford else Color(0.12, 0.1, 0.1, 0.6)
		draw_rect(Rect2(cx + cw * 0.5 - 55, icon_y + 140, 110, 40), btn_col)
		draw_rect(Rect2(cx + cw * 0.5 - 55, icon_y + 140, 110, 40), Color(0.4, 0.8, 0.3, 0.4) if can_afford else Color(0.3, 0.3, 0.3, 0.3), false, 1.0)
		_udraw(font, Vector2(cx + cw * 0.5, icon_y + 165), "FORGE", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.9, 0.85, 0.6) if can_afford else Color(0.4, 0.4, 0.4))
	# Back button
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.85, 0.7, 0.4))

func _on_chest_crafting_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		queue_redraw()
		return
	var chest_keys = ["bronze", "silver", "gold"]
	for i in range(3):
		var craft = golden_chest_craft_costs[i]
		var cx = panel_x + 80 + float(i) * 360.0
		var icon_y = panel_y + 100.0 + 40
		var btn_x = cx + 160.0 - 55
		var btn_y = icon_y + 140
		if mouse_pos.x >= btn_x and mouse_pos.x <= btn_x + 110 and mouse_pos.y >= btn_y and mouse_pos.y <= btn_y + 40:
			if player_relic_shards >= craft["shard_cost"]:
				player_relic_shards -= craft["shard_cost"]
				treasure_chests_owned[chest_keys[i]] = treasure_chests_owned.get(chest_keys[i], 0) + 1
				_save_game()
			queue_redraw()
			return

# =====================================================================================
# === FEATURE 5: ROTATING DAILY DEALS SHOP ============================================
# =====================================================================================

func _generate_daily_deals() -> void:
	var today = Time.get_date_string_from_system()
	if daily_deals_date == today and daily_deals.size() == 3:
		return
	# Seed based on date for consistent deals per day
	var date = Time.get_date_dict_from_system()
	var day_seed = date["year"] * 366 + date["month"] * 31 + date["day"]
	var rng = RandomNumberGenerator.new()
	rng.seed = day_seed
	daily_deals.clear()
	daily_deals_purchased = [false, false, false]
	# Deal types: bindings, battle powers, currency packs, chests
	var deal_pool = []
	# Add some random bindings
	for b in TOME_BINDINGS:
		deal_pool.append({"type": "binding", "item": b, "cost_type": "quills", "cost": rng.randi_range(5, 20), "name": b["name"], "desc": b["desc"]})
	# Add power deals
	for bp in battle_power_definitions:
		deal_pool.append({"type": "power", "power_id": bp["id"], "cost_type": "shards", "cost": rng.randi_range(8, 18), "name": bp["name"] + " x2", "desc": bp["desc"], "amount": 2})
	# Add currency deals
	deal_pool.append({"type": "currency", "currency": "shards", "amount": rng.randi_range(20, 50), "cost_type": "quills", "cost": rng.randi_range(5, 12), "name": "Shard Pouch", "desc": "A pouch of Relic Shards"})
	deal_pool.append({"type": "currency", "currency": "quills", "amount": rng.randi_range(5, 15), "cost_type": "shards", "cost": rng.randi_range(15, 30), "name": "Quill Bundle", "desc": "A bundle of Enchanted Quills"})
	deal_pool.append({"type": "chest", "chest_tier": "silver", "cost_type": "quills", "cost": rng.randi_range(15, 25), "name": "Silver Chest", "desc": "Uncommon treasures await"})
	# Pick 3 random deals
	deal_pool.shuffle()
	for i in range(min(3, deal_pool.size())):
		daily_deals.append(deal_pool[i])
	daily_deals_date = today

func _draw_daily_deals() -> void:
	var font = game_font
	# Small panel at top of chapters view
	var dx = 830.0
	var dy = 50.0
	var dw = 420.0
	var dh = 220.0
	draw_rect(Rect2(dx, dy, dw, dh), Color(0.06, 0.05, 0.10, 0.9))
	draw_rect(Rect2(dx, dy, dw, dh), Color(menu_gold.r, menu_gold.g, menu_gold.b, 0.35), false, 1.5)
	_udraw(font, Vector2(dx + dw * 0.5, dy + 18), "DAILY DEALS", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, menu_gold)
	_udraw(font, Vector2(dx + dw * 0.5, dy + 34), "Refreshes at midnight", HORIZONTAL_ALIGNMENT_CENTER, -1, 9, menu_text_muted)
	for i in range(min(3, daily_deals.size())):
		var deal = daily_deals[i]
		var ix = dx + 10
		var iy = dy + 42 + float(i) * 58.0
		var iw = dw - 20
		var ih = 52.0
		var purchased = daily_deals_purchased[i] if i < daily_deals_purchased.size() else false
		var bg_col = Color(0.05, 0.15, 0.05, 0.6) if purchased else Color(0.08, 0.06, 0.12, 0.7)
		draw_rect(Rect2(ix, iy, iw, ih), bg_col)
		draw_rect(Rect2(ix, iy, iw, ih), Color(0.4, 0.35, 0.2, 0.3), false, 1.0)
		_udraw(font, Vector2(ix + 10, iy + 18), deal.get("name", "Deal"), HORIZONTAL_ALIGNMENT_LEFT, int(iw - 120), 12, Color(0.85, 0.75, 0.5))
		_udraw(font, Vector2(ix + 10, iy + 36), deal.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(iw - 120), 9, menu_text_muted)
		if purchased:
			_udraw(font, Vector2(ix + iw - 60, iy + 28), "SOLD", HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(0.4, 0.7, 0.3))
		else:
			var cost_str = "%d %s" % [deal.get("cost", 0), deal.get("cost_type", "").capitalize()]
			draw_rect(Rect2(ix + iw - 100, iy + 8, 88, 34), Color(0.15, 0.12, 0.08, 0.8))
			_udraw(font, Vector2(ix + iw - 56, iy + 30), cost_str, HORIZONTAL_ALIGNMENT_CENTER, -1, 11, menu_gold)

func _on_daily_deals_clicked(mouse_pos: Vector2) -> void:
	var dx = 836.0
	var dy = 80.0  # sidebar panel_y
	var dw = 420.0
	for i in range(min(3, daily_deals.size())):
		if daily_deals_purchased[i]:
			continue
		var deal = daily_deals[i]
		var ix = dx + 10
		var iy = dy + 42 + float(i) * 58.0
		var iw = dw - 20
		if mouse_pos.x >= ix + iw - 100 and mouse_pos.x <= ix + iw - 12 and mouse_pos.y >= iy + 8 and mouse_pos.y <= iy + 42:
			var cost = deal.get("cost", 0)
			var cost_type = deal.get("cost_type", "")
			var can_afford = false
			match cost_type:
				"quills": can_afford = player_quills >= cost
				"shards": can_afford = player_relic_shards >= cost
				"stars": can_afford = player_storybook_stars >= cost
				"gold": can_afford = player_gold >= cost
			if not can_afford:
				return
			# Deduct cost
			match cost_type:
				"quills": player_quills -= cost
				"shards": player_relic_shards -= cost
				"stars": player_storybook_stars -= cost
				"gold": player_gold -= cost
			# Grant reward
			match deal.get("type", ""):
				"binding":
					var b = deal.get("item", {})
					if b.has("id"):
						owned_bindings[b["id"]] = owned_bindings.get(b["id"], 0) + 1
				"power":
					var pid = deal.get("power_id", "")
					var amt = deal.get("amount", 1)
					if pid != "":
						owned_powers[pid] = owned_powers.get(pid, 0) + amt
				"currency":
					var curr = deal.get("currency", "")
					var amt = deal.get("amount", 0)
					match curr:
						"shards": player_relic_shards += amt
						"quills": player_quills += amt
						"stars": player_storybook_stars += amt
						"gold": player_gold += amt
				"chest":
					var tier = deal.get("chest_tier", "bronze")
					treasure_chests_owned[tier] = treasure_chests_owned.get(tier, 0) + 1
			daily_deals_purchased[i] = true
			_save_game()
			queue_redraw()
			return

# =====================================================================================
# === FEATURE 6: SHADOW ARENA (Competitive Leaderboard Mode) ==========================
# =====================================================================================

func _init_shadow_arena() -> void:
	var date = Time.get_date_dict_from_system()
	shadow_arena_weekly_seed = date["year"] * 52 + (date["day"] + date["month"] * 31) / 7
	# Generate simulated leaderboard
	var rng = RandomNumberGenerator.new()
	rng.seed = shadow_arena_weekly_seed
	arena_leaderboard.clear()
	var bot_names = ["BookWorm_42", "InkSlinger", "PageTurner", "QuillMaster", "ShadowHunter",
		"StoryKeeper", "ChapterOne", "DarkReader", "TaleSpinner", "LibraryGhost",
		"PenFighter", "NovelKnight", "ScrollWarden", "FableHero", "MythBreaker"]
	for i in range(15):
		arena_leaderboard.append({"name": bot_names[i], "score": rng.randi_range(15, 60 - i * 2)})
	arena_leaderboard.sort_custom(func(a, b): return a["score"] > b["score"])
	# Weekly modifiers (2 random)
	var all_mods = ["shadow_infested", "regrow_only", "no_powers", "fast_enemies", "fortified_all", "double_hp"]
	all_mods.shuffle()
	shadow_arena_modifiers = [all_mods[0], all_mods[1]]

func _start_shadow_arena() -> void:
	shadow_arena_active = true
	shadow_arena_wave = 0
	# Pick a level from mid-to-late game (avoid beginner maps)
	var rng = RandomNumberGenerator.new()
	rng.seed = shadow_arena_weekly_seed + 99
	var min_level = mini(9, levels.size() - 1)  # At least world 4
	var arena_level = rng.randi_range(min_level, levels.size() - 1)
	selected_difficulty = 2  # Arena always plays on Hard
	_do_level_start(arena_level)

func _end_shadow_arena() -> void:
	shadow_arena_active = false
	var score = wave
	if score > shadow_arena_high_score:
		shadow_arena_high_score = score
	# Award arena crystals based on performance
	var crystals = score / 5
	arena_crystals += crystals
	# Insert into leaderboard
	arena_leaderboard.append({"name": "YOU", "score": score})
	arena_leaderboard.sort_custom(func(a, b): return a["score"] > b["score"])
	if arena_leaderboard.size() > 16:
		arena_leaderboard.resize(16)
	_save_game()

func _draw_shadow_arena_panel() -> void:
	var font = game_font
	var px = 38.0
	var py = 290.0
	var pw = 385.0
	var ph = 280.0
	draw_rect(Rect2(px, py, pw, ph), Color(0.04, 0.02, 0.06, 0.85))
	draw_rect(Rect2(px, py, pw, ph), Color(0.5, 0.1, 0.6, 0.3), false, 1.5)
	_udraw(font, Vector2(px + pw * 0.5, py + 20), "SHADOW ARENA", HORIZONTAL_ALIGNMENT_CENTER, -1, 15, Color(0.7, 0.3, 0.9))
	_udraw(font, Vector2(px + pw * 0.5, py + 38), "Weekly competitive challenge", HORIZONTAL_ALIGNMENT_CENTER, -1, 10, menu_text_muted)
	# Modifiers
	var mod_str = ""
	for m in shadow_arena_modifiers:
		mod_str += m.replace("_", " ").capitalize() + "  "
	_udraw(font, Vector2(px + pw * 0.5, py + 56), "Modifiers: " + mod_str, HORIZONTAL_ALIGNMENT_CENTER, int(pw - 20), 10, Color(0.8, 0.5, 0.3))
	# Leaderboard (top 8)
	_udraw(font, Vector2(px + 15, py + 78), "LEADERBOARD", HORIZONTAL_ALIGNMENT_LEFT, -1, 11, menu_gold)
	for i in range(min(8, arena_leaderboard.size())):
		var entry = arena_leaderboard[i]
		var ey = py + 92 + float(i) * 18.0
		var name_col = Color(0.9, 0.8, 0.3) if entry["name"] == "YOU" else menu_text
		_udraw(font, Vector2(px + 15, ey), "#%d  %s" % [i + 1, entry["name"]], HORIZONTAL_ALIGNMENT_LEFT, int(pw - 80), 10, name_col)
		_udraw(font, Vector2(px + pw - 20, ey), "Wave %d" % entry["score"], HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, menu_text_muted)
	# Your best
	_udraw(font, Vector2(px + 15, py + ph - 55), "Your Best: Wave %d" % shadow_arena_high_score, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.7, 0.7, 0.9))
	_udraw(font, Vector2(px + 15, py + ph - 38), "Arena Crystals: %d" % arena_crystals, HORIZONTAL_ALIGNMENT_LEFT, -1, 11, Color(0.6, 0.3, 0.9))
	# Arena Crystal Shop items
	var shop_items = _get_arena_shop_items()
	var shop_x = px + pw + 15.0
	var shop_w = 200.0
	draw_rect(Rect2(shop_x, py, shop_w, ph), Color(0.04, 0.02, 0.06, 0.85))
	draw_rect(Rect2(shop_x, py, shop_w, ph), Color(0.5, 0.1, 0.6, 0.3), false, 1.5)
	_udraw(font, Vector2(shop_x + shop_w * 0.5, py + 20), "CRYSTAL SHOP", HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(0.6, 0.3, 0.9))
	for si in range(shop_items.size()):
		var item = shop_items[si]
		var iy = py + 42 + float(si) * 46.0
		var can_buy = arena_crystals >= item["cost"]
		var item_col = Color(0.9, 0.85, 1.0) if can_buy else Color(0.5, 0.4, 0.5)
		draw_rect(Rect2(shop_x + 8, iy, shop_w - 16, 40), Color(0.15, 0.08, 0.2, 0.6))
		_udraw(font, Vector2(shop_x + 14, iy + 14), item["name"], HORIZONTAL_ALIGNMENT_LEFT, int(shop_w - 28), 10, item_col)
		_udraw(font, Vector2(shop_x + 14, iy + 30), "%d Crystals" % item["cost"], HORIZONTAL_ALIGNMENT_LEFT, -1, 9, Color(0.6, 0.3, 0.9, 0.8) if can_buy else Color(0.4, 0.25, 0.4))
	# Start button
	draw_rect(Rect2(px + pw - 88, py + ph - 50, 78, 40), Color(0.3, 0.1, 0.4, 0.7))
	draw_rect(Rect2(px + pw - 88, py + ph - 50, 78, 40), Color(0.6, 0.2, 0.8, 0.4), false, 1.0)
	_udraw(font, Vector2(px + pw - 49, py + ph - 25), "ENTER", HORIZONTAL_ALIGNMENT_CENTER, -1, 13, Color(0.9, 0.7, 1.0))

func _get_arena_shop_items() -> Array:
	return [
		{"name": "50 Relic Shards", "cost": 5, "type": "shards", "amount": 50},
		{"name": "10 Quills", "cost": 8, "type": "quills", "amount": 10},
		{"name": "5 Storybook Stars", "cost": 12, "type": "stars", "amount": 5},
		{"name": "200 Gold", "cost": 10, "type": "gold", "amount": 200},
		{"name": "3 Knowledge Ink", "cost": 15, "type": "ink", "amount": 3},
	]

func _on_shadow_arena_clicked(mouse_pos: Vector2) -> void:
	var px = 836.0
	var py = 80.0  # sidebar panel_y
	var pw = 420.0
	# Enter button
	var shop_items = _get_arena_shop_items()
	var enter_y = py + 54 + 16 + float(shop_items.size()) * 42.0 + 10 + 210
	if Rect2(px + pw * 0.5 - 60, enter_y, 120, 36).has_point(mouse_pos):
		_start_shadow_arena()
	# Crystal shop clicks (now inline in sidebar)
	for si in range(shop_items.size()):
		var item = shop_items[si]
		var iy = py + 280 + 16 + float(si) * 42.0
		if mouse_pos.x >= px + 8 and mouse_pos.x <= px + pw - 8 and mouse_pos.y >= iy and mouse_pos.y <= iy + 36:
			if arena_crystals >= item["cost"]:
				arena_crystals -= item["cost"]
				match item["type"]:
					"shards": player_relic_shards += item["amount"]
					"quills": player_quills += item["amount"]
					"stars": player_storybook_stars += item["amount"]
					"gold": player_gold += item["amount"]
					"ink": knowledge_ink += item["amount"]
				queue_redraw()
			break

# =====================================================================================
# === FEATURE 7: BRANCHING UPGRADE PATHS ===============================================
# =====================================================================================

# Branch data per tower type — 2 branches (A/B), each with 2 tiers
const UPGRADE_BRANCHES: Dictionary = {
	# Robin Hood
	0: {
		"A": {"name": "Sherwood Marksman", "tiers": [
			{"name": "Piercing Shot", "desc": "+40% pierce damage", "cost": 180, "effect": "pierce_damage", "value": 0.40},
			{"name": "Storm of Arrows", "desc": "Fires 3 arrows at once", "cost": 350, "effect": "multi_shot", "value": 3.0},
		]},
		"B": {"name": "Merry Benefactor", "tiers": [
			{"name": "Golden Arrow", "desc": "+50% gold per kill", "cost": 160, "effect": "gold_bonus", "value": 0.50},
			{"name": "Robin's Bounty", "desc": "Enemies drop gold on hit", "cost": 300, "effect": "gold_on_hit", "value": 2.0},
		]},
	},
	# Alice
	1: {
		"A": {"name": "Wonderland Chaos", "tiers": [
			{"name": "Mad Tea Storm", "desc": "+50% AoE radius", "cost": 200, "effect": "aoe_radius", "value": 0.50},
			{"name": "Jabberwocky Rage", "desc": "Cake explodes for 3x damage", "cost": 380, "effect": "damage", "value": 2.0},
		]},
		"B": {"name": "Curiosity Control", "tiers": [
			{"name": "Shrink Ray", "desc": "Shrunk enemies take +30% damage", "cost": 180, "effect": "shrink_damage", "value": 0.30},
			{"name": "Looking Glass", "desc": "Reveals all shadow-infested enemies", "cost": 320, "effect": "reveal_shadow", "value": 1.0},
		]},
	},
	# Wicked Witch
	2: {
		"A": {"name": "Dark Summoner", "tiers": [
			{"name": "Monkey Army", "desc": "Summons 3 flying monkeys", "cost": 220, "effect": "extra_summon", "value": 2.0},
			{"name": "Tornado Strike", "desc": "Periodically launches a tornado", "cost": 400, "effect": "tornado", "value": 1.0},
		]},
		"B": {"name": "Hex Weaver", "tiers": [
			{"name": "Poppy Curse", "desc": "Attacks have 20% chance to sleep", "cost": 190, "effect": "sleep_chance", "value": 0.20},
			{"name": "Witch's Doom", "desc": "Cursed enemies explode on death", "cost": 360, "effect": "death_explode", "value": 1.0},
		]},
	},
	# Peter Pan
	3: {
		"A": {"name": "Shadow Assassin", "tiers": [
			{"name": "Shadow Strike", "desc": "+60% crit damage", "cost": 200, "effect": "crit_damage", "value": 0.60},
			{"name": "Lost Boys Ambush", "desc": "Shadow clones attack independently", "cost": 370, "effect": "clone_attack", "value": 2.0},
		]},
		"B": {"name": "Fairy Guardian", "tiers": [
			{"name": "Pixie Shield", "desc": "Nearby towers take 20% less damage", "cost": 180, "effect": "damage_reduction", "value": 0.20},
			{"name": "Neverland Blessing", "desc": "+25% attack speed to all nearby", "cost": 340, "effect": "attack_speed_aura", "value": 0.25},
		]},
	},
	# Phantom
	4: {
		"A": {"name": "Maestro of Doom", "tiers": [
			{"name": "Crescendo", "desc": "Damage increases with consecutive hits", "cost": 210, "effect": "ramp_damage", "value": 0.10},
			{"name": "Requiem", "desc": "Devastating AoE blast every 10 attacks", "cost": 400, "effect": "charged_blast", "value": 10.0},
		]},
		"B": {"name": "Opera Phantom", "tiers": [
			{"name": "Chandelier Drop", "desc": "Stuns all enemies in range every 8s", "cost": 200, "effect": "periodic_stun", "value": 8.0},
			{"name": "Masquerade", "desc": "Enemies confused, attack each other", "cost": 380, "effect": "confuse_aura", "value": 1.0},
		]},
	},
	# Scrooge
	5: {
		"A": {"name": "Golden Miser", "tiers": [
			{"name": "Interest Rate", "desc": "+5 gold per wave passively", "cost": 150, "effect": "passive_gold", "value": 5.0},
			{"name": "Counting House", "desc": "All towers earn +15% gold", "cost": 300, "effect": "global_gold", "value": 0.15},
		]},
		"B": {"name": "Spirit Channeler", "tiers": [
			{"name": "Ghost Chill", "desc": "Attacks slow enemies by 40%", "cost": 170, "effect": "slow", "value": 0.40},
			{"name": "Three Spirits", "desc": "Summons 3 ghosts that deal AoE damage", "cost": 350, "effect": "ghost_summon", "value": 3.0},
		]},
	},
	# Sherlock
	6: {
		"A": {"name": "Master Detective", "tiers": [
			{"name": "Deduction", "desc": "Marks reveal enemy weaknesses (+40% dmg)", "cost": 230, "effect": "mark_damage", "value": 0.40},
			{"name": "Case Closed", "desc": "Marked enemies die instantly below 10% HP", "cost": 420, "effect": "execute", "value": 0.10},
		]},
		"B": {"name": "Baker Street Intel", "tiers": [
			{"name": "Network", "desc": "All towers gain +10% range", "cost": 200, "effect": "global_range", "value": 0.10},
			{"name": "Elementary", "desc": "Reveals all invisible/phantom enemies", "cost": 350, "effect": "reveal_all", "value": 1.0},
		]},
	},
	# Tarzan
	7: {
		"A": {"name": "King of the Jungle", "tiers": [
			{"name": "Primal Fury", "desc": "+80% damage below 50% map progress", "cost": 200, "effect": "early_damage", "value": 0.80},
			{"name": "Jungle Stampede", "desc": "Summons elephant charge every 15s", "cost": 380, "effect": "stampede", "value": 1.0},
		]},
		"B": {"name": "Vine Lord", "tiers": [
			{"name": "Entangle", "desc": "Vine snares hold enemies for 2s", "cost": 190, "effect": "snare", "value": 2.0},
			{"name": "Living Jungle", "desc": "Vines grow across path, slowing all by 25%", "cost": 350, "effect": "path_slow", "value": 0.25},
		]},
	},
	# Dracula
	8: {
		"A": {"name": "Lord of Darkness", "tiers": [
			{"name": "Blood Feast", "desc": "Life steal heals all nearby towers", "cost": 220, "effect": "aoe_heal", "value": 1.0},
			{"name": "Vampire Lord", "desc": "Charmed enemies fight for you permanently", "cost": 420, "effect": "permanent_charm", "value": 1.0},
		]},
		"B": {"name": "Bat Master", "tiers": [
			{"name": "Bat Swarm", "desc": "Sends bat swarm dealing AoE damage", "cost": 200, "effect": "bat_swarm", "value": 1.0},
			{"name": "Eclipse", "desc": "All enemies on screen take 5% HP/s for 5s", "cost": 400, "effect": "eclipse", "value": 1.0},
		]},
	},
	# Merlin
	9: {
		"A": {"name": "Archmage Supreme", "tiers": [
			{"name": "Meteor Storm", "desc": "Rains meteors every 12 seconds", "cost": 240, "effect": "meteor", "value": 1.0},
			{"name": "Time Warp", "desc": "Slows all enemies by 50% for 5s periodically", "cost": 440, "effect": "time_warp", "value": 1.0},
		]},
		"B": {"name": "Enchanter", "tiers": [
			{"name": "Enchant Weapons", "desc": "Nearby towers deal magic damage", "cost": 200, "effect": "magic_aura", "value": 1.0},
			{"name": "Excalibur's Call", "desc": "Summons Excalibur to strike strongest enemy", "cost": 380, "effect": "excalibur", "value": 1.0},
		]},
	},
	# Frankenstein
	10: {
		"A": {"name": "Lightning Engine", "tiers": [
			{"name": "Overcharge", "desc": "Chain lightning hits 5 additional targets", "cost": 220, "effect": "chain_count", "value": 5.0},
			{"name": "Tesla Coil", "desc": "Passive lightning field damages all nearby", "cost": 400, "effect": "tesla", "value": 1.0},
		]},
		"B": {"name": "Unstoppable Monster", "tiers": [
			{"name": "Rage", "desc": "Damage increases as HP drops", "cost": 190, "effect": "rage", "value": 1.0},
			{"name": "Rampage", "desc": "AoE ground slam stuns for 3s", "cost": 370, "effect": "ground_slam", "value": 3.0},
		]},
	},
	# Shadow Author
	11: {
		"A": {"name": "Story Rewriter", "tiers": [
			{"name": "Plot Twist", "desc": "Random enemy instantly dies every 10s", "cost": 300, "effect": "plot_twist", "value": 1.0},
			{"name": "The End", "desc": "All enemies below 15% HP are erased", "cost": 500, "effect": "erase", "value": 0.15},
		]},
		"B": {"name": "Ink Overlord", "tiers": [
			{"name": "Ink Flood", "desc": "Path covered in ink, 30% slow to all", "cost": 280, "effect": "ink_slow", "value": 0.30},
			{"name": "Dark Chapter", "desc": "Spawns shadow clones of your towers", "cost": 480, "effect": "shadow_clone", "value": 1.0},
		]},
	},
}

func _get_branch_for_tower(tower_node) -> String:
	if tower_node == null:
		return ""
	var iid = tower_node.get_instance_id()
	return tower_branch_choice.get(iid, "")

func _choose_branch(tower_node, branch: String) -> void:
	if tower_node == null:
		return
	var iid = tower_node.get_instance_id()
	tower_branch_choice[iid] = branch

func _purchase_branch_upgrade(tower_node, tower_type_int: int, branch: String, tier_idx: int) -> bool:
	if not UPGRADE_BRANCHES.has(tower_type_int):
		return false
	var branch_data = UPGRADE_BRANCHES[tower_type_int].get(branch, {})
	if branch_data.is_empty():
		return false
	var tiers = branch_data.get("tiers", [])
	if tier_idx >= tiers.size():
		return false
	var tier = tiers[tier_idx]
	var cost = tier.get("cost", 0)
	if gold < cost:
		return false
	gold -= cost
	total_gold_spent += cost
	# Apply branch upgrade effect via meta buffs
	var iid = tower_node.get_instance_id()
	if not tower_node.has_meta("branch_upgrades"):
		tower_node.set_meta("branch_upgrades", [])
	var upgrades = tower_node.get_meta("branch_upgrades")
	upgrades.append({"branch": branch, "tier": tier_idx, "effect": tier["effect"], "value": tier["value"]})
	tower_node.set_meta("branch_upgrades", upgrades)
	tower_node.set_meta("branch_tier_" + branch, tier_idx + 1)
	# Refresh meta buffs so the new branch upgrade takes effect immediately
	var tt_enum = tower_node.get_meta("tower_type_enum") if tower_node.has_meta("tower_type_enum") else tower_type_int
	_apply_meta_buffs(tower_node, tt_enum)
	update_hud()
	queue_redraw()
	return true

func _draw_branch_upgrade_panel() -> void:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	if selected_tower_node.upgrade_tier < 4:
		return
	var tower_type_int: int = -1
	if selected_tower_node.has_meta("tower_type_enum"):
		tower_type_int = int(selected_tower_node.get_meta("tower_type_enum"))
	else:
		return
	if not UPGRADE_BRANCHES.has(tower_type_int):
		return
	var font = game_font
	var branches = UPGRADE_BRANCHES[tower_type_int]
	var chosen = _get_branch_for_tower(selected_tower_node)
	# Panel position — draw below the upgrade panel (right side)
	var px = 1080.0
	var py = 660.0
	var pw = 200.0
	if chosen == "":
		# Show branch selection (A vs B)
		var ph = 160.0
		py = 540.0
		draw_rect(Rect2(px, py, pw, ph), Color(0.06, 0.03, 0.10, 0.95))
		draw_rect(Rect2(px, py, pw, ph), Color(0.6, 0.3, 0.8, 0.5), false, 1.5)
		_udraw(font, Vector2(px + pw * 0.5, py + 16), "CHOOSE PATH", HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color(0.8, 0.6, 1.0))
		draw_rect(Rect2(px + 10, py + 22, pw - 20, 1), Color(0.6, 0.3, 0.8, 0.3))
		for bi in range(2):
			var bkey = "A" if bi == 0 else "B"
			var bdata = branches.get(bkey, {})
			var bname = bdata.get("name", "Path " + bkey)
			var by = py + 28 + float(bi) * 64.0
			var is_hover = _branch_hover == bkey
			var bg_col = Color(0.15, 0.08, 0.22, 0.9) if is_hover else Color(0.08, 0.05, 0.14, 0.8)
			draw_rect(Rect2(px + 6, by, pw - 12, 58), bg_col)
			draw_rect(Rect2(px + 6, by, pw - 12, 58), Color(0.7, 0.4, 0.9, 0.4) if is_hover else Color(0.5, 0.3, 0.6, 0.25), false, 1.0)
			_udraw(font, Vector2(px + 14, by + 16), bkey + ": " + bname, HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 11, Color(0.9, 0.8, 0.5) if is_hover else Color(0.8, 0.7, 0.4))
			# Show tier 1 preview
			var tiers = bdata.get("tiers", [])
			if tiers.size() > 0:
				_udraw(font, Vector2(px + 14, by + 34), tiers[0].get("name", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 9, Color(0.7, 0.65, 0.6))
				_udraw(font, Vector2(px + 14, by + 48), tiers[0].get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 8, Color(0.55, 0.5, 0.5))
	else:
		# Show branch upgrade tiers
		var bdata = branches.get(chosen, {})
		var bname = bdata.get("name", "Path " + chosen)
		var tiers = bdata.get("tiers", [])
		var current_tier = 0
		if selected_tower_node.has_meta("branch_tier_" + chosen):
			current_tier = selected_tower_node.get_meta("branch_tier_" + chosen)
		var ph = 30.0 + float(tiers.size()) * 68.0
		py = 540.0
		draw_rect(Rect2(px, py, pw, ph), Color(0.06, 0.03, 0.10, 0.95))
		draw_rect(Rect2(px, py, pw, ph), Color(0.6, 0.3, 0.8, 0.5), false, 1.5)
		_udraw(font, Vector2(px + pw * 0.5, py + 16), chosen + ": " + bname, HORIZONTAL_ALIGNMENT_CENTER, int(pw - 10), 11, Color(0.8, 0.6, 1.0))
		draw_rect(Rect2(px + 10, py + 22, pw - 20, 1), Color(0.6, 0.3, 0.8, 0.3))
		for ti in range(tiers.size()):
			var tier = tiers[ti]
			var ty = py + 28 + float(ti) * 68.0
			var is_hover = (_branch_tier_hover == ti)
			if ti < current_tier:
				# Purchased
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), Color(0.06, 0.15, 0.06, 0.85))
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), Color(0.3, 0.7, 0.2, 0.4), false, 1.0)
				_udraw(font, Vector2(px + 14, ty + 16), tier.get("name", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 11, Color(0.5, 0.8, 0.4))
				_udraw(font, Vector2(px + 14, ty + 32), tier.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 8, Color(0.5, 0.65, 0.4))
				_udraw(font, Vector2(px + pw - 14, ty + 52), "OWNED", HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(0.4, 0.7, 0.3))
			elif ti == current_tier:
				# Available
				var cost = tier.get("cost", 0)
				var can_afford = gold >= cost
				var bg_c = Color(0.14, 0.10, 0.06, 0.9) if is_hover else Color(0.10, 0.07, 0.12, 0.85)
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), bg_c)
				var bdr_c = Color(0.85, 0.65, 0.1, 0.6) if (can_afford and is_hover) else Color(0.5, 0.35, 0.6, 0.3)
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), bdr_c, false, 1.0)
				_udraw(font, Vector2(px + 14, ty + 16), tier.get("name", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 11, Color(0.9, 0.8, 0.5))
				_udraw(font, Vector2(px + 14, ty + 32), tier.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 8, Color(0.75, 0.7, 0.65))
				var cost_col = Color(1.0, 0.84, 0.0) if can_afford else Color(0.6, 0.4, 0.3)
				_udraw(font, Vector2(px + pw - 14, ty + 52), "%dG" % cost, HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, cost_col)
			else:
				# Locked
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), Color(0.06, 0.04, 0.08, 0.7))
				draw_rect(Rect2(px + 6, ty, pw - 12, 62), Color(0.3, 0.25, 0.35, 0.25), false, 1.0)
				_udraw(font, Vector2(px + 14, ty + 16), tier.get("name", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 11, Color(0.45, 0.4, 0.4))
				_udraw(font, Vector2(px + 14, ty + 32), tier.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(pw - 24), 8, Color(0.4, 0.35, 0.35))
				_udraw(font, Vector2(px + pw - 14, ty + 52), "%dG" % tier.get("cost", 0), HORIZONTAL_ALIGNMENT_RIGHT, -1, 10, Color(0.4, 0.35, 0.3))

func _handle_branch_panel_click(mouse_pos: Vector2) -> bool:
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return false
	if selected_tower_node.upgrade_tier < 4 or not upgrade_panel.visible:
		return false
	var tower_type_int: int = -1
	if selected_tower_node.has_meta("tower_type_enum"):
		tower_type_int = int(selected_tower_node.get_meta("tower_type_enum"))
	else:
		return false
	if not UPGRADE_BRANCHES.has(tower_type_int):
		return false
	var branches = UPGRADE_BRANCHES[tower_type_int]
	var chosen = _get_branch_for_tower(selected_tower_node)
	var px = 1080.0
	var pw = 200.0
	if chosen == "":
		var py = 540.0
		for bi in range(2):
			var bkey = "A" if bi == 0 else "B"
			var by = py + 28 + float(bi) * 64.0
			if Rect2(px + 6, by, pw - 12, 58).has_point(mouse_pos):
				_choose_branch(selected_tower_node, bkey)
				queue_redraw()
				return true
	else:
		var py = 540.0
		var bdata = branches.get(chosen, {})
		var tiers = bdata.get("tiers", [])
		var current_tier = 0
		if selected_tower_node.has_meta("branch_tier_" + chosen):
			current_tier = selected_tower_node.get_meta("branch_tier_" + chosen)
		for ti in range(tiers.size()):
			var ty = py + 28 + float(ti) * 68.0
			if ti == current_tier and Rect2(px + 6, ty, pw - 12, 62).has_point(mouse_pos):
				if _purchase_branch_upgrade(selected_tower_node, tower_type_int, chosen, ti):
					_update_upgrade_panel()
					queue_redraw()
				return true
	return false

func _update_branch_hover(mouse_pos: Vector2) -> void:
	_branch_hover = ""
	_branch_tier_hover = -1
	if not selected_tower_node or not is_instance_valid(selected_tower_node):
		return
	if selected_tower_node.upgrade_tier < 4 or not upgrade_panel.visible:
		return
	var tower_type_int: int = -1
	if selected_tower_node.has_meta("tower_type_enum"):
		tower_type_int = int(selected_tower_node.get_meta("tower_type_enum"))
	else:
		return
	if not UPGRADE_BRANCHES.has(tower_type_int):
		return
	var chosen = _get_branch_for_tower(selected_tower_node)
	var px = 1080.0
	var pw = 200.0
	if chosen == "":
		var py = 540.0
		for bi in range(2):
			var bkey = "A" if bi == 0 else "B"
			var by = py + 28 + float(bi) * 64.0
			if Rect2(px + 6, by, pw - 12, 58).has_point(mouse_pos):
				_branch_hover = bkey
				return
	else:
		var py = 540.0
		var branches = UPGRADE_BRANCHES[tower_type_int]
		var bdata = branches.get(chosen, {})
		var tiers = bdata.get("tiers", [])
		for ti in range(tiers.size()):
			var ty = py + 28 + float(ti) * 68.0
			if Rect2(px + 6, ty, pw - 12, 62).has_point(mouse_pos):
				_branch_tier_hover = ti
				return

# =====================================================================================
# === FEATURE 8: GOLDEN SHIELDS (Expandable Gear Slots) ================================
# =====================================================================================

func _upgrade_golden_shield(tower_type) -> bool:
	var progress = survivor_progress.get(tower_type, {})
	var current_shields = progress.get("golden_shields", 0)
	if current_shields >= MAX_GOLDEN_SHIELD:
		return false
	var cost = GOLDEN_SHIELD_COSTS[current_shields]
	if player_relic_shards < cost:
		return false
	player_relic_shards -= cost
	survivor_progress[tower_type]["golden_shields"] = current_shields + 1
	_save_game()
	return true

func _draw_golden_shield_indicator(center: Vector2, level: int, font: Font) -> void:
	# Draw a golden shield icon with level number
	var sz = 14.0
	# Shield shape
	var points = PackedVector2Array([
		center + Vector2(0, -sz),
		center + Vector2(sz * 0.8, -sz * 0.4),
		center + Vector2(sz * 0.8, sz * 0.3),
		center + Vector2(0, sz),
		center + Vector2(-sz * 0.8, sz * 0.3),
		center + Vector2(-sz * 0.8, -sz * 0.4),
	])
	draw_colored_polygon(points, Color(0.85, 0.7, 0.2, 0.8))
	# Border
	for i in range(points.size()):
		draw_line(points[i], points[(i + 1) % points.size()], Color(0.95, 0.85, 0.3, 0.9), 1.5)
	# Level number
	draw_string(font, center + Vector2(-4, 5), str(level), HORIZONTAL_ALIGNMENT_CENTER, -1, 10, Color(0.15, 0.1, 0.05))

# =====================================================================================
# === FEATURE 9: QUEST / MISSION SYSTEM ================================================
# =====================================================================================

func _init_quests() -> void:
	_refresh_quests_if_needed()

func _refresh_quests_if_needed() -> void:
	var today = Time.get_date_string_from_system()
	if quest_last_refresh == today and active_quests.size() > 0:
		return
	# Generate 3 daily quests
	active_quests.clear()
	var rng = RandomNumberGenerator.new()
	var date = Time.get_date_dict_from_system()
	rng.seed = date["year"] * 366 + date["month"] * 31 + date["day"] + 7777
	var templates = QUEST_TEMPLATES.duplicate()
	templates.shuffle()
	for i in range(min(3, templates.size())):
		var tmpl = templates[i]
		var diff_idx = rng.randi_range(0, 2)
		var target = tmpl["targets"][diff_idx]
		var reward_amount = tmpl["amounts"][diff_idx]
		active_quests.append({
			"id": "quest_%d_%s" % [i, today],
			"desc": tmpl["desc"] % target,
			"type": tmpl["type"],
			"target": target,
			"progress": 0,
			"reward_type": tmpl["reward_type"],
			"reward_amount": reward_amount,
			"completed": false,
		})
	quest_last_refresh = today

func _update_quest_progress(quest_type: String, amount: int = 1) -> void:
	for q in active_quests:
		if q["completed"]:
			continue
		if q["type"] == quest_type:
			q["progress"] = mini(q["progress"] + amount, q["target"])
			if q["progress"] >= q["target"]:
				_complete_quest(q)

func _complete_quest(quest: Dictionary) -> void:
	quest["completed"] = true
	total_quests_completed += 1
	match quest["reward_type"]:
		"shards": player_relic_shards += quest["reward_amount"]
		"quills": player_quills += quest["reward_amount"]
		"stars": player_storybook_stars += quest["reward_amount"]
		"gold": player_gold += quest["reward_amount"]
	_save_game()

func _draw_quest_panel() -> void:
	var font = game_font
	var qx = 830.0
	var qy = 280.0
	var qw = 420.0
	var qh = 195.0
	draw_rect(Rect2(qx, qy, qw, qh), Color(0.04, 0.06, 0.04, 0.85))
	draw_rect(Rect2(qx, qy, qw, qh), Color(0.3, 0.7, 0.3, 0.3), false, 1.5)
	_udraw(font, Vector2(qx + qw * 0.5, qy + 18), "DAILY QUESTS", HORIZONTAL_ALIGNMENT_CENTER, -1, 14, Color(0.4, 0.8, 0.3))
	_udraw(font, Vector2(qx + qw * 0.5, qy + 34), "Complete for rewards!", HORIZONTAL_ALIGNMENT_CENTER, -1, 9, menu_text_muted)
	for i in range(min(3, active_quests.size())):
		var q = active_quests[i]
		var iy = qy + 44 + float(i) * 48.0
		var completed = q.get("completed", false)
		var bg = Color(0.05, 0.12, 0.05, 0.6) if completed else Color(0.06, 0.06, 0.08, 0.6)
		draw_rect(Rect2(qx + 8, iy, qw - 16, 42), bg)
		draw_rect(Rect2(qx + 8, iy, qw - 16, 42), Color(0.3, 0.6, 0.3, 0.25), false, 1.0)
		_udraw(font, Vector2(qx + 16, iy + 16), q.get("desc", ""), HORIZONTAL_ALIGNMENT_LEFT, int(qw - 130), 11, Color(0.8, 0.75, 0.6))
		# Progress bar
		var pct = float(q.get("progress", 0)) / float(max(1, q.get("target", 1)))
		var bar_w = 80.0
		draw_rect(Rect2(qx + qw - 100, iy + 6, bar_w, 10), Color(0.15, 0.15, 0.15))
		draw_rect(Rect2(qx + qw - 100, iy + 6, bar_w * pct, 10), Color(0.3, 0.8, 0.3) if not completed else Color(0.2, 0.6, 0.2))
		_udraw(font, Vector2(qx + qw - 60, iy + 14), "%d/%d" % [q.get("progress", 0), q.get("target", 1)], HORIZONTAL_ALIGNMENT_CENTER, -1, 8, Color(0.8, 0.8, 0.8))
		# Reward
		var reward_str = "+%d %s" % [q.get("reward_amount", 0), q.get("reward_type", "").capitalize()]
		if completed:
			_udraw(font, Vector2(qx + qw - 60, iy + 34), "DONE!", HORIZONTAL_ALIGNMENT_CENTER, -1, 10, Color(0.4, 0.8, 0.3))
		else:
			_udraw(font, Vector2(qx + qw - 60, iy + 34), reward_str, HORIZONTAL_ALIGNMENT_CENTER, -1, 9, menu_gold)

# =====================================================================================
# === FEATURE 10: LITERARY INSTRUMENTS (Aura Support Gear) =============================
# =====================================================================================

func _draw_instrument_shop() -> void:
	var font = game_font
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	for i in range(56):
		var t = float(i) / 55.0
		draw_rect(Rect2(panel_x, panel_y + float(i) * 10.0, panel_w, 10.0), menu_bg_section.lerp(menu_bg_dark, t))
	draw_rect(Rect2(panel_x, panel_y, panel_w, panel_h), Color(menu_gold_dim.r, menu_gold_dim.g, menu_gold_dim.b, 0.4), false, 1.5)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 28), "LITERARY INSTRUMENTS", HORIZONTAL_ALIGNMENT_CENTER, -1, 18, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w - 180, panel_y + 28), "Quills: %d" % player_quills, HORIZONTAL_ALIGNMENT_RIGHT, -1, 14, menu_gold)
	_udraw(font, Vector2(panel_x + panel_w * 0.5, panel_y + 46), "Place instruments to buff nearby towers with aura effects", HORIZONTAL_ALIGNMENT_CENTER, -1, 11, menu_text_muted)
	for i in range(literary_instruments.size()):
		var inst = literary_instruments[i]
		var col_i = i % 3
		var row_i = i / 3
		var cw = 350.0
		var ch = 110.0
		var ix = panel_x + 20 + float(col_i) * (cw + 15)
		var iy = panel_y + 65 + float(row_i) * (ch + 10)
		var owned = owned_instruments.get(inst["id"], 0)
		draw_rect(Rect2(ix, iy, cw, ch), Color(0.07, 0.06, 0.10, 0.85))
		draw_rect(Rect2(ix, iy, cw, ch), Color(0.6, 0.4, 0.2, 0.3), false, 1.0)
		# Instrument icon (music note)
		draw_circle(Vector2(ix + 30, iy + 40), 10, Color(0.85, 0.7, 0.2, 0.7))
		draw_line(Vector2(ix + 38, iy + 40), Vector2(ix + 38, iy + 18), Color(0.85, 0.7, 0.2, 0.7), 2.0)
		_udraw(font, Vector2(ix + 55, iy + 22), inst["name"], HORIZONTAL_ALIGNMENT_LEFT, int(cw - 65), 13, Color(0.9, 0.8, 0.5))
		_udraw(font, Vector2(ix + 55, iy + 40), inst["desc"], HORIZONTAL_ALIGNMENT_LEFT, int(cw - 65), 10, menu_text_muted)
		_udraw(font, Vector2(ix + 55, iy + 58), "Radius: %d  |  Owned: %d" % [int(inst["radius"]), owned], HORIZONTAL_ALIGNMENT_LEFT, -1, 10, menu_text)
		# Buy button
		var btn_x = ix + cw - 95
		var btn_y = iy + ch - 38
		var can_buy = player_quills >= inst["cost"]
		draw_rect(Rect2(btn_x, btn_y, 82, 30), Color(0.15, 0.3, 0.15, 0.7) if can_buy else Color(0.1, 0.1, 0.1, 0.5))
		draw_rect(Rect2(btn_x, btn_y, 82, 30), Color(0.4, 0.7, 0.3, 0.4) if can_buy else Color(0.3, 0.3, 0.3, 0.3), false, 1.0)
		_udraw(font, Vector2(btn_x + 41, btn_y + 20), "%dQ" % inst["cost"], HORIZONTAL_ALIGNMENT_CENTER, -1, 11, menu_gold if can_buy else Color(0.4, 0.4, 0.4))
	# Back button
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.15, 0.10, 0.08, 0.8))
	draw_rect(Rect2(panel_x + 10, panel_y + panel_h - 45, 110, 35), Color(0.54, 0.45, 0.20, 0.3), false, 1.0)
	_udraw(font, Vector2(panel_x + 30, panel_y + panel_h - 22), "< BACK", HORIZONTAL_ALIGNMENT_LEFT, -1, 13, Color(0.85, 0.7, 0.4))

func _on_instrument_shop_clicked(mouse_pos: Vector2) -> void:
	var panel_x = 70.0
	var panel_y = 45.0
	var panel_w = 1140.0
	var panel_h = 560.0
	# Back button
	if mouse_pos.x >= panel_x + 10 and mouse_pos.x <= panel_x + 120 and mouse_pos.y >= panel_y + panel_h - 45 and mouse_pos.y <= panel_y + panel_h - 10:
		emporium_sub_category = -1
		queue_redraw()
		return
	for i in range(literary_instruments.size()):
		var inst = literary_instruments[i]
		var col_i = i % 3
		var row_i = i / 3
		var cw = 350.0
		var ch = 110.0
		var ix = panel_x + 20 + float(col_i) * (cw + 15)
		var iy = panel_y + 65 + float(row_i) * (ch + 10)
		var btn_x = ix + cw - 95
		var btn_y = iy + ch - 38
		if mouse_pos.x >= btn_x and mouse_pos.x <= btn_x + 82 and mouse_pos.y >= btn_y and mouse_pos.y <= btn_y + 30:
			if player_quills >= inst["cost"]:
				player_quills -= inst["cost"]
				owned_instruments[inst["id"]] = owned_instruments.get(inst["id"], 0) + 1
				_save_game()
			queue_redraw()
			return

func _place_instrument(inst_id: String, pos: Vector2) -> bool:
	var inst_data = null
	for inst in literary_instruments:
		if inst["id"] == inst_id:
			inst_data = inst
			break
	if inst_data == null:
		return false
	if owned_instruments.get(inst_id, 0) <= 0:
		return false
	if not _is_valid_placement(pos):
		return false
	owned_instruments[inst_id] -= 1
	placed_instruments.append({
		"id": inst_id, "position": pos,
		"radius": inst_data["radius"], "effect": inst_data["effect"],
		"value": inst_data["value"], "name": inst_data["name"]
	})
	return true

func _get_instrument_buffs_at(pos: Vector2) -> Dictionary:
	var buffs: Dictionary = {}
	for inst in placed_instruments:
		var dist = pos.distance_to(inst["position"])
		if dist <= inst["radius"]:
			var eff = inst["effect"]
			var val = inst["value"]
			buffs[eff] = buffs.get(eff, 0.0) + val
	return buffs

func _draw_placed_instruments() -> void:
	for inst in placed_instruments:
		var pos = inst["position"]
		var radius = inst["radius"]
		# Aura circle
		draw_arc(pos, radius, 0, TAU, 32, Color(0.85, 0.7, 0.2, 0.12), 1.5)
		# Instrument body (small harp shape)
		draw_circle(pos, 12.0, Color(0.6, 0.45, 0.15, 0.8))
		draw_circle(pos, 8.0, Color(0.8, 0.65, 0.2, 0.9))
		draw_line(pos + Vector2(0, -8), pos + Vector2(0, -18), Color(0.85, 0.7, 0.2), 2.0)
		draw_line(pos + Vector2(-3, -16), pos + Vector2(3, -16), Color(0.85, 0.7, 0.2), 1.5)
		# Pulsing glow
		var t = fmod(Time.get_ticks_msec() / 1000.0, TAU)
		var pulse = 0.15 + sin(t * 2.0) * 0.08
		draw_circle(pos, 16.0, Color(0.9, 0.8, 0.3, pulse))

func _draw_instrument_hud() -> void:
	# Check if player has any owned instruments
	var has_any = false
	for iid in owned_instruments:
		if owned_instruments[iid] > 0:
			has_any = true
			break
	if not has_any and _placing_instrument == "":
		return
	var font = game_font
	# Instrument button (bottom-left — mobile-friendly size)
	var btn_x = 8.0
	var btn_y = 48.0
	var btn_w = 110.0
	var btn_h = 38.0
	var is_placing = _placing_instrument != ""
	var bg_col = Color(0.3, 0.2, 0.08, 0.85) if is_placing else Color(0.12, 0.08, 0.04, 0.75)
	draw_rect(Rect2(btn_x, btn_y, btn_w, btn_h), bg_col)
	draw_rect(Rect2(btn_x, btn_y, btn_w, btn_h), Color(0.85, 0.65, 0.1, 0.5), false, 1.5)
	draw_circle(Vector2(btn_x + 16, btn_y + 19), 8, Color(0.85, 0.7, 0.2, 0.7))
	_udraw(font, Vector2(btn_x + 28, btn_y + 24), "INSTRUMENTS", HORIZONTAL_ALIGNMENT_LEFT, int(btn_w - 32), 11, Color(0.85, 0.7, 0.2))
	# If placing, show placement cursor
	if is_placing:
		var inst_data = null
		for inst in literary_instruments:
			if inst["id"] == _placing_instrument:
				inst_data = inst
				break
		if inst_data:
			var gpos = ghost_position
			var valid = _is_valid_placement(gpos)
			var cursor_col = Color(0.85, 0.7, 0.2, 0.3) if valid else Color(0.8, 0.2, 0.2, 0.3)
			draw_arc(gpos, inst_data["radius"], 0, TAU, 32, cursor_col, 1.5)
			draw_circle(gpos, 10, Color(0.85, 0.7, 0.2, 0.6) if valid else Color(0.8, 0.2, 0.2, 0.6))
			_udraw(font, Vector2(gpos.x, gpos.y - 18), inst_data["name"], HORIZONTAL_ALIGNMENT_CENTER, -1, 9, Color(0.9, 0.8, 0.5))
			_udraw(font, Vector2(gpos.x, gpos.y + 24), "CLICK TO PLACE" if valid else "INVALID SPOT", HORIZONTAL_ALIGNMENT_CENTER, -1, 8, Color(0.7, 0.6, 0.4))
		# Cancel hint
		_udraw(font, Vector2(btn_x + btn_w + 8, btn_y + 19), "RIGHT-CLICK TO CANCEL", HORIZONTAL_ALIGNMENT_LEFT, -1, 8, Color(0.6, 0.5, 0.4))
		return
	# Instrument picker (small overlay listing owned instruments)
	if _instrument_picker_open:
		var px = btn_x
		var py = btn_y + btn_h + 4
		var pw = 220.0
		var items: Array = []
		for inst in literary_instruments:
			var count = owned_instruments.get(inst["id"], 0)
			if count > 0:
				items.append(inst)
		var ph = 8.0 + float(items.size()) * 32.0
		draw_rect(Rect2(px, py, pw, ph), Color(0.06, 0.04, 0.08, 0.92))
		draw_rect(Rect2(px, py, pw, ph), Color(0.85, 0.65, 0.1, 0.4), false, 1.0)
		for i in range(items.size()):
			var inst = items[i]
			var iy = py + 4 + float(i) * 32.0
			var ih = _instrument_picker_hover == i
			draw_rect(Rect2(px + 4, iy, pw - 8, 28), Color(0.15, 0.12, 0.06, 0.7) if ih else Color(0.08, 0.06, 0.04, 0.5))
			draw_circle(Vector2(px + 18, iy + 14), 5, Color(0.85, 0.7, 0.2, 0.6))
			var count = owned_instruments.get(inst["id"], 0)
			_udraw(font, Vector2(px + 28, iy + 18), "%s (x%d)" % [inst["name"], count], HORIZONTAL_ALIGNMENT_LEFT, int(pw - 40), 10, Color(0.9, 0.8, 0.5) if ih else Color(0.75, 0.65, 0.4))

func _handle_instrument_placement_click(mouse_pos: Vector2) -> bool:
	# Check instrument button click
	var btn_x = 10.0
	var btn_y = 52.0
	var btn_w = 90.0
	var btn_h = 28.0
	if _placing_instrument != "":
		# Currently placing — place the instrument or cancel
		if Rect2(btn_x, btn_y, btn_w, btn_h).has_point(mouse_pos):
			_placing_instrument = ""
			_instrument_picker_open = false
			queue_redraw()
			return true
		if _place_instrument(_placing_instrument, mouse_pos):
			_placing_instrument = ""
			_instrument_picker_open = false
			# Re-apply meta buffs to nearby towers
			for tower in get_tree().get_nodes_in_group("towers"):
				if tower.has_meta("tower_type_enum"):
					_apply_meta_buffs(tower, tower.get_meta("tower_type_enum"))
			queue_redraw()
			return true
		return false
	if Rect2(btn_x, btn_y, btn_w, btn_h).has_point(mouse_pos):
		_instrument_picker_open = not _instrument_picker_open
		queue_redraw()
		return true
	if _instrument_picker_open:
		var px = btn_x
		var py = btn_y + btn_h + 4
		var pw = 220.0
		var items: Array = []
		for inst in literary_instruments:
			var count = owned_instruments.get(inst["id"], 0)
			if count > 0:
				items.append(inst)
		var ph = 8.0 + float(items.size()) * 32.0
		if Rect2(px, py, pw, ph).has_point(mouse_pos):
			for i in range(items.size()):
				var iy = py + 4 + float(i) * 32.0
				if Rect2(px + 4, iy, pw - 8, 28).has_point(mouse_pos):
					_placing_instrument = items[i]["id"]
					_instrument_picker_open = false
					queue_redraw()
					return true
			return true
		else:
			_instrument_picker_open = false
			queue_redraw()
	return false
